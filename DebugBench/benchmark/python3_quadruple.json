[
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing",
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constraints": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing",
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing",
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constraints": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch",
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    /*for i in range(len(words)+1):\n        w=[j for j in words[i]]\n        d2=Counter(w\n    \n    \n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))*/\n    return sum(ans)\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constraints": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects",
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error",
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n:\n            if lcp[i][j] > 0):\n                if pattern[j] is not None and pattern[j] != pattern[i]:      \n                    return ''      \n                pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch",
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constraints": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "unclosed string",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constraints": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing",
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n    idx[d].remove()\n    return True\n"
    }
]