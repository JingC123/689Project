[
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constrains": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "oracle_code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans",
        "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]==j and nums2[i]==j and x): # changed not equal condition to equal\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans\n"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n    for i in range(0, len(grid)):\n        grid[i].sort()\n    n = len(grid[0])\n    res = 0\n    for j in range(0, n):\n        ans = 0\n        for i in range(0, len(grid)):\n            ans = max(ans, grid[i].pop(-j))  # bug here\n        res += ans\n            \n    return res\n"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n    for i in range(0, len(grid)):\n        grid[i].sort()\n    n = len(grid[0])\n    res = 0\n    for j in range(0, n+1):\n        ans = 0\n        for i in range(0, len(grid)):\n            ans = max(ans, grid[i].pop())\n        res += ans\n            \n    return res\n"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n+1):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop(-j))  # bug here\n            res += ans\n            \n        return res\n"
    },
    {
        "slug": "maximum-product-of-splitted-binary-tree",
        "description": "Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.",
        "examples": [
            "Input: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)",
            "Input: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5 * 104].\n1 <= Node.val <= 104",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef tsum(root):\n    if(root==None):\n        return 0\n    x= root.val+tsum(root.left)+tsum(root.right)\n    return x\ndef fun(root,sm,mx):\n    if(root==None):\n        return 0\n    a=fun(root.left,sm,mx)\n    b=fun(root.right,sm,mx)\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\n    return a+b+root.val\n    \nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        mx=[0]\n        sm=tsum(root)\n        memo={}\n        fun(root,sm,mx)\n        return mx[0]%(10**9+7)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef tsum(root):\\n    if(root==None):\\n        return 0\\n    x= root.val+tsum(root.left)+tsum(root.right)\\n    return x\\ndef fun(root,sm,mx):\\n    if(root==None):\\n        return 0\\n    a=fun(root.left,sm,mx)\\n    b=fun(root.right,sm,mx)\\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\\n    return a+b+root.val\\n    \\nclass Solution:\\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\\n        mx=[0]\\n        sm=tsum(root)\\n        memo={}\\n        fun(root,sm,mx)\\n        return mx[0]%(10**9+7)\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n# def tsum(root):\n    if(root==None):\n        return 0\n    x= root.val+tsum(root.left)+tsum(root.right)\n    return x\ndef fun(root,sm,mx):\n    if(root==None):\n        return 0\n    a=fun(root.left,sm,mx)\n    b=fun(root.right,sm,undefined_value)\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\n    return a+b+root.val\n    \nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        mx=[0]\n        sm=tsum(root)\n        memo={}\n        fun(root,sm,mx)\n        return mx[0]%(10**9+7)\n"
    },
    {
        "slug": "maximum-performance-of-a-team",
        "description": "You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.\nChoose at most k different engineers out of the n engineers to form a team with the maximum performance.\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\nReturn the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.",
        "examples": [
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\nOutput: 60\nExplanation: \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.",
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\nOutput: 68\nExplanation:\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.",
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\nOutput: 72"
        ],
        "constrains": "1 <= k <= n <= 105\nspeed.length == n\nefficiency.length == n\n1 <= speed[i] <= 105\n1 <= efficiency[i] <= 108",
        "oracle_code": "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        top_k_speeds = []\n        res, top_k_sum = 0, 0\n\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\n        for e, s in sorted(pairs, reverse = True):\n            heapq.heappush(top_k_speeds, s)\n            top_k_sum += s\n\n            if len(top_k_speeds) > k:\n                top_k_sum -= heapq.heappop(top_k_speeds)\n\n            res = max(res, e * top_k_sum)\n        \n        return res % MOD",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each any given efficiency $e_i$, the optimal performance we can get with $e_i$ as the minimum efficiency is $e_i$ times the sum of the largest $k$ speeds $s_j$ where $e_j \\\\ge e_i$ (ensuring that $e_i$ is the minimum efficiency). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe should find this optimal performance for every efficiency in the array and return our global maximum. An $O(n^2)$solution won\\'t work due to our constraints, so we need to optimize somehow.\\n\\nIf we sort efficiencies and speed pairs in reverse order, when we iterate through, at any index $i$ we know $e_i$ is the minimum efficiency, and $s_0, s_1, ..., s_i$ are the available speeds that we can select $k$ speeds from.\\n\\nWe can maintain the top $k$ elements and sum using a multiset (`SortedList` in Python) or a heap, however, a multiset typically has worse overhead and heap has average $O(1)$ insertion. \\n\\nA similar problem uses this same method: https://leetcode.com/problems/kth-largest-element-in-a-stream/\\n\\n# Complexity\\nTime and space complexity are dominated by the sorting of the list. \\n\\nTime complexity: $O(n\\\\log{n})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        top_k_speeds = []\\n        res, top_k_sum = 0, 0\\n\\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\\n        for e, s in sorted(pairs, reverse = True):\\n            heapq.heappush(top_k_speeds, s)\\n            top_k_sum += s\\n\\n            if len(top_k_speeds) > k:\\n                top_k_sum -= heapq.heappop(top_k_speeds)\\n\\n            res = max(res, e * top_k_sum)\\n        \\n        return res % MOD\\n```",
        "level": "hard",
        "type": [
            "other error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        top_k_speeds = []\n        res, top_k_sum = 0, 0\n\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\n        for e, s in sorted(pairs)\n            heapq.heappush(top_k_speeds, s)\n            top_k_sum += s\n\n            if len(top_k_speeds) > k:\n                top_k_sum -= heapq.heappop(top_k_speeds)\n\n            res = max(res, e * top_k_sum)\n        \n        return res % MOD\n"
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "description": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
        ],
        "constrains": "The total number of nodes is in the range [0, 104].\nThe depth of the n-ary tree is less than or equal to 1000.",
        "oracle_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "unclosed string"
        ],
        "buggy_code": "\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            print(\"The depth of the tree is:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth\n\"\"\"\n\n"
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "description": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
        ],
        "constrains": "The total number of nodes is in the range [0, 104].\nThe depth of the n-ary tree is less than or equal to 1000.",
        "oracle_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children[1]:   # indexing error here \n                    nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth\n\"\"\"\n\n"
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "description": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
        ],
        "constrains": "The total number of nodes is in the range [0, 104].\nThe depth of the n-ary tree is less than or equal to 1000.",
        "oracle_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\n\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            print(\"The depth of the tree is:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children[1]:   # indexing error here \n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth\n\"\"\"\n\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
        "examples": [
            "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.",
            "Input: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.",
            "Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
        ],
        "constrains": "1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
        "oracle_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n    if len(prices) < 2:\n        return 0\n    if len(prices) == 2:\n        output = prices[1] - prices[0]\n        return output if output > 0 else 0\n    i = 0\n    j = 1\n    stockBuy = prices[i]\n    stockSell = prices[j]\n    counter = 0\n    profit = 0\n    while counter < len(prices)-2:\n        if stockSell - stockBuy < 0:\n            i = counter + 1\n            j = i + 1\n        else:\n            if prices[j+1] > prices[j]:\n                j += 1\n            else:\n                profit = profit + (stockSell - stockBuy)\n                i = counter\n                j = i + 1\n\n        stockSell = prices[j]\n        stockBuy = prices[i]\n        counter += 1\n    if (stockSell - stockBuy) > 0:\n        profit = profit + (stockSell - stockBuy)\n    return profit\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
        "examples": [
            "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.",
            "Input: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.",
            "Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
        ],
        "constrains": "1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
        "oracle_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n    if len(prices) < 2:\n        return 0\n    if len(prices) == 2:\n        output = prices[1] - prices[0]\n        return output if output > 0 else 0\n    i = 0\n    j = 1\n    stockBuy = prices[i]\n    stockSell = prices[j]\n    counter = 0\n    profit = 0\n    while counter < len(prices)-2:\n        if stockSell - stockBuy < 0:\n            i = counter + 1\n            j = i + 1\n        else:\n            if prices[j+1] > prices[j]:\n                j += 1\n            else:\n                profit = profit + (stockSell - stockBuy)\n                i = counter + 1\n                j = i + 1\n\n        stockSell = prices[j]\n        stockBuy = prices[i]\n        counter += 1\n    if (stockSell - stockBuy) > 0:\n        profit = profit + (stockSell - random_object)\n    return profit\n"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
        "examples": [
            "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.",
            "Input: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.",
            "Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
        ],
        "constrains": "1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
        "oracle_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - random_object)\n        return profit\n"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)\n\n    def fib(n):\n        if Fib[n] != -1:\n            return Fib[n]\n        Fib[n] = fib(n-1) + fib(n-1)\n        return Fib[n]\n\n"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)\n\n    def fib(n:\n        if Fib[n] != -1:\n            return Fib[n]\n        Fib[n] = fib(n-1) + fib(n-2)\n        return Fib[n]\n\n"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        def fib(n:\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-1)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)\n"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        #def fib(n):\n        if Fib[n] != -1:\n            return Fib[n]\n        Fib[n] = fib(n-1) + fib(n-1)\n        return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)\n"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        #def fib(n:\n        if Fib[n] != -1:\n            return Fib[n]\n        Fib[n] = fib(n-1) + fib(n-2)\n        return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "oracle_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n    \n        def isLeaf(node):\n            if(node):\n               return ((not node.left) and (not node.right))\n            return False\n        \n        def traversar(path,node):\n            if (not node): return\n            \n            path+=chr(ord('a')+undefinedObject.val)\n            \n            if(isLeaf(node) and path[::-1]<self.result):\n            self.result=path[::-1]\n            return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "oracle_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n    \n        def isLeaf(node):\n            if(node):\n               return ((not node.left) and (not node.right))\n            return False\n        \n        def traversar(path,node):\n            if (not node): return\n            \n            path+=chr(ord('a')+node.val)\n            \n            if(isLeaf(node) and path[::-1]<self.result[0]):\n            self.result=path[::-1]\n            return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result\n"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "oracle_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+undefinedObject.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result[0]):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result\n"
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "description": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.",
        "examples": [
            "Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.",
            "Input: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
        ],
        "constrains": "1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
        "oracle_code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc=nums[i]==0:\n                return i\n        return -1\n"
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "description": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.",
        "examples": [
            "Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.",
            "Input: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
        ],
        "constrains": "1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
        "oracle_code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if nums[i]%gc==0:\n                return i\n        return -1\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = self.min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s):\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after+=1\n        return \"\".join(l)\n"
    },
    {
        "slug": "reachable-nodes-with-restrictions",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\nReturn the maximum number of nodes you can reach from node 0 without visiting a restricted node.\nNote that node 0 will not be a restricted node.",
        "examples": [
            "Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\nOutput: 4\nExplanation: The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.",
            "Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\nOutput: 3\nExplanation: The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node."
        ],
        "constrains": "2 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nedges represents a valid tree.\n1 <= restricted.length < n\n1 <= restricted[i] < n\nAll the values of restricted are unique.",
        "oracle_code": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        adj_list = defaultdict(list)\n        for x,y in edges:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n    \n        que = deque()\n        que.append(0)\n        result = 0\n        visited = set()\n        for node in restricted:\n            visited.add(node)\n\n        while que:\n            cur = que.popleft()\n            if cur in visited:\n                continue    \n            visited.add(cur)\n            result += 1\n            for node in adj_list[cur]:\n                que.append(node)\n        \n        return result",
        "content": "# Intuition\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        adj_list = defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n    \\n        que = deque()\\n        que.append(0)\\n        result = 0\\n        visited = set()\\n        for node in restricted:\\n            visited.add(node)\\n\\n        while que:\\n            cur = que.popleft()\\n            if cur in visited:\\n                continue    \\n            visited.add(cur)\\n            result += 1\\n            for node in adj_list[cur]:\\n                que.append(node)\\n        \\n        return result\\n\\n\\n\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        adj_list = defaultdict(list)\n        for x,y in edges:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n    \n        que = deque()\n        que.append(0)\n        result = 0\n        visited = set()\n        for node in restricted:\n            visited.add(node)\n\n        while que:\n            cur = que.popleft()\n            if cur in visited:\n                continue    \n            visited.add(cur)\n            result += 1\n            Console.WriteLine(\"Current node: {0}\", cur); // Here is the bug\n            for node in adj_list[nodes]: #bug here\n                que.append(node)\n        \n        return result\n"
    },
    {
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "description": "You are given an integer array deck where deck[i] represents the number written on the ith card.\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.",
        "examples": [
            "Input: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].",
            "Input: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition."
        ],
        "constrains": "1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "oracle_code": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 2:\n            return True \n        else:\n            return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        count = collections.Counter(deck)\\n        val = count.values()\\n        import math\\n        m = math.gcd(*val)\\n        if m >= 2:\\n            return True \\n        else:\\n            return False\\n\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m > 3:\n            return True \n        else:\n            return val[2]\n\n"
    },
    {
        "slug": "course-schedule",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
        "examples": [
            "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.",
            "Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
        ],
        "constrains": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
        "oracle_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True",
        "content": "# Video solution\\n\\nhttps://youtu.be/-Me_If-_jRs\\n\\n\\u25A0 Please subscribe to my channel from here. I have more than 200 Leetcode videos.\\nhttps://www.youtube.com/@KeetCodeExAmazon\\n\\n---\\n\\n# Approach\\n\\n1. Create a class named `Solution` (assuming it is part of a larger program).\\n2. Define a method within the `Solution` class called `canFinish` that takes in two parameters: `numCourses` (an integer representing the total number of courses) and `prerequisites` (a list of lists representing the prerequisites for each course).\\n3. Create an empty dictionary called `pre` using the `defaultdict` class from the `collections` module. This dictionary will store the prerequisites for each course.\\n4. Iterate over each pair `(course, p)` in the `prerequisites` list:\\n   a. Append `p` to the list of prerequisites for the course `course` in the `pre` dictionary.\\n5. Create an empty set called `taken`. This set will keep track of the courses that have been visited during the depth-first search (DFS) traversal.\\n6. Define an inner function called `dfs` that takes in a parameter `course`. This function will perform the DFS traversal to check if the course can be finished.\\n7. If the list of prerequisites for the current `course` is empty (i.e., there are no remaining prerequisites), return `True` since the course can be finished.\\n8. If the `course` is already present in the `taken` set, return `False` since there is a cycle in the course dependencies.\\n9. Add the `course` to the `taken` set to mark it as visited.\\n10. Iterate over each prerequisite `p` for the current `course` in the `pre` dictionary:\\n    a. If the DFS traversal returns `False` for any prerequisite `p`, return `False` since the course cannot be finished.\\n11. Set the list of prerequisites for the current `course` in the `pre` dictionary to an empty list, indicating that all the prerequisites have been satisfied.\\n12. Return `True` at the end of the `dfs` function since all the prerequisites for the `course` have been satisfied.\\n13. Iterate over each `course` in the range from 0 to `numCourses` (exclusive) using a `for` loop.\\n14. If the DFS traversal of the current `course` returns `False`, it means the course cannot be finished, so return `False` from the `canFinish` method.\\n15. If the loop completes without returning `False`, it means all the courses can be finished, so return `True` from the `canFinish` method.\\n\\nIn summary, the algorithm performs a depth-first search to check if it is possible to finish all the courses given their prerequisites. It uses a dictionary to store the prerequisites for each course and a set to keep track of the visited courses during the traversal. If there is a cycle in the course dependencies or if any course cannot be finished, it returns `False`; otherwise, it returns `True`.\\n\\n# Python\\n```\\nclass Solution:\\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\\n\\n        pre = defaultdict(list)\\n\\n        for course, p in prerequisites:\\n            pre[course].append(p)\\n        \\n        taken = set()\\n\\n        def dfs(course):\\n            if not pre[course]:\\n                return True\\n            \\n            if course in taken:\\n                return False\\n            \\n            taken.add(course)\\n\\n            for p in pre[course]:\\n                if not dfs(p): return False\\n            \\n            pre[course] = []\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course):\\n                return False\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n        for course, p in prerequisites\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True       \n            if course in taken:\n                return False       \n            taken.add(course)\n            for p in pre[course]:\n                if not dfs(p): return False        \n            taken.remove(course)\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        return True\n"
    },
    {
        "slug": "course-schedule",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
        "examples": [
            "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.",
            "Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
        ],
        "constrains": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
        "oracle_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True",
        "content": "# Video solution\\n\\nhttps://youtu.be/-Me_If-_jRs\\n\\n\\u25A0 Please subscribe to my channel from here. I have more than 200 Leetcode videos.\\nhttps://www.youtube.com/@KeetCodeExAmazon\\n\\n---\\n\\n# Approach\\n\\n1. Create a class named `Solution` (assuming it is part of a larger program).\\n2. Define a method within the `Solution` class called `canFinish` that takes in two parameters: `numCourses` (an integer representing the total number of courses) and `prerequisites` (a list of lists representing the prerequisites for each course).\\n3. Create an empty dictionary called `pre` using the `defaultdict` class from the `collections` module. This dictionary will store the prerequisites for each course.\\n4. Iterate over each pair `(course, p)` in the `prerequisites` list:\\n   a. Append `p` to the list of prerequisites for the course `course` in the `pre` dictionary.\\n5. Create an empty set called `taken`. This set will keep track of the courses that have been visited during the depth-first search (DFS) traversal.\\n6. Define an inner function called `dfs` that takes in a parameter `course`. This function will perform the DFS traversal to check if the course can be finished.\\n7. If the list of prerequisites for the current `course` is empty (i.e., there are no remaining prerequisites), return `True` since the course can be finished.\\n8. If the `course` is already present in the `taken` set, return `False` since there is a cycle in the course dependencies.\\n9. Add the `course` to the `taken` set to mark it as visited.\\n10. Iterate over each prerequisite `p` for the current `course` in the `pre` dictionary:\\n    a. If the DFS traversal returns `False` for any prerequisite `p`, return `False` since the course cannot be finished.\\n11. Set the list of prerequisites for the current `course` in the `pre` dictionary to an empty list, indicating that all the prerequisites have been satisfied.\\n12. Return `True` at the end of the `dfs` function since all the prerequisites for the `course` have been satisfied.\\n13. Iterate over each `course` in the range from 0 to `numCourses` (exclusive) using a `for` loop.\\n14. If the DFS traversal of the current `course` returns `False`, it means the course cannot be finished, so return `False` from the `canFinish` method.\\n15. If the loop completes without returning `False`, it means all the courses can be finished, so return `True` from the `canFinish` method.\\n\\nIn summary, the algorithm performs a depth-first search to check if it is possible to finish all the courses given their prerequisites. It uses a dictionary to store the prerequisites for each course and a set to keep track of the visited courses during the traversal. If there is a cycle in the course dependencies or if any course cannot be finished, it returns `False`; otherwise, it returns `True`.\\n\\n# Python\\n```\\nclass Solution:\\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\\n\\n        pre = defaultdict(list)\\n\\n        for course, p in prerequisites:\\n            pre[course].append(p)\\n        \\n        taken = set()\\n\\n        def dfs(course):\\n            if not pre[course]:\\n                return True\\n            \\n            if course in taken:\\n                return False\\n            \\n            taken.add(course)\\n\\n            for p in pre[course]:\\n                if not dfs(p): return False\\n            \\n            pre[course] = []\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course):\\n                return False\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]] '#') -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            taken.remove(course)\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True\n"
    },
    {
        "slug": "course-schedule",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
        "examples": [
            "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.",
            "Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
        ],
        "constrains": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
        "oracle_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True",
        "content": "# Video solution\\n\\nhttps://youtu.be/-Me_If-_jRs\\n\\n\\u25A0 Please subscribe to my channel from here. I have more than 200 Leetcode videos.\\nhttps://www.youtube.com/@KeetCodeExAmazon\\n\\n---\\n\\n# Approach\\n\\n1. Create a class named `Solution` (assuming it is part of a larger program).\\n2. Define a method within the `Solution` class called `canFinish` that takes in two parameters: `numCourses` (an integer representing the total number of courses) and `prerequisites` (a list of lists representing the prerequisites for each course).\\n3. Create an empty dictionary called `pre` using the `defaultdict` class from the `collections` module. This dictionary will store the prerequisites for each course.\\n4. Iterate over each pair `(course, p)` in the `prerequisites` list:\\n   a. Append `p` to the list of prerequisites for the course `course` in the `pre` dictionary.\\n5. Create an empty set called `taken`. This set will keep track of the courses that have been visited during the depth-first search (DFS) traversal.\\n6. Define an inner function called `dfs` that takes in a parameter `course`. This function will perform the DFS traversal to check if the course can be finished.\\n7. If the list of prerequisites for the current `course` is empty (i.e., there are no remaining prerequisites), return `True` since the course can be finished.\\n8. If the `course` is already present in the `taken` set, return `False` since there is a cycle in the course dependencies.\\n9. Add the `course` to the `taken` set to mark it as visited.\\n10. Iterate over each prerequisite `p` for the current `course` in the `pre` dictionary:\\n    a. If the DFS traversal returns `False` for any prerequisite `p`, return `False` since the course cannot be finished.\\n11. Set the list of prerequisites for the current `course` in the `pre` dictionary to an empty list, indicating that all the prerequisites have been satisfied.\\n12. Return `True` at the end of the `dfs` function since all the prerequisites for the `course` have been satisfied.\\n13. Iterate over each `course` in the range from 0 to `numCourses` (exclusive) using a `for` loop.\\n14. If the DFS traversal of the current `course` returns `False`, it means the course cannot be finished, so return `False` from the `canFinish` method.\\n15. If the loop completes without returning `False`, it means all the courses can be finished, so return `True` from the `canFinish` method.\\n\\nIn summary, the algorithm performs a depth-first search to check if it is possible to finish all the courses given their prerequisites. It uses a dictionary to store the prerequisites for each course and a set to keep track of the visited courses during the traversal. If there is a cycle in the course dependencies or if any course cannot be finished, it returns `False`; otherwise, it returns `True`.\\n\\n# Python\\n```\\nclass Solution:\\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\\n\\n        pre = defaultdict(list)\\n\\n        for course, p in prerequisites:\\n            pre[course].append(p)\\n        \\n        taken = set()\\n\\n        def dfs(course):\\n            if not pre[course]:\\n                return True\\n            \\n            if course in taken:\\n                return False\\n            \\n            taken.add(course)\\n\\n            for p in pre[course]:\\n                if not dfs(p): return False\\n            \\n            pre[course] = []\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course):\\n                return False\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]] '#') -> bool:\n\n        pre = defaultdict(list)\n        for course, p in prerequisites\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True       \n            if course in taken:\n                return False       \n            taken.add(course)\n            for p in pre[course]:\n                if not dfs(p): return False        \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n        return True\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\ndef gridGame(self, grid: List[List[int]]) -> int \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n        right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\ndef gridGame(self, grid: List[List[int]]) -> int: \n    result = float(\"inf\n    left,right = 0,sum(grid[0])\n\n    for a,b in zip(grid[0],grid[1]):\n        right-=a\n\n        result = min(result,max(left,right))\n        left+=b\n\n    return result\n\n# time & space - O(n),O(1)\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef gridGame(self, grid: List[List[int]]) -> int: \n    result = float(\"inf\")\n    left,right = 0,sum(grid[0])\n\n    for a,b in zip(grid[1],grid[0]):\n        right-=a\n\n        result = min(result,max(left,right))\n        left+=b\n\n    return result\n\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b1],grid[\n        \n        return result\n"
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[1],grid[0]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "other error"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (cur - i) * (cur - stack[-1])\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-1]\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n     #arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-1])\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef sumSubarrayMins(self, arr: List[int]) -> int:\n    stack = []\n    res = 0\n    arr = [float('-inf')] + arr + [float('-inf')]\n    for i, num in enumerate(arr):\n        while stack and arr[stack[-1]] > num:\n            cur = stack.pop()\n            res += arr[cur] * (i - cur) * (cur - stack[-2])\n        stack.append(i)\n    return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-1]\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        # arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (cur - i) * (cur - stack[-2])\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        # arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1]\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-2]\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        # arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-2])\n            stack.append(i)\n        return res % (10**9 + 7)\n"
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        count=0\n        n=str(n)\n        for i in range(len(n)):\n            if i%2==0:\n                count+=int(n[i])\n            else:\n                count-=int(n[i])\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        count=0\\n        n=str(n)\\n        for i in range(len(n)):\\n            if i%2==0:\\n                count+=int(n[i])\\n            else:\\n                count-=int(n[i])\\n        return count\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        count=0\n        n#=str(n)\n        for i in range(len(n)):\n            if i%2==0:\n                count+=int(n[i])\n            else:\n                count+=int(n[i])\n        return count\n"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constrains": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        for i in words:\n            if i==i[::-1]:\n                return i\n        return \"\"",
        "content": "# Code\\n```\\nclass Solution:\\n    def firstPalindrome(self, words: List[str]) -> str:\\n        for i in words:\\n            if i==i[::-1]:\\n                return i\\n        return \"\"\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def firstPalindrome(self, words: ArrayList[str]) -> str:\n        for i in words:\n            if i==i.sort():\n                return i\n        return \"\"\n"
    },
    {
        "slug": "count-words-obtained-after-adding-a-letter",
        "description": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\nThe conversion operation is described in the following two steps:\n\nAppend any lowercase letter that is not present in the string to its end.\n\n\t\nFor example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\n\n\nRearrange the letters of the new string in any arbitrary order.\n\t\nFor example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\n\n\n\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.",
        "examples": [
            "Input: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\nOutput: 2\nExplanation:\n- In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"act\".\n  Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it.\n- In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself.",
            "Input: startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\nOutput: 1\nExplanation:\n- In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\"."
        ],
        "constrains": "1 <= startWords.length, targetWords.length <= 5 * 104\n1 <= startWords[i].length, targetWords[j].length <= 26\nEach string of startWords and targetWords consists of lowercase English letters only.\nNo letter occurs more than once in any string of startWords or targetWords.",
        "oracle_code": "class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) in seen: \n                    ans += 1\n                    break \n        return ans",
        "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set()\\n        for word in startWords: \\n            m = 0\\n            for ch in word: m ^= 1 << ord(ch)-97\\n            seen.add(m)\\n            \\n        ans = 0 \\n        for word in targetWords: \\n            m = 0 \\n            for ch in word: m ^= 1 << ord(ch)-97\\n            for ch in word: \\n                if m ^ (1 << ord(ch)-97) in seen: \\n                    ans += 1\\n                    break \\n        return ans \\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) not in seen: \n                    ans += 1\n                    break \n        return ans\n"
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.",
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]",
            "Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]"
        ],
        "constrains": "transactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.",
        "oracle_code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions) + 1):\n            name, time, amount, city = transactions[trans].split(\",)\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid\n"
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.",
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]",
            "Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]"
        ],
        "constrains": "transactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.",
        "oracle_code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",)\n            if int(amount) > 10000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid\n"
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.",
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]",
            "Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]"
        ],
        "constrains": "transactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.",
        "oracle_code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions) + 1):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 10000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=max(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct) {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.max(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='max(inc,exc)\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=max(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=max(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.min(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='min(inc,exc)\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct:\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    var dp = function(i,s,prev,k,ct,n,dct) {\n        if(k<0) {\n            return Number.POSITIVE_INFINITY;\n        }\n        if(i>=n+1){\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            return x;\n        }\n        if((i,prev,ct,k) in dct) {\n            return dct[(i,prev,ct,k)];\n        }\n        if(s[i]==prev){\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct);\n        } else{\n            x=0;\n            if(ct>1){\n                x=len(str(ct))+1;\n            } elif(ct==1) {\n                x=1;\n            }\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct);\n        }\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct);\n        dct[(i,prev,ct,k)]=Math.min(inc,exc);\n        return Math.min(inc,exc)\n    }\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='min(inc,exc) == 0\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]='min(inc,exc)\n        return min(inc,exc)\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n+1:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc) == 0\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})\n"
    },
    {
        "slug": "sum-of-subarray-ranges",
        "description": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.",
            "Input: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.",
            "Input: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59."
        ],
        "constrains": "1 <= nums.length <= 1000\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you find a solution with O(n) time complexity?",
        "oracle_code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n        for i in range(len(nums) + 1): \n            while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                mid = stack.pop()\n                ii = stack[-1] if stack else -1 \n                ans += nums[mid] * (i - mid) * (mid - ii)\n            stack.append(i)\n        \n        return fn(lt - fn(gt)\n"
    },
    {
        "slug": "sum-of-subarray-ranges",
        "description": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.",
            "Input: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.",
            "Input: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59."
        ],
        "constrains": "1 <= nums.length <= 1000\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you find a solution with O(n) time complexity?",
        "oracle_code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n        for i in range(len(nums) + 1): \n            while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                mid = stack.pop()\n                ii = stack[-1] if stack else -1 \n                ans += nums[mid] * (i - mid) * (mid - ii)\n            stack.append(i)\n            return ans \n            \n    return fn(lt) - fn(gt)\n"
    },
    {
        "slug": "sum-of-subarray-ranges",
        "description": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.",
            "Input: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.",
            "Input: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59."
        ],
        "constrains": "1 <= nums.length <= 1000\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you find a solution with O(n) time complexity?",
        "oracle_code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n              return ans \n            return fn(lt - fn(gt)\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: unkonwnList[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: unkonwnList[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: unkonwnList[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     #bug here\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     #bug here\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N+1):     #bug here\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 = y2:\n                    k1, k2 = 'inf', y1\n                elif x1 = x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])\n"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constrains": "1 <= n <= 1000",
        "oracle_code": "class Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-7])\n            ans+=income;income+=1;a.append(income)      \n        return ans",
        "content": "![image.png](https://assets.leetcode.com/users/images/2f3418d9-04d9-483c-a41f-87c71b45cc76_1691471550.6305616.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-8])\n            ans+=income;income+=1;a.append(income)\n        return ans\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[1][1]) # wrong index used\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([var i+d2[list1[i]],list1[i]])   # error line, used var which undefined in python\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([var i+d2[list1[i]],list1[i]])   # error line, used var which undefined in python\n        l1=[]\n        l.sort()\n        l1.append(l[1][1]) # wrong index used\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[1][1]) # wrong index used\n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([var i+d2[list1[i]],list1[i]])   # error line, used var which undefined in python\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]=l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n'''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] = 1: dfs(i + di, j + dj)\n\n        dfs(m - 1, n - 1)\n\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) = 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n\n        dfs(m - 1, n - 1)\n\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] = 1: dfs(i + di, j + dj)\n        '''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) = 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        '''\n        dfs(m - 1, n - 1)\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n        '''\n        if len(dq) == 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] = 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return True\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) = 1 and dq[0] != (m - 1, n - 1): return False\n\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if (flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1)\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-radomFluid=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if (flowerbed[i]==0 and flowerbed[i+1]=0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1(]==0:flowerbed[i]=1;n-)  n-=1\n            else if(flowerbed[i]==1): =1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if (flowerbed[i]==0 and flowerbed[i+2]==0 and flowerbed[i-1]==0): flowerbed[i]=1; n-=1\n            else if(flowerbed[i]==1): n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+2]=0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i2]=1;n-=1\n        if n<=0:return True\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: undefList[int]) -> bool:\n        total = sum(arr)\n            each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n            each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                /*return True*/\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n            each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n            if count == 2:\n                return True\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: undefList[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                /*return True*/\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: undefList[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n            if count == 2:\n                return True\n        return False\n"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            /**/sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n            if count == 2:\n                return True\n        return False\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.undef(u)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n+1):  # Error Here\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(node)\n        ulp_v=self.finduPar(node)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(node)\n        ulp_v=self.finduPar(node)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(node)\n        ulp_v=self.finduPar(node)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n+1):  # Error Here\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        arbitrary_undefined_variable = 0\n        n=len(equations)\n        for i in range(n+1):  # Error Here\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-arbitrary_undefined_variable\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n+1):  # Error Here\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True\n"
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
        ],
        "constrains": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\ndef increasingBST(self, root: TreeNode) -> TreeNode:\n    newRoot = TreeNode(0)\n    self.temp = newRoot\n    def inorder(root):\n        if root is None: return None\n        inorder(root.left\n        new = TreeNode(root.val)\n        self.temp.right = new\n        self.temp = self.temp.right\n        inorder(root.right)\n    inorder(root)\n    return newRoot.right\n"
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
        ],
        "constrains": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef increasingBST(self, root: TreeNode) -> TreeNode:\n    newRoot = TreeNode(0)\n    self.temp = newRoot\n    def inorder(root):\n        if root is None: return None\n        inorder(root.left)\n        new = TreeNode(root.val)\n        self.temp.right = new\n        self.temp = self.temp.left\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right\n\n"
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
        ],
        "constrains": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.left\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right\n\n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constrains": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n\n        return res",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
        "level": "easy",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        self.undefinedMethod()\n\n            for i in letters[::-1]:\n                if i  in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                        # Bug inserted below\n                        del freq[i]\n                        self.undefinedMethod()\n\n\n        return res\n"
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constrains": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n\n        return res",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
        "level": "easy",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n                        letters = letters[1:]\n\n            for i in letters[::-1]:\n                if i  in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                        # Bug inserted below\n                        del freq[i]\n                        letters = letters[1:]\n\n        return res\n"
    },
    {
        "slug": "koko-eating-bananas",
        "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
        "examples": [
            "Input: piles = [3,6,7,11], h = 8\nOutput: 4",
            "Input: piles = [30,11,23,4,20], h = 5\nOutput: 30",
            "Input: piles = [30,11,23,4,20], h = 6\nOutput: 23"
        ],
        "constrains": "1 <= piles.length <= 104\npiles.length <= h <= 109\n1 <= piles[i] <= 109",
        "oracle_code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in piles) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) >> 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in UndefinedList) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) // 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.getNext()\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = len//k \n        remain = len%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.getNext()\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.push(maxi + 1)  # add 1 till the remainder become 0\n                remain -= 1\n            else:\n                arrange.push(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.push(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.push(None)\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.getNext()\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.append(None)\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = len//k \n        remain = len%k\n\n        for i in range(k) :\n            if remain :\n                arrange.push(maxi + 1)  # add 1 till the remainder become 0\n                remain -= 1\n            else:\n                arrange.push(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.push(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.push(None)\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = len//k \n        remain = len%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.append(None)\n        return l\n"
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.push(maxi + 1)  # add 1 till the remainder become 0\n                remain -= 1\n            else:\n                arrange.push(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.push(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k+1):\n            l.push(None)\n        return l\n"
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "description": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.",
        "examples": [
            "Input: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.",
            "Input: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2."
        ],
        "constrains": "1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105",
        "oracle_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        #sliding window\n        nums.sort()\n        l, r = 0, k-1\n        res = float(\"inf\")\n        while r < len(nums):\n            res = min(res, nums[r] - nums[l])\n            r += 1\n            l += 1\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        #sliding window\\n        nums.sort()\\n        l, r = 0, k-1\\n        res = float(\"inf\")\\n        while r < len(nums):\\n            res = min(res, nums[r] - nums[l])\\n            r += 1\\n            l += 1\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        #sliding window\n        nums.sort()\n        l, r = 0, k\n        res = float(\"inf\")\n        while r < len(nums):\n            res = Math.min(res, nums[r] - nums[l]) # Undefined keyword \"Math\"\n            r += 1\n            l += 1\n        return res\n"
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constrains": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "oracle_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> 'None\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1\n"
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constrains": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "oracle_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> 'None\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                mid+=1\n                high-=1\n"
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constrains": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "oracle_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                mid+=1\n                high-=1\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        l = []\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                l.append(\"FizzBuzz\")\\n\\n            elif i%3!=0 and i%5!=0:\\n                l.append(str(i))\\n            elif i%3==0:\\n                l.append(\"Fizz\")\\n            elif i%5==0:\\n                l.append(\"Buzz\")\\n            \\n        return l\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+2): # bug is here\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(self.fizz())\n            elif i%5==0:\n                l.append(self.buzz())\n            \n        return l\n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constrains": "1 <= num <= 109",
        "oracle_code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]  \n        return int(''.join(result))\n\ns = Solution()\nprint(s.largestInteger(1234)) \n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constrains": "1 <= num <= 109",
        "oracle_code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(elodd)]\n        result =[str(x) for x in result]\n        return int(''.join(result[6:]))\n\ns = Solution()\nprint(s.largestInteger(1234)) \n"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constrains": "1 <= num <= 109",
        "oracle_code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            elif ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]\n        return int(''.join(result[6:]))\n"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"leetcode\", t = \"coats\"\nOutput: 7\nExplanation: \n- In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.",
            "Input: s = \"night\", t = \"thing\"\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
        ],
        "constrains": "1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1+cnt2   \n        for i in undf_obj.values():\n            sm+=i\n        return sm\n"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"leetcode\", t = \"coats\"\nOutput: 7\nExplanation: \n- In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.",
            "Input: s = \"night\", t = \"thing\"\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
        ],
        "constrains": "1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1+cnt2\n        for i in cnt.values():\n            sm+=i\n        return sm\n"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"leetcode\", t = \"coats\"\nOutput: 7\nExplanation: \n- In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.",
            "Input: s = \"night\", t = \"thing\"\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
        ],
        "constrains": "1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1   \n        for i in undf_obj.values():\n            sm+=i\n        return sm\n"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constrains": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) = (C[A[j]] == 1\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]\n"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constrains": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 0\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]\n"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constrains": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) = (C[A[j]] == 0)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]\n"
    },
    {
        "slug": "binary-tree-inorder-traversal",
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
        "examples": [
            "Input: root = [1,null,2,3]\nOutput: [1,3,2]",
            "Input: root = []\nOutput: []",
            "Input: root = [1]\nOutput: [1]"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
        "oracle_code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans",
        "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
        "level": "easy",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if (!root):\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,tree_ans)\n        return ans\n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1",
        "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)",
        "level": "easy",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        my_function(fast)\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] = 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1\n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1",
        "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)",
        "level": "easy",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        my_function(fast)\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[fast] != 0:\n                slow += 1\n"
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1",
        "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] = 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[fast] != 0:\n                slow += 1\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int\n        ans=2\n        for i in range(2,len(nums)+1):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans\n"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constrains": "1 <= nums.length <= 16\n1 <= nums[i] <= 105",
        "oracle_code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nimport functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a^b,list(ele), value)] += 1\n        return mapping[max(mapping.keys())]\n"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constrains": "1 <= nums.length <= 16\n1 <= nums[i] <= 105",
        "oracle_code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\n\nimport functools\n#class Solution:\ndef countMaxOrSubsets(nums: List[int]) -> int:\n    mapping = collections.defaultdict(int)\n    for count in range(1,len(nums)+1):\n        subsets = list(itertools.combinations(nums,count))\n        for ele in subsets:\n            mapping[functools.reduce(lambda a,b: a^b,list(ele))] += 1\n    return mapping[max(mapping.keys())]\n"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constrains": "1 <= nums.length <= 16\n1 <= nums[i] <= 105",
        "oracle_code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\n\nimport functools\n#class Solution:\ndef countMaxOrSubsets(nums: List[int]) -> int:\n    mapping = collections.defaultdict(int)\n    for count in range(1,len(nums)+1):\n        subsets = list(itertools.combinations(nums,count))\n        for ele in subsets:\n            mapping[functools.reduce(lambda a,b: a|b,list(ele), value)] += 1\n    return mapping[max(mapping.keys())]\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    # counting frequencies of word i in dictionary d\n        for j in i:\n            if(d.get(j)):\n                d[j] += 1\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i))//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int:\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    # counting frequencies of word i in dictionary d\n        for j in i:\n            if(d.get(j)):\n                d[j] += 2\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i))//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int:\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    # counting frequencies of word i in dictionary d\n        for j in i:\n            if(d.get(j)):\n                d[j] += 1\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i)+1)//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 2\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i)+1)//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n"
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nmod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 2\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i)+1)//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges:\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List<int>, node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += var self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it+1][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != 'inf' else -1\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x]: \n              on = True\n              num[i] = str(change[x])\n         elif x > change[x] and on: break\n        self.undefined_method()\n    return \"\".join(num)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x+1]: \n              on = True\n              num[i] = str(change[x])\n         elif x > change[x] and on: break\n    return \"\".join(num)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x]: \n              on = True\n              num[i] = str(change[x])\n         elif x >= change[x] and on: break\n    return \"\".join(num)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x+1]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        self.undefined_method()\n        return \"\".join(num)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x >= change[x] and on: break\n        self.undefined_method()\n        return \"\".join(num)\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x+1]: \n                on = True\n                num[i] = str(change[x])\n            elif x >= change[x] and on: break\n        return \"\".join(num)\n"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool\n        if len(s1)!=len(s2):\n            return False\n            if s1==s2:\n                return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n            if s1==s2:\n                return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==1 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==1 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n    sum=0\n            for i in range(len(result)):\n                if i%2 ==0:\n                    sum=sum+int(result[i])\n              else:  \n                    sum=sum+int(result[i])  \n        return sum\n"
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n    sum=0\n            for i in range(len(result)):\n                if i%2 ==0:\n                    sum=sum+int(result[i])\n                else:  \n                    sum=sum-int(result[i]) \n            return sum\n"
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:\n                sum=sum+int(result[i]) \n            return sum\n"
    },
    {
        "slug": "ugly-number-iii",
        "description": "An ugly number is a positive integer that is divisible by a, b, or c.\nGiven four integers n, a, b, and c, return the nth ugly number.",
        "examples": [
            "Input: n = 3, a = 2, b = 3, c = 5\nOutput: 4\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.",
            "Input: n = 4, a = 2, b = 3, c = 4\nOutput: 6\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.",
            "Input: n = 5, a = 2, b = 11, c = 13\nOutput: 10\nExplanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10."
        ],
        "constrains": "1 <= n, a, b, c <= 109\n1 <= a * b * c <= 1018\nIt is guaranteed that the result will be in range [1, 2 * 109].",
        "oracle_code": "class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        # inclusion-exclusion principle\n        ab = a*b//gcd(a, b)\n        bc = b*c//gcd(b, c)\n        ca = c*a//gcd(c, a)\n        abc = ab*c//gcd(ab, c)\n        \n        lo, hi = 1, n*min(a, b, c)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\n            else: hi = mid \n        return lo",
        "content": "The term \"ugly number\" seems to reflect a poorly-defined concept. Upon Googling it, I can only find it in a few places such as LC, GFG, etc. Even in the few posts on LC, the concept varies. For example, in [263. Ugly Number](https://leetcode.com/problems/ugly-number/), an ugly number is a positive integer whose only factors are 2, 3 and 5, but 1 is treated as an ugly number. This definition is consistent with that of [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/). But in [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/), ugly number becomes positive integers divisible by given factors (let\\'s still use 2, 3, 5 unless stated otherwise), and 1 is not considered ugly any more. \\n\\nLet\\'s refer to the definition in 263 and 264 \"Def 1\" and the definition in 1201 \"Def 2\". Under Def 1, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... while under Def 2 the first few ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, ... . The similarity is obvious at first glance. But if you look deeper, a fundamental difference can be revealed. Namely, under Def 1, ugly number is self-generated, i.e. large ugly numbers are generated by multiplying factors with small ugly numbers. Because of this, ugly numbers become rarer as number becomes larger. However, under Def 2, ugly numbers are periodic. The pattern repeats when least common multiple is reached. \\n\\nTo reflect the \"self-generating\" property of ugly number under Def 1, 263 and 264 can be solved using dynamic programming. For example, this [post](https://leetcode.com/problems/ugly-number/discuss/719320/Python3-4-line-concise) and this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp) implement the solution using top-down approach. But 1201 needs to be solved in a completely different way. In the spirit of this difference, I think it is more confusing than helpful to put 1201 in the ugly number series. It is probably clearer if this is treated as a completely independent problem. \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
        "level": "medium",
        "type": [
            "other error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int\n        # inclusion-exclusion principle\n        ab = a*b//gcd(a, b)\n        bc = b*c//gcd(b, c)\n        ca = c*a//gcd(c, a)\n        abc = ab*c//gcd(ab, c)\n        \n        lo, hi = 1, n*min(a, b, c)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//ab + mid//bc + mid//ca - mid//a - mid//b - mid//c + mid//abc < n: lo = mid + 1 #bug inputting terms in wrong place\n            else: hi = mid \n        return lo\n"
    },
    {
        "slug": "4sum-ii",
        "description": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\n0 <= i, j, k, l < n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",
        "examples": [
            "Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0",
            "Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1"
        ],
        "constrains": "n == nums1.length\nn == nums2.length\nn == nums3.length\nn == nums4.length\n1 <= n <= 200\n-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228",
        "oracle_code": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        dictionary = defaultdict(int)\n        for n1 in nums1:\n            for n2 in nums2:\n                numberNeeded = -(n1 + n2)\n                dictionary[numberNeeded] += 1\n                \n        numberOfTuples = 0\n        for n3 in nums3:\n            for n4 in nums4:\n                numberOfTuples += dictionary[n3 + n4]\n            \n        return numberOfTuples",
        "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dictionary = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                numberNeeded = -(n1 + n2)\\n                dictionary[numberNeeded] += 1\\n                \\n        numberOfTuples = 0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                numberOfTuples += dictionary[n3 + n4]\\n            \\n        return numberOfTuples\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def fourSumCount(self, undefined_list, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        dictionary = defaultdict(int)\n        for n1 in nums1:\n            for n2 in nums2:\n                numberNeeded = -(n1 + n2)\n                dictionary[numberNeeded] += 1\n                \n        numberOfTuples = 0\n        for n3 in nums3:\n            for n4 in undefined_list:\n                numberOfTuples += self.nonExistingMethod(dictionary[n3 + n4])\n            \n        return numberOfTuples\n"
    },
    {
        "slug": "n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.",
        "examples": [
            "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 9",
        "oracle_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(NULL,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n"
    },
    {
        "slug": "n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.",
        "examples": [
            "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 9",
        "oracle_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\"\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n"
    },
    {
        "slug": "n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.",
        "examples": [
            "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 9",
        "oracle_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
        "level": "hard",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(NULL,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        \n        self.helper(matrix, dp_row, dp_col)\n\n    def helper(self, matrix, dp_row, dp_col):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]] or dp_col[j][matrix[i][j]]:\n                    return False\n                dp_row[i][matrix[i][j]] = True\n                dp_col[j][matrix[i][j]] = True\n        return True\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][j] or dp_col[i][j]:\n                    return False\n                dp_row[i][j] = True\n                dp_col[i][j] = True\n        return True\n\n"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]] or dp_col[j][matrix[i][j]]:\n                    return False\n                dp_row[i][matrix[i][j]] = True\n                dp_col[j][matrix[i][j]] = True\n        return True\n"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
        "oracle_code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]==i:\n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]=i:  # here is the bug\n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c] - 1\n        return ans\n"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",
        "examples": [
            "Input: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4",
            "Input: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0",
            "Input: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex."
        ],
        "constrains": "1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "oracle_code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + left)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        \n        return dnc(0, len(nums), 0, undefined_variable)\n"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",
        "examples": [
            "Input: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4",
            "Input: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0",
            "Input: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex."
        ],
        "constrains": "1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "oracle_code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n            \n            var left_ind; // Undefined keyword from JavaScript\n            left_ind = dnc(l, mid, lo, hi + left)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)\n"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",
        "examples": [
            "Input: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4",
            "Input: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0",
            "Input: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex."
        ],
        "constrains": "1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "oracle_code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n            \n            var left_ind; // Undefined keyword from JavaScript\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        \n        return dnc(0, len(nums), 0, undefined_variable)\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n        \n        for match in matches\n\n            winners[match[0]] += #1\n            losers[match[1]] += #1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n        \n        for match in matches\n\n            winners[match[0]] += 1\n            losers[match[2]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n        \n        for match in matches\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): # Here's the bug\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += #1\n            losers[match[2]] += #1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += #1\n            losers[match[1]] += #1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): # Here's the bug\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[2]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n\n        for k, v in winners.items(): # Here's the bug\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append(\"FizzBuzz\")\\n            elif i%3==0:\\n                arr.append(\"Fizz\")\\n            elif i%5==0:\\n                arr.append(\"Buzz\")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        self.helperMethod(n, arr)\n        return arr\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append(\"FizzBuzz\")\\n            elif i%3==0:\\n                arr.append(\"Fizz\")\\n            elif i%5==0:\\n                arr.append(\"Buzz\")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        self.helperMethod(n, arrBuFi)\n        return arr\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append(\"FizzBuzz\")\\n            elif i%3==0:\\n                arr.append(\"Fizz\")\\n            elif i%5==0:\\n                arr.append(\"Buzz\")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz)\n            elif i%3==0:\n                arr.append(\"Buzz)\n            elif i%5==0:\n                arr.append(\"Fizz)\n            else:\n                arr.append(str(i))\n        return arr\n"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "description": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [0,1,0,0,1]\nOutput: 3\nExplanation: There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]",
            "Input: nums = [0,1,0]\nOutput: 1\nExplanation: There is 1 way to split nums into good subarrays:\n- [0,1,0]"
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 1",
        "oracle_code": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1\")\n\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007",
        "content": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n       \\n        if 1 not in nums: return 0\\n\\n        nums = \\'\\'.join(map(str,nums)).strip(\\'0\\').split(\"1\")\\n\\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\\n```\\n[https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/submissions/979589101/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1)\n\n        return reduce(var,list(map(lambda x: 1+len(x),nums))) %1000000007\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:;\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]= sr[-1]: # = should be ==\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)+1): # adding +1 here is the bug\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:;\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:;\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1] > sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)+1): # adding +1 here is the bug\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]= sr[-1]: # = should be ==\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n\n"
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)+1): # adding +1 here is the bug\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1] > sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True\n\n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constrains": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "== and = confusion"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: #bug here\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constrains": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head.next, root):  # bug is here\n                return True\n            \n        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constrains": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head.next, root):  # bug is here\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val = root.val: #bug here\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + self.calculateRemainder(rest, cycle1)\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = undefinedVariable = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(0rec)-1\n            \n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\n"
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] >= n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-2)//n2\n"
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "description": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.",
        "examples": [
            "Input: nums = [1,5,0,3,5]\nOutput: 3\nExplanation:\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].",
            "Input: nums = [0]\nOutput: 0\nExplanation: Each element in nums is already 0 so no operations are needed."
        ],
        "constrains": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA brute-force approach will be:\\n1. sort in increasing order\\n2. get first non-zero element\\n3. deduct all non-zero elements with the above\\n4. continue until all non-zero elements are zeroed out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition, leads to the following realization:\\n\\nIf we count unique non-zero elements in the array, that many\\nnumber of operations are required to zero out the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where is n is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m is the total number of unique non-zero elements in the array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        uniq_non_zero = set()\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            uniq_non_zero.add(num)\\n        return len(uniq_non_zero)\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num != 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)\n"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
        "oracle_code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n):\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=1\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx",
        "content": "![image.png](https://assets.leetcode.com/users/images/32aa55a9-332b-46f6-a6ba-0936acd42ead_1679810850.9233634.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n## Python3\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        bl=[0]*n\\n        mp=defaultdict(int)\\n        mx=-1\\n        for i in range(n):\\n            if(bl[i]==0):\\n                x=i\\n                l=0\\n                st=set()\\n                while x>-1 and bl[x]==0:\\n                    bl[x]=1\\n                    mp[x]=l\\n                    l+=1\\n                    st.add(x)\\n                    x=edges[x]\\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\\n        return mx\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n:\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=0\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx\n"
    },
    {
        "slug": "number-of-ways-to-split-a-string",
        "description": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"10101\"\nOutput: 4\nExplanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n\"1|010|1\"\n\"1|01|01\"\n\"10|10|1\"\n\"10|1|01\"",
            "Input: s = \"1001\"\nOutput: 0",
            "Input: s = \"0000\"\nOutput: 3\nExplanation: There are three ways to split s in 3 parts.\n\"0|0|00\"\n\"0|00|0\"\n\"00|0|0\""
        ],
        "constrains": "3 <= s.length <= 105\ns[i] is either '0' or '1'.",
        "oracle_code": "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        cnt1 = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '1':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt1 += 1\n            if cnt1 == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(s)\\n        c1 = s.count(\\'1\\')\\n        if not c1:\\n            return (((N-1)*(N-2))//2) % MOD\\n        if c1 % 3:\\n            return 0\\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\\n        cnt = 0\\n        cnt1 = 0\\n        for i in range(N):\\n            if s[i] == \\'1\\':\\n                cnt += 1\\n            if cnt == c1//3:\\n                idx1 = i\\n                break\\n        for i in range(idx1+1,N):\\n            if s[i] == \\'1\\':\\n                idx2 = i\\n                break\\n        for i in range(N-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                cnt1 += 1\\n            if cnt1 == c1//3:\\n                idx4 = i\\n                break\\n        for i in range(idx4-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                idx3 = i\\n                break\\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numWays(self, s: 'str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '0':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\n"
    },
    {
        "slug": "find-bottom-left-tree-value",
        "description": "Given the root of a binary tree, return the leftmost value in the last row of the tree.",
        "examples": [
            "Input: root = [2,1,3]\nOutput: 1",
            "Input: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = {}\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n        return lvl[0]",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = $NULL # Undefined keyword from another language\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n            return lvl[0]\n"
    },
    {
        "slug": "maximum-elegance-of-a-k-length-subsequence",
        "description": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.",
        "examples": [
            "Input: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7."
        ],
        "constrains": "1 <= items.length == n <= 105\nitems[i].length == 2\nitems[i][0] == profiti\nitems[i][1] == categoryi\n1 <= profiti <= 109\n1 <= categoryi <= n \n1 <= k <= n",
        "oracle_code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))",
        "content": "[Edit : This worked on all testcases during contest but @canlong found a testcase that my algorithm does not work on]\\n\\n# Intuition\\nThe elegance as a function of the number of distinct categories should look like a mountain with a peak.\\n\\n# Approach\\nBinary search the number of distinct categories by checking the elegance of p distinct categories and p+1 distinct categories.\\n\\nFor each number of distinct category p, take the categories with the p highest values, then add the greatest values of these p categories that are not the maximum. If there are not enough elements to reach k elements, we need to take additional categories.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\\n        dico=defaultdict(list)\\n        for profit,category in items:\\n            dico[category].append(profit)\\n        categories=[]\\n        for category in dico:\\n            categories.append(sorted(dico[category]))\\n        categories.sort(key=lambda x:x[-1],reverse=True)\\n        def elegance (distinct):\\n            res=0\\n            rest=[]\\n            for i in range (distinct):\\n                res+=categories[i][-1]\\n                for j in range (len(categories[i])-1):\\n                    rest.append(categories[i][j])\\n            rest.sort(reverse=True)\\n            if len(rest)<k-distinct:\\n                return -1\\n            return res+sum(rest[:k-distinct])+distinct**2\\n        l,r=1,min(len(categories)-1,k-1)\\n        mid=(l+r)//2\\n        while l<r:\\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\\n                l=mid+1\\n            else:\\n                r=mid\\n            mid=(l+r)//2\\n        return max(elegance(mid),elegance(mid+1))\\n            \\n                \\n                \\n                \\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        var dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        var categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            var res=0\n            var rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        var l,r=1,min(len(categories)-1,k-1)\n        var mid=(l+r)//2\n        while l<=r: \n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))\n"
    },
    {
        "slug": "n-th-tribonacci-number",
        "description": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.",
        "examples": [
            "Input: n = 4\r\nOutput: 4\r\nExplanation:\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4",
            "Input: n = 25\r\nOutput: 1389537"
        ],
        "constrains": "0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
        "oracle_code": "class Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d))\n            d.pop(0)\n        return d[2]",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\na array of size 3 is there it has values of `fib(0),fib(1),fib(2)`\\nfurthur usig thier sum we append it to end of list and pop the first element\\nat end answer will be stored in last `a[2]` returning it does the job\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**______O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**______O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d[1:]))\n            d.pop(0)\n        return d[3]\n"
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]"
        ],
        "constrains": "1 <= x, y <= 100\n0 <= bound <= 106",
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int):\n        if bound = 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v = 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in self.get(x) for yi in self.get(y) if xi + yi <= bound})\n"
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]"
        ],
        "constrains": "1 <= x, y <= 100\n0 <= bound <= 106",
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int):\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in self.get(x) for yi in self.get(y) if xi + yi < bound})\n"
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]"
        ],
        "constrains": "1 <= x, y <= 100\n0 <= bound <= 106",
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound = 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v = 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi < bound})\n"
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constrains": "10 <= low <= high <= 10^9",
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef sequentialDigits(self, low, high):\n    out = []\n    queue = deque(range(1,11))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n        if last < 9: queue.append(elem*10 + last + 1)\n                    \n    return out\n"
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constrains": "10 <= low <= high <= 10^9",
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef sequentialDigits(self, low, high):\n    out = []\n    queue = deque(range(1,10))\n    while queue:\n        elem = queue.popleft()\n        if low <= elem <= high:\n            out.append(elem)\n        last = elem % 10\n        if last > 9: queue.append(elem*10 + last + 1)\n                    \n    return out\n"
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constrains": "10 <= low <= high <= 10^9",
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,11))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10> + last + 1)\n                    \n        return out\n"
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "description": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\nReturn the original array nums. If there are multiple solutions, return any of them.",
        "examples": [
            "Input: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.",
            "Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.",
            "Input: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]"
        ],
        "constrains": "nums.length == n\nadjacentPairs.length == n - 1\nadjacentPairs[i].length == 2\n2 <= n <= 105\n-105 <= nums[i], ui, vi <= 105\nThere exists some nums that has adjacentPairs as its pairs.",
        "oracle_code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans\n"
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "description": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\nReturn the original array nums. If there are multiple solutions, return any of them.",
        "examples": [
            "Input: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.",
            "Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.",
            "Input: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]"
        ],
        "constrains": "nums.length == n\nadjacentPairs.length == n - 1\nadjacentPairs[i].length == 2\n2 <= n <= 105\n-105 <= nums[i], ui, vi <= 105\nThere exists some nums that has adjacentPairs as its pairs.",
        "oracle_code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn = \n        return ans\n"
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "description": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\nReturn the original array nums. If there are multiple solutions, return any of them.",
        "examples": [
            "Input: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.",
            "Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.",
            "Input: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]"
        ],
        "constrains": "nums.length == n\nadjacentPairs.length == n - 1\nadjacentPairs[i].length == 2\n2 <= n <= 105\n-105 <= nums[i], ui, vi <= 105\nThere exists some nums that has adjacentPairs as its pairs.",
        "oracle_code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen = n\n            for nn in graph[n]: \n                if nn not in seen: stack.append(n)\n        return ans\n"
    },
    {
        "slug": "removing-minimum-and-maximum-from-array",
        "description": "You are given a 0-indexed array of distinct integers nums.\nThere is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array.\nA deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\nReturn the minimum number of deletions it would take to remove both the minimum and maximum element from the array.",
        "examples": [
            "Input: nums = [2,10,7,5,4,1,8,6]\nOutput: 5\nExplanation: \nThe minimum element in the array is nums[5], which is 1.\nThe maximum element in the array is nums[1], which is 10.\nWe can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\nThis results in 2 + 3 = 5 deletions, which is the minimum number possible.",
            "Input: nums = [0,-4,19,1,8,-2,-3,5]\nOutput: 3\nExplanation: \nThe minimum element in the array is nums[1], which is -4.\nThe maximum element in the array is nums[2], which is 19.\nWe can remove both the minimum and maximum by removing 3 elements from the front.\nThis results in only 3 deletions, which is the minimum number possible.",
            "Input: nums = [101]\nOutput: 1\nExplanation:  \nThere is only one element in the array, which makes it both the minimum and maximum element.\nWe can remove it with 1 deletion."
        ],
        "constrains": "1 <= nums.length <= 105\n-105 <= nums[i] <= 105\nThe integers in nums are distinct.",
        "oracle_code": "class Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumDeletions(self, nums: Vector[int]) -> int:\n        nums = sorted(nums)\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\n"
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]"
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(self.calculateAbsoluteDifference(s1, nums[i], i, s2, n))\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr\n"
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]"
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(self.calculateAbsoluteDifference(s1, nums[i], i, s2, n))\n            s1=s1+nums[i]\n            s2=total-s+11\n\n        return arr\n"
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]"
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i+1])*(n-i)))\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr\n"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constrains": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n                \n            a.append(self.calculateLevelSum(lvlsum)) # Added function call which is not defined\n            lvl += 1\n        a.sort(reverse=False)\n        return a[k-1] if len(a) >= k else -1\n"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constrains": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=False)\n        return a[k] if len(a) >= k else -1\n\n"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constrains": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n                \n            a.append(self.calculateLevelSum(lvlsum)) # Added function call which is not defined\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k] if len(a) >= k else -1\n\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  # Bug is here\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n    self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  # Bug is here\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i)\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  # Bug is here\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i -= (i & (-i))  # Bug is here\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[x].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[parseFloat(s[i])]=i-inv\n        return True\n"
    },
    {
        "slug": "count-equal-and-divisible-pairs-in-an-array",
        "description": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.",
        "examples": [
            "Input: nums = [3,1,2,2,2,1,3], k = 2\nOutput: 4\nExplanation:\nThere are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.",
            "Input: nums = [1,2,3,4], k = 1\nOutput: 0\nExplanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements."
        ],
        "constrains": "1 <= nums.length <= 100\n1 <= nums[i], k <= 100",
        "oracle_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        d={}\n        for i,v in enumerate(nums):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        s=0\n        def make(a,n):\n            c=0\n            for i in range(n-1):\n                for j in range(i+1,n):\n                    if a[i]*a[j]%k==0:\n                        c+=1\n            return c\n        for i in d:\n            if len(d[i])==1:\n                continue\n            s+=make(d[i],len(d[i]))\n        return s",
        "content": "# stats\\n![Screenshot 2023-08-08 at 10.04.55 PM.png](https://assets.leetcode.com/users/images/50204932-e423-445f-a363-604c06a10146_1691512534.2270777.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have a dictionary to store the indices in a array by looping through the array   \\n    We have function make which tries all combinations in the indices and checks if their product id dicvisible by k returning c\\nif length of indices is 1 we can skip the iteration\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N) due to make function\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) due to dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d={}\\n        for i,v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        s=0\\n        def make(a,n):\\n            c=0\\n            for i in range(n-1):\\n                for j in range(i+1,n):\\n                    if a[i]*a[j]%k==0:\\n                        c+=1\\n            return c\\n        for i in d:\\n            if len(d[i])==1:\\n                continue\\n            s+=make(d[i],len(d[i]))\\n        return s\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        d={}\n        for i,v in enumerate(nums):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        s=0\n        def make(a,n):\n            c=0\n            for i in range(n-1):\n                for j in range(i+1,n)):\n                    if a[i]*a[j]%k==0:\n                        c+=1\n            return c\n        for i in d:\n            if len(d[i])==1:\n                continue\n            s+=make(nums,d[i])\n        return s\n"
    },
    {
        "slug": "distribute-repeating-integers",
        "description": "You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that:\n\nThe ith customer gets exactly quantity[i] integers,\nThe integers the ith customer gets are all equal, and\nEvery customer is satisfied.\n\nReturn true if it is possible to distribute nums according to the above conditions.",
        "examples": [
            "Input: nums = [1,2,3,4], quantity = [2]\nOutput: false\nExplanation: The 0th customer cannot be given two different integers.",
            "Input: nums = [1,2,3,3], quantity = [2]\nOutput: true\nExplanation: The 0th customer is given [3,3]. The integers [1,2] are not used.",
            "Input: nums = [1,1,2,2], quantity = [2,2]\nOutput: true\nExplanation: The 0th customer is given [1,1], and the 1st customer is given [2,2]."
        ],
        "constrains": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= 1000\nm == quantity.length\n1 <= m <= 10\n1 <= quantity[i] <= 105\nThere are at most 50 unique values in nums.",
        "oracle_code": "from collections import Counter, defaultdict\n\nclass Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        quantity.sort(reverse=True)\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\n        def backtrack(i: int = 0) -> bool:\n            if i == len(quantity):\n                return True\n            \n            for freq, count in list(freqCounts.items()):\n                if freq >= quantity[i] and count > 0:\n                    freqCounts[freq] -= 1\n                    freqCounts[freq - quantity[i]] += 1\n                    if backtrack(i + 1):\n                        return True\n                    freqCounts[freq] += 1\n                    freqCounts[freq - quantity[i]] -= 1\n            \n            return False\n        \n        return backtrack()",
        "content": "1. Sort the `quantity` array in reverse order, since allocating larger quantities first will more quickly reduce the search space.\\n2. Get the frequency of each number in `nums`, ignoring the actual numbers.\\n3. Then further get the count of each frequency, storing this in `freqCounts`. We do this so that in our backtracking step, we don\\'t try allocating a quantity to two different but equal frequencies, as they would have an equivalent result.\\n4. In the backtracking, we try allocating each quantity to each unique frequency, simply decrementing and incrementing the frequency counts in each step.\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nfrom collections import Counter, defaultdict\n\nclass Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        quantity.sort(reverse=True)\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\n        def backtrack(i: int = 0) -> bool:\n            if i == len(quantity):\n                return True\n            \n            for freq, count in list(freqCounts.items()):\n                if freq >= quantity[i] and count > 1:\n                    freqCounts[freq] -= 1\n                    # freqCounts[freq - quantity[i]] += 1\n                    if backtrack(i + 1):\n                        return True\n                    freqCounts[freq] += 1\n                    freqCounts[freq - quantity[i]] -= 1\n            \n            return False\n        \n        return backtrack()\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a!=None and a.next!=None):\n        b=b.moveNext()\n            a=a.moveTwoStepNext()\n        if(a==b):\n            return True\n    return False\n\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a is not None and a.next is not None):\n        b=b.next\n        a=a.next.next\n        if(a=b):\n            return True\n    return False\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\ndef hasCycle(self, head: Optional[ListNode]) -> bool:\n    a=b=head\n    while(a!=None and a.next!=None):\n        b=b.next\n        a=a.next\n        if(a==b):\n            return True\n    return False\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a is not None and a.next is not None):\n            b=b.moveNext()\n            a=a.moveTwoStepNext()\n            if(a=b):\n                return True\n        return False\n\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.moveNext()\n            a=amovTwoSepNext()\n            if(a==b):\n                return True\n        return False\n\n"
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a is not None and a.next is not None):\n            b=b.next\n            a=a.next\n            if(a=b):\n                return True\n        return False\n"
    },
    {
        "slug": "third-maximum-number",
        "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "examples": [
            "Input: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.",
            "Input: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.",
            "Input: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\ndef thirdMax(self, nums) -> int:\n    return self.max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\n"
    },
    {
        "slug": "third-maximum-number",
        "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "examples": [
            "Input: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.",
            "Input: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.",
            "Input: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef thirdMax(self, nums: List[int]) -> int:\n    return max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]\n"
    },
    {
        "slug": "third-maximum-number",
        "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "examples": [
            "Input: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.",
            "Input: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.",
            "Input: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def thirdMax(self, nums) -> int:\n        return self.max(list(set(nums))) if len(list(set(nums)))>3 else sorted(list(set(nums)))[-3]\n"
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constrains": "1 <= left <= right <= 104",
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> Lista[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                #if j!='0':\n                if i%int(j)!=0:\n                    ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n"
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constrains": "1 <= left <= right <= 104",
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> Lista[int]:\n        res=[]\n        for i in range(left,right ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n"
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constrains": "1 <= left <= right <= 104",
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right ):\n            ch=True\n            for j in str(i):\n                #if j!='0':\n                if i%int(j)!=0:\n                    ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += self.fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += self.fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += self.fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1: \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1\n        return 0\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            if not self.compareChar(s, i, j):\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            if not self.compareChar(s, i, j):\n                j=lps[j]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            if not self.compareChar(s, i, j):\n                j=lps[j-1]\n\n            if s[i]=s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            while s[i]!=s[j] and j>0:\n                j=lps[j]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n)\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]=s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n"
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]\n\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nimport random\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float)\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = undefined_variable\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float)\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, console.log(y + self.r))\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float)\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r[1], self.x + self.r[1])\n            y = random.uniform(self.y - self.r[1], self.y + self.r[1])\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r[1] ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nimport random\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = undefined_variable\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, console.log(y + self.r))\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nimport random\n\nclass Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = undefined_variable\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r[1], self.x + self.r[1])\n            y = random.uniform(self.y - self.r[1], self.y + self.r[1])\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r[1] ** 2:\n                return [x, y]\n\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()\n"
    },
    {
        "slug": "reverse-bits",
        "description": "Reverse bits of a given 32 bits unsigned integer.\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.",
        "examples": [
            "Input: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.",
            "Input: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111."
        ],
        "constrains": "The input must be a binary string of length 32",
        "oracle_code": "class Solution:\n    def f(self,n,r,count):\n        if n<1:return r<<(32-count)\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def f(self,n,r,count):\\n        if n<1:return r<<(32-count)\\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def f(self,n,r,count):\n        if n<1:return (r<<(32-count)\n        return self.f(n<<1,(r<<1)|(n&1),count+1)\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: list) -> int:\n        nums=sorted(nums)\n        min=float(\"inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-undefined_variable)\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"inf)\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: list) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-undefined_variable\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: list) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf)\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-undefined_variable)\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf)\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1\n            if min<x:\n                min=x\n        return min\n"
    },
    {
        "slug": "convert-sorted-list-to-binary-search-tree",
        "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "examples": [
            "Input: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.",
            "Input: head = []\nOutput: []"
        ],
        "constrains": "The number of nodes in head is in the range [0, 2 * 104].\n-105 <= Node.val <= 105",
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums=[]\n        curr=head\n        while curr:\n            nums.append(curr.val)\n            curr=curr.next\n        def helper(l,r):\n            if l>r:\n                return None\n            mid=(l+r)//2\n            root=TreeNode(nums[mid])\n            root.left=helper(l,mid-1)\n            root.right=helper(mid+1,r)\n            return root\n        return helper(0,len(nums)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        nums=[]\\n        curr=head\\n        while curr:\\n            nums.append(curr.val)\\n            curr=curr.next\\n        def helper(l,r):\\n            if l>r:\\n                return None\\n            mid=(l+r)//2\\n            root=TreeNode(nums[mid])\\n            root.left=helper(l,mid-1)\\n            root.right=helper(mid+1,r)\\n            return root\\n        return helper(0,len(nums)-1)\\n\\n        \\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "wrong comment mark"
        ],
        "buggy_code": "\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums=[]\n        curr=head\n        while curr:\n            nums.append(curr.val)\n            # curr=curr.next\n        def helper(l,r):\n            if l>r:\n                return None\n            mid=(l+r)//2\n            root=TreeNode(nums[mid])\n            root.left=helper(l,mid)\n            root.right=helper(mid+1,r)\n            return root\n        return helper(0,len(nums)-1)\n\n"
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constrains": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return 'encoded_text\n\n        N = len(encoded_text)\n        cols = non_existing_variable // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n"
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constrains": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = non_existing_variable // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows + 1:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n"
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constrains": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return 'encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows + 1:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constrains": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "oracle_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=self.length(nums)\n        low=0\n        high=n\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                high=mid+1\n            else:\n                low=mid-1\n        return -1\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constrains": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "oracle_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=self.length(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1\n\n"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constrains": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "oracle_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return high=mid+1\n            else:\n                -1\n\n"
    },
    {
        "slug": "delete-operation-for-two-strings",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.",
        "examples": [
            "Input: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".",
            "Input: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4"
        ],
        "constrains": "1 <= word1.length, word2.length <= 500\nword1 and word2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1)\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=self.min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]\n\n"
    },
    {
        "slug": "delete-operation-for-two-strings",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.",
        "examples": [
            "Input: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".",
            "Input: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4"
        ],
        "constrains": "1 <= word1.length, word2.length <= 500\nword1 and word2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i]==word2[j]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=self.min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]\n\n"
    },
    {
        "slug": "delete-operation-for-two-strings",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.",
        "examples": [
            "Input: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".",
            "Input: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4"
        ],
        "constrains": "1 <= word1.length, word2.length <= 500\nword1 and word2 consist of only lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1)\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i]==word2[j]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid1, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root  \n        \n    def buildTree(self, grid, rs, re, cs, ce, level)\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid1, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid1, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid1, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:\n            new_node = Node(tl.val, True, None, None, None, None\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n                \n        return     new_node\n\n\n"
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs+1], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node\n\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return \"1 if R else '0\n"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K <= mid: return self.findKthBit(N - 1, K, R)\n        if K = mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'\n"
    },
    {
        "slug": "range-sum-query-immutable",
        "description": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).",
        "examples": [
            "Input\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
        ],
        "constrains": "1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n0 <= left <= right < nums.length\nAt most 104 calls will be made to sumRange.",
        "oracle_code": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.nums=[0]+list(accumulate(nums))\n        print(self.nums)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.nums[right+1]-self.nums[left]\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "other error"
        ],
        "buggy_code": "\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n    self.nums=[0]+list(accumulate(nums))\n    print(self.nums)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.nums[right]-self.nums[left]\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)\n"
    },
    {
        "slug": "excel-sheet-column-title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
        "examples": [
            "Input: columnNumber = 1\nOutput: \"A\"",
            "Input: columnNumber = 28\nOutput: \"AB\"",
            "Input: columnNumber = 701\nOutput: \"ZY\""
        ],
        "constrains": "1 <= columnNumber <= 231 - 1",
        "oracle_code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        if n<27:\\n            return chr(ord(\\'A\\')+(n-1)%26)\\n        ans=\"\"\\n        while n>0:\\n            if n%26==0:\\n                ans+=chr(ord(\\'A\\')+25)\\n                n-=1\\n            else:\\n                ans+=chr(ord(\\'A\\')+n%26-1)\\n            n//=26\\n        return ans[::-1]\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        if n>0:\n            if n%26 == 0:\n                ans+=chr(ord('A')+25)\n                n == 26  # bug here\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,self.computeMaxAndMin(val1))\n        ans=max(ans,self.computeMaxAndMin(val2))\n        ans=max(ans,self.computeMaxAndMin(val3))\n        ans=max(ans,self.computeMaxAndMin(val4))\n        return ans\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,max(val2)-min(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,max(val4)-min(val4))\n        return ans\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4)) == 0\n        return ans\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,sel2f.computeMaxAndMin(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,self.coputeMaxAndMself.coputeMAndMinself.coputeMAndMin4))\n        return ans\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nfrom typing import List\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,self.computeMaxAndMin(val1))\n        ans=max(ans,self.computeMaxAndMin(val2))\n        ans=max(ans,self.computeMaxAndMin(val3))\n        ans=max(ans,self.computeMaxAndMin(val4)) == 0\n        return ans\n"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=min(ans,max(val1)-min(val1))\n        ans=min(ans,max(val2)-min(val2))\n        ans=min(ans,max(val3)-min(val3))\n        ans=min(ans,max(val4)-min(val4)) == 0\n        return ans\n"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constrains": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\ndef addNegabinary(self, A, B):\n    res = []\n    carry = 0\n    while A or B or carry:\n        carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n        res.append(carry & 1)\n        carry = -(carry >> 1)\n    while len(res) > 1 and res[-1] == 0:\n        res.pop()\n    return res[::-1]\n\n"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constrains": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        #return res[::-1]\n\ndef addNegabinary(self, A, B):\n    res = []\n    carry = 0\n    while A or B or carry:\n        carry += (A or [0]).pop() + (B or [0]).pop()\n        res.append(carry & 1)\n        carry = -(carry >> 1)\n    while len(res) > 1 and res[-1] == 0:\n        res.pop()\n    #return res[::-1]\n\n"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constrains": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = carry >> 1\n        #return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop(0) + (B or [0]).pop(0)\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        #return res[::-1]\n"
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "description": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.",
        "examples": [
            "Input: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.",
            "Input: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "oracle_code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]=1 #bug here\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i not in dic) and (i+1 not in dic):  #bug\n                    res.append(i)\n        return res\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(self.find_pos(i)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(j)\n        return (l)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(self.find_pos(i)+1,len(nums2):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i=j:\n                    for k in range(self.find_pos(i)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count=0:\n                        l.append(-1)\n        return (l)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(j)\n        return (l)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i=j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count=0:\n                        l.append(j)\n        return (l)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i=j:\n                    for k in range(nums2.index(j)+1,len(nums2):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count=0:\n                        l.append(-1)\n        return (l)\n"
    },
    {
        "slug": "minimize-maximum-pair-sum-in-array",
        "description": "The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\nFor example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\nEach element of nums is in exactly one pair, and\nThe maximum pair sum is minimized.\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.",
        "examples": [
            "Input: nums = [3,5,2,3]\r\nOutput: 7\r\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.",
            "Input: nums = [3,5,4,2,4,6]\r\nOutput: 8\r\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8."
        ],
        "constrains": "n == nums.length\n2 <= n <= 105\nn is even.\n1 <= nums[i] <= 105",
        "oracle_code": "class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)-1\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        right=0,len(nums)\n        while right>0:\n            list2.append(nums[right]+nums[0])\n            right-=1\n        return max(list2)\n"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1"
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
        "oracle_code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost += 1\n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)",
        "content": "We re-use grid to keep track of `seen`.\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n\\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\\n        M, N = range(m), range(n)\\n\\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\\n\\n        def dfs(x: int,y: int)->None:\\n            while not seen(x,y):\\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\\n                queue.append((x,y))\\n                x,y = x+dx, y+dy\\n            return\\n\\n        dfs(0, 0)\\n\\n        while queue:\\n            if (m-1, n-1) in queue: return cost\\n            cost += 1\\n            q = len(queue)\\n\\n            for _ in range(q):\\n                x, y = queue.popleft()\\n                for dx,dy in dir[1:]:\\n                    dfs(x+dx, y+dy)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/submissions/878791604/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is worstcase\\n *O*(*MN*).",
        "level": "hard",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef minCost(self, grid: List[List[int]]) -> int:\n\n    m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n    M, N = range(m), range(n)\n\n    seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n    dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n    def dfs(x: int,y: int)->None:\n        while not seen(x,y):\n            (dx,dy), grid[x][y] = dir[grid[x][y]], None\n            queue.append((x,y))\n            x,y = x+dx, y+dy\n        return\n\n    dfs(0, 0)\n        cost += 1\n\n    while queue:\n        if (m-1, n-1) in queue: return cost\n        cost +=1 \n        q = len(queue)\n\n        for _ in range(q):\n            x, y = queue.popleft()\n            for dx,dy in dir[1:]:\n                dfs(x+dx, y+dy)\n"
    },
    {
        "slug": "maximum-strength-of-a-group",
        "description": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b].\nReturn the maximum strength of a group the teacher can create.",
        "examples": [
            "Input: nums = [3,-1,-5,2,5,-9]\nOutput: 1350\nExplanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.",
            "Input: nums = [-4,-5,-4]\nOutput: 20\nExplanation: Group the students at indices [0, 1] . Then, we\u2019ll have a resulting strength of 20. We cannot achieve greater strength."
        ],
        "constrains": "1 <= nums.length <= 13\n-9 <= nums[i] <= 9",
        "oracle_code": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_memo, min_memo = nums[0], nums[0]\n        for num in nums[1:]:\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\n        return max_memo",
        "content": "# Approach\\nKeep track of minimum and maximum combinations.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_memo, min_memo = nums[0], nums[0]\\n        for num in nums[1:]:\\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\\n        return max_memo\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_memo, min_memo = nums[0], nums[0]\n        for num in nums[1:]\n            max_memo, min_memo = max(max_memo, num, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\n        return max_memo\n"
    },
    {
        "slug": "design-a-text-editor",
        "description": "Design a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.",
        "examples": [
            "Input\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\nOutput\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\nExplanation\nTextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\ntextEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\ntextEditor.deleteText(4); // return 4\n                          // The current text is \"leet|\". \n                          // 4 characters were deleted.\ntextEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \ntextEditor.cursorRight(3); // return \"etpractice\"\n                           // The current text is \"leetpractice|\". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // \"etpractice\" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return \"leet\"\n                          // The current text is \"leet|practice\".\n                          // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is \"|practice\".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return \"\"\n                          // The current text is \"|practice\".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return \"practi\"\n                           // The current text is \"practi|ce\".\n                           // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor."
        ],
        "constrains": "1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call?",
        "oracle_code": "class TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n            \n\n\n\n       \n        \n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\nfrom collections import deque\n\nclass TextEditor:\n    def __init__(self):\n        self.stack = []\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.q.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n        \n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n"
    },
    {
        "slug": "design-a-text-editor",
        "description": "Design a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.",
        "examples": [
            "Input\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\nOutput\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\nExplanation\nTextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\ntextEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\ntextEditor.deleteText(4); // return 4\n                          // The current text is \"leet|\". \n                          // 4 characters were deleted.\ntextEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \ntextEditor.cursorRight(3); // return \"etpractice\"\n                           // The current text is \"leetpractice|\". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // \"etpractice\" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return \"leet\"\n                          // The current text is \"leet|practice\".\n                          // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is \"|practice\".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return \"\"\n                          // The current text is \"|practice\".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return \"practi\"\n                           // The current text is \"practi|ce\".\n                           // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor."
        ],
        "constrains": "1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call?",
        "oracle_code": "class TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n            \n\n\n\n       \n        \n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
        "level": "hard",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.q.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str):\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n        \n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n\n"
    },
    {
        "slug": "design-a-text-editor",
        "description": "Design a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.",
        "examples": [
            "Input\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\nOutput\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\nExplanation\nTextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\ntextEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\ntextEditor.deleteText(4); // return 4\n                          // The current text is \"leet|\". \n                          // 4 characters were deleted.\ntextEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \ntextEditor.cursorRight(3); // return \"etpractice\"\n                           // The current text is \"leetpractice|\". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // \"etpractice\" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return \"leet\"\n                          // The current text is \"leet|practice\".\n                          // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is \"|practice\".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return \"\"\n                          // The current text is \"|practice\".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return \"practi\"\n                           // The current text is \"practi|ce\".\n                           // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor."
        ],
        "constrains": "1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call?",
        "oracle_code": "class TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n            \n\n\n\n       \n        \n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nfrom collections import deque\n\nclass TextEditor:\n    def __init__(self):\n        self.stack = []\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str):\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): #Here is the bug, == should be used instead of =\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): #Here is the bug, == should be used instead of =\n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): #Here is the bug, == should be used instead of =\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+2): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+3): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D:\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): #Here is the bug, == should be used instead of =\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+2): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+3): # indexing error here\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i=len(s): #Here is the bug, == should be used instead of =\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                if ind in range(val+1,i+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in myList]\n        return ans\n\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            #if(indegrees[i] == 0):\n            queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in myList]\n        return ans\n\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(listwhile queue:\n            cur = queue.pop()\n            \n            for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, e soudhave set of ancestors for each and every node!\n        #in worst case, set s for ith node coudhave atr tices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in mL\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            #if(indegrees[i] == 0):\n            queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s)) for s in ans]\n        return ans\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(list(s))) for s in ans]\n        return ans\n"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n\n        queue = deque()\n        ans = [set() for _ in range(n)]\n\n        for i in range(len(indegrees)):\n            if(indegrees[i] = 0):\n                queue.append(i)\n\n        while queue:\n            cur = queue.pop()\n\n            for neighbor in graph[cur]:\n                ans[neighbor].add(cur)\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] = 0):\n                    queue.append(neighbor)\n\n        ans = [(sorted(lis#t(s))) for s in ans]\n        return ans\n"
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i+1]]+=i\n            if sc[edges[i+1]]>mx:\n                mx=sc[edges[i+1]]\n                ans=edges[i+1]\n            elif sc[edges[i+1]]=mx:   # incorrect use of the assignment operator\n                if ans>edges[i+1]:\n                    ans=edges[i+1]\n        return ans\n"
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx and i != n-1: #bug here\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]=mx:   # incorrect use of the assignment operator\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans\n"
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i+1]]+=i\n            if sc[edges[i+1]]>mx and i != n-1: #bug here\n                mx=sc[edges[i+1]]\n                ans=edges[i+1]\n            elif sc[edges[i+1]]==mx:\n                if ans>edges[i+1]:\n                    ans=edges[i+1]\n        return ans\n"
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.",
            "Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
        ],
        "constrains": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "oracle_code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c = '|\"\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] = x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l == r else 0)\n        return ans\n"
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.",
            "Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
        ],
        "constrains": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "oracle_code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == '|\"\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m + 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans\n"
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.",
            "Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
        ],
        "constrains": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "oracle_code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c = \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] = x: l = m + 1\n                else: r = m + 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l == r else 0)\n        return ans\n"
    },
    {
        "slug": "longest-harmonious-subsequence",
        "description": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
        "examples": [
            "Input: nums = [1,3,2,2,5,2,3,7]\r\nOutput: 5\r\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].",
            "Input: nums = [1,2,3,4]\r\nOutput: 2",
            "Input: nums = [1,1,1,1]\r\nOutput: 0"
        ],
        "constrains": "1 <= nums.length <= 2 * 104\n-109 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] += 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 1], result)\n        return result",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a count map holding occurences on elements and loop on keys to check if next consecutive element is present in the map.\\nIf present, compare the result with the max variable\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findLHS(self, nums: List[int]) -> int:\\n        result = 0\\n        count_map = {}\\n        for num in nums:\\n            if num not in count_map:\\n                count_map[num] = 1\\n            else:\\n                count_map[num] += 1\\n        for num, count in count_map.items():\\n            if num + 1 in count_map:\\n                result = max(count + count_map[num + 1], result)\\n        return result\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] -= 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 2], result)\n        return result\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(no_nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(no_nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(no_nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(no_nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sort(nums)[-k]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int -> int:\n        return sorted(nums)[-k-1]\n"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sort(nums)[-k-1]\n"
    },
    {
        "slug": "count-subtrees-with-max-distance-between-cities",
        "description": "There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.",
        "examples": [
            "Input: n = 4, edges = [[1,2],[2,3],[2,4]]\r\nOutput: [3,4,0]\r\nExplanation:\r\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\r\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\r\nNo subtree has two nodes where the max distance between them is 3.",
            "Input: n = 2, edges = [[1,2]]\r\nOutput: [1]",
            "Input: n = 3, edges = [[1,2],[2,3]]\r\nOutput: [2,1]"
        ],
        "constrains": "2 <= n <= 15\nedges.length == n-1\nedges[i].length == 2\n1 <= ui, vi <= n\nAll pairs (ui, vi) are distinct.",
        "oracle_code": "class Solution:\n    # odd/even diameter couned individually\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(n)]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\n            if len(q)<len(p): p,q = q,p\n            res = [0]*len(q)\n            res[0] = p[0]*q[0]\n            for i in range(1,len(p)): p[i] += p[i-1]\n            for i in range(1,len(q)): q[i] += q[i-1]\n            for i in range(1,len(p)):\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\n            for i in range(len(p),len(q)):\n                res[i] = (q[i]-q[i-1])*p[-1]\n            return res\n            \n        def dfs(r,p): # num of subtree rooted at r with given depth\n            d = [1]\n            for v in adj[r]:\n                if v==p: continue\n                t = [1]+dfs(v,r)\n                d = comb(t,d)\n            return d\n        #end dfs\n        ans = [0]*n\n        # odd diameter with (u,v) as center edge\n        for u,v in edges:\n            u -= 1; v-=1\n            p = dfs(u,v)\n            q = dfs(v,u)\n            for i in range(min(len(p),len(q))):\n                ans[i+i+1] += p[i]*q[i]\n        #even diamter with v as center vertex\n        for v in range(n): \n            if len(adj[v])==1: continue \n            tree = [1]+dfs(adj[v][0],v) #tree with depth\n            curr = [0]*n\n            for u in adj[v][1:]:\n                q = [1]+dfs(u,v)\n                # curr tree + new small\n                j = 1; t = q[1]+1 # prefix sum of q\n                for i in range(4,n,2):\n                    while j+1<min(i//2,len(q)):\n                        j += 1; t += q[j]\n                    curr[i] *= t\n                # curr tree + same height\n                for i in range(min(len(tree),len(q))):\n                    curr[i+i] += tree[i]*q[i]\n                tree = comb(tree,q)\n            for i in range(2,n,2):\n                ans[i] += curr[i]\n        #end\n        return ans[1:]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA (sub)tree may have many diameters, but there is exactly one or two centers. To simplfying the implementation, we divide into two cases: diameter is even or odd. For the case of even diameter, we  count the subtrees by enumerating each vertex as the center. For the case of odd diameter, we enumerate each edge as the center. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each node $v$ as the center, we root the tree at $v$ and do a DFS. When visiting a vertex $u$, we recursively compute the number of subtrees rooted at $u$ and with depth $i$, for each possible $i$.\\nWhen combining the results from the children of $u$, a naive implementation takes $O(deg(u)\\\\times n^2)$ time. By using prefix sum, it can be reduced to $O(deg(u)\\\\times n)$ time. Thus a DFS takes $O(n^2)$ since the total degree of a tree is $O(n)$.\\nAt root $v$, we combine the results from its children. Since we care about only even diameter and centered at $v$, two branches of same depth $i$ form a subtree of diamter $2i$. When combining the branches one by one, we need to count the way that a current subtree is merged with a small incoming subtree which does not change its diameter.\\nThe case of odd diameter is similar and simpler since there are only two branches for each center edge.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^3)$ since each center vertex takes $O(n^2)$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLinear.\\n\\n# Code\\n```\\nclass Solution:\\n    # odd/even diameter couned individually\\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\\n        adj = [[] for i in range(n)]\\n        for u,v in edges:\\n            adj[u-1].append(v-1)\\n            adj[v-1].append(u-1)\\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\\n            if len(q)<len(p): p,q = q,p\\n            res = [0]*len(q)\\n            res[0] = p[0]*q[0]\\n            for i in range(1,len(p)): p[i] += p[i-1]\\n            for i in range(1,len(q)): q[i] += q[i-1]\\n            for i in range(1,len(p)):\\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\\n            for i in range(len(p),len(q)):\\n                res[i] = (q[i]-q[i-1])*p[-1]\\n            return res\\n            \\n        def dfs(r,p): # num of subtree rooted at r with given depth\\n            d = [1]\\n            for v in adj[r]:\\n                if v==p: continue\\n                t = [1]+dfs(v,r)\\n                d = comb(t,d)\\n            return d\\n        #end dfs\\n        ans = [0]*n\\n        # odd diameter with (u,v) as center edge\\n        for u,v in edges:\\n            u -= 1; v-=1\\n            p = dfs(u,v)\\n            q = dfs(v,u)\\n            for i in range(min(len(p),len(q))):\\n                ans[i+i+1] += p[i]*q[i]\\n        #even diamter with v as center vertex\\n        for v in range(n): \\n            if len(adj[v])==1: continue \\n            tree = [1]+dfs(adj[v][0],v) #tree with depth\\n            curr = [0]*n\\n            for u in adj[v][1:]:\\n                q = [1]+dfs(u,v)\\n                # curr tree + new small\\n                j = 1; t = q[1]+1 # prefix sum of q\\n                for i in range(4,n,2):\\n                    while j+1<min(i//2,len(q)):\\n                        j += 1; t += q[j]\\n                    curr[i] *= t\\n                # curr tree + same height\\n                for i in range(min(len(tree),len(q))):\\n                    curr[i+i] += tree[i]*q[i]\\n                tree = comb(tree,q)\\n            for i in range(2,n,2):\\n                ans[i] += curr[i]\\n        #end\\n        return ans[1:]\\n\\n\\n```\\n",
        "level": "hard",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    # odd/even diameter couned individually\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(n)]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\n            if len(q)<len(p): p,q = q,p\n            res = [0]*len(q)\n            res[0] = p[0]*q[0]\n            for i in range(1,len(p)): p[i] += p[i-1]\n            for i in range(1,len(q)): q[i] += q[i-1]\n            for i in range(1,len(p)):\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\n            for i in range(len(p),len(q)):\n                res[i] = (q[i]-q[i-1])*p[-1]\n            return res\n            \n        def dfs(r,p): # num of subtree rooted at r with given depth\n            d = [1]\n            for v in undefined_list:\n                if v==p: continue\n                t = [0]+dfs(v,r) # Inserted Bug Here.\n                d = comb(t,d)\n            return d\n        #end dfs\n        ans = [0]*n\n        # odd diameter with (u,v) as center edge\n        for u,v in edges:\n            u -= 1; v-=1\n            p = dfs(u,v)\n            q = dfs(v,u)\n            for i in range(min(len(p),len(q))):\n                ans[i+i+1] += p[i]*q[i]\n        #even diamter with v as center vertex\n        for v in range(n): \n            if len(adj[v])==1: continue \n            tree = [1]+dfs(adj[v][0],v) #tree with depth\n            curr = [0]*n\n            for u in adj[v][1:]:\n                q = [1]+dfs(u,v)\n                # curr tree + new small\n                j = 1; t = q[1]+1 # prefix sum of q\n                for i in range(4,n,2):\n                    while j+1<min(i//2,len(q)):\n                        j += 1; t += q[j]\n                    curr[i] *= t\n                # curr tree + same height\n                for i in range(min(len(tree),len(q))):\n                    curr[i+i] += tree[i]*q[i]\n                tree = comb(tree,q)\n            for i in range(2,n,2):\n                ans[i] += curr[i]\n        #end\n        return ans[1:]\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples -= 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.charlie[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1   \n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            found = False\n            for c in range(j, this.c):\n                apple_in_region = this.pfsum_col[this.r - 1][c]\n                if i > 0:\n                     apple_in_region -= this.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < this.r - 1:\n                while nr < this.r - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_row[nr][this.c - 1]\n                    if j > 0:\n                        apple_in_region -= this.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < this.r - 1:\n                    t_cnt += this.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            cannot_cut = True\n            nc = j\n            while nc < this.c - 1:\n                while nc < this.c - 1 and cannot_cut:\n                    apple_in_region = this.pfsum_col[this.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= this.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < this.c - 1:\n                    t_cnt += this.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k = 1:\n            return 1\n        \n        return self.getWays(0, 0, k - 2) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constrains": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n    s= ''.join(map(str,digits))\n    i='int(s)+1\n    li=list(map(int,str(i)))  \n    return li\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constrains": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n    s= ''.join(map(str,digits))\n    i=int(s)+1\n    if i<10:\n            li=[]\n        else:\n            li=list(map(int,str(i)))  \n    return li\n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constrains": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i='int(s)+1\n        if i<10:\n            li=[]\n        else:\n            li=list(map(int,str(i)))  \n        return li\n"
    },
    {
        "slug": "most-common-word",
        "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.",
        "examples": [
            "Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.",
            "Input: paragraph = \"a.\", banned = []\nOutput: \"a\""
        ],
        "constrains": "1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
        "oracle_code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
        "level": "easy",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\n#Import RegEx\nimport re\n\nclass Solution\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0],split(' ')\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        return Counter(paragraph).most_common(1)[0][0]\n"
    },
    {
        "slug": "most-common-word",
        "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.",
        "examples": [
            "Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.",
            "Input: paragraph = \"a.\", banned = []\nOutput: \"a\""
        ],
        "constrains": "1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
        "oracle_code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\n#Import RegEx\nimport re\nfrom collections import Counter\n\nclass Solution\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]\n"
    },
    {
        "slug": "most-common-word",
        "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.",
        "examples": [
            "Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.",
            "Input: paragraph = \"a.\", banned = []\nOutput: \"a\""
        ],
        "constrains": "1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
        "oracle_code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\n#Import RegEx\nimport re\nfrom collections import Counter\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0],split(' ')\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        return Counter(paragraph).most_common(1)[0][0]\n"
    },
    {
        "slug": "rings-and-rods",
        "description": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\nYou are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n\nThe first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\nThe second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n\nFor example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\nReturn the number of rods that have all three colors of rings on them.",
        "examples": [
            "Input: rings = \"B0B6G0R6R0R6G9\"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.",
            "Input: rings = \"B0R0G0R9R0B0G0\"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.",
            "Input: rings = \"G4\"\nOutput: 0\nExplanation: \nOnly one ring is given. Thus, no rods have all three colors."
        ],
        "constrains": "rings.length == 2 * n\n1 <= n <= 100\nrings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).\nrings[i] where i is odd is a digit from '0' to '9' (0-indexed).",
        "oracle_code": "class Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1])\n                if len(set(rgb))==3:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPoints(self, rings: str) -> int:\\n        lst=[]\\n        rgb=[]\\n        count=0\\n        for i in range(1,len(rings),2):\\n            rgb=[]\\n            if rings[i] not in lst:\\n                lst.append(rings[i])\\n                for j in range(1,len(rings),2):\\n                    if rings[j]==rings[i]:\\n                        if rings[j-1]==\\'R\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'G\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'B\\':\\n                            rgb.append(rings[j-1])\\n                if len(set(rgb))==3:\\n                    count+=1\\n        return count\\n\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1]')\n                if len(set(rgb))==2:\n                    count+=1\n        return count\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "oracle_code": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return b",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool\n        b = True\n        for n in numbers:\n            b = not b if n else b\n        return b\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "oracle_code": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return b",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return #b\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "oracle_code": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return b",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in numbers:\n            b = not b if n else b\n        return #b\n"
    },
    {
        "slug": "find-the-value-of-the-partition",
        "description": "You are given a positive integer array nums.\nPartition nums into two arrays,\u00a0nums1 and nums2, such that:\n\nEach element of the array nums belongs to either the array nums1 or the array nums2.\nBoth arrays are non-empty.\nThe value of the partition is minimized.\n\nThe value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.",
        "examples": [
            "Input: nums = [1,3,2,4]\nOutput: 1\nExplanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].\n- The maximum element of the array nums1 is equal to 2.\n- The minimum element of the array nums2 is equal to 3.\nThe value of the partition is |2 - 3| = 1. \nIt can be proven that 1 is the minimum value out of all partitions.",
            "Input: nums = [100,1,10]\nOutput: 9\nExplanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1].\n- The maximum element of the array nums1 is equal to 10.\n- The minimum element of the array nums2 is equal to 1.\nThe value of the partition is |10 - 1| = 9.\nIt can be proven that 9 is the minimum value out of all partitions."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n            \n        return min_diff",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem tells us that we must make a partition where nums1 and nums2 are non empty. \\n\\n2. If we sort the array, we can make a partition between each pair of adajacent elements where the left element would always be the max of nums1 and the right element in the pair will always be the min of nums2.\\n3. In this way, we can check all possible partitions, save the min as we go, and return it once were through every pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initialize a min variable to save the min partition value\\n2. sort nums\\n3. iterate over nums array from 1->len(nums)\\n4. compare each adajacent pair with the calculation given in the problem: abs(nums[i] - nums[i-1])\\n5. return the min diff\\n\\n~If this was helpful please upvote! \\n~Thanks for reading :)\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe sort nums and then iterate over nums which is bounded by nlogn for sorting.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur only additional space comes from min_diff\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findValueOfPartition(self, nums: Array[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i+1]))\n            \n        return min_diff\n"
    },
    {
        "slug": "sliding-puzzle",
        "description": "On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.",
        "examples": [
            "Input: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.",
            "Input: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.",
            "Input: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]"
        ],
        "constrains": "board.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] is unique.",
        "oracle_code": "class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = [row[:] for row in board]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [4, 5, 0]]:\n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that this problem can be solved using a breadth-first search (BFS) algorithm, where we start with the initial board state and explore all possible moves (by swapping the empty space with its neighboring tiles) until we reach the desired board state.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a BFS algorithm to explore all possible moves from the initial board state. The function starts by initializing a queue and adding the initial board state and the number of moves (0) to the queue. It also initializes a set to keep track of the board states that have already been seen. The function then enters a while loop that continues until the queue is empty. In each iteration, the function takes the first board state and move count from the queue, and checks if the board state is the desired state. If it is, the function returns the number of moves. If not, the function uses a helper function get_neighbors to find all possible moves (by swapping the empty space with its neighboring tiles) and adds them to the queue. The function also adds the new board states to the set of seen states. If the queue becomes empty, the function returns -1 indicating that the desired board state was not reached.\\n\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\\n        def get_neighbors(board):\\n            neighbors = []\\n            r, c = 0, 0\\n            for i in range(2):\\n                for j in range(3):\\n                    if board[i][j] == 0:\\n                        r, c = i, j\\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                new_r, new_c = r + i, c + j\\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\\n                    new_board = [row[:] for row in board]\\n                    new_board[r][c] = new_board[new_r][new_c]\\n                    new_board[new_r][new_c] = 0\\n                    neighbors.append(new_board)\\n            return neighbors\\n\\n        queue = deque()\\n        queue.append((board, 0))\\n        seen = set()\\n        seen.add(tuple(tuple(row) for row in board))\\n\\n        while queue:\\n            board, moves = queue.popleft()\\n            if board == [[1, 2, 3], [4, 5, 0]]:\\n                return moves\\n            for neighbor in get_neighbors(board):\\n                if tuple(tuple(row) for row in neighbor) not in seen:\\n                    queue.append((neighbor, moves + 1))\\n                    seen.add(tuple(tuple(row) for row in neighbor))\\n        return -1\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = List[List[int]]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [5, 4, 0]]:      #Change here from correct state to incorrect state\n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "from collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 1:\n                nums[index] = num\n                index += 1\n\n        return index",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nfrom collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in self.counter.items():\n            nums[index] = num\n            index += 1\n            if count > 2:\n                nums[index] = num\n                index += 1\n\n        return index\n"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
        ],
        "constrains": "0 <= start, goal <= 109",
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n    s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(51): # Indexing error here\n            if s[i]!=g[i]:\n                count+=1\n    return count\n"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
        ],
        "constrains": "0 <= start, goal <= 109",
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n    s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(51):\n            if s[i]!=g[i]:\n                count+=1\n    return count\n"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
        ],
        "constrains": "0 <= start, goal <= 109",
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(51): # Indexing error here\n            if s[i]!=g[i]:\n                count+=1\n        return count\n"
    },
    {
        "slug": "unique-number-of-occurrences",
        "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
        "examples": [
            "Input: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation:\u00a0The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.",
            "Input: arr = [1,2]\nOutput: false",
            "Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true"
        ],
        "constrains": "1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
        "oracle_code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool\n        d=Counter(arr)\n        l=self.get_values(d)\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "unique-number-of-occurrences",
        "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
        "examples": [
            "Input: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation:\u00a0The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.",
            "Input: arr = [1,2]\nOutput: false",
            "Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true"
        ],
        "constrains": "1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
        "oracle_code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=self.get_values(dky) \n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "unique-number-of-occurrences",
        "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
        "examples": [
            "Input: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation:\u00a0The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.",
            "Input: arr = [1,2]\nOutput: false",
            "Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true"
        ],
        "constrains": "1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
        "oracle_code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool\n        d=Counter(arr)\n        l=list(d.keys()) \n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "make-costs-of-paths-equal-in-a-binary-tree",
        "description": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.",
        "examples": [
            "Input: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.",
            "Input: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed."
        ],
        "constrains": "3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104",
        "oracle_code": "class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n\n        ans = 0\n        n//=2                                               # <-- 1)\n\n        for i in reversed(range(n)):\n        \n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\n\n            ans+= mx - mn\n            cost[i]+= mx\n\n        return ans",
        "content": "A couple of notes:\\n1. The iteration covers only the parents, so we can prune the leaves from the iteration.\\n2. We add `1` each to `2i` and `2i+1` because `cost` is zero-indexed and the tree is one-indexed.\\n\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/submissions/946746736/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n\n        ans = 0\n        undefined_variable//=2\n\n        for i in reversed(range(n)):\n        \n            mn, mx = sorted((cost[2*i+1], cost[2*i]))  \n\n            ans+= mx - mn\n            cost[i]+= mx\n\n        return ans\n"
    },
    {
        "slug": "find-the-kth-largest-integer-in-the-array",
        "description": "You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\nReturn the string that represents the kth largest integer in nums.\nNote: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.",
        "examples": [
            "Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\nOutput: \"3\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"].\nThe 4th largest integer in nums is \"3\".",
            "Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\nOutput: \"2\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"].\nThe 3rd largest integer in nums is \"2\".",
            "Input: nums = [\"0\",\"0\"], k = 2\nOutput: \"0\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"0\",\"0\"].\nThe 2nd largest integer in nums is \"0\"."
        ],
        "constrains": "1 <= k <= nums.length <= 104\n1 <= nums[i].length <= 100\nnums[i] consists of only digits.\nnums[i] will not have any leading zeros.",
        "oracle_code": "class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        ls = []\n        for i in nums:\n            ls.append(int(i))\n        sorted_ = sorted(ls)\n        return str(sorted_[-1*k])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        ls = []\\n        for i in nums:\\n            ls.append(int(i))\\n        sorted_ = sorted(ls)\\n        return str(sorted_[-1*k])\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        ls = []\n        for i in nums:\n            ls.append(int(i))\n        sorted_ = sorted(ls)\n        return str(sorted_[k])\n"
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.",
        "examples": [
            "Input: root = [1,null,2,2]\nOutput: [2]",
            "Input: root = [0]\nOutput: [0]"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val]ree  += 1\n\n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans\n"
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.",
        "examples": [
            "Input: root = [1,null,2,2]\nOutput: [2]",
            "Input: root = [0]\nOutput: [0]"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n\n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq\n            if cnt == max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt = max_cnt: # == is replaced by =\n                ans.append(num)\n        return ans\n"
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.",
        "examples": [
            "Input: root = [1,null,2,2]\nOutput: [2]",
            "Input: root = [0]\nOutput: [0]"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [tree]\n            while queue:\n                curr = queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt = max_cnt: # == is replaced by =\n                ans.append(num)\n        return ans\n"
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]"
        ],
        "constrains": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "oracle_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "medium",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nfrom typing import List\nfrom itertools import accumulate\n\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        \n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[x]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]self.))\n"
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]"
        ],
        "constrains": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "oracle_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar+1]-= seats\n\n        return list(self.accumulate(arr[:-1]))\n"
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]"
        ],
        "constrains": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "oracle_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nfrom typing import List\nfrom itertools import accumulate\n\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        \n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[x]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]+1))\n"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constrains": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "oracle_code": "class Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans",
        "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(n)`\\n```\\nclass Solution:\\n    def longestWPI(self, A):\\n        curr, ans, D = 0, 0, {}\\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\\n            curr += i\\n            D[curr] = D.get(curr, e)\\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(self.transform(A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 2, e))\n        return ans\n"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.",
        "examples": [
            "Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.",
            "Input: root = [1,null,2,null,0,3]\nOutput: 3"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\nif(root==None):\n    return\nd1=abs(root.val-mx)\nd2=abs(root.val-mn)\nans[0]=max(d1,d2,ans[0])\nmx=max(mx,root.val)\nmn=min(mn,root.val)\nfun(root.left,mx,mn,ans)\nfun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return 0\n"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.",
        "examples": [
            "Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.",
            "Input: root = [1,null,2,null,0,3]\nOutput: 3"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\nif(root==None):\n    return\nd1=abs(root.val-mx)\nd2=abs(root.val-mn)\nans[0]=max(d1,d2,ans[0])\nmx=max(mx,root.val)\nmn=min(mn,root.val)\nfun(root.left,mx,mn,ans)\nfun(some_node,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]\n"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.",
        "examples": [
            "Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.",
            "Input: root = [1,null,2,null,0,3]\nOutput: 3"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(some_node,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return 0\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):\n                        distance[ci][cj] = self.sum(d, grid[ci][cj])\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n                else: q.appendleft((distance[i][j], i, j))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        undefined_variable.m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j = n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums);ans = 0\n        dp = defaultdict(Counter)\n        for i in range(1,n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                dp[i][d] += dp[j][d] + 1\n            ans += sum(dp[i].values()) - i\n        return ans",
        "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n**2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n**2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums);ans = 0\\n        dp = defaultdict(Counter)\\n        for i in range(1,n):\\n            for j in range(i):\\n                d = nums[i] - nums[j]\\n                dp[i][d] += dp[j][d] + 1\\n            ans += sum(dp[i].values()) - i\\n        return ans\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums);ans = 0\n        dp = defaultdict(Counter)\n        for i in range(1,n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                dp[i][d] += dp[j][d]\n            ans += sum(dp[i].values()) - i\n        return ans\n\nimport java.util.*;\n"
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
            "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
            "Input: s1 = \"a\", s2 = \"a\"\nOutput: true"
        ],
        "constrains": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2)):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)+1):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False\n"
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
            "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
            "Input: s1 = \"a\", s2 = \"a\"\nOutput: true"
        ],
        "constrains": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2)):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])\n            ) or (\n                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])\n            ): return True\n        return False\n"
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
            "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
            "Input: s1 = \"a\", s2 = \"a\"\nOutput: true"
        ],
        "constrains": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)+1):\n            if (\n                self.isScramble(s1[:-k], s2[:-k]) and self.isScramble(s1[k:], s2[k:])\n            ) or (\n                self.isScramble(s1[:-k], s2[k:]) and self.isScramble(s1[k:], s2[:-k])\n            ): return True\n        return False\n"
    },
    {
        "slug": "maximum-number-of-consecutive-values-you-can-make",
        "description": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.",
        "examples": [
            "Input: coins = [1,3]\nOutput: 2\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\nYou can make 2 consecutive integer values starting from 0.",
            "Input: coins = [1,1,1,4]\nOutput: 8\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\n- 2: take [1,1]\n- 3: take [1,1,1]\n- 4: take [4]\n- 5: take [4,1]\n- 6: take [4,1,1]\n- 7: take [4,1,1,1]\nYou can make 8 consecutive integer values starting from 0.",
            "Input: nums = [1,4,10,3,1]\nOutput: 20"
        ],
        "constrains": "coins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
        "oracle_code": "class Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\\n    ans = 1  # next value we want to make\\n\\n    for coin in sorted(coins):\\n      if coin > ans:\\n        return ans\\n      ans += coin\\n\\n    return ans\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n  return ans\n"
    },
    {
        "slug": "maximum-number-of-consecutive-values-you-can-make",
        "description": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.",
        "examples": [
            "Input: coins = [1,3]\nOutput: 2\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\nYou can make 2 consecutive integer values starting from 0.",
            "Input: coins = [1,1,1,4]\nOutput: 8\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\n- 2: take [1,1]\n- 3: take [1,1,1]\n- 4: take [4]\n- 5: take [4,1]\n- 6: take [4,1,1]\n- 7: take [4,1,1,1]\nYou can make 8 consecutive integer values starting from 0.",
            "Input: nums = [1,4,10,3,1]\nOutput: 20"
        ],
        "constrains": "coins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
        "oracle_code": "class Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\\n    ans = 1  # next value we want to make\\n\\n    for coin in sorted(coins):\\n      if coin > ans:\\n        return ans\\n      ans += coin\\n\\n    return ans\\n\\n```",
        "level": "medium",
        "type": [
            "other error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    # for coin in sorted(coins):\n    if coin > ans:\n        return ans\n    ans += coin\n\n  return ans\n"
    },
    {
        "slug": "maximum-number-of-consecutive-values-you-can-make",
        "description": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.",
        "examples": [
            "Input: coins = [1,3]\nOutput: 2\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\nYou can make 2 consecutive integer values starting from 0.",
            "Input: coins = [1,1,1,4]\nOutput: 8\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\n- 2: take [1,1]\n- 3: take [1,1,1]\n- 4: take [4]\n- 5: take [4,1]\n- 6: take [4,1,1]\n- 7: take [4,1,1,1]\nYou can make 8 consecutive integer values starting from 0.",
            "Input: nums = [1,4,10,3,1]\nOutput: 20"
        ],
        "constrains": "coins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
        "oracle_code": "class Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\\n    ans = 1  # next value we want to make\\n\\n    for coin in sorted(coins):\\n      if coin > ans:\\n        return ans\\n      ans += coin\\n\\n    return ans\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    # for coin in sorted(coins):\n    if coin > ans:\n        return ans\n    ans += coin\n\n  return ans\n"
    },
    {
        "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
        "description": "We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\nWhen two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\nWhen an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\nGiven an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.",
        "examples": [
            "Input: n = 4, left = [4,3], right = [0,1]\nOutput: 4\nExplanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).",
            "Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\nOutput: 7\nExplanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.",
            "Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []\nOutput: 7\nExplanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall."
        ],
        "constrains": "1 <= n <= 104\n0 <= left.length <= n + 1\n0 <= left[i] <= n\n0 <= right.length <= n + 1\n0 <= right[i] <= n\n1 <= left.length + right.length <= n + 1\nAll values of left and right are unique, and each value can appear only in one of the two arrays.",
        "oracle_code": "class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left, default=0), n - min(right, default=n))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to find the last moment when any of the ants are still on the line. This can be done by looking at the leftmost ant\\'s position and the rightmost ant\\'s position. The answer will be whichever of these two is greater.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use a two-pass approach. In the first pass, we will find the maximum position of any of the ants in the left array. In the second pass, we will find the minimum position of any of the ants in the right array. Finally, we will compare these two values and return the greater of the two. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left[0], default=0), n - max(right[0], default=n))\n"
    },
    {
        "slug": "capitalize-the-title",
        "description": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.",
        "examples": [
            "Input: title = \"capiTalIze tHe titLe\"\nOutput: \"Capitalize The Title\"\nExplanation:\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"First leTTeR of EACH Word\"\nOutput: \"First Letter of Each Word\"\nExplanation:\nThe word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"i lOve leetcode\"\nOutput: \"i Love Leetcode\"\nExplanation:\nThe word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
        ],
        "constrains": "1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty.",
        "oracle_code": "class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = l.lower()\n            else:\n                li[i] = l[0].upper() + l[1:].lower()\n        return ' '.join(li)",
        "content": "# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = self.lowerWords(l)\n            else:\n                li[i] = l[0].lower() + l[1:].lower()\n        return ' '.join(li)\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n                undefinedFunction(word)\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i - truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return 'counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    //return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word) + 1\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res\n"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constrains": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n    if len(dist) >= hour + 1  : return -1\n    left,right = 1, ceil(max(max(dist),dist[-2]/(1 if hour.is_integer() else hour-int(hour))))\n    while left<right:\n        mid=(left+right)//2\n        if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n            right=mid\n        else:\n            left=mid+1\n    return left\n"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constrains": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n    if len(dist) >= hour - 1  : return -1\n    left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n    while left<right:\n        mid=(left+right)//2\n        if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n            right=mid\n        else:\n            left=mid+1\n    return left\n"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constrains": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour - 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-2]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left\n"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "oracle_code": "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res",
        "content": "**Idea**\\nFirst we build an adjacency list using `edges`.\\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\\n2. Use set to record all the visited nodes along the way **(method 2)**\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3, DFS with recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        visited, res = set(), 0.\\n        def dfs(leaf_id, p, time):\\n            nonlocal res\\n            if time >= t:\\n                if leaf_id == target: res = p\\n                return\\n            visited.add(leaf_id)\\n            neighbors = nei[leaf_id] - visited\\n            for n in neighbors or [leaf_id]:\\n                dfs(n, p / (len(neighbors) or 1), time + 1)\\n        dfs(1, 1, 0)\\n        return res\\n```\\n\\n**Python 3, BFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.popleft()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS on tree without recursion, method 1**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n                    \\n        dp = collections.deque([1])\\n        while dp:\\n            leaf = dp.popleft()\\n            for n_ in nei[leaf]:\\n                nei[n_].remove(leaf)\\n                dp += n_,\\n                \\n        dp = [(1, 1, 0)]\\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            for n in nei[leaf] or [leaf]:\\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\\n        return 0.0\\n```\\n",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        #nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return random_value\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n        if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip)\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n        if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: IntList, totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n        if trip >= totalTrip:\n                return False\n        return True\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips:\n                right = mid\n            else:\n                left = mid + 1\n        return right\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int])\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]\n"
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        dfn(s)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    function validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        function fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] = 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] != 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\n"
    },
    {
        "slug": "all-elements-in-two-binary-search-trees",
        "description": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.",
        "examples": [
            "Input: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]",
            "Input: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]"
        ],
        "constrains": "The number of nodes in each tree is in the range [0, 5000].\n-105 <= Node.val <= 105",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        l=list()\n        def traversal(root):\n            if root is None :\n                return\n            l.append(root.val)\n            traversal(root.left)\n            traversal(root.right)\n        traversal(root1)\n        traversal(root2)\n        l.sort()\n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/be31fa66-f14d-4430-a166-5f23f990b4cf_1689964875.4489777.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\\n        l=list()\\n        def traversal(root):\\n            if root is None :\\n                return\\n            l.append(root.val)\\n            traversal(root.left)\\n            traversal(root.right)\\n        traversal(root1)\\n        traversal(root2)\\n        l.sort()\\n        return l\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        l=ArrayList()\n        def traversal(root):\n            if root is None :\n                return\n            l.append(root.val)\n            traversal(root.left)\n            traversal(f)\n        traversal(root1)\n        traversal(root2)\n        l.sort()\n        return l\n"
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "description": "Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text\u00a0following the format shown above.",
        "examples": [
            "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.",
            "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.",
            "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\""
        ],
        "constrains": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5",
        "oracle_code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def arrangeWords(self, text: undefined_str) -> str\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\n"
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "description": "Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text\u00a0following the format shown above.",
        "examples": [
            "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.",
            "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.",
            "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\""
        ],
        "constrains": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5",
        "oracle_code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def arrangeWords(self, text: str) -> str\n        return \" \".join(sorted(text.split(), key=len.capitalize()\n"
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "description": "Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text\u00a0following the format shown above.",
        "examples": [
            "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.",
            "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.",
            "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\""
        ],
        "constrains": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5",
        "oracle_code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def arrangeWords(self, text: undefined_str) -> str:\n        return \" \".join(sorted(text.split(), key=len.capitalize()\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = d\n        return ans\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curt + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int\n        #curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curt + int(d)\n            if curr > k:\n                ans += 1\n                curr = d\n        return ans\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        #curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = d\n        return ans\n"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        #curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curt + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans\n"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "oracle_code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nfrom queue import Queue\n\n#class Solution:\ndef frogPosition(n: int, edges: Arraylist[list[int]], t: int, target: int) -> float:\n    if edges == []:\n        if target == 1:return 1\n        return 0\n\n    d = {}\n    for i in edges:\n        d[i[0]] = d.get(i[0] , []) + [i[1]]\n        d[i[1]] = d.get(i[1] , []) + [i[0]]\n    \n    visit = [0]*(n+1)\n\n    q = Queue()     \n    q.put([1 , 1])\n\n    // for dur in range(t):\n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n\n            count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                return temp[1]\n                \n            if visit[temp[0]] != 0:    \n                continue\n            \n            visit[temp[0]] = 1\n\n            for ele in d[temp[0]]:\n                if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n            \n    \n    l = q.qsize()\n    for i in range(l):\n        temp = q.get()\n        if temp[0] == target:\n            return temp[1]\n\n    return 0\n"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "oracle_code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nfrom queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: ArrayList[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t+1):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    \n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0\n"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "oracle_code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nfrom queue import Queue\n\n#class Solution:\ndef frogPosition(n: int, edges: list[list[int]], t: int, target: int) -> float:\n    if edges == []:\n        if target == 1:return 1\n        return 0\n\n    d = {}\n    for i in edges:\n        d[i[0]] = d.get(i[0] , []) + [i[1]]\n        d[i[1]] = d.get(i[1] , []) + [i[0]]\n    \n    visit = [0]*(n+1)\n\n    q = Queue()     \n    q.put([1 , 1])\n\n    // for dur in range(t+1):\n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n\n            # Count no.of non-visited nodes\n            count = 0\n            for ele in d[temp[0]]:\n                if visit[ele] == 0: count += 1\n        \n            if temp[0] == target and count == 0:     \n                # If the target is reached and if its the end node\n                return temp[1]\n            \n            if visit[temp[0]] != 0:    # if already visited\n                continue\n            \n            visit[temp[0]] = 1\n\n            for ele in d[temp[0]]:\n                if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n            \n    \n    l = q.qsize()\n    for i in range(l):\n        temp = q.get()\n        if temp[0] == target:\n            return temp[1]\n\n    return 0\n"
    },
    {
        "slug": "word-subsets",
        "description": "You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\n\nFor example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.",
        "examples": [
            "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\nOutput: [\"facebook\",\"google\",\"leetcode\"]",
            "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\nOutput: [\"apple\",\"google\",\"leetcode\"]"
        ],
        "constrains": "1 <= words1.length, words2.length <= 104\n1 <= words1[i].length, words2[i].length <= 10\nwords1[i] and words2[i] consist only of lowercase English letters.\nAll the strings of words1 are unique.",
        "oracle_code": "class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        w2 = reduce(operator.or_, map(Counter, words2))\n        return [w1 for w1 in words1 if Counter(w1) >= w2]",
        "content": "```\\nclass Solution:\\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        w2 = reduce(operator.or_, map(Counter, words2))\\n        return [w1 for w1 in words1 if Counter(w1) >= w2]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\ndef wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n    w2 = reduce(operator.and_, map(Counter, words2))\n    return [w1 for w1 in words1 if Counter(w1) >= w2]\n"
    },
    {
        "slug": "magic-squares-in-grid",
        "description": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col\u00a0grid\u00a0of integers, how many 3 x 3 \"magic square\" subgrids are there?\u00a0 (Each subgrid is contiguous).",
        "examples": [
            "Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.",
            "Input: grid = [[8]]\nOutput: 0"
        ],
        "constrains": "row == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
        "oracle_code": "class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        res = 0\n\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\n\n\n        for i in range(M):\n            for j in range(N):\n                arr = []\n\n                for k in range(3):\n                    if k + i >= M:\n                        break\n                    arr.append(tuple(grid[i + k][j:j + 3]))\n                \n                arr.sort(key=lambda x: x[0])\n\n                if tuple(arr) in solution:\n                    res += 1\n                else:\n                    for row in arr:\n                        row = row[::-1]\n\n                    if tuple(arr) in solution:\n                        res += 1\n\n        \n        return res\n\n\n\n        '''\n        logic: find answer for 3 by 3 grid\n\n        4 3 8 \n        9 5 1\n        2 7 6\n\n\n        8 3 4\n        1 5 9 \n        2 7 6\n\n\n        have a solution key with all possible answers\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\n\n\n        '''",
        "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        res = 0\n\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\n\n\n        for i in range(M):\n            for j in range(N):\n                arr = []\n\n                for k in range(3):\n                    if k + i >= M:\n                        break\n                    arr.append(tuple(grid[i + k][j:j + 3]))\n                \n                arr.sort(key=lambda x: x[0])\n                '''\n\n                if tuple(arr) in solution:\n                    res += 1\n                else:\n                    for row in arr:\n                        row = self.reverse_array(row)\n\n                    if tuple(arr) in solution:\n                        res += 1\n        rt"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n    res=[]\n    for num in nums:\n        count[num]+=1 \n    for num in nums:\n        res.append(self.calculate_numbers(count[:num]))\n    return res\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n    res=[]\n    for num in nums:\n        count[num]+=1 \n    for num in nums:\n        res.append(sum(count[:num]\n    return res\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n    res=[]\n    for num in nums:\n        count[num]+=1 \n    for num in #nums:\n        res.append(sum(count[:num]))\n    return res\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(self.calculate_numbers(count[:num]\n        return res\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in #nums:\n            res.append(self.calculate_numbers(count[:num]))\n        return res\n"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in #nums:\n            res.append(sum(count[:num]\n        return res\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] = nums[p2-1] == nums[p2-2]: \n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    var break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p1-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    var break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] = nums[p2-1] == nums[p1-2]: \n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1\n"
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.",
        "examples": [
            "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.",
            "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.",
            "Input: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0."
        ],
        "constrains": "n == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
        "oracle_code": "class Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)",
        "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
        "level": "easy",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i+1]==10 or i>=2 and nums1[i-3]==10:\n                    res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n                if nums2[i+1]==10 or i>=2 and nums2[i-3]==10:\n                    res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        if res1>res2:\n            return)\n       elrn(1<lif re<res2:\n            return(2)\n        else:\n            return(0)\n"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        i=0\\n        c=0\\n        j=len(nums)-1\\n        while(i<=j):\\n            if(i==j):\\n                c=c+nums[i]\\n                break\\n            s=str(nums[i])+str(nums[j])\\n            c=c+int(s)\\n            i=i+1\\n            j=j-1\\n        return c\\n                \\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums) -> int:\n        i=0\n        c=0\n        j=len(nums)\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c\n\n"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        i=0\\n        c=0\\n        j=len(nums)-1\\n        while(i<=j):\\n            if(i==j):\\n                c=c+nums[i]\\n                break\\n            s=str(nums[i])+str(nums[j])\\n            c=c+int(s)\\n            i=i+1\\n            j=j-1\\n        return c\\n                \\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        #c=0\n        j=len(nums)\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c\n\n"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        i=0\\n        c=0\\n        j=len(nums)-1\\n        while(i<=j):\\n            if(i==j):\\n                c=c+nums[i]\\n                break\\n            s=str(nums[i])+str(nums[j])\\n            c=c+int(s)\\n            i=i+1\\n            j=j-1\\n        return c\\n                \\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums) -> int:\n        i=0\n        #c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+num[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c\n"
    },
    {
        "slug": "stone-game-vi",
        "description": "Alice and Bob take turns playing a game, with Alice starting first.\nThere are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\nYou are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\nDetermine the result of the game, and:\n\nIf Alice wins, return 1.\nIf Bob wins, return -1.\nIf the game results in a draw, return 0.",
        "examples": [
            "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1\nExplanation:\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.",
            "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0\nExplanation:\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.",
            "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1\nExplanation:\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins."
        ],
        "constrains": "n == aliceValues.length == bobValues.length\n1 <= n <= 105\n1 <= aliceValues[i], bobValues[i] <= 100",
        "oracle_code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        combines = [(a[i] + c[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True)\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(1, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0\n"
    },
    {
        "slug": "stone-game-vi",
        "description": "Alice and Bob take turns playing a game, with Alice starting first.\nThere are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\nYou are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\nDetermine the result of the game, and:\n\nIf Alice wins, return 1.\nIf Bob wins, return -1.\nIf the game results in a draw, return 0.",
        "examples": [
            "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1\nExplanation:\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.",
            "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0\nExplanation:\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.",
            "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1\nExplanation:\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins."
        ],
        "constrains": "n == aliceValues.length == bobValues.length\n1 <= n <= 105\n1 <= aliceValues[i], bobValues[i] <= 100",
        "oracle_code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(1, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0\n"
    },
    {
        "slug": "stone-game-vi",
        "description": "Alice and Bob take turns playing a game, with Alice starting first.\nThere are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\nYou are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\nDetermine the result of the game, and:\n\nIf Alice wins, return 1.\nIf Bob wins, return -1.\nIf the game results in a draw, return 0.",
        "examples": [
            "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1\nExplanation:\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.",
            "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0\nExplanation:\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.",
            "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1\nExplanation:\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins."
        ],
        "constrains": "n == aliceValues.length == bobValues.length\n1 <= n <= 105\n1 <= aliceValues[i], bobValues[i] <= 100",
        "oracle_code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        combines = [(a[i] + c[i], a[i], b[i]) for i in range(len(a))\n        combines.sort(reverse=True)\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3 = 0 and  i % k==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5 = 0 :\n                arr.append(\"Buzz\")\n  \n            else  :\n                arr.append(  str(i))\n        return(arr)\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(0,n+1):\n            if i % 3==0 and  i % k==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)\n"
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(0,n+1):\n            if i % 3 = 0 and  i % 5 = 0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3 = 0:\n                arr.append(\"Fizz\")\n            elif i % 5 = 0 :\n                arr.append(\"Buzz\")\n\n            else:\n                arr.append(str(i))\n        return(arr)\n"
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        \n        self.checks = (True, False, nums[0] == nums[1]) //this line has the bug\n        \n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n            s(elf.checks  = (checks[1], checks[2],\n                            (self.checks[1] and curr == prev1) or\n                            (self.checks[0] and curr == prev1 == prev2) or\n                            (self.checks[0] and curr == prev1)+1 == prev2+2))   \n        \n        return self.checks[2]\n"
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        \n        self.checks = (True, False, nums[0] == nums[1]) //this line has the bug\n        \n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n            self.checks  = (checks[1], checks[2],\n                            (self.checks[1] and curr == prev1) or\n                            (self.checks[0] and curr == prev1 == prev2) or\n                            (self.checks[0] and curr == prev1 == prev2+1 == curr+2))   \n        \n        return self.checks[2]\n"
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = ((checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2)) or     # <-- conditiion 2\n                      (checks[0] and prev1 == prev2+1 == curr+2))   # <-- conditiion 3    \n\n        return checks[2]\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if thisnums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        # nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)+1):\n            if nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        # nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if this-nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)+1):\n            if this-nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        # nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)+1):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False\n        return True\n    res=[]\n    #first look\n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0})\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1})\n        if test():\n            res.append(k)\n        #complete\n        for i in range(wlen+k, len(s)-slen+1,wlen):\n            \n            nw=s[i+slen-wlen:i+slen]\n            pw=s[i-wlen:i]\n            if nw in words:\n                track.update({nw: track[nw]+1})\n            if pw in words:\n                track.update({pw: track[pw]-1})\n            if test():\n                res.append(i-wlen)\n    return res\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False \n        return True\n    res=[]\n    #first look\n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0}))\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n            if pw in words:\n                track.update({pw: track[pw]-1)})\n            if test()):\n                res.append(i))\n    return res\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False\n        return True\n    res=[]\n    #first look\n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0})\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1})\n        if test():\n            res.append(k)\n        #complete\n        for i in range(wlen+k, len(s)-slen+1,wlen):\n            \n            nw=s[i+slen-wlen:i+slen]\n            pw=s[i-wlen:i]\n            if nw in words:\n                track.update({nw: track[nw]+1})\n            if pw in words:\n                track.update({pw: track[pw]-1})\n            if test():\n                res.append(i+wlen)\n    return res\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False \n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0}))\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n                if pw in words:\n                    track.update({pw: track[pw]-1)})\n                if test()):\n                    res.append(i-wlen))\n        return res\n"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False \n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0}))\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1)})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1}))\n                if pw in words:\n                    track.update({pw: track[pw]-1)})\n                if test()):\n                    res.append(i+wlen))\n        return res\n"
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
        ],
        "constrains": "1 <= targetX, targetY\u00a0<= 109",
        "oracle_code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=1:\n            if d&1:\n                return False\n            d>>=1\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite straightforward: a pair (a, b) is accessible if and only if the greatest common divisor of a and b, gcd(a, b), is a power of 2.\\nThe difficulty is proving this, which fortunately was not required during the contest. Anyway, here is the proof.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn one direction, note that all four operations preserve this property. The starting pair (1, 1) has it since $gcd(1, 1)=1=2^0$, the first two operations preserve the gcd, and the last two operations can multiply the gcd by 2 (or not). Thus, gcd(a, b) can only be a power of 2.\\n\\nConversely, starting from (1, 1) and multiplying the first term repeatedly by 2 we can obtain any pair of the form $(2^n, 1)$, then subtracting $1$ from $2^n$ repeatedly we can obtain any pair of the form $(n, 1)$.\\n\\nMultiplying the second term by 2 repeatedly we can obtain any pair of the form $(n, 2^m)$, then by subtracting $n$ from $2^m$ repeatedly we can obtain any pair of the form $(n,\\\\ 2^m \\\\mod n)$.\\n\\nSuppose we want to obtain the pair (n, k), where k<n and gcd(n, k)=1. Consider the infinite arithmetic progression (n, n+k, n+2k, ...). By Dirichlet\\'s theorem, this progression contains infinitely many primes. Consider one of them: p=n+jk for some $j \\\\geq 0$.\\n\\nBy a slight generalization of [Artin\\'s conjecture](https://mathworld.wolfram.com/ArtinsConjecture.html) (the generalization may need proof, but Artin\\'s conjecture was proved by Christopher Hooley, [\"On Artin\\'s Conjecture\"](https://eudml.org/doc/150785), in 1967, assuming the [Generalized Riemann Hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis)), there are infinitely many such p for which 2 is a primitive root of unity modulo p, meaning that $2^{p-1} \\\\equiv 1 \\\\mod p$ and $2^{k} \\\\not \\\\equiv 1 \\\\mod p$ for $0<k<p-1$.\\n\\nWe know we can obtain any pair of the form $(p,\\\\ 2^m \\\\mod p)$. Since p is prime, the multiplicative group $\\\\mathbb Z_p^*$ is cyclic. Since 2 is a generator (its order is equal to the order of the group), we can obtain any pair (p, k) where $1 \\\\leq k <p$ using powers of 2 modulo p, including the k we want.\\n\\nBut this is the same as (n+jk, k) and then by repeatedly subtracting k from n+jk we can obtain (n, k), as desired.\\n\\nBy symmetry (doing the same thing in reverse if necessary), we can obtain any pair (n, m) where gcd(m, n)=1. Finally, multiplying m and n by (possibly different) arbitrary powers of 2 we can obtain any pair whose gcd is a power of two.\\n\\nEdited: The initial proof was wrong and I corrected it.\\n\\n# Complexity\\n- Time complexity: Logarithmic: $O(\\\\max(\\\\log a, \\\\log b))$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            redefine b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=0:\n            if d&1:\n                return False\n            d>>=1\n        return True\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constrains": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd = 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return self.checkOddNeighbors(neighbors)\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] & neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) = n\n        return False\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constrains": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return self.checkOddNeighbors(neighbors)\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] & neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constrains": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd = 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) = n\n        return False\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "other error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p)\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 2\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p)\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 2\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p:\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 2\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p)\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p)\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p)\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p:\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        undefinedLCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))\n"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = X_noexisted_list[preorder_idx] # X_noexisted_list is undefined\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "parentheses mismatch"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = X_noexisted_list[preorder_idx] # X_noexisted_list is undefined\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 \n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n"
    },
    {
        "slug": "nim-game",
        "description": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.",
        "examples": [
            "Input: n = 4\nOutput: false\nExplanation: These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.",
            "Input: n = 1\nOutput: true",
            "Input: n = 2\nOutput: true"
        ],
        "constrains": "1 <= n <= 231 - 1",
        "oracle_code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0",
        "content": "This is a classic example of a game theory problem where both players play optimally. The game\\'s outcome depends on the number of stones in the heap. To determine whether you can win the game or not, we need to look at the number of stones in the heap and find a pattern.\\n\\nLet\\'s consider the base cases first:\\n\\n- If there is only one stone, you can remove it and win the game.\\n- If there are two stones, you can remove one stone and win the game.\\n- If there are three stones, you can remove two stones and win the game.\\n\\nFor n=4, you cannot win the game, as you can remove at most three stones on your turn, and your friend can remove the remaining stones on their turn. Therefore, your friend will win the game.\\n\\nFor n=5,6,7, you can win the game. If there are 5 stones, you can remove one stone and reduce it to four stones, and your friend will be forced to remove one to three stones. In any case, you will be able to remove the last stone and win the game.\\n\\nSimilarly, if there are six stones, you can remove two stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nIf there are seven stones, you can remove three stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nWe can observe that for any n that is a multiple of four, you cannot win the game. For any other value of n, you can win the game.\\n\\nTherefore, to solve this problem, we need to check if n is a multiple of four or not. If it is, return false; otherwise, return true.\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef canWinNim(self, n: int) -> bool:\n    return n % 4 == 0\n"
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            "Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]",
            "Input: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]",
            "Input: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]"
        ],
        "constrains": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "oracle_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def palindromePairs(self, words: Arreglo[str]) -> Arreglo[Arreglo[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward' and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res\n"
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            "Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]",
            "Input: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]",
            "Input: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]"
        ],
        "constrains": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "oracle_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
        "level": "hard",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def palindromePairs(self, words: Arreglo[str]) -> Arreglo[Arreglo[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res\n"
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            "Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]",
            "Input: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]",
            "Input: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]"
        ],
        "constrains": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "oracle_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward' and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n#    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i=pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n#    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(nums[i])\n            elif i<pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        return lst+val+tmp\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n#    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i==pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i=pivot:val.append(nums[i])\n            elif i<pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        return lst+val+tmp\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i=pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp\n"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i<pivot:val.append(i)\n            elif i==pivot:lst.append(nums[i])\n            else:tmp.append(nums[i])\n        nums[]return lst+val+tmp\n"
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.",
        "examples": [
            "Input: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.",
            "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.",
            "Input: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city."
        ],
        "constrains": "1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
        "oracle_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        #for road in roads : \n        adjacencyList[road[0]].append(road[1])\n        adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]\n"
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.",
        "examples": [
            "Input: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.",
            "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.",
            "Input: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city."
        ],
        "constrains": "1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
        "oracle_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] = 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]\n"
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.",
        "examples": [
            "Input: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.",
            "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.",
            "Input: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city."
        ],
        "constrains": "1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
        "oracle_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        #for road in roads : \n        adjacencyList[road[0]].append(road[1])\n        adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] = 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((release(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count)\n    else:\n        return get(root.left, index)\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "other error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n            return ans\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random(\n        self.size = 1\n        self.left = self.right = None\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "other error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return ans\n\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return nums\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count)\n    else:\n        return get(root.left, index)\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((release(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n            return ans\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random(\n        self.size = 1\n        self.left = self.right = None\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((release(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return ans\n\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((release(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return nums\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)\n"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n            return ans"
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k + 1])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    nums.append((get(tree, k // 2) + get('tree', k // 2 + 1)) / 2)\n        return nums\n"
    },
    {
        "slug": "watering-plants-ii",
        "description": "Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\nAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\nIt takes the same amount of time to water each plant regardless of how much water it needs.\nAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\nIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",
        "examples": [
            "Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.",
            "Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.",
            "Input: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0."
        ],
        "constrains": "n == plants.length\n1 <= n <= 105\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacityA, capacityB <= 109",
        "oracle_code": "class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n        if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n        lo, hi = lo+1, hi+1 # Start decrementing hi from lo+1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans\n"
    },
    {
        "slug": "watering-plants-ii",
        "description": "Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\nAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\nIt takes the same amount of time to water each plant regardless of how much water it needs.\nAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\nIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",
        "examples": [
            "Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.",
            "Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.",
            "Input: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0."
        ],
        "constrains": "n == plants.length\n1 <= n <= 105\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacityA, capacityB <= 109",
        "oracle_code": "class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n        if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi: ans += 1; canB = capacityB\n            canB -= plants[hi]\n        lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans\n"
    },
    {
        "slug": "watering-plants-ii",
        "description": "Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\nAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\nIt takes the same amount of time to water each plant regardless of how much water it needs.\nAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\nIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",
        "examples": [
            "Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.",
            "Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.",
            "Input: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0."
        ],
        "constrains": "n == plants.length\n1 <= n <= 105\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacityA, capacityB <= 109",
        "oracle_code": "class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi+1 # Start decrementing hi from lo+1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans\n"
    },
    {
        "slug": "reveal-cards-in-increasing-order",
        "description": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.",
        "examples": [
            "Input: deck = [17,13,11,2,3,5,7]\nOutput: [2,13,3,11,5,17,7]\nExplanation: \nWe get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.",
            "Input: deck = [1,1000]\nOutput: [1,1000]"
        ],
        "constrains": "1 <= deck.length <= 1000\n1 <= deck[i] <= 106\nAll the values of deck are unique.",
        "oracle_code": "class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)",
        "content": "# Code\\n```\\nclass Solution:\\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        def reveal(n):\\n            lst = list(range(n))\\n            ans = []\\n            i = 0\\n            while lst:\\n                if not i&1: ans.append(lst.pop(0))\\n                else: lst.append(lst.pop(0))\\n                i += 1\\n            return ans\\n        ans = reveal(len(deck))\\n        ans = sorted([v, i] for i, v in enumerate(ans))\\n        deck.sort()\\n        return (deck[j] for i,j in ans)\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(10))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return deck[j] for i,j in ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\ndef maxDistance(self, colors: List[int]) -> int\n    ans = 0 \n    for i, x in enumerate(colors): \n        if x != colors[0]: ans = max(ans, i)\n        if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n    return ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\ndef maxDistance(self, colors: List[int]) -> int:\n    ans = maxPink \n    for i, x in enumerate(colors): \n        if x != colors[0]: ans = max(ans, i)\n        if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n    return ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\ndef maxDistance(self, colors: List[int]) -> int:\n    ans = 0 \n    for i, x in enumerate(colors): \n        if x == colors[0]: ans = max(ans, i)\n        if x == colors[-1]: ans = max(ans, len(colors)-1-i)\n    return ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maxDistance(self, colors: List[int]) -> int\n        ans = maxPink \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxDistance(self, colors: List[int]) -> int\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x == colors[0]: ans = max(ans, i)\n            if x == colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans\n"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = maxPink \n        for i, x in enumerate(colors): \n            if x == colors[0]: ans = max(ans, i)\n            if x == colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*math.notify(stack[-1]))\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack[0])\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C\":\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return sum(stack[0])\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return stack==sum(stack[0])\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*math.notify(stack[-1]))\n            elif i=='C\":\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return sum(stack)\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*math.notify(stack[-1]))\n            elif i=='C':\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return stack==sum(stack)\n"
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C\":\n                stack.pop()\n            elif i='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(\"i))\n        return stack==sum(stack)\n"
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
            "Input: root = [1,null,2]\nOutput: 2"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "parentheses mismatch"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth])\n\n        return res\n"
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
            "Input: root = [1,null,2]\nOutput: 2"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```",
        "level": "easy",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop(1)\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth])\n\n        return res\n"
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
            "Input: root = [1,null,2]\nOutput: 2"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1\n        res = 0\n\n        while stack:\n            node, depth = stack.pop(1)\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n    else:\n        power = primeFactors // 3\n        return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD) * 2\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n    else:\n        power = primeFactors // 3\n        return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n    else:\n        power = primeFactors // 3\n        return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD) * 2\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD) * 2\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % modulo == 1:\n            result = (result * base) % MOD\n\n        return result\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.right = treeHelper(inorder_index+1, right)\n            root.left = treeHelper(left, inorder_index-1 )\n            \n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            # root=TreeNode(node_val)\n            root=TreeNode node_val\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(inorder_index+1, right)\n            root.right = treeHelper(left, inorder_index-1 )\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)\n"
    },
    {
        "slug": "next-greater-element-iv",
        "description": "You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\n\nj > i\nnums[j] > nums[i]\nThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n\nIf there is no such nums[j], the second greater integer is considered to be -1.\n\nFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,\u00a0and that of 3 and 4 is -1.\n\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].",
        "examples": [
            "Input: nums = [2,4,0,9,6]\nOutput: [9,6,6,-1,-1]\nExplanation:\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return [9,6,6,-1,-1].",
            "Input: nums = [3,3]\nOutput: [-1,-1]\nExplanation:\nWe return [-1,-1] since neither integer has any integer greater than it."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "oracle_code": "class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        ans = [-1] * len(nums)\n        s, ss = [], []\n        for i, x in enumerate(nums): \n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\n            buff = []\n            while s and nums[s[-1]] < x: buff.append(s.pop())\n            while buff: ss.append(buff.pop())\n            s.append(i)\n        return ans",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/a90ca3f9de0f99297262514c111f27700c24c04a) for solutions of biweekly 90. \\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ans = [-1] * len(nums)\\n        s, ss = [], []\\n        for i, x in enumerate(nums): \\n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\\n            buff = []\\n            while s and nums[s[-1]] < x: buff.append(s.pop())\\n            while buff: ss.append(buff.pop())\\n            s.append(i)\\n        return ans \\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n    ans = [-1] * len(nums)\n    s, ss = [], []\n    for i, x in enumerate(nums): \n        while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\n        buff = []\n        while s and nums[s[-1]] < x: buff.append(s.pop())\n        while buff: s.append(buff.pop())\n            s.append(i)\n    return ans\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"b\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: B[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A]\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: B[ord(char) - ord(\"b\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"b\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A]\n"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "type": [
            "undefined objects",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: B[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A]\n"
    },
    {
        "slug": "lexicographical-numbers",
        "description": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.",
        "examples": [
            "Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
            "Input: n = 2\nOutput: [1,2]"
        ],
        "constrains": "1 <= n <= 5 * 104",
        "oracle_code": "class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]",
        "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n)]\n        lst.sort()\n        return [int(i) for i in lst]\n    console.log(lexicalOrder(13));\n"
    },
    {
        "slug": "lexicographical-numbers",
        "description": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.",
        "examples": [
            "Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
            "Input: n = 2\nOutput: [1,2]"
        ],
        "constrains": "1 <= n <= 5 * 104",
        "oracle_code": "class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]",
        "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
        "level": "medium",
        "type": [
            "other error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n)]\n    # lst.sort()\n        return [int(i) for i in lst]\n"
    },
    {
        "slug": "lexicographical-numbers",
        "description": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.",
        "examples": [
            "Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
            "Input: n = 2\nOutput: [1,2]"
        ],
        "constrains": "1 <= n <= 5 * 104",
        "oracle_code": "class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]",
        "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n    # lst.sort()\n        return [int(i) for i in lst]\n    console.log(lexicalOrder(13));\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    for i in range(len(words)):\n        w=[j for j in words[i]]\n        d2=Counter(w\n    #print(dc)\n    #print(dw)\n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))\n    return sum(ans)\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    /*for i in range(len(words)):\n        w=[j for j in words[i]]\n        d2=Counter(w)\n    #print(dc)\n    #print(dw)\n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))*/\n    return sum(ans)\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    for i in range(len(words)+1):\n        w=[j for j in words[i]]\n        d2=Counter(w)\n    #print(dc)\n    #print(dw)\n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))\n    return sum(ans)\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        /*for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))*/\n        return sum(ans)\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)+1):\n            w=[j for j in words[i]]\n            d2=Counter(w\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)\n"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        /*for i in range(len(words)+1):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))*/\n        return sum(ans)\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "variable value error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        # new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 = 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n            new.append(nums1[p1])\n            p1 += 1\n        else:\n            new.append(nums2[p2])\n            p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        # new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p2 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p1 += 1\n\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        # new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        # new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        # new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 = 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 <= len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median\n"
    },
    {
        "slug": "palindrome-partitioning-iii",
        "description": "You are given a string s containing lowercase letters and an integer k. You need to :\n\nFirst, change some characters of s to other lowercase English letters.\nThen divide s into k non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn the minimal number of characters that you need to change to divide the string.",
        "examples": [
            "Input: s = \"abc\", k = 2\nOutput: 1\nExplanation:\u00a0You can split the string into \"ab\" and \"c\", and change 1 character in \"ab\" to make it palindrome.",
            "Input: s = \"aabbc\", k = 3\nOutput: 0\nExplanation:\u00a0You can split the string into \"aa\", \"bb\" and \"c\", all of them are palindrome.",
            "Input: s = \"leetcode\", k = 8\nOutput: 0"
        ],
        "constrains": "1 <= k <= s.length <= 100.\ns only contains lowercase English letters.",
        "oracle_code": "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp:\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)",
        "content": "```\\nclass Solution:\\n    def palindromePartition(self, s: str, k: int) -> int:\\n        \\n        \\n\\t\\t#This is the cost function \\n        \\n        def Cost(s):\\n            i,j,c=0,len(s)-1,0\\n            \\n            while i<j:\\n                if s[i]!=s[j]:c+=1\\n                j-=1\\n                i+=1\\n            return c\\n        \\n        dp={}\\n        \\n\\t\\t# Recursion\\n\\t\\t\\n        def A(s,k):\\n\\t\\t\\t# Memoization\\n            if (s,k) in dp:\\n                return dp[(s,k)]\\n\\t\\t\\t# if k==1 then we want the whole string there is no other way \\n            if k==1:\\n                return Cost(s)\\n            \\n\\t\\t\\t#intial value to max\\n            f=float(\\'inf\\')\\n            \\n            #start checking whole string \\n            for x in range(1,len(s)+1):\\n                #check wheather if both the strings exist.\\n                if len(s[:x]) and len(s[x:]):\\n\\t\\t\\t\\t\\n                    #if exist we find the cost recursively assign min value \\n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\\n             #store the min value       \\n            dp[(s,k)]=f\\n\\t\\t\\t\\n            return dp[(s,k)]\\n        return A(s,k)\\n                \\n                    \\n            \\n            ```",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1'))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts)+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = infinity\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts)+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts)+1: return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i = len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+2, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n\n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts)+1: return 0\n            return min(fn(i+2, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans\n"
    },
    {
        "slug": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
        "description": "Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.",
        "examples": [
            "Input: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\nOutput: 4\nExplanation: Valid pairs are:\n- (0, 1): \"777\" + \"7\"\n- (1, 0): \"7\" + \"777\"\n- (2, 3): \"77\" + \"77\"\n- (3, 2): \"77\" + \"77\"",
            "Input: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\nOutput: 2\nExplanation: Valid pairs are:\n- (0, 1): \"123\" + \"4\"\n- (2, 3): \"12\" + \"34\"",
            "Input: nums = [\"1\",\"1\",\"1\"], target = \"11\"\nOutput: 6\nExplanation: Valid pairs are:\n- (0, 1): \"1\" + \"1\"\n- (1, 0): \"1\" + \"1\"\n- (0, 2): \"1\" + \"1\"\n- (2, 0): \"1\" + \"1\"\n- (1, 2): \"1\" + \"1\"\n- (2, 1): \"1\" + \"1\""
        ],
        "constrains": "2 <= nums.length <= 100\n1 <= nums[i].length <= 100\n2 <= target.length <= 100\nnums[i] and target consist of digits.\nnums[i] and target do not have leading zeros.",
        "oracle_code": "class Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        d = defaultdict(int)\n        for char in nums:\n            d[char] += 1\n            \n        arr = []\n        for char in target:\n            arr.append(char)\n        \n        pairs = 0\n        num = \"\"\n        while len(arr) > 1:\n            num += arr.pop()\n            findNum = \"\".join(arr)\n            if num[::-1] not in d or findNum not in d:\n                continue\n\n            c1 = d[num[::-1]]\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\n            \n            c2 = d[findNum]\n            d[num[::-1]] += 1 # make the count again same.\n\n            pairs += c1 * c2\n        return pairs",
        "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = defaultdict(int)\\n        for char in nums:\\n            d[char] += 1\\n            \\n        arr = []\\n        for char in target:\\n            arr.append(char)\\n        \\n        pairs = 0\\n        num = \"\"\\n        while len(arr) > 1:\\n            num += arr.pop()\\n            findNum = \"\".join(arr)\\n            if num[::-1] not in d or findNum not in d:\\n                continue\\n\\n            c1 = d[num[::-1]]\\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\\n            \\n            c2 = d[findNum]\\n            d[num[::-1]] += 1 # make the count again same.\\n\\n            pairs += c1 * c2\\n        return pairs\\n        \\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        d = defaultdict(int)\n        for char in nums:\n            d[char] += 1\n            \n        arr = []\n        for char in target:\n            arr.append(char)\n        \n        pairs = 0\n        num = \"\"\n        while len(arr) > 1:\n            num += arr.pop()\n            findNum = \"\".join(arr)\n            if num[::-1] not in d or findNum not in d:\n                continue\n\n            c1 = d[num[::-1]]\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\n            var c2 = d[findNum]\n            d[num[::-1] += 1 # make the count again same.\n\n            pairs += c1 * c2\n        return pairs\n"
    },
    {
        "slug": "jump-game-ii",
        "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
        "examples": [
            "Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
            "Input: nums = [2,3,0,1,4]\nOutput: 2"
        ],
        "constrains": "1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt's guaranteed that you can reach nums[n - 1].",
        "oracle_code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        #print(nums)\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    #print(index-1,steps[index-1])\n                    steps.append(steps[index]+1)\n            #print(steps)\n        return steps[L-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        #print(nums)\\n        L=len(nums)\\n        if L==1:\\n            return 0\\n        steps=[0]\\n        for i in range(nums[0]):\\n            steps.append(1)\\n        for index in range(1,L):\\n            len_steps=len(steps)\\n            if len_steps >= nums[index]+index+1:\\n                index += 1\\n            elif len_steps < nums[index]+index+1:\\n                for j in range(nums[index]+index-len_steps+1):\\n                    #print(index-1,steps[index-1])\\n                    steps.append(steps[index]+1)\\n            #print(steps)\\n        return steps[L-1]\\n\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def jump(self, blue: List[int]) -> int:\n        L=len(blue)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    steps.append(steps[index+1]+1return steps[L-1]\n"
    },
    {
        "slug": "distribute-candies",
        "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.",
        "examples": [
            "Input: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.",
            "Input: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.",
            "Input: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
        ],
        "constrains": "n == candyType.length\n2 <= n <= 104\nn\u00a0is even.\n-105 <= candyType[i] <= 105",
        "oracle_code": "class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(set(candyType)))",
        "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\ndef distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(self.uniqueCandyTypes(candyType)))\n\n    def uniqueCandyTypes(self, candyList):\n        self.processCandyList(candyList)\n"
    },
    {
        "slug": "distribute-candies",
        "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.",
        "examples": [
            "Input: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.",
            "Input: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.",
            "Input: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
        ],
        "constrains": "n == candyType.length\n2 <= n <= 104\nn\u00a0is even.\n-105 <= candyType[i] <= 105",
        "oracle_code": "class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(set(candyType)))",
        "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\ndef distributeCandies(self, candyType: List[int]) -> int:\n        return max(len(candyType)//2, len(set(candyType)))\n"
    },
    {
        "slug": "distribute-candies",
        "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.",
        "examples": [
            "Input: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.",
            "Input: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.",
            "Input: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
        ],
        "constrains": "n == candyType.length\n2 <= n <= 104\nn\u00a0is even.\n-105 <= candyType[i] <= 105",
        "oracle_code": "class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(set(candyType)))",
        "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return max(len(candyType)//2, len(self.uniqueCandyTypes(candyType)))\n\n    def uniqueCandyTypes(self, candyList):\n        self.processCandyList(candyList)\n"
    },
    {
        "slug": "pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
            "Input: numRows = 1\nOutput: [[1]]"
        ],
        "constrains": "1 <= numRows <= 30",
        "oracle_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = Array(1)\n        for i in range(len(fin)-1:\n            now.append(fin[i] + fin[i+1])\n        now.push(1)\n        prev.append(now)\n        return prev\n"
    },
    {
        "slug": "pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
            "Input: numRows = 1\nOutput: [[1]]"
        ],
        "constrains": "1 <= numRows <= 30",
        "oracle_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 0:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1:\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev\n"
    },
    {
        "slug": "pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
            "Input: numRows = 1\nOutput: [[1]]"
        ],
        "constrains": "1 <= numRows <= 30",
        "oracle_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 0:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = Array(1)\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.push(1)\n        prev.append(now)\n        return prev\n"
    },
    {
        "slug": "minimum-distance-to-the-target-element",
        "description": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that\u00a0abs(x)\u00a0is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.",
        "examples": [
            "Input: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.",
            "Input: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.",
            "Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\n0 <= start < nums.length\ntarget is in nums.",
        "oracle_code": "class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        curVal=len(nums)\n        for i in range(start,len(nums)):\n            if nums[i]==target:\n                curVal=min(curVal,abs(i-start))\n                break\n        j=start\n        while(j>=0):\n            if nums[j]==target:\n                curVal=min(curVal,abs(j-start))\n                break\n            j-=1\n        return curVal",
        "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def getMinDistance(self, nums: undefinedList[int], target: int, start: int) -> int:\n        curVal=len(nums)\n        for i in range(start,len(nums)):\n        if nums[i]==target:\n            curVal=min(curVal,abs(i-start))\n            break\n        j=start\n        while(j>=0):\n            if nums[j]==target:\n                curVal=min(curVal,abs(j-start))\n                break\n            j-=1\n        return curVal\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] -= diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n\nmy_solution = Solution()\nmy_solution.maxPower([1,2,3], 2, 5)\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, # end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] -= diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] -= diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, # end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n\nmy_solution = Solution()\nmy_solution.maxPower([1,2,3], 2, 5)\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n\nmy_solution = Solution()\nmy_solution.maxPower([1,2,3], 2, 5)\n"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, # end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n + 1):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1.reverse())\n        word4 = self.concat(word2)\n        if word3 == word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1)\n        word4 = self.concat(word2\n        if word3 == word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1\n        word4 = self.concat(word2)\n        if word3 == word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3 = self.concat(word1)\n        word4 = self.concat(word2)\n        if word3 = word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1.reverse())\n        word4=\"\".join(word2\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1.reverse()\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1.reverse())\n        word4=/*.join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1.reverse())\n        word4=\"\".join(word2)\n        if word3=word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1\n        word4=\"\".join(word2\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1)\n        word4=/*.join(word2\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2\n        if word3=word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1\n        word4=/*.join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1\n        word4=\"\".join(word2)\n        if word3=word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=/*.join(word1)\n        word4=/*.join(word2)\n        if word3=word4:\n            return True\n        else:\n            return False\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s)\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution():\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i:\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return 'res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i=len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res\n"
    },
    {
        "slug": "maximum-profit-of-operating-a-centennial-wheel",
        "description": "You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.",
        "examples": [
            "Input: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.",
            "Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.",
            "Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1."
        ],
        "constrains": "n == customers.length\n1 <= n <= 105\n0 <= customers[i] <= 50\n1 <= boardingCost, runningCost <= 100",
        "oracle_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans",
        "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minOperationsMaxProfit(self, customers: UndefinedList[int], boardingCost: int, runningCost: int) -> int:\n        \n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            \n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>=maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined objects"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(Node),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                q.append(curr.left)\n                q.append(curr.right)\n\n            ans.append(l)\n        return checkReverse(ans)\n"
    },
    {
        "slug": "minimum-suffix-flips",
        "description": "You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target.\nIn one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'.\nReturn the minimum number of operations needed to make s equal to target.",
        "examples": [
            "Input: target = \"10111\"\nOutput: 3\nExplanation: Initially, s = \"00000\".\nChoose index i = 2: \"00000\" -> \"00111\"\nChoose index i = 0: \"00111\" -> \"11000\"\nChoose index i = 1: \"11000\" -> \"10111\"\nWe need at least 3 flip operations to form target.",
            "Input: target = \"101\"\nOutput: 3\nExplanation: Initially, s = \"000\".\nChoose index i = 0: \"000\" -> \"111\"\nChoose index i = 1: \"111\" -> \"100\"\nChoose index i = 2: \"100\" -> \"101\"\nWe need at least 3 flip operations to form target.",
            "Input: target = \"00000\"\nOutput: 0\nExplanation: We do not need any operations since the initial s already equals target."
        ],
        "constrains": "n == target.length\n1 <= n <= 105\ntarget[i] is either '0' or '1'.",
        "oracle_code": "class Solution:\n    def minFlips(self, target: str) -> int:\n        return len(list(groupby(\"0\" + target)))-1",
        "content": "Algo: \\n\\nTo abstract this problem in math terms, the purpose of it is to simply convert a string composed of `0`\\'s and `1`\\'s to all `0`\\'s using a predefined flip operation that flips everything from a given position to the end. As a result, at any step, one could focus on the left-most `1`. By fliping it, a desirable byproduct is that a continous chunk of `1`\\'s connecting to the left-most `1` is set to `0`. An undesirable side effect is that the next `0` will become the left-most `1`. In the next step, you would have to flip this `1`. \\n\\nIt is not difficult to realize that this problem is to count the number of changes in the string. One caveat is the first character, for which one flip needs to be counted if it is `1`. To unify the operation, we could add a dummy `0` in front so that the string always starts with `0`. \\n\\nUsing the example given by the problem, the above argument would suggest 3 as the answer as there are in total 3 changes while scanning `010111` (a dummy `0` is added in front) from left to right. \\n`10111`\\n`01000` after 1st flip\\n`00111` after 2nd flip\\n`00000` after 3rd flip \\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return len(list(groupby(\"0\" + target)))-1\\n```\\n\\nHere, we leverage on `groupby` function of `itertools` module which groups the string for us though the only info we need is the number of groups minus one (`n` groups comes with `n-1` changes from group to group).\\n\\nFurthermore, the below elegant solution is due to @awice. \\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans = flip = 0\\n        for bulb in target: \\n            if flip ^ int(bulb): \\n                flip ^= 1\\n                ans += 1\\n        return ans\\n```\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0,\"0\"\\n        for c in target: \\n            if prev != c: ans += 1\\n            prev = c\\n        return ans \\n```",
        "level": "medium",
        "type": [
            "variable value error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def minFlips(self, target: str) -> int:\n        return len(list(groupby(target + \"0\")))-1\ntarget = \"Hello, World\nprint(Solution().minFlips(target))\n"
    },
    {
        "slug": "reverse-subarray-to-maximize-array-value",
        "description": "You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\nFind maximum possible value of the final array.",
        "examples": [
            "Input: nums = [2,3,1,5,4]\nOutput: 10\nExplanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.",
            "Input: nums = [2,4,9,24,2,1,10]\nOutput: 68"
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-105 <= nums[i] <= 105",
        "oracle_code": "class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = 0, len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        for idx in range(sz - 1):\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\\n        originalValue, sz = 0, len(nums)\\n        for idx in range(sz - 1):\\n            originalValue += abs(nums[idx] - nums[idx + 1])\\n        finalValue = originalValue\\n        for idx in range(1, sz - 1):\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\\n        minimum, maximum = inf, -inf\\n        for idx in range(sz - 1):\\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\\n            minimum = min(minimum, tempMax)\\n            maximum = max(maximum, tempMin)\\n        return finalValue\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = getOriginalValue(nums), len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        #for idx in range(sz - 1):\n        tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n        if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n        if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com,2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com[::-1],2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n           com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1][1:],2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com,2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com,2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com][1:,2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com[::-1],2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += 0\n            else:\n                com += 1\n            num = num // 2\n        return int(com[::-1][1:],2)\n"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 = 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1][1:],2)\n"
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        break\n                    if(j==len(nums2)-1):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        out=[]\\n        for i in range(0,len(nums1)):\\n            if(nums2.index(nums1[i])==len(nums2)-1):\\n                out.append(-1)\\n            else:\\n                j=nums2.index(nums1[i])+1\\n                while(1):\\n                    if(nums1[i]<nums2[j]):\\n                        out.append(nums2[j])\\n                        break\\n                    if(j==len(nums2)-1):\\n                        out.append(-1)\\n                        break\\n                    j+=1\\n        return out\\n```",
        "level": "easy",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        self.undefinedMethod()\n                        break\n                    if(j==len(nums2)):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out\n"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constrains": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b = c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if d[i] != c[i]: #<--- The BUG is here.\n                    cnt += 1\n        return cnt\n"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constrains": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "type": [
            "undefined objects",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '0':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if d[i] != c[i]: #<--- The BUG is here.\n                    cnt += 1\n        return cnt\n"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constrains": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b = c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '0':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt\n"
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]",
            "Input: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.",
            "Input: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
        ],
        "constrains": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i=n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n"
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]",
            "Input: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.",
            "Input: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
        ],
        "constrains": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x)%mod) #bug here, should have been (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n"
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]",
            "Input: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.",
            "Input: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
        ],
        "constrains": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "oracle_code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i=n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x)%mod) #bug here, should have been (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()\n"
    },
    {
        "slug": "card-flipping-game",
        "description": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.",
        "examples": [
            "Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation:\nIf we flip the second card, the face up numbers are [1,3,4,4,7] and the face down are [1,2,4,1,3].\n2 is the minimum good integer as it appears facing down but not facing up.\nIt can be shown that 2 is the minimum possible good integer obtainable after flipping some cards.",
            "Input: fronts = [1], backs = [1]\nOutput: 0\nExplanation:\nThere are no good integers no matter how we flip the cards, so we return 0."
        ],
        "constrains": "n == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000",
        "oracle_code": "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs)):\n            if i in bad:\n                continue\n            return i\n        return 0",
        "content": "# Intuition\\nThe only way you can\\'t have a good integer is if you have a card with it on both sides.  You want the minimum, so just sort, giving you the lowest, and check if any card has it on both sides.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\\n        for i in sorted(set(fronts + backs)):\\n            if i in bad:\\n                continue\\n            return i\\n        return 0\\n\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i, j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts - backs:\n            if i in bad:\n                continue\n            return i\n        return 0\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  # Bug is here\n                    queue.append(tmp.left)   # Switched order of left and right\n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "wrong comment mark"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        # lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  # Bug is here\n                    queue.append(tmp.left)   # Switched order of left and right\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): #bug here\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.right)  # Bug is here\n                    queue.append(tmp.left)   # Switched order of left and right\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "wrong comment mark"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        # lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): #bug here\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.add(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        # lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)+1): #bug here\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) # if len(lst := [num for num in nums if num % 6 = 0]) > 0 else 0\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) # if len(lst := [num for num in nums if num % 6 == 0]) > 1 else 0\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 = 0]) > 1 else 0\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:      \n                    return ''      \n                pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n:\n            if lcp[i][j] > 0):\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n\n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:      \n                        return ''      \n                    pattern[j] = pattern[i]\n\n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n\n\n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n:\n                if lcp[i][j] > 0):\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "type": [
            "unclosed string",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] = lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] = n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] = pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "other error"
        ],
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2\n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = min(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones):\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n        \nsolution = Solution()\nprint(solution.moveFinal([2,3,4,5,6]))\n\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1) - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length :\n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] = stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate = 0 or move_final = 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_length = len(stones)\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimate, move_final)\n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n        for index, stone in enumerate(stones) :\n            while stones[starting_index + 1] <= stone - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_length - max_legal_moves, most_moves]\n\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "undefined methods"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\nmove_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = min(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "other error",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\nmove_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = min(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mvsne_leng==ms_mves = max(move_penultimate, move_nal)\n      if move_uima=0ormove_x__=0\n       arting_inex= 0\n        f in,stones[starting_index] <= stone - stone_leng:\n              starting_[stone_\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1) - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length :\n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index + 1<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mv)sne_lengms_mves = max(move_penultimate, move_nal)\n      if move_uima==0or move_final == 0 : \n            min_legal_moves = min(, most_moves)\n            return [min_legal_moves, most_moves]\n        max_legal_moves = 0 \n        starting_index = 0\n       x stone in enumerate(stones) :\n           le stones[starting_index] <= stone - stone_lengt:\n           starting_index += 1\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        return [stone_leng-mx__mv,mos_movs]\n     \nsolution = Solution()\nprint(solution.moveFinal([,6"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int] :\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1) - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index<=stne - stone_length :\n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mvsne_leng==ms_mves = max(move_penultimate, move_nal)\n      if move_uima=0ormove_x__=0\n       arting_inex= 0\n        f in,stones[starting_index] <= stone - stone_leng:\n              starting_[stone_\n"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "type": [
            "== and = confusion",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:dfnumMovStonesII(sef,stones: List[int]) -> List[int]:\n        stones.sort()\n        stone_leng = len(stnes)\n        move_penltimate = stones[-2] - stones[0] - stone_lent+2\n move_final = stones[-1] - stones[1] - stone_length + 2 \n        most_moves = max(move_penultimatemove_final)\n      if move_nultimate==mv_final==:_gl_movs=most_moves\n            return [min_legal_movesmost_moves\n      max_legal_moves = 0 \n        starting_index = 0\n        for index():starting_index + 1<=stne - stone_length : \n                starting_index += 1\n            max_legal_moves = min(max(max_legal_moves-trting_iext_)rtur[tone_length- max_legal_movesm_mvsne_leng==ms_mves = max(move_penultimate, move_nal)\n      if move_uima=0ormove_x__=0\n       arting_inex= 0\n        f in,stones[starting_index] <= stone - stone_leng:\n              starting_[stone_\n"
    },
    {
        "slug": "merge-k-sorted-lists",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
            "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6",
            "Input: lists = []\nOutput: []",
            "Input: lists = [[]]\nOutput: []"
        ],
        "constrains": "k == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.",
        "oracle_code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in lists:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr):\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\n        head = temp = ListNode()\\n        arr = []\\n\\n        for ls in lists:\\n            while ls:\\n                arr.append(ls.val)\\n                ls = ls.next\\n\\n        for val in sorted(arr):\\n            temp.next = ListNode()\\n            temp = temp.next\\n            temp.val = val\\n\\n        return head.next\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "other error"
        ],
        "buggy_code": "\nclass Solution:\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n    head = temp = ListNode()\n    arr = []\n\n    for ls in lists:\n        while ls:\n            arr.append(ls.val)\n            ls = ls.next\n\n    for val in sorted(arr, reverse=True):   # added reverse=True here\n        temp.next = ListNode()\n        temp = temp.next\n        temp.val = val\n\n    return head.next\n"
    },
    {
        "slug": "merge-k-sorted-lists",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
            "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6",
            "Input: lists = []\nOutput: []",
            "Input: lists = [[]]\nOutput: []"
        ],
        "constrains": "k == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.",
        "oracle_code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in lists:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr):\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\n        head = temp = ListNode()\\n        arr = []\\n\\n        for ls in lists:\\n            while ls:\\n                arr.append(ls.val)\\n                ls = ls.next\\n\\n        for val in sorted(arr):\\n            temp.next = ListNode()\\n            temp = temp.next\\n            temp.val = val\\n\\n        return head.next\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n    head = temp = ListNode()\n    arr = []\n\n    for ls in undefined_variable:\n        while ls:\n            arr.append(ls.val)\n            ls = ls.next\n\n    for val in sorted(arr):\n        temp.next = ListNode()\n        temp = temp.next\n        temp.val = val\n\n    return head.next\n"
    },
    {
        "slug": "merge-k-sorted-lists",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
            "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6",
            "Input: lists = []\nOutput: []",
            "Input: lists = [[]]\nOutput: []"
        ],
        "constrains": "k == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.",
        "oracle_code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in lists:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr):\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\n        head = temp = ListNode()\\n        arr = []\\n\\n        for ls in lists:\\n            while ls:\\n                arr.append(ls.val)\\n                ls = ls.next\\n\\n        for val in sorted(arr):\\n            temp.next = ListNode()\\n            temp = temp.next\\n            temp.val = val\\n\\n        return head.next\\n```",
        "level": "hard",
        "type": [
            "other error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in undefined_variable:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr, reverse=True):   # added reverse=True here\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next\n"
    },
    {
        "slug": "construct-the-longest-new-string",
        "description": "You are given three integers x, y, and z.\nYou have x strings equal to \"AA\", y strings equal to \"BB\", and z strings equal to \"AB\". You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain \"AAA\" or \"BBB\" as a substring.\nReturn the maximum possible length of the new string.\nA substring is a contiguous non-empty sequence of characters within a string.",
        "examples": [
            "Input: x = 2, y = 5, z = 1\nOutput: 12\nExplanation: We can concactenate the strings \"BB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AB\" in that order. Then, our new string is \"BBAABBAABBAB\". \nThat string has length 12, and we can show that it is impossible to construct a string of longer length.",
            "Input: x = 3, y = 2, z = 2\nOutput: 14\nExplanation: We can concactenate the strings \"AB\", \"AB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AA\" in that order. Then, our new string is \"ABABAABBAABBAA\". \nThat string has length 14, and we can show that it is impossible to construct a string of longer length."
        ],
        "constrains": "1 <= x, y, z <= 50",
        "oracle_code": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n\n        if x > y: x,y = y,x\n\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;",
        "content": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        if x > y: x,y = y,x\\n\\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;\\n```\\n[https://leetcode.com/problems/construct-the-longest-new-string/submissions/985072631/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
        "level": "medium",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n\n        if x > y: x,y = y,x\n\n        return (min(x + y, 2*x + 1 ) * 2 - 2*z\n"
    },
    {
        "slug": "reverse-nodes-in-k-group",
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
            "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
            "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]"
        ],
        "constrains": "The number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\u00a0\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "oracle_code": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n            k += 1 # Bug inserted here\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node\n"
    },
    {
        "slug": "reverse-nodes-in-k-group",
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
            "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
            "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]"
        ],
        "constrains": "The number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\u00a0\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "oracle_code": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
        "level": "hard",
        "type": [
            "indentation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, nextGroup\n            while curr != nextGroup:\n            tmp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node\n\n"
    },
    {
        "slug": "reverse-nodes-in-k-group",
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
            "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
            "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]"
        ],
        "constrains": "The number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\u00a0\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "oracle_code": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "undefined objects"
        ],
        "buggy_code": "\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, nextGroup\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n            k += 1 # Bug inserted here\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node\n\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n)\n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.append(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                supplies.append(x)\n\n        return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.append(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            # if ans[x]!=[]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i]-=1\n            if indegree[i]==0:\n                st.append(i)\n        if x in recepies:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(i)\n\n    return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.push(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            # if ans[x]!=[]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i]-=1\n            if indegree[i]==0:\n                st.append(i)\n        if x in recepies:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "indentation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n+1):   # Bug introduced here\n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.append(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            # if ans[x]!=[]:\n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i]-=1\n            if indegree[i]==0:\n                st.append(i)\n        if x in recepies:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n)\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return iflst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n)\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1)   # Bug introduced here\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "undefined keywords from other languages"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(i)\n\n        return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "operation error",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1):   # Bug introduced here\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(i)\n\n        return flst\n"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "type": [
            "undefined keywords from other languages",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n+1):   # Bug introduced here\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.push(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] = dp[j][diff] + 1\n                total += dp[j][diff]\n        self.undifned_method()return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += self.undifned_method(dp[j][diff])\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for ''j in range(i):'' #added wrong comment mark here\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += self.undifned_method(dp[j][diff])\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i+1][diff] += dp[j][diff] + 1\n                total += self.undifned_method(dp[j][diff])\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] = dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for ''j in range(i):'' #added wrong comment mark here\n                diff = nums[j] - nums[i]\n                dp[i][diff] = dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for ''j in range(i):'' #added wrong comment mark here\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i+1][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "type": [
            "wrong comment mark",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for ''j in range(i):'' #added wrong comment mark here\n                diff = nums[j] - nums[i]\n                dp[i+1][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total\n"
    },
    {
        "slug": "smallest-string-with-swaps",
        "description": "You are given a string s, and an array of pairs of indices in the string\u00a0pairs\u00a0where\u00a0pairs[i] =\u00a0[a, b]\u00a0indicates 2 indices(0-indexed) of the string.\nYou can\u00a0swap the characters at any pair of indices in the given\u00a0pairs\u00a0any number of times.\nReturn the\u00a0lexicographically smallest string that s\u00a0can be changed to after using the swaps.",
        "examples": [
            "Input: s = \"dcab\", pairs = [[0,3],[1,2]]\nOutput: \"bacd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[1] and s[2], s = \"bacd\"",
            "Input: s = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\nOutput: \"abcd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[0] and s[2], s = \"acbd\"\nSwap s[1] and s[2], s = \"abcd\"",
            "Input: s = \"cba\", pairs = [[0,1],[1,2]]\nOutput: \"abc\"\nExplaination: \nSwap s[0] and s[1], s = \"bca\"\nSwap s[1] and s[2], s = \"bac\"\nSwap s[0] and s[1], s = \"abc\""
        ],
        "constrains": "1 <= s.length <= 10^5\n0 <= pairs.length <= 10^5\n0 <= pairs[i][0], pairs[i][1] <\u00a0s.length\ns\u00a0only contains lower case English letters.",
        "oracle_code": "class Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
        "level": "medium",
        "type": [
            "indentation error",
            "parentheses mismatch"
        ],
        "buggy_code": "\nclass Solution:\n    def union(self, a, b):\n    self.parent[self.find(a)] = self.find(b)\n        \n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        self.parent = list(range(len(s)))\n\n        for a, b in pairs:\n            self.union(a, b)\n\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort(\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)\n"
    },
    {
        "slug": "smallest-string-with-swaps",
        "description": "You are given a string s, and an array of pairs of indices in the string\u00a0pairs\u00a0where\u00a0pairs[i] =\u00a0[a, b]\u00a0indicates 2 indices(0-indexed) of the string.\nYou can\u00a0swap the characters at any pair of indices in the given\u00a0pairs\u00a0any number of times.\nReturn the\u00a0lexicographically smallest string that s\u00a0can be changed to after using the swaps.",
        "examples": [
            "Input: s = \"dcab\", pairs = [[0,3],[1,2]]\nOutput: \"bacd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[1] and s[2], s = \"bacd\"",
            "Input: s = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\nOutput: \"abcd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[0] and s[2], s = \"acbd\"\nSwap s[1] and s[2], s = \"abcd\"",
            "Input: s = \"cba\", pairs = [[0,1],[1,2]]\nOutput: \"abc\"\nExplaination: \nSwap s[0] and s[1], s = \"bca\"\nSwap s[1] and s[2], s = \"bac\"\nSwap s[0] and s[1], s = \"abc\""
        ],
        "constrains": "1 <= s.length <= 10^5\n0 <= pairs.length <= 10^5\n0 <= pairs[i][0], pairs[i][1] <\u00a0s.length\ns\u00a0only contains lower case English letters.",
        "oracle_code": "class Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
        "level": "medium",
        "type": [
            "indentation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def union(self, a, b):\n    self.parent[self.find(a)] = self.find(b)\n        \n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        # 1. Union-Find\n        self.parent = list(range('len(s')))\n        for a, b in pairs:\n            self.union(a, b)\n\n        # 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n        # 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)\n"
    },
    {
        "slug": "smallest-string-with-swaps",
        "description": "You are given a string s, and an array of pairs of indices in the string\u00a0pairs\u00a0where\u00a0pairs[i] =\u00a0[a, b]\u00a0indicates 2 indices(0-indexed) of the string.\nYou can\u00a0swap the characters at any pair of indices in the given\u00a0pairs\u00a0any number of times.\nReturn the\u00a0lexicographically smallest string that s\u00a0can be changed to after using the swaps.",
        "examples": [
            "Input: s = \"dcab\", pairs = [[0,3],[1,2]]\nOutput: \"bacd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[1] and s[2], s = \"bacd\"",
            "Input: s = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\nOutput: \"abcd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[0] and s[2], s = \"acbd\"\nSwap s[1] and s[2], s = \"abcd\"",
            "Input: s = \"cba\", pairs = [[0,1],[1,2]]\nOutput: \"abc\"\nExplaination: \nSwap s[0] and s[1], s = \"bca\"\nSwap s[1] and s[2], s = \"bac\"\nSwap s[0] and s[1], s = \"abc\""
        ],
        "constrains": "1 <= s.length <= 10^5\n0 <= pairs.length <= 10^5\n0 <= pairs[i][0], pairs[i][1] <\u00a0s.length\ns\u00a0only contains lower case English letters.",
        "oracle_code": "class Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
        "level": "medium",
        "type": [
            "parentheses mismatch",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n        \n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n                self.parent = list(range('len(s')))\n\n        for a, b in pairs:\n            self.union(a, b)\n        \n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n                res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort(\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)\n"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
        "examples": [
            "Input: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
            "Input: n = 1, k = 1\nOutput: 1"
        ],
        "constrains": "1 <= k <= n <= 109",
        "oracle_code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 0\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x\n"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
        "examples": [
            "Input: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
            "Input: n = 1, k = 1\nOutput: 1"
        ],
        "constrains": "1 <= k <= n <= 109",
        "oracle_code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
        "level": "hard",
        "type": [
            "variable value error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"Return node counts in denary trie.\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 0\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x\n"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
        "examples": [
            "Input: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
            "Input: n = 1, k = 1\nOutput: 1"
        ],
        "constrains": "1 <= k <= n <= 109",
        "oracle_code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int\n        \n        def fn(x): \n            \"Return node counts in denary trie.\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "colon missing"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].remove()\n    return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].remove()\n    return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "undefined methods",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].remove()\n    return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "indexing error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "colon missing",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n    idx[d].popleft()\n    return True\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "type": [
            "indexing error",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d + 1]: return False\n    idx[d].popleft()\n    return True\n"
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        ],
        "constrains": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "== and = confusion"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j:\n            if(i=n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)\n"
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        ],
        "constrains": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "type": [
            "parentheses mismatch",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j:\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)\n"
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        ],
        "constrains": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "type": [
            "== and = confusion",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i=n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)\n"
    },
    {
        "slug": "the-kth-factor-of-n",
        "description": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.",
        "examples": [
            "Input: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.",
            "Input: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.",
            "Input: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1."
        ],
        "constrains": "1 <= k <= n <= 1000",
        "oracle_code": "class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k else -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to iterate through all positive integers from 1 to `n` and check if they are factors of `n`. The code aims to find the `kth` factor of `n`, where `k` is a given positive integer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a simple iterative approach to find the `kth` factor of `n`. It initializes a variable `j` to keep track of the number of factors found. For each integer `i` from 1 to `n`, it checks if `i` is a factor of n by verifying if `n % i == 0`. If `i` is indeed a factor, it increments `j` and updates the variable `num` with the value of `i`.\\n\\n- The loop continues until `j` becomes equal to k or until all integers from 1 to n have been considered. If `j` becomes equal to `k`, it breaks out of the loop. At the end of the loop, if `j` is equal to `k`, it returns the value of `num`; otherwise, it returns `-1` to indicate that there is no `kth` factor.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthFactor(self, n: int, k: int) -> int:\\n        j = 0\\n        for i in range(1, n + 1):\\n            if n % i == 0:\\n                num = i\\n                j += 1\\n            if j == k:\\n                break\\n        return num if j == k else -1\\n```",
        "level": "medium",
        "type": [
            "wrong comment mark",
            "conditional statement error"
        ],
        "buggy_code": "\nclass Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            num = i\n            if n % i == 0:\n                j += 1\n                \"if j == k:\"\n                break\n        return num if j == k+1 else -1\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "undefined methods",
            "operation error"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-2)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else UndefinedFunc(ans[:-1]+'z')    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "undefined methods",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n            return chr(ord(s[0])-1)*(len(s))              \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                break\n        return ans+s[ct2:] if change else UndefinedFunc(ans[:-1]+'z')    \n\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "undefined methods",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n        #    return chr(ord(s[0])-1)*(len(s))             \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                break\n        return ans+s[ct2:] if change else UndefinedFunc(ans[:-1]+'z')    \n\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "operation error",
            "unclosed string"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n            return chr(ord(s[0])-1)*(len(s))              \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-2)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    \n\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "operation error",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n        #    return chr(ord(s[0])-1)*(len(s))             \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-2)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    \n\n"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "type": [
            "unclosed string",
            "wrong comment mark"
        ],
        "buggy_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != \"{'a'}\": \n        #    return chr(ord(s[0])-1)*(len(s))             \n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       \n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               \n                continue\n            else:\n                ans+=cha                                  \n                if change:                                \n                    contiguous = False\n            if not contiguous:                            \n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    \n"
    }
]