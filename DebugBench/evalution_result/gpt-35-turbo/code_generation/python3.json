[
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constrains": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
        "release_time": 1670688279,
        "oracle_code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans",
        "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n = len(nums1)\n        cost = 0\n        diff = [(nums1[i] - nums2[i], i) for i in range(n)]\n        diff.sort()\n        \n        for i in range(n):\n            if diff[i][0] > 0:\n                break\n            cost -= diff[i][0]\n        \n        return cost if sum(nums1) != sum(nums2) else -1\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 37404000,
            "question_id": "2592",
            "elapsed_time": 977,
            "compare_result": "00100001100000100110000000010000000000000000000000000000000000000000000011000000000000000000000000000000",
            "code_output": "-1",
            "std_output": "",
            "last_testcase": "[1,2,3,4,5]\n[1,2,3,4,5]",
            "expected_output": "10",
            "task_finish_time": 1699922231735,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 9,
            "total_testcases": 104,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098274972",
            "input_formatted": "[1,2,3,4,5], [1,2,3,4,5]",
            "input": "[1,2,3,4,5]\n[1,2,3,4,5]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "binary-search",
        "description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4",
            "Input: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1"
        ],
        "constrains": "1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order.",
        "release_time": 1680309400,
        "oracle_code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return -1\\n        \\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n        \\n```\\nOne-liner in python:\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums, target) if target in nums else -1\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            elif nums[mid] < target:\n                left = mid + 1\n            \n            else:\n                right = mid - 1\n        \n        return -1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "213 ms",
            "memory": 17808000,
            "question_id": "792",
            "elapsed_time": 229,
            "compare_result": "11111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922246125,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 47,
            "total_testcases": 47,
            "runtime_percentile": 61.703399999999974,
            "status_memory": "17.8 MB",
            "memory_percentile": 33.7685,
            "pretty_lang": "Python3",
            "submission_id": "1098275062",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
        "release_time": 1670732887,
        "oracle_code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        # Initialize the answer\n        ans = 0\n        \n        # Loop until grid becomes empty\n        while grid:\n            # Delete the greatest value in each row\n            deleted = [max(row) for row in grid]\n            \n            # Add the maximum of deleted elements to the answer\n            ans += max(deleted)\n            \n            # Update the grid by removing the greatest value from each row\n            grid = [[x for x in row if x != max(row)] for row in grid]\n            \n            # Remove the empty rows from the grid\n            grid = [row for row in grid if row]\n        \n        return ans\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16360000,
            "question_id": "2585",
            "elapsed_time": 433,
            "compare_result": "0110111010000000000000000000000000000000000000000010001",
            "code_output": "7",
            "std_output": "",
            "last_testcase": "[[1,2,4],[3,3,1]]",
            "expected_output": "8",
            "task_finish_time": 1699922261167,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 55,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098275152",
            "input_formatted": "[[1,2,4],[3,3,1]]",
            "input": "[[1,2,4],[3,3,1]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-product-of-splitted-binary-tree",
        "description": "Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.",
        "examples": [
            "Input: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)",
            "Input: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5 * 104].\n1 <= Node.val <= 104",
        "release_time": 1670642810,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef tsum(root):\n    if(root==None):\n        return 0\n    x= root.val+tsum(root.left)+tsum(root.right)\n    return x\ndef fun(root,sm,mx):\n    if(root==None):\n        return 0\n    a=fun(root.left,sm,mx)\n    b=fun(root.right,sm,mx)\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\n    return a+b+root.val\n    \nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        mx=[0]\n        sm=tsum(root)\n        memo={}\n        fun(root,sm,mx)\n        return mx[0]%(10**9+7)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef tsum(root):\\n    if(root==None):\\n        return 0\\n    x= root.val+tsum(root.left)+tsum(root.right)\\n    return x\\ndef fun(root,sm,mx):\\n    if(root==None):\\n        return 0\\n    a=fun(root.left,sm,mx)\\n    b=fun(root.right,sm,mx)\\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\\n    return a+b+root.val\\n    \\nclass Solution:\\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\\n        mx=[0]\\n        sm=tsum(root)\\n        memo={}\\n        fun(root,sm,mx)\\n        return mx[0]%(10**9+7)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def tsum(self, root):\n        def fun(root, sm, mx):\n            if root is None:\n                return 0\n            left_sum = fun(root.left, sm, mx)\n            right_sum = fun(root.right, sm, mx)\n            total_sum = left_sum + root.val + right_sum\n            sm.append(total_sum)\n            return total_sum\n\n        sm = []\n        total_sum = fun(root, sm, mx)\n        max_prod = 0\n        \n        for s in sm:\n            product = s * (total_sum - s)\n            max_prod = max(max_prod, product)\n        \n        return max_prod % (10**9 + 7)\n\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        return self.tsum(root)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 14: NameError: name 'mx' is not defined. Did you mean: 'max'?",
            "full_runtime_error": "NameError: name 'mx' is not defined. Did you mean: 'max'?\n    total_sum = fun(root, sm, mx)\nLine 14 in tsum (Solution.py)\n    return self.tsum(root)\nLine 24 in maxProduct (Solution.py)\n    ret = Solution().maxProduct(param_1)\nLine 44 in _driver (Solution.py)\n    _driver()\nLine 55 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16288000,
            "question_id": "1465",
            "elapsed_time": 56,
            "compare_result": "000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[1,2,3,4,5,6]",
            "expected_output": "110",
            "task_finish_time": 1699922275848,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 54,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098275236",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-performance-of-a-team",
        "description": "You are given two integers n and k and two integer arrays speed and efficiency both of length n. There are n engineers numbered from 1 to n. speed[i] and efficiency[i] represent the speed and efficiency of the ith engineer respectively.\nChoose at most k different engineers out of the n engineers to form a team with the maximum performance.\nThe performance of a team is the sum of their engineers' speeds multiplied by the minimum efficiency among their engineers.\nReturn the maximum performance of this team. Since the answer can be a huge number, return it modulo 109 + 7.",
        "examples": [
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 2\nOutput: 60\nExplanation: \nWe have the maximum performance of the team by selecting engineer 2 (with speed=10 and efficiency=4) and engineer 5 (with speed=5 and efficiency=7). That is, performance = (10 + 5) * min(4, 7) = 60.",
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 3\nOutput: 68\nExplanation:\nThis is the same example as the first but k = 3. We can select engineer 1, engineer 2 and engineer 5 to get the maximum performance of the team. That is, performance = (2 + 10 + 5) * min(5, 4, 7) = 68.",
            "Input: n = 6, speed = [2,10,3,1,5,8], efficiency = [5,4,3,9,7,2], k = 4\nOutput: 72"
        ],
        "constrains": "1 <= k <= n <= 105\nspeed.length == n\nefficiency.length == n\n1 <= speed[i] <= 105\n1 <= efficiency[i] <= 108",
        "release_time": 1691737203,
        "oracle_code": "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        top_k_speeds = []\n        res, top_k_sum = 0, 0\n\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\n        for e, s in sorted(pairs, reverse = True):\n            heapq.heappush(top_k_speeds, s)\n            top_k_sum += s\n\n            if len(top_k_speeds) > k:\n                top_k_sum -= heapq.heappop(top_k_speeds)\n\n            res = max(res, e * top_k_sum)\n        \n        return res % MOD",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each any given efficiency $e_i$, the optimal performance we can get with $e_i$ as the minimum efficiency is $e_i$ times the sum of the largest $k$ speeds $s_j$ where $e_j \\\\ge e_i$ (ensuring that $e_i$ is the minimum efficiency). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe should find this optimal performance for every efficiency in the array and return our global maximum. An $O(n^2)$solution won\\'t work due to our constraints, so we need to optimize somehow.\\n\\nIf we sort efficiencies and speed pairs in reverse order, when we iterate through, at any index $i$ we know $e_i$ is the minimum efficiency, and $s_0, s_1, ..., s_i$ are the available speeds that we can select $k$ speeds from.\\n\\nWe can maintain the top $k$ elements and sum using a multiset (`SortedList` in Python) or a heap, however, a multiset typically has worse overhead and heap has average $O(1)$ insertion. \\n\\nA similar problem uses this same method: https://leetcode.com/problems/kth-largest-element-in-a-stream/\\n\\n# Complexity\\nTime and space complexity are dominated by the sorting of the list. \\n\\nTime complexity: $O(n\\\\log{n})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        top_k_speeds = []\\n        res, top_k_sum = 0, 0\\n\\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\\n        for e, s in sorted(pairs, reverse = True):\\n            heapq.heappush(top_k_speeds, s)\\n            top_k_sum += s\\n\\n            if len(top_k_speeds) > k:\\n                top_k_sum -= heapq.heappop(top_k_speeds)\\n\\n            res = max(res, e * top_k_sum)\\n        \\n        return res % MOD\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        # Create a list of tuples to store the speed and efficiency of each engineer\n        engineers = zip(speed, efficiency)\n        # Sort the engineers based on their efficiency in descending order\n        engineers = sorted(engineers, key=lambda x: x[1], reverse=True)\n        \n        # Initialize the variables to store the maximum performance and the sum of speeds\n        max_performance = 0\n        speed_sum = 0\n        \n        # Create a min heap to store the speeds of the selected engineers\n        speed_heap = []\n        \n        for curr_speed, curr_efficiency in engineers:\n            # Add the current engineer's speed to the sum of speeds\n            speed_sum += curr_speed\n            \n            # Push the current engineer's speed to the heap\n            heapq.heappush(speed_heap, curr_speed)\n            \n            # If the number of selected engineers exceeds k, remove the engineer with the minimum speed\n            if len(speed_heap) > k:\n                speed_sum -= heapq.heappop(speed_heap)\n            \n            # Calculate the current performance as the product of the sum of speeds and the current efficiency\n            current_performance = speed_sum * curr_efficiency\n            \n            # Update the maximum performance if the current performance is greater\n            max_performance = max(max_performance, current_performance)\n        \n        # Return the maximum performance modulo 10^9 + 7\n        return max_performance % (10**9 + 7)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "313 ms",
            "memory": 32808000,
            "question_id": "1499",
            "elapsed_time": 330,
            "compare_result": "1111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922291172,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 55,
            "total_testcases": 55,
            "runtime_percentile": 75.48690000000002,
            "status_memory": "32.8 MB",
            "memory_percentile": 48.189200000000014,
            "pretty_lang": "Python3",
            "submission_id": "1098275323",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "description": "Given a n-ary tree, find its maximum depth.\nThe maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.\nNary-Tree input serialization is represented in their level order traversal, each group of children is separated by the null value (See examples).",
        "examples": [
            "Input: root = [1,null,3,2,4,null,5,6]\nOutput: 3",
            "Input: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]\nOutput: 5"
        ],
        "constrains": "The total number of nodes is in the range [0, 104].\nThe depth of the n-ary tree is less than or equal to 1000.",
        "release_time": 1665143377,
        "oracle_code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```",
        "level": "easy",
        "completed_code": "\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if not root:\n            return 0\n        max_depth = 0\n        for child in root.children:\n            max_depth = max(max_depth, self.maxDepth(child))\n        return max_depth + 1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 18520000,
            "question_id": "774",
            "elapsed_time": 66,
            "compare_result": "11111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922306034,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 38,
            "total_testcases": 38,
            "runtime_percentile": 94.35339999999998,
            "status_memory": "18.5 MB",
            "memory_percentile": 10.928899999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098275418",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.",
        "examples": [
            "Input: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.",
            "Input: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.",
            "Input: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0."
        ],
        "constrains": "1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104",
        "release_time": 1688875218,
        "oracle_code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        maxProfit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                maxProfit += prices[i] - prices[i-1]\n        return maxProfit\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "58 ms",
            "memory": 17864000,
            "question_id": "122",
            "elapsed_time": 78,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922321526,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 200,
            "total_testcases": 200,
            "runtime_percentile": 88.4463,
            "status_memory": "17.9 MB",
            "memory_percentile": 7.0886,
            "pretty_lang": "Python3",
            "submission_id": "1098275529",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constrains": "0 <= n <= 30",
        "release_time": 1687050164,
        "oracle_code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if n == 0:\n                return 0\n            elif n == 1:\n                return 1\n            else:\n                return fib(n-1) + fib(n-2)\n        \n        return fib(n)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "536 ms",
            "memory": 16252000,
            "question_id": "1013",
            "elapsed_time": 553,
            "compare_result": "1111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922336835,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 31,
            "total_testcases": 31,
            "runtime_percentile": 20.709600000000123,
            "status_memory": "16.3 MB",
            "memory_percentile": 28.541600000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098275630",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25",
        "release_time": 1672085022,
        "oracle_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        if not root:\n            return \"\"\n        \n        def isLeaf(node):\n            return not node.left and not node.right\n        \n        def traverse(path, node):\n            if not node:\n                return \"\"\n            \n            path.append(chr(node.val + ord('a')))\n            \n            if isLeaf(node):\n                return \"\".join(reversed(path))\n            \n            left_path = traverse(path, node.left)\n            right_path = traverse(path, node.right)\n            \n            path.pop()\n            \n            if left_path == \"\" or (right_path != \"\" and right_path < left_path):\n                return right_path\n            else:\n                return left_path\n        \n        return traverse([], root)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17908000,
            "question_id": "1030",
            "elapsed_time": 144,
            "compare_result": "1000111010001010001001000100000000100000001000000000000000000000001111",
            "code_output": "\"adbbz\"",
            "std_output": "",
            "last_testcase": "[25,1,3,1,3,0,2]",
            "expected_output": "\"adz\"",
            "task_finish_time": 1699922351243,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 70,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098275729",
            "input_formatted": "[25,1,3,1,3,0,2]",
            "input": "[25,1,3,1,3,0,2]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "make-k-subarray-sums-equal",
        "description": "You are given a 0-indexed integer array arr and an integer k. The array arr is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\nYou can do the following operation any number of times:\n\nPick any element from arr and increase or decrease it by 1.\n\nReturn the minimum number of operations such that the sum of each subarray of length k is equal.\nA subarray is a contiguous part of the array.",
        "examples": [
            "Input: arr = [1,4,1,3], k = 2\nOutput: 1\nExplanation: we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is [1,3,1,3]\n- Subarray starts at index 0 is [1, 3], and its sum is 4 \n- Subarray starts at index 1 is [3, 1], and its sum is 4 \n- Subarray starts at index 2 is [1, 3], and its sum is 4 \n- Subarray starts at index 3 is [3, 1], and its sum is 4",
            "Input: arr = [2,5,5,7], k = 3\nOutput: 5\nExplanation: we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is [5,5,5,5]\n- Subarray starts at index 0 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 1 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 2 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 3 is [5, 5, 5], and its sum is 15"
        ],
        "constrains": "1 <= k <= arr.length <= 105\n1 <= arr[i] <= 109",
        "release_time": 1680365297,
        "oracle_code": "class Solution:\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\n        lA = len(A)\n        g = gcd(lA, K)\n        retV = 0\n        for i in range(g):\n            med = int(median(A[i::g]))\n            retV += sum(abs(a-med) for a in A[i::g])\n            \n        return retV",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\n        n = len(A)\n        prefix_sum = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            prefix_sum[i] = prefix_sum[i-1] + A[i-1]\n        \n        min_operations = float('inf')\n        \n        for start in range(n):\n            target_sum = prefix_sum[start] + K\n            \n            for end in range(start + K - 1, n):\n                curr_sum = prefix_sum[end + 1] - prefix_sum[start]\n                operations = abs(curr_sum - target_sum)\n                min_operations = min(min_operations, operations)\n        \n        return min_operations\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "description": "You are given two positive integer arrays nums and numsDivide. You can delete any number of elements from nums.\nReturn the minimum number of deletions such that the smallest element in nums divides all the elements of numsDivide. If this is not possible, return -1.\nNote that an integer x divides y if y % x == 0.",
        "examples": [
            "Input: nums = [2,3,2,4,3], numsDivide = [9,6,9,3,15]\nOutput: 2\nExplanation: \nThe smallest element in [2,3,2,4,3] is 2, which does not divide all the elements of numsDivide.\nWe use 2 deletions to delete the elements in nums that are equal to 2 which makes nums = [3,4,3].\nThe smallest element in [3,4,3] is 3, which divides all the elements of numsDivide.\nIt can be shown that 2 is the minimum number of deletions needed.",
            "Input: nums = [4,3,6], numsDivide = [8,2,6,10]\nOutput: -1\nExplanation: \nWe want the smallest element in nums to divide all the elements of numsDivide.\nThere is no way to delete elements from nums to allow this."
        ],
        "constrains": "1 <= nums.length, numsDivide.length <= 105\n1 <= nums[i], numsDivide[i] <= 109",
        "release_time": 1672922632,
        "oracle_code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        min_num = min(nums)\n        count = 0\n        for num in numsDivide:\n            if num % min_num != 0:\n                return -1\n            count += num // min_num - 1\n        return count\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 28456000,
            "question_id": "2423",
            "elapsed_time": 732,
            "compare_result": "0101100100001000000000010000000100010111101011101",
            "code_output": "-1",
            "std_output": "",
            "last_testcase": "[2,3,2,4,3]\n[9,6,9,3,15]",
            "expected_output": "2",
            "task_finish_time": 1699922381985,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 17,
            "total_testcases": 49,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098275930",
            "input_formatted": "[2,3,2,4,3], [9,6,9,3,15]",
            "input": "[2,3,2,4,3]\n[9,6,9,3,15]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-substring-with-at-least-k-repeating-characters",
        "description": "Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\nif no such substring exists, return 0.",
        "examples": [
            "Input: s = \"aaabb\", k = 3\nOutput: 3\nExplanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.",
            "Input: s = \"ababbc\", k = 2\nOutput: 5\nExplanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times."
        ],
        "constrains": "1 <= s.length <= 104\ns consists of only lowercase English letters.\n1 <= k <= 105",
        "release_time": 1689559880,
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        x=self.recursion(s,k)\n        if x>=k:\n            return x\n        else:\n            \n            return 0\n\n    def recursion(self,s,k):\n        if len(s)<=1 :\n            return len(s)\n        flag=True\n        for i in range(len(s)):\n            if s.count(s[i])<k:\n                flag=False\n                break\n            \n        if flag:\n            return len(s)\n        left=(self.recursion(s[:i],k))\n        right=(self.recursion(s[i+1:],k))\n        if left>right:\n            return (left)\n        return (right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve this problem by dividing the list at the point that has frequency less thn \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestSubstring(self, s: str, k: int) -> int:\\n        x=self.recursion(s,k)\\n        if x>=k:\\n            return x\\n        else:\\n            \\n            return 0\\n\\n    def recursion(self,s,k):\\n        if len(s)<=1 :\\n            return len(s)\\n        flag=True\\n        for i in range(len(s)):\\n            if s.count(s[i])<k:\\n                flag=False\\n                break\\n            \\n        if flag:\\n            return len(s)\\n        left=(self.recursion(s[:i],k))\\n        right=(self.recursion(s[i+1:],k))\\n        if left>right:\\n            return (left)\\n        return (right)\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        # helper function for recursion\n        def recursion(s, k):\n            # base case: if length of string is less than k, return 0\n            if len(s) < k:\n                return 0\n            \n            # count the frequencies of each character in the string\n            freq = {}\n            for char in s:\n                if char not in freq:\n                    freq[char] = 1\n                else:\n                    freq[char] += 1\n            \n            # check if all characters have frequency greater than or equal to k\n            all_chars_valid = True\n            for char in freq:\n                if freq[char] < k:\n                    all_chars_valid = False\n                    break\n            \n            # if all characters have frequency greater than or equal to k, return the length of string\n            if all_chars_valid:\n                return len(s)\n            \n            # find the split points in the string\n            split_points = [0]\n            for i in range(len(s)):\n                if freq[s[i]] < k:\n                    split_points.append(i)\n            \n            split_points.append(len(s))\n            \n            # recursively find the length of longest substring for each split point\n            max_length = 0\n            for i in range(1, len(split_points)):\n                start = split_points[i-1]\n                end = split_points[i]\n                max_length = max(max_length, recursion(s[start:end], k))\n            \n            return max_length\n        \n        # call recursion function with initial string and k\n        return recursion(s, k)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 12,
            "lang": "python3",
            "run_success": false,
            "status_runtime": "N/A",
            "memory": 851336000,
            "question_id": "395",
            "elapsed_time": 2450,
            "compare_result": "11111110000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "\"bbaaacbd\"\n3",
            "expected_output": "3",
            "task_finish_time": 1699922402328,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 7,
            "total_testcases": 38,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098276062",
            "status_msg": "Memory Limit Exceeded",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-positive-integer-solution-for-a-given-equation",
        "description": "Given a callable function f(x, y) with a hidden formula and a value z, reverse engineer the formula and return all positive integer pairs x and y where f(x,y) == z. You may return the pairs in any order.\nWhile the exact formula is hidden, the function is monotonically increasing, i.e.:\n\nf(x, y) < f(x + 1, y)\nf(x, y) < f(x, y + 1)\n\nThe function interface is defined like this:\n\ninterface CustomFunction {\npublic:\n  // Returns some positive integer f(x, y) for two positive integers x and y based on a formula.\n  int f(int x, int y);\n};\n\nWe will judge your solution as follows:\n\nThe judge has a list of 9 hidden implementations of CustomFunction, along with a way to generate an answer key of all valid pairs for a specific z.\nThe judge will receive two inputs: a function_id (to determine which implementation to test your code with), and the target z.\nThe judge will call your findSolution and compare your results with the answer key.\nIf your results match the answer key, your solution will be Accepted.",
        "examples": [
            "Input: function_id = 1, z = 5\nOutput: [[1,4],[2,3],[3,2],[4,1]]\nExplanation: The hidden formula for function_id = 1 is f(x, y) = x + y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=4 -> f(1, 4) = 1 + 4 = 5.\nx=2, y=3 -> f(2, 3) = 2 + 3 = 5.\nx=3, y=2 -> f(3, 2) = 3 + 2 = 5.\nx=4, y=1 -> f(4, 1) = 4 + 1 = 5.",
            "Input: function_id = 2, z = 5\nOutput: [[1,5],[5,1]]\nExplanation: The hidden formula for function_id = 2 is f(x, y) = x * y.\nThe following positive integer values of x and y make f(x, y) equal to 5:\nx=1, y=5 -> f(1, 5) = 1 * 5 = 5.\nx=5, y=1 -> f(5, 1) = 5 * 1 = 5."
        ],
        "constrains": "1 <= function_id <= 9\n1 <= z <= 100\nIt is guaranteed that the solutions of f(x, y) == z will be in the range 1 <= x, y <= 1000.\nIt is also guaranteed that f(x, y) will fit in 32 bit signed integer if 1 <= x, y <= 1000.",
        "release_time": 1665119482,
        "oracle_code": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\n\nclass Solution:\n    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n        ans=[]\n        y=1000\n        for x in range(1,1001):\n            while y>1 and customfunction.f(x,y)>z:\n                y-=1\n            if customfunction.f(x,y)==z:\n                ans.append([x,y])\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(X+Y)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(X)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n   This is the custom function interface.\\n   You should not implement it, or speculate about its implementation\\n   class CustomFunction:\\n       # Returns f(x, y) for any given positive integers x and y.\\n       # Note that f(x, y) is increasing with respect to both x and y.\\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\\n       def f(self, x, y):\\n  \\n\"\"\"\\n\\nclass Solution:\\n    def findSolution(self, customfunction: \\'CustomFunction\\', z: int) -> List[List[int]]:\\n        ans=[]\\n        y=1000\\n        for x in range(1,1001):\\n            while y>1 and customfunction.f(x,y)>z:\\n                y-=1\\n            if customfunction.f(x,y)==z:\\n                ans.append([x,y])\\n        return ans\\n        \\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n        result = []\n        x, y = 1, z\n        \n        while x <= z and y >= 1:\n            if customfunction.f(x, y) == z:\n                result.append([x, y])\n                x += 1\n            elif customfunction.f(x, y) < z:\n                x += 1\n            else:\n                y -= 1\n        \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "39 ms",
            "memory": 16384000,
            "question_id": "1358",
            "elapsed_time": 56,
            "compare_result": "111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922414988,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 45,
            "total_testcases": 45,
            "runtime_percentile": 87.5002,
            "status_memory": "16.4 MB",
            "memory_percentile": 23.437499999999993,
            "pretty_lang": "Python3",
            "submission_id": "1098276153",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "description": "You are given a string s consisting of lowercase English letters, and you are allowed to perform operations on it. In one operation, you can replace a character in s with another lowercase English letter.\nYour task is to make s a palindrome with the minimum number of operations possible. If there are multiple palindromes that can be made using the minimum number of operations, make the lexicographically smallest one.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b.\nReturn the resulting palindrome string.",
        "examples": [
            "Input: s = \"egcfe\"\nOutput: \"efcfe\"\nExplanation: The minimum number of operations to make \"egcfe\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"efcfe\", by changing 'g'.",
            "Input: s = \"abcd\"\nOutput: \"abba\"\nExplanation: The minimum number of operations to make \"abcd\" a palindrome is 2, and the lexicographically smallest palindrome string we can get by modifying two characters is \"abba\".",
            "Input: s = \"seven\"\nOutput: \"neven\"\nExplanation: The minimum number of operations to make \"seven\" a palindrome is 1, and the lexicographically smallest palindrome string we can get by modifying one character is \"neven\"."
        ],
        "constrains": "1 <= s.length <= 1000\ns\u00a0consists of only lowercase English letters.",
        "release_time": 1684850284,
        "oracle_code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        s_list = list(s)\n        i = 0\n        j = len(s_list) - 1\n        \n        while i < j:\n            if s_list[i] != s_list[j]:\n                if s_list[i] > s_list[j]:\n                    s_list[i] = s_list[j]\n                else:\n                    s_list[j] = s_list[i]\n            i += 1\n            j -= 1\n        \n        return ''.join(s_list)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "126 ms",
            "memory": 16416000,
            "question_id": "2816",
            "elapsed_time": 145,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922430088,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4519,
            "total_testcases": 4519,
            "runtime_percentile": 70.50779999999997,
            "status_memory": "16.4 MB",
            "memory_percentile": 28.906200000000005,
            "pretty_lang": "Python3",
            "submission_id": "1098276245",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reachable-nodes-with-restrictions",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1 and n - 1 edges.\nYou are given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an integer array restricted which represents restricted nodes.\nReturn the maximum number of nodes you can reach from node 0 without visiting a restricted node.\nNote that node 0 will not be a restricted node.",
        "examples": [
            "Input: n = 7, edges = [[0,1],[1,2],[3,1],[4,0],[0,5],[5,6]], restricted = [4,5]\nOutput: 4\nExplanation: The diagram above shows the tree.\nWe have that [0,1,2,3] are the only nodes that can be reached from node 0 without visiting a restricted node.",
            "Input: n = 7, edges = [[0,1],[0,2],[0,5],[0,4],[3,2],[6,5]], restricted = [4,2,1]\nOutput: 3\nExplanation: The diagram above shows the tree.\nWe have that [0,5,6] are the only nodes that can be reached from node 0 without visiting a restricted node."
        ],
        "constrains": "2 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nedges represents a valid tree.\n1 <= restricted.length < n\n1 <= restricted[i] < n\nAll the values of restricted are unique.",
        "release_time": 1682443628,
        "oracle_code": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        adj_list = defaultdict(list)\n        for x,y in edges:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n    \n        que = deque()\n        que.append(0)\n        result = 0\n        visited = set()\n        for node in restricted:\n            visited.add(node)\n\n        while que:\n            cur = que.popleft()\n            if cur in visited:\n                continue    \n            visited.add(cur)\n            result += 1\n            for node in adj_list[cur]:\n                que.append(node)\n        \n        return result",
        "content": "# Intuition\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        adj_list = defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n    \\n        que = deque()\\n        que.append(0)\\n        result = 0\\n        visited = set()\\n        for node in restricted:\\n            visited.add(node)\\n\\n        while que:\\n            cur = que.popleft()\\n            if cur in visited:\\n                continue    \\n            visited.add(cur)\\n            result += 1\\n            for node in adj_list[cur]:\\n                que.append(node)\\n        \\n        return result\\n\\n\\n\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        # Create adjacency list to represent the tree\n        adj_list = [[] for _ in range(n)]\n        for u, v in edges:\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Create a set to store the restricted nodes\n        restricted_nodes = set(restricted)\n        \n        # Create a visited set to track the visited nodes\n        visited = set()\n        \n        # DFS function to traverse the tree\n        def dfs(node):\n            # Add the node to visited set\n            visited.add(node)\n            \n            # Initialize the count of reachable nodes\n            reachable_count = 1\n            \n            # Explore the neighbors of the current node\n            for neighbor in adj_list[node]:\n                # Check if the neighbor is restricted or already visited\n                if neighbor not in visited and neighbor not in restricted_nodes:\n                    # Recursively explore the neighbor\n                    reachable_count += dfs(neighbor)\n            \n            return reachable_count\n        \n        # Call the DFS function starting from node 0\n        return dfs(0)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1505 ms",
            "memory": 135360000,
            "question_id": "2445",
            "elapsed_time": 1613,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922448161,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 62,
            "total_testcases": 62,
            "runtime_percentile": 17.567100000000153,
            "status_memory": "135.4 MB",
            "memory_percentile": 58.88189999999997,
            "pretty_lang": "Python3",
            "submission_id": "1098276348",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.",
        "examples": [
            "Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\nOutput: true\nExplanation: As 'h' comes before 'l' in this language, then the sequence is sorted.",
            "Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\nOutput: false\nExplanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.",
            "Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: false\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '\u2205', where '\u2205' is defined as the blank character which is less than any other character (More info)."
        ],
        "constrains": "1 <= words.length <= 100\n1 <= words[i].length <= 20\norder.length == 26\nAll characters in words[i] and order are English lowercase letters.",
        "release_time": 1675353365,
        "oracle_code": "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        mapper = {chr(i):-1 for i in range(97,97+26)}\n        def map_value():\n            nonlocal order\n            nonlocal mapper\n            for i in range(len(order)):\n                mapper[order[i]] = i\n        map_value()\n        def helper():\n            for i in range(len(words)-1):\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\n                    return False\n                else:\n                    for j in range(min(len(words[i]), len(words[i+1]))):\n                        if words[i][j] != words[i+1][j]:\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\n                                return False\n                            break\n            return True\n        return helper()",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In lexicographically ordered dictionary we don\\'t have any words less in value after greater.\\n- So we don\\'t need to traverse $$words$$ array $$n^2$$ times just check it for $$n$$ times.\\n- if $$current word[i]$$ is greater in size of $$currentword[i+1]$$ and  next word is having less value according to orders then return false\\n- else check for every word pair in one iteration from i=0 to i=n-1\\n- because for $$nth$$ word we will check at $$n-1\\'th$$ tearm\\n- proceed further till we match in pair of $$words[i]$$ and $$words[i+1]$$\\n- when not matched check $$current$$ $$alphabet$$ $$order$$ in $$words[i]$$ and $$words[i+1]$$\\n- if it\\'s not according to given order then return false\\n- else at last return true\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapper = {chr(i):-1 for i in range(97,97+26)}\\n        def map_value():\\n            nonlocal order\\n            nonlocal mapper\\n            for i in range(len(order)):\\n                mapper[order[i]] = i\\n        map_value()\\n        def helper():\\n            for i in range(len(words)-1):\\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\\n                    return False\\n                else:\\n                    for j in range(min(len(words[i]), len(words[i+1]))):\\n                        if words[i][j] != words[i+1][j]:\\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\\n                                return False\\n                            break\\n            return True\\n        return helper()\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        mapper = {} # dictionary to map each character to its corresponding order in the alien language\n        for i, char in enumerate(order):\n            mapper[char] = i\n            \n        # helper function to compare two words based on the alien language order\n        def compare_words(word1, word2):\n            i = 0\n            while i < min(len(word1), len(word2)):\n                if mapper[word1[i]] < mapper[word2[i]]:\n                    return True\n                elif mapper[word1[i]] > mapper[word2[i]]:\n                    return False\n                else:\n                    i += 1\n                    \n            # if both words have exactly same characters till now, then the longer word comes later\n            return len(word1) <= len(word2)\n        \n        # check if given words are sorted lexicographically in alien language\n        for i in range(1, len(words)):\n            if not compare_words(words[i-1], words[i]):\n                return False\n            \n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "46 ms",
            "memory": 16460000,
            "question_id": "990",
            "elapsed_time": 58,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922461720,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 125,
            "total_testcases": 125,
            "runtime_percentile": 46.93189999999999,
            "status_memory": "16.5 MB",
            "memory_percentile": 25.717000000000013,
            "pretty_lang": "Python3",
            "submission_id": "1098276450",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "description": "You are given an integer array deck where deck[i] represents the number written on the ith card.\nPartition the cards into one or more groups such that:\n\nEach group has exactly x cards where x > 1, and\nAll the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.",
        "examples": [
            "Input: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].",
            "Input: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition."
        ],
        "constrains": "1 <= deck.length <= 104\n0 <= deck[i] < 104",
        "release_time": 1669647083,
        "oracle_code": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 2:\n            return True \n        else:\n            return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        count = collections.Counter(deck)\\n        val = count.values()\\n        import math\\n        m = math.gcd(*val)\\n        if m >= 2:\\n            return True \\n        else:\\n            return False\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        from collections import Counter\n        \n        # Count the occurrences of each number in the deck\n        counts = Counter(deck)\n        \n        # Find the gcd of all the counts\n        gcd = counts[deck[0]]\n        for count in counts.values():\n            gcd = math.gcd(gcd, count)\n        \n        # If gcd is greater than 1, return True. Otherwise, return False\n        return gcd > 1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "125 ms",
            "memory": 16676000,
            "question_id": "950",
            "elapsed_time": 138,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922476730,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 75,
            "total_testcases": 75,
            "runtime_percentile": 53.506599999999985,
            "status_memory": "16.7 MB",
            "memory_percentile": 6.1039000000000065,
            "pretty_lang": "Python3",
            "submission_id": "1098276564",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "course-schedule",
        "description": "There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\n\nReturn true if you can finish all courses. Otherwise, return false.",
        "examples": [
            "Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.",
            "Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
        ],
        "constrains": "1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.",
        "release_time": 1689214588,
        "oracle_code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True",
        "content": "# Video solution\\n\\nhttps://youtu.be/-Me_If-_jRs\\n\\n\\u25A0 Please subscribe to my channel from here. I have more than 200 Leetcode videos.\\nhttps://www.youtube.com/@KeetCodeExAmazon\\n\\n---\\n\\n# Approach\\n\\n1. Create a class named `Solution` (assuming it is part of a larger program).\\n2. Define a method within the `Solution` class called `canFinish` that takes in two parameters: `numCourses` (an integer representing the total number of courses) and `prerequisites` (a list of lists representing the prerequisites for each course).\\n3. Create an empty dictionary called `pre` using the `defaultdict` class from the `collections` module. This dictionary will store the prerequisites for each course.\\n4. Iterate over each pair `(course, p)` in the `prerequisites` list:\\n   a. Append `p` to the list of prerequisites for the course `course` in the `pre` dictionary.\\n5. Create an empty set called `taken`. This set will keep track of the courses that have been visited during the depth-first search (DFS) traversal.\\n6. Define an inner function called `dfs` that takes in a parameter `course`. This function will perform the DFS traversal to check if the course can be finished.\\n7. If the list of prerequisites for the current `course` is empty (i.e., there are no remaining prerequisites), return `True` since the course can be finished.\\n8. If the `course` is already present in the `taken` set, return `False` since there is a cycle in the course dependencies.\\n9. Add the `course` to the `taken` set to mark it as visited.\\n10. Iterate over each prerequisite `p` for the current `course` in the `pre` dictionary:\\n    a. If the DFS traversal returns `False` for any prerequisite `p`, return `False` since the course cannot be finished.\\n11. Set the list of prerequisites for the current `course` in the `pre` dictionary to an empty list, indicating that all the prerequisites have been satisfied.\\n12. Return `True` at the end of the `dfs` function since all the prerequisites for the `course` have been satisfied.\\n13. Iterate over each `course` in the range from 0 to `numCourses` (exclusive) using a `for` loop.\\n14. If the DFS traversal of the current `course` returns `False`, it means the course cannot be finished, so return `False` from the `canFinish` method.\\n15. If the loop completes without returning `False`, it means all the courses can be finished, so return `True` from the `canFinish` method.\\n\\nIn summary, the algorithm performs a depth-first search to check if it is possible to finish all the courses given their prerequisites. It uses a dictionary to store the prerequisites for each course and a set to keep track of the visited courses during the traversal. If there is a cycle in the course dependencies or if any course cannot be finished, it returns `False`; otherwise, it returns `True`.\\n\\n# Python\\n```\\nclass Solution:\\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\\n\\n        pre = defaultdict(list)\\n\\n        for course, p in prerequisites:\\n            pre[course].append(p)\\n        \\n        taken = set()\\n\\n        def dfs(course):\\n            if not pre[course]:\\n                return True\\n            \\n            if course in taken:\\n                return False\\n            \\n            taken.add(course)\\n\\n            for p in pre[course]:\\n                if not dfs(p): return False\\n            \\n            pre[course] = []\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course):\\n                return False\\n\\n        return True\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        def dfs(course):\n            if visited[course] == 1:\n                return False\n            if visited[course] == -1:\n                return True\n            \n            visited[course] = 1\n            \n            for pre in graph[course]:\n                if not dfs(pre):\n                    return False\n                \n            visited[course] = -1\n            return True\n        \n        graph = [[] for _ in range(numCourses)]\n        visited = [0 for _ in range(numCourses)]\n        \n        for cur, pre in prerequisites:\n            graph[cur].append(pre)\n            \n        for i in range(numCourses):\n            if not dfs(i):\n                return False\n            \n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "104 ms",
            "memory": 19164000,
            "question_id": "207",
            "elapsed_time": 114,
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922491753,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 52,
            "total_testcases": 52,
            "runtime_percentile": 30.056499999999982,
            "status_memory": "19.2 MB",
            "memory_percentile": 39.9102,
            "pretty_lang": "Python3",
            "submission_id": "1098276661",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "grid-game",
        "description": "You are given a 0-indexed 2D array grid of size 2 x n, where grid[r][c] represents the number of points at position (r, c) on the matrix. Two robots are playing a game on this matrix.\nBoth robots initially start at (0, 0) and want to reach (1, n-1). Each robot may only move to the right ((r, c) to (r, c + 1)) or down ((r, c) to (r + 1, c)).\nAt the start of the game, the first robot moves from (0, 0) to (1, n-1), collecting all the points from the cells on its path. For all cells (r, c) traversed on the path, grid[r][c] is set to 0. Then, the second robot moves from (0, 0) to (1, n-1), collecting the points on its path. Note that their paths may intersect with one another.\nThe first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return the number of points collected by the second robot.",
        "examples": [
            "Input: grid = [[2,5,4],[1,5,1]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 0 + 4 + 0 = 4 points.",
            "Input: grid = [[3,3,1],[8,5,2]]\nOutput: 4\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 3 + 1 + 0 = 4 points.",
            "Input: grid = [[1,3,1,15],[1,3,3,1]]\nOutput: 7\nExplanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.\nThe cells visited by the first robot are set to 0.\nThe second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points."
        ],
        "constrains": "grid.length == 2\nn == grid[r].length\n1 <= n <= 5 * 104\n1 <= grid[r][c] <= 105",
        "release_time": 1687022285,
        "oracle_code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        n = len(grid[0])\n        prefix_sum = [[0] * (n+1) for _ in range(2)]\n        \n        # Calculate prefix sum for both robots\n        for r in range(2):\n            for c in range(1, n+1):\n                prefix_sum[r][c] = prefix_sum[r][c-1] + grid[r][c-1]\n        \n        result = float('inf')\n        for i in range(1, n+1):\n            # Calculate the maximum points for the second robot\n            max_points = max(prefix_sum[0][n] - prefix_sum[0][i], prefix_sum[1][i-1])\n            result = min(result, max_points)\n        \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1012 ms",
            "memory": 32768000,
            "question_id": "2145",
            "elapsed_time": 1038,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922508027,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 109,
            "total_testcases": 109,
            "runtime_percentile": 11.777500000000076,
            "status_memory": "32.8 MB",
            "memory_percentile": 53.832000000000036,
            "pretty_lang": "Python3",
            "submission_id": "1098276747",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sum-of-subarray-minimums",
        "description": "Given an array of integers arr, find the sum of min(b), where b ranges over every (contiguous) subarray of arr. Since the answer may be large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: arr = [3,1,2,4]\nOutput: 17\nExplanation: \nSubarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. \nMinimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.\nSum is 17.",
            "Input: arr = [11,81,94,43,3]\nOutput: 444"
        ],
        "constrains": "1 <= arr.length <= 3 * 104\n1 <= arr[i] <= 3 * 104",
        "release_time": 1669419936,
        "oracle_code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        modulo = 10**9 + 7\n        stack = []\n        res = 0\n        arr = [0] + arr + [0]\n        \n        for i in range(len(arr)):\n            while stack and arr[i] < arr[stack[-1]]:\n                idx = stack.pop()\n                res += arr[idx] * (i - idx) * (idx - stack[-1]) % modulo\n            stack.append(i)\n        \n        return res % modulo\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "374 ms",
            "memory": 20924000,
            "question_id": "943",
            "elapsed_time": 415,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922522315,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 87,
            "total_testcases": 87,
            "runtime_percentile": 78.11720000000003,
            "status_memory": "20.9 MB",
            "memory_percentile": 37.53179999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098276863",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "redundant-connection",
        "description": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.",
        "examples": [
            "Input: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]",
            "Input: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]"
        ],
        "constrains": "n == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ai < bi <= edges.length\nai != bi\nThere are no repeated edges.\nThe given graph is connected.",
        "release_time": 1680183186,
        "oracle_code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        parent = [i for i in range(len(edges)+1)]\n        rank = [1]* (len(edges)+1)\n\n        def find(n):\n            temp = parent[n]\n            while temp!=parent[temp]:\n                temp=parent[temp]\n            return temp\n        \n        def union(n1,n2):\n            p1 , p2 = find(n1),find(n2)\n\n            if p1 == p2:\n                return False\n            \n            if rank[p1] > rank[p2]:\n                parent[p2] = p1\n                rank[p1]+=rank[p2]\n            else: \n                parent[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n        \n        for i,j in edges:\n            if not union(i,j):\n                return [i,j]",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\\n        parent = [i for i in range(len(edges)+1)]\\n        rank = [1]* (len(edges)+1)\\n\\n        def find(n):\\n            temp = parent[n]\\n            while temp!=parent[temp]:\\n                temp=parent[temp]\\n            return temp\\n        \\n        def union(n1,n2):\\n            p1 , p2 = find(n1),find(n2)\\n\\n            if p1 == p2:\\n                return False\\n            \\n            if rank[p1] > rank[p2]:\\n                parent[p2] = p1\\n                rank[p1]+=rank[p2]\\n            else: \\n                parent[p1] = p2\\n                rank[p2] += rank[p1]\\n            return True\\n        \\n        for i,j in edges:\\n            if not union(i,j):\\n                return [i,j]\\n\\n\\n\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        def find(n):\n            if parent[n] != n:\n                parent[n] = find(parent[n])\n            return parent[n]\n        \n        def union(n1, n2):\n            parent[find(n1)] = find(n2)\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        \n        for edge in edges:\n            n1, n2 = edge[0], edge[1]\n            if find(n1) == find(n2):\n                return edge\n            union(n1, n2)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "62 ms",
            "memory": 16928000,
            "question_id": "684",
            "elapsed_time": 74,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922536915,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 49.59549999999998,
            "status_memory": "16.9 MB",
            "memory_percentile": 25.855000000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098276951",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "release_time": 1677611169,
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        count=0\n        n=str(n)\n        for i in range(len(n)):\n            if i%2==0:\n                count+=int(n[i])\n            else:\n                count-=int(n[i])\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        count=0\\n        n=str(n)\\n        for i in range(len(n)):\\n            if i%2==0:\\n                count+=int(n[i])\\n            else:\\n                count-=int(n[i])\\n        return count\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        # convert the integer to a string\n        n_str = str(n)\n        \n        # initialize the sum variable\n        total_sum = 0\n        \n        # initialize the sign variable\n        sign = 1\n        \n        # iterate through each digit in the string\n        for i in range(len(n_str)):\n            # convert the digit back to an integer\n            digit = int(n_str[i])\n            \n            # calculate the sum with the current sign\n            total_sum += sign * digit\n            \n            # update the sign for the next digit\n            sign *= -1\n        \n        return total_sum\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16196000,
            "question_id": "2630",
            "elapsed_time": 87,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922552035,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 118,
            "total_testcases": 118,
            "runtime_percentile": 24.175900000000013,
            "status_memory": "16.2 MB",
            "memory_percentile": 61.1389,
            "pretty_lang": "Python3",
            "submission_id": "1098277063",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constrains": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "release_time": 1689502465,
        "oracle_code": "class Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        for i in words:\n            if i==i[::-1]:\n                return i\n        return \"\"",
        "content": "# Code\\n```\\nclass Solution:\\n    def firstPalindrome(self, words: List[str]) -> str:\\n        for i in words:\\n            if i==i[::-1]:\\n                return i\\n        return \"\"\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        for word in words:\n            if word == word[::-1]:\n                return word\n        return \"\"\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "89 ms",
            "memory": 16388000,
            "question_id": "2231",
            "elapsed_time": 100,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922567033,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 266,
            "total_testcases": 266,
            "runtime_percentile": 35.46999999999997,
            "status_memory": "16.4 MB",
            "memory_percentile": 53.76480000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098277174",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-words-obtained-after-adding-a-letter",
        "description": "You are given two 0-indexed arrays of strings startWords and targetWords. Each string consists of lowercase English letters only.\nFor each string in targetWords, check if it is possible to choose a string from startWords and perform a conversion operation on it to be equal to that from targetWords.\nThe conversion operation is described in the following two steps:\n\nAppend any lowercase letter that is not present in the string to its end.\n\n\t\nFor example, if the string is \"abc\", the letters 'd', 'e', or 'y' can be added to it, but not 'a'. If 'd' is added, the resulting string will be \"abcd\".\n\n\nRearrange the letters of the new string in any arbitrary order.\n\t\nFor example, \"abcd\" can be rearranged to \"acbd\", \"bacd\", \"cbda\", and so on. Note that it can also be rearranged to \"abcd\" itself.\n\n\n\nReturn the number of strings in targetWords that can be obtained by performing the operations on any string of startWords.\nNote that you will only be verifying if the string in targetWords can be obtained from a string in startWords by performing the operations. The strings in startWords do not actually change during this process.",
        "examples": [
            "Input: startWords = [\"ant\",\"act\",\"tack\"], targetWords = [\"tack\",\"act\",\"acti\"]\nOutput: 2\nExplanation:\n- In order to form targetWords[0] = \"tack\", we use startWords[1] = \"act\", append 'k' to it, and rearrange \"actk\" to \"tack\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"act\".\n  Note that \"act\" does exist in startWords, but we must append one letter to the string before rearranging it.\n- In order to form targetWords[2] = \"acti\", we use startWords[1] = \"act\", append 'i' to it, and rearrange \"acti\" to \"acti\" itself.",
            "Input: startWords = [\"ab\",\"a\"], targetWords = [\"abc\",\"abcd\"]\nOutput: 1\nExplanation:\n- In order to form targetWords[0] = \"abc\", we use startWords[0] = \"ab\", add 'c' to it, and rearrange it to \"abc\".\n- There is no string in startWords that can be used to obtain targetWords[1] = \"abcd\"."
        ],
        "constrains": "1 <= startWords.length, targetWords.length <= 5 * 104\n1 <= startWords[i].length, targetWords[j].length <= 26\nEach string of startWords and targetWords consists of lowercase English letters only.\nNo letter occurs more than once in any string of startWords or targetWords.",
        "release_time": 1641700880,
        "oracle_code": "class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) in seen: \n                    ans += 1\n                    break \n        return ans",
        "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set()\\n        for word in startWords: \\n            m = 0\\n            for ch in word: m ^= 1 << ord(ch)-97\\n            seen.add(m)\\n            \\n        ans = 0 \\n        for word in targetWords: \\n            m = 0 \\n            for ch in word: m ^= 1 << ord(ch)-97\\n            for ch in word: \\n                if m ^ (1 << ord(ch)-97) in seen: \\n                    ans += 1\\n                    break \\n        return ans \\n```",
        "level": "medium",
        "completed_code": "\nfrom typing import List\n\nclass Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        count = 0\n        \n        for target in targetWords:\n            for start in startWords:\n                temp = start[:]\n                for letter in target:\n                    if letter not in temp:\n                        temp += letter\n                if sorted(temp) == sorted(target):\n                    count += 1\n                    break\n        \n        return count\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "invalid-transactions",
        "description": "A transaction is possibly invalid if:\n\nthe amount exceeds $1000, or;\nif it occurs within (and including) 60 minutes of another transaction with the same name in a different city.\n\nYou are given an array of strings transaction where transactions[i] consists of comma-separated values representing the name, time (in minutes), amount, and city of the transaction.\nReturn a list of transactions that are possibly invalid. You may return the answer in any order.",
        "examples": [
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nOutput: [\"alice,20,800,mtv\",\"alice,50,100,beijing\"]\nExplanation: The first transaction is invalid because the second transaction occurs within a difference of 60 minutes, have the same name and is in a different city. Similarly the second one is invalid too.",
            "Input: transactions = [\"alice,20,800,mtv\",\"alice,50,1200,mtv\"]\nOutput: [\"alice,50,1200,mtv\"]",
            "Input: transactions = [\"alice,20,800,mtv\",\"bob,50,1200,mtv\"]\nOutput: [\"bob,50,1200,mtv\"]"
        ],
        "constrains": "transactions.length <= 1000\nEach transactions[i] takes the form \"{name},{time},{amount},{city}\"\nEach {name} and {city} consist of lowercase English letters, and have lengths between 1 and 10.\nEach {time} consist of digits, and represent an integer between 0 and 1000.\nEach {amount} consist of digits, and represent an integer between 0 and 2000.",
        "release_time": 1667938900,
        "oracle_code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        for i in range(len(transactions)):\n            name, time, amount, city = transactions[i].split(',')\n            time = int(time)\n            amount = int(amount)\n            if amount > 1000:\n                invalid.append(transactions[i])\n            for j in range(len(transactions)):\n                if i != j:\n                    other_name, other_time, other_amount, other_city = transactions[j].split(',')\n                    other_time = int(other_time)\n                    if name == other_name and abs(time - other_time) <= 60 and city != other_city:\n                        invalid.append(transactions[i])\n                        break\n        return invalid\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16728000,
            "question_id": "1272",
            "elapsed_time": 184,
            "compare_result": "1111101001110101010110000000000000001",
            "code_output": "[\"alice,20,800,mtv\",\"bob,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,1200,mtv\",\"alice,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,100,beijing\"]",
            "std_output": "",
            "last_testcase": "[\"alice,20,800,mtv\",\"bob,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,100,beijing\"]",
            "expected_output": "[\"alice,20,800,mtv\",\"bob,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,100,beijing\"]",
            "task_finish_time": 1699922597273,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 15,
            "total_testcases": 37,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098277364",
            "input_formatted": "[\"alice,20,800,mtv\",\"bob,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,100,beijing\"]",
            "input": "[\"alice,20,800,mtv\",\"bob,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,1200,mtv\",\"alice,20,800,mtv\",\"alice,50,100,beijing\"]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "string-compression-ii",
        "description": "Run-length encoding is a string compression method that works by\u00a0replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string\u00a0\"aabccc\"\u00a0we replace \"aa\"\u00a0by\u00a0\"a2\"\u00a0and replace \"ccc\"\u00a0by\u00a0\"c3\". Thus the compressed string becomes \"a2bc3\".\nNotice that in this problem, we are not adding\u00a0'1'\u00a0after single characters.\nGiven a\u00a0string s\u00a0and an integer k. You need to delete at most\u00a0k characters from\u00a0s\u00a0such that the run-length encoded version of s\u00a0has minimum length.\nFind the minimum length of the run-length encoded\u00a0version of s after deleting at most k characters.",
        "examples": [
            "Input: s = \"aaabcccd\", k = 2\nOutput: 4\nExplanation: Compressing s without deleting anything will give us \"a3bc3d\" of length 6. Deleting any of the characters 'a' or 'c' would at most decrease the length of the compressed string to 5, for instance delete 2 'a' then we will have s = \"abcccd\" which compressed is abc3d. Therefore, the optimal way is to delete 'b' and 'd', then the compressed version of s will be \"a3c3\" of length 4.",
            "Input: s = \"aabbaa\", k = 2\nOutput: 2\nExplanation: If we delete both 'b' characters, the resulting compressed string would be \"a4\" of length 2.",
            "Input: s = \"aaaaaaaaaaa\", k = 0\nOutput: 3\nExplanation: Since k is zero, we cannot delete anything. The compressed string is \"a11\" of length 3."
        ],
        "constrains": "1 <= s.length <= 100\n0 <= k <= s.length\ns contains only lowercase English letters.",
        "release_time": 1684779092,
        "oracle_code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def dp(self, i, s, prev, k, ct, n, dct):\n        if i == n:\n            if ct == 1:\n                return 1\n            return 1 + len(str(ct))\n        if k < 0:\n            return float('inf')\n        if (i, prev, k, ct) in dct:\n            return dct[(i, prev, k, ct)]\n        if s[i] == prev:\n            keep = self.dp(i + 1, s, prev, k, ct + 1, n, dct)\n            delete = self.dp(i + 1, s, prev, k - 1, ct, n, dct)\n            dct[(i, prev, k, ct)] = min(keep, delete)\n        else:\n            keep = 1 + self.dp(i + 1, s, s[i], k, 1, n, dct)\n            delete = self.dp(i + 1, s, prev, k - 1, ct, n, dct)\n            dct[(i, prev, k, ct)] = min(keep, delete)\n        return dct[(i, prev, k, ct)]\n    \n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n = len(s)\n        dct = {}\n        return self.dp(0, s, '', k, 0, n, dct)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 38540000,
            "question_id": "1637",
            "elapsed_time": 2290,
            "compare_result": "100001111011111000010100100011001100000000001001000000000000100010000000000010110011000100000000000000000000000000000000000000000000000000010000",
            "code_output": "3",
            "std_output": "",
            "last_testcase": "\"aabbaa\"\n2",
            "expected_output": "2",
            "task_finish_time": 1699922616174,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 28,
            "total_testcases": 144,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098277465",
            "input_formatted": "\"aabbaa\", 2",
            "input": "\"aabbaa\"\n2",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sum-of-subarray-ranges",
        "description": "You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\nReturn the sum of all subarray ranges of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.",
            "Input: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.",
            "Input: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59."
        ],
        "constrains": "1 <= nums.length <= 1000\n-109 <= nums[i] <= 109\n\n\u00a0\nFollow-up: Could you find a solution with O(n) time complexity?",
        "release_time": 1639283898,
        "oracle_code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        def fn(op):\n            if op == 'min':\n                return min(nums)\n            elif op == 'max':\n                return max(nums)\n            else:\n                return 0\n\n        subarray_ranges = 0\n        for i in range(len(nums)):\n            for j in range(i, len(nums)):\n                subarray = nums[i:j+1]\n                subarray_ranges += fn('max') - fn('min')\n\n        return subarray_ranges\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "ransom-note",
        "description": "Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.",
        "examples": [
            "Input: ransomNote = \"a\", magazine = \"b\"\nOutput: false",
            "Input: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false",
            "Input: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true"
        ],
        "constrains": "1 <= ransomNote.length, magazine.length <= 105\nransomNote and magazine consist of lowercase English letters.",
        "release_time": 1688389692,
        "oracle_code": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ransomNote = list(ransomNote)\n        magazine = list(magazine)\n        for char in ransomNote:\n            if char in magazine:\n                magazine.remove(char)\n            else:\n                return False\n        return True",
        "content": "# Intuition\\nThe intuition behind the given code is to check if we can construct the ransomNote string using the letters from the magazine string, while adhering to the constraint that each letter in magazine can only be used once.\\n\\nThe code accomplishes this by using two for loops to traverse the ransomNote and magazine strings.\\n\\n# Approach\\nIn the first loop, we iterate over each character in the ransomNote string. For each character, we check if it is present in the magazine string. If the character is found, it means we can use it to construct the ransomNote, so we remove that character from the magazine string by calling magazine.remove(char).\\n\\nIf a character in ransomNote is not found in magazine, it means we cannot construct the ransomNote using the available characters, so we immediately return False.\\n\\nAfter iterating over all characters in ransomNote, if we have successfully removed each character from the magazine string, it means we can construct the ransomNote using the letters from magazine, while satisfying the constraint that each letter in magazine can only be used once. In this case, we return True.\\n\\nThe approach of converting the strings to lists allows us to manipulate the magazine string by removing characters as they are used, effectively ensuring that each letter in magazine is used only once.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n+m)\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        ransomNote = list(ransomNote)\\n        magazine = list(magazine)\\n        for char in ransomNote:\\n            if char in magazine:\\n                magazine.remove(char)\\n            else:\\n                return False\\n        return True\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        # Convert the strings to lists\n        ransom_list = list(ransomNote)\n        magazine_list = list(magazine)\n        \n        for letter in ransom_list:\n            \n            # Check if the letter is in magazine_list\n            if letter in magazine_list:\n                \n                # Remove the letter from magazine_list\n                magazine_list.remove(letter)\n                \n            else:\n                # If the letter is not found, return False\n                return False\n        \n        # If all letters are found in magazine_list, return True\n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "50 ms",
            "memory": 16764000,
            "question_id": "383",
            "elapsed_time": 74,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922644077,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 128,
            "total_testcases": 128,
            "runtime_percentile": 85.22779999999997,
            "status_memory": "16.8 MB",
            "memory_percentile": 9.601600000000005,
            "pretty_lang": "Python3",
            "submission_id": "1098277680",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "max-points-on-a-line",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.",
        "examples": [
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: 3",
            "Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]\nOutput: 4"
        ],
        "constrains": "1 <= points.length <= 300\npoints[i].length == 2\n-104 <= xi, yi <= 104\nAll the points are unique.",
        "release_time": 1673194328,
        "oracle_code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```",
        "level": "hard",
        "completed_code": "\nfrom collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        if len(points) < 3:\n            return len(points)\n        \n        max_points = 1\n        \n        for i in range(len(points)):\n            slope_count = defaultdict(int)\n            duplicate = 1\n            \n            for j in range(i+1, len(points)):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                \n                if x1 == x2 and y1 == y2:\n                    duplicate += 1\n                    continue\n                \n                dx = x2 - x1\n                dy = y2 - y1\n                gcd = self.find_gcd(dy, dx)\n                \n                slope = str(dy//gcd) + \"/\" + str(dx//gcd)\n                slope_count[slope] += 1\n            \n            max_points = max(max_points, max(slope_count.values()) + duplicate)\n        \n        return max_points\n    \n    def find_gcd(self, a, b):\n        if b == 0:\n            return a\n        return self.find_gcd(b, a % b)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 29: ValueError: max() arg is an empty sequence",
            "full_runtime_error": "ValueError: max() arg is an empty sequence\n    max_points = max(max_points, max(slope_count.values()) + duplicate)\nLine 29 in maxPoints (Solution.py)\n    ret = Solution().maxPoints(param_1)\nLine 56 in _driver (Solution.py)\n    _driver()\nLine 67 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16460000,
            "question_id": "149",
            "elapsed_time": 53,
            "compare_result": "00000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[1,1],[2,2],[3,3]]",
            "expected_output": "3",
            "task_finish_time": 1699922659315,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 41,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098277793",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constrains": "1 <= n <= 1000",
        "release_time": 1691471559,
        "oracle_code": "class Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-7])\n            ans+=income;income+=1;a.append(income)      \n        return ans",
        "content": "![image.png](https://assets.leetcode.com/users/images/2f3418d9-04d9-483c-a41f-87c71b45cc76_1691471550.6305616.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def totalMoney(self, n: int) -> int:\n        total_money = 0\n        for day in range(n):\n            # calculate the week number\n            week = day // 7\n            # calculate the day number within the week\n            day_within_week = day % 7\n            # calculate the money to be added on this day\n            money = week + day_within_week + 1\n            # add the money to the total amount\n            total_money += money\n        return total_money\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "49 ms",
            "memory": 16424000,
            "question_id": "1817",
            "elapsed_time": 63,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922674064,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 106,
            "total_testcases": 106,
            "runtime_percentile": 7.330000000000015,
            "status_memory": "16.4 MB",
            "memory_percentile": 31.239100000000008,
            "pretty_lang": "Python3",
            "submission_id": "1098277873",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "description": "Given two arrays of strings list1 and list2, find the common strings with the least index sum.\nA common string is a string that appeared in both list1 and list2.\nA common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\nReturn all the common strings with the least index sum. Return the answer in any order.",
        "examples": [
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"Piatti\",\"The Grill at Torrey Pines\",\"Hungry Hunter Steakhouse\",\"Shogun\"]\nOutput: [\"Shogun\"]\nExplanation: The only common string is \"Shogun\".",
            "Input: list1 = [\"Shogun\",\"Tapioca Express\",\"Burger King\",\"KFC\"], list2 = [\"KFC\",\"Shogun\",\"Burger King\"]\nOutput: [\"Shogun\"]\nExplanation: The common string with the least index sum is \"Shogun\" with index sum = (0 + 1) = 1.",
            "Input: list1 = [\"happy\",\"sad\",\"good\"], list2 = [\"sad\",\"happy\",\"good\"]\nOutput: [\"sad\",\"happy\"]\nExplanation: There are three common strings:\n\"happy\" with index sum = (0 + 1) = 1.\n\"sad\" with index sum = (1 + 0) = 1.\n\"good\" with index sum = (2 + 2) = 4.\nThe strings with the least index sum are \"sad\" and \"happy\"."
        ],
        "constrains": "1 <= list1.length, list2.length <= 1000\n1 <= list1[i].length, list2[i].length <= 30\nlist1[i] and list2[i] consist of spaces ' ' and English letters.\nAll the strings of list1 are unique.\nAll the strings of list2 are unique.\nThere is at least a common string between list1 and list2.",
        "release_time": 1671462500,
        "oracle_code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```",
        "level": "easy",
        "completed_code": "\n### Implemented code ###\n\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        common = []\n        min_index_sum = float('inf')\n        restaurant_dict = {}\n        \n        # Build a dictionary with restaurant name as key and index as value for list1\n        for i, restaurant in enumerate(list1):\n            restaurant_dict[restaurant] = i\n        \n        # Check if restaurant name exists in list2 and calculate the sum of indices\n        for j, restaurant in enumerate(list2):\n            if restaurant in restaurant_dict:\n                index_sum = j + restaurant_dict[restaurant]\n                # Update minimum index sum and common list if a new minimum is found\n                if index_sum < min_index_sum:\n                    min_index_sum = index_sum\n                    common = [restaurant]\n                # Add to common list if index sum is equal to minimum index sum\n                elif index_sum == min_index_sum:\n                    common.append(restaurant)\n        \n        return common\n\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "150 ms",
            "memory": 16884000,
            "question_id": "599",
            "elapsed_time": 181,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922689324,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 137,
            "total_testcases": 137,
            "runtime_percentile": 94.2043,
            "status_memory": "16.9 MB",
            "memory_percentile": 21.601699999999987,
            "pretty_lang": "Python3",
            "submission_id": "1098277973",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1.\u00a0The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.",
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
        "release_time": 1690124160,
        "oracle_code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m = len(grid)\n        n = len(grid[0])\n        \n        def dfs(i: int, j: int) -> None:\n            if i == m - 1 and j == n - 1:\n                return True\n            grid[i][j] = 0\n            if i + 1 < m and grid[i + 1][j] == 1 and dfs(i + 1, j):\n                return True\n            if j + 1 < n and grid[i][j + 1] == 1 and dfs(i, j + 1):\n                return True\n            grid[i][j] = 1\n            return False\n        \n        if dfs(0, 0):\n            return True\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    grid[i][j] = 0\n                    if not dfs(0, 0):\n                        return True\n                    grid[i][j] = 1\n        \n        return False\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 22696000,
            "question_id": "2641",
            "elapsed_time": 793,
            "compare_result": "1011101011111111001111111111111111110010010101101110110",
            "code_output": "true",
            "std_output": "",
            "last_testcase": "[[1,1,1],[1,0,1],[1,1,1]]",
            "expected_output": "false",
            "task_finish_time": 1699922704937,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 55,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098278093",
            "input_formatted": "[[1,1,1],[1,0,1],[1,1,1]]",
            "input": "[[1,1,1],[1,0,1],[1,1,1]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "can-place-flowers",
        "description": "You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true\u00a0if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.",
        "examples": [
            "Input: flowerbed = [1,0,0,0,1], n = 1\nOutput: true",
            "Input: flowerbed = [1,0,0,0,1], n = 2\nOutput: false"
        ],
        "constrains": "1 <= flowerbed.length <= 2 * 104\nflowerbed[i] is 0 or 1.\nThere are no two adjacent flowers in flowerbed.\n0 <= n <= flowerbed.length",
        "release_time": 1691328348,
        "oracle_code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        length = len(flowerbed)\n        count = 0\n        i = 0\n        \n        while i < length:\n            if flowerbed[i] == 0 and (i == 0 or flowerbed[i-1] == 0) and (i == length-1 or flowerbed[i+1] == 0):\n                flowerbed[i] = 1\n                count += 1\n                if count >= n:\n                    return True\n            i += 1\n        \n        return False\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16876000,
            "question_id": "605",
            "elapsed_time": 167,
            "compare_result": "11111101111011111111111111111111111111111111110011111110110111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "[1,0,1,0,1,0,1]\n0",
            "expected_output": "true",
            "task_finish_time": 1699922719336,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 122,
            "total_testcases": 128,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098278186",
            "input_formatted": "[1,0,1,0,1,0,1], 0",
            "input": "[1,0,1,0,1,0,1]\n0",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constrains": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104",
        "release_time": 1679245385,
        "oracle_code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total_sum = sum(arr)\n        if total_sum % 3 != 0:\n            return False\n        partition_sum = total_sum // 3\n        count = 0\n        current_sum = 0\n        for num in arr:\n            current_sum += num\n            if current_sum == partition_sum:\n                count += 1\n                current_sum = 0\n        return count >= 3\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "267 ms",
            "memory": 23000000,
            "question_id": "1062",
            "elapsed_time": 285,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922734481,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 72,
            "total_testcases": 72,
            "runtime_percentile": 67.69779999999997,
            "status_memory": "23 MB",
            "memory_percentile": 66.66669999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098278287",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "description": "You are given an array of strings equations that represent relationships between variables where each string equations[i] is of length 4 and takes one of two different forms: \"xi==yi\" or \"xi!=yi\".Here, xi and yi are lowercase letters (not necessarily different) that represent one-letter variable names.\nReturn true if it is possible to assign integers to variable names so as to satisfy all the given equations, or false otherwise.",
        "examples": [
            "Input: equations = [\"a==b\",\"b!=a\"]\nOutput: false\nExplanation: If we assign say, a = 1 and b = 1, then the first equation is satisfied, but not the second.\nThere is no way to assign the variables to satisfy both equations.",
            "Input: equations = [\"b==a\",\"a==b\"]\nOutput: true\nExplanation: We could assign a = 1 and b = 1 to satisfy both equations."
        ],
        "constrains": "1 <= equations.length <= 500\nequations[i].length == 4\nequations[i][0] is a lowercase letter.\nequations[i][1] is either '=' or '!'.\nequations[i][2] is '='.\nequations[i][3] is a lowercase letter.",
        "release_time": 1672762507,
        "oracle_code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```",
        "level": "medium",
        "completed_code": "\nclass Disjoint:\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n        self.rank = [0 for i in range(n)]\n        \n    def finduPar(self, node):\n        if self.parent[node] == node:\n            return node\n        self.parent[node] = self.finduPar(self.parent[node])\n        return self.parent[node]\n        \n    def byrank(self, u, v):\n        uPar = self.finduPar(u)\n        vPar = self.finduPar(v)\n        \n        if self.rank[uPar] < self.rank[vPar]:\n            self.parent[uPar] = vPar\n        elif self.rank[uPar] > self.rank[vPar]:\n            self.parent[vPar] = uPar\n        else:\n            self.parent[vPar] = uPar\n            self.rank[uPar] += 1\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint = Disjoint(26)\n        \n        for equation in equations:\n            x = ord(equation[0]) - ord('a')\n            y = ord(equation[3]) - ord('a')\n            equal = equation[1] == '='\n            \n            if equal:\n                disjoint.byrank(x, y)\n        \n        for equation in equations:\n            x = ord(equation[0]) - ord('a')\n            y = ord(equation[3]) - ord('a')\n            notEqual = equation[1] == '!'\n            \n            if notEqual:\n                if disjoint.finduPar(x) == disjoint.finduPar(y):\n                    return False\n        \n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "59 ms",
            "memory": 16452000,
            "question_id": "1032",
            "elapsed_time": 68,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922752274,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 181,
            "total_testcases": 181,
            "runtime_percentile": 16.00610000000001,
            "status_memory": "16.5 MB",
            "memory_percentile": 48.336,
            "pretty_lang": "Python3",
            "submission_id": "1098278403",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "increasing-order-search-tree",
        "description": "Given the root of a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only one right child.",
        "examples": [
            "Input: root = [5,3,6,2,4,null,8,1,null,null,null,7,9]\nOutput: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]",
            "Input: root = [5,1,7]\nOutput: [1,null,5,null,7]"
        ],
        "constrains": "The number of nodes in the given tree will be in the range [1, 100].\n0 <= Node.val <= 1000",
        "release_time": 1676961244,
        "oracle_code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        # helper function to perform in-order traversal\n        def inorder(node):\n            nonlocal prev, new_root\n            if node:\n                inorder(node.left)\n                # if new_root is not assigned yet, assign it to the leftmost node\n                if not new_root:\n                    new_root = node\n                # update the right child of the previous node to the current node\n                if prev:\n                    prev.right = node\n                # set the left child of the current node to None\n                node.left = None\n                # update the previous node\n                prev = node\n                inorder(node.right)\n        \n        # initialize variables\n        prev = None\n        new_root = None\n        \n        # perform in-order traversal\n        inorder(root)\n        \n        return new_root\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16496000,
            "question_id": "933",
            "elapsed_time": 55,
            "compare_result": "11111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922766863,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 38,
            "total_testcases": 38,
            "runtime_percentile": 36.227000000000004,
            "status_memory": "16.5 MB",
            "memory_percentile": 5.482900000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098278503",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constrains": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "release_time": 1675543738,
        "oracle_code": "class Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n\n        return res",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def sortString(self, s: str) -> str:\n        # Create a dictionary to store the count of each character in the string\n        char_count = {}\n        for char in s:\n            char_count[char] = char_count.get(char, 0) + 1\n        \n        # Create an empty result string\n        result = \"\"\n        \n        # Initialize a flag to indicate whether we are picking the smallest or largest character\n        is_reversed = False\n        \n        # Repeat until we have picked all characters from s\n        while len(result) < len(s):\n            # If we are picking the smallest character, traverse the characters in ascending order\n            if not is_reversed:\n                # Traverse the characters in ascending order\n                for char in sorted(char_count.keys()):\n                    # If the character still has occurrences, append it to the result and decrement its count\n                    if char_count[char] > 0:\n                        result += char\n                        char_count[char] -= 1\n            \n            # If we are picking the largest character, traverse the characters in descending order\n            else:\n                # Traverse the characters in descending order\n                for char in sorted(char_count.keys(), reverse=True):\n                    # If the character still has occurrences, append it to the result and decrement its count\n                    if char_count[char] > 0:\n                        result += char\n                        char_count[char] -= 1\n            \n            # Toggle the flag to switch between picking the smallest and largest characters\n            is_reversed = not is_reversed\n        \n        # Return the sorted result string\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "65 ms",
            "memory": 16332000,
            "question_id": "1472",
            "elapsed_time": 78,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922781934,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 323,
            "total_testcases": 323,
            "runtime_percentile": 67.14279999999997,
            "status_memory": "16.3 MB",
            "memory_percentile": 47.6786,
            "pretty_lang": "Python3",
            "submission_id": "1098278609",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "koko-eating-bananas",
        "description": "Koko loves to eat bananas. There are n piles of bananas, the ith pile has piles[i] bananas. The guards have gone and will come back in h hours.\nKoko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.\nKoko likes to eat slowly but still wants to finish eating all the bananas before the guards return.\nReturn the minimum integer k such that she can eat all the bananas within h hours.",
        "examples": [
            "Input: piles = [3,6,7,11], h = 8\nOutput: 4",
            "Input: piles = [30,11,23,4,20], h = 5\nOutput: 30",
            "Input: piles = [30,11,23,4,20], h = 6\nOutput: 23"
        ],
        "constrains": "1 <= piles.length <= 104\npiles.length <= h <= 109\n1 <= piles[i] <= 109",
        "release_time": 1686109303,
        "oracle_code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in piles) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) >> 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            hours = 0\n            for pile in piles:\n                hours += (pile-1)//x + 1\n            return hours\n\n        l = 1\n        r = max(piles)\n\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid) > h:\n                l = mid + 1\n            else:\n                r = mid\n\n        return l\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "311 ms",
            "memory": 17612000,
            "question_id": "907",
            "elapsed_time": 333,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922797279,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 126,
            "total_testcases": 126,
            "runtime_percentile": 87.87300000000016,
            "status_memory": "17.6 MB",
            "memory_percentile": 97.2037,
            "pretty_lang": "Python3",
            "submission_id": "1098278724",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "split-linked-list-in-parts",
        "description": "Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\nReturn an array of the k parts.",
        "examples": [
            "Input: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].",
            "Input: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts."
        ],
        "constrains": "The number of nodes in the list is in the range [0, 1000].\n0 <= Node.val <= 1000\n1 <= k <= 50",
        "release_time": 1680676083,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n        # Step 1: Calculate the length of the linked list\n        curr = head\n        length = 0\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # Step 2: Calculate the number of nodes to include in each part\n        part_size = length // k\n        remainder = length % k\n        \n        # Step 3: Split the linked list into k parts\n        parts = []\n        curr = head\n        \n        for i in range(k):\n            part_head = curr\n            \n            # Calculate the size of the current part including the remainder\n            size = part_size + 1 if i < remainder else part_size\n            \n            # Move the curr pointer forward by size\n            for j in range(size - 1):\n                if curr:\n                    curr = curr.next\n            \n            # If curr is not None, update the next pointer and move curr to the next node\n            if curr:\n                next_node = curr.next\n                curr.next = None\n                curr = next_node\n            \n            # Add the current part to the parts array\n            parts.append(part_head)\n        \n        return parts\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "40 ms",
            "memory": 16848000,
            "question_id": "725",
            "elapsed_time": 61,
            "compare_result": "1111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922812013,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 43,
            "total_testcases": 43,
            "runtime_percentile": 78.24110000000002,
            "status_memory": "16.8 MB",
            "memory_percentile": 6.087899999999994,
            "pretty_lang": "Python3",
            "submission_id": "1098278826",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "description": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.",
        "examples": [
            "Input: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.",
            "Input: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2."
        ],
        "constrains": "1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105",
        "release_time": 1690753327,
        "oracle_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        #sliding window\n        nums.sort()\n        l, r = 0, k-1\n        res = float(\"inf\")\n        while r < len(nums):\n            res = min(res, nums[r] - nums[l])\n            r += 1\n            l += 1\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        #sliding window\\n        nums.sort()\\n        l, r = 0, k-1\\n        res = float(\"inf\")\\n        while r < len(nums):\\n            res = min(res, nums[r] - nums[l])\\n            r += 1\\n            l += 1\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        min_diff = float('inf')\n        for i in range(len(nums)-k+1):\n            min_diff = min(min_diff, nums[i+k-1] - nums[i])\n        return min_diff\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "87 ms",
            "memory": 16464000,
            "question_id": "2112",
            "elapsed_time": 117,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922827212,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 118,
            "total_testcases": 118,
            "runtime_percentile": 97.2554,
            "status_memory": "16.5 MB",
            "memory_percentile": 51.172099999999986,
            "pretty_lang": "Python3",
            "submission_id": "1098278922",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-subsequence-with-limited-sum",
        "description": "You are given an integer array nums of length n, and an integer array queries of length m.\nReturn an array answer of length m where answer[i] is the maximum size of a subsequence that you can take from nums such that the sum of its elements is less than or equal to queries[i].\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.",
        "examples": [
            "Input: nums = [4,5,2,1], queries = [3,10,21]\nOutput: [2,3,4]\nExplanation: We answer the queries as follows:\n- The subsequence [2,1] has a sum less than or equal to 3. It can be proven that 2 is the maximum size of such a subsequence, so answer[0] = 2.\n- The subsequence [4,5,1] has a sum less than or equal to 10. It can be proven that 3 is the maximum size of such a subsequence, so answer[1] = 3.\n- The subsequence [4,5,2,1] has a sum less than or equal to 21. It can be proven that 4 is the maximum size of such a subsequence, so answer[2] = 4.",
            "Input: nums = [2,3,4,5], queries = [1]\nOutput: [0]\nExplanation: The empty subsequence is the only subsequence that has a sum less than or equal to 1, so answer[0] = 0."
        ],
        "constrains": "n == nums.length\nm == queries.length\n1 <= n, m <= 1000\n1 <= nums[i], queries[i] <= 106",
        "release_time": 1671999947,
        "oracle_code": "class Solution:\n  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n    nums, sums, res, n = sorted(nums), [0], [], len(nums)+1\n    for num in nums:\n      sums.append(sums[-1] + num)\n    \n    def bSearch(q, l=0, mid=n>>1, r=n):\n      while l < mid < r:\n        if sums[mid] > q:\n          r = mid\n        elif sums[mid] < q:\n          l = mid\n        else: break\n        mid = (l+r)>>1\n      return mid\n\n    return [bSearch(q) for q in queries]",
        "content": "# Intuition\\n1. Create sums array of sorted\\n2. Search index\\n\\n# Approach\\nBinary search of each index with time complexity $$O(logN)$$\\n\\n# Complexity\\n- Time complexity:\\n  $$O(M*logN)$$\\n\\n- Space complexity:\\n  $$O(Nbi)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums, sums, res, n = sorted(nums), [0], [], len(nums)+1\\n    for num in nums:\\n      sums.append(sums[-1] + num)\\n    \\n    def bSearch(q, l=0, mid=n>>1, r=n):\\n      while l < mid < r:\\n        if sums[mid] > q:\\n          r = mid\\n        elif sums[mid] < q:\\n          l = mid\\n        else: break\\n        mid = (l+r)>>1\\n      return mid\\n\\n    return [bSearch(q) for q in queries]\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n    def bSearch(q, l=0, mid=n>>1, r=n):\n      while l < r:\n        mid = (l + r) >> 1\n        if nums[mid] <= q:\n          l = mid + 1\n        else:\n          r = mid\n      return l\n    \n    nums.sort()\n    n = len(nums)\n    return [bSearch(q) for q in queries]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 4: UnboundLocalError: local variable 'n' referenced before assignment",
            "full_runtime_error": "UnboundLocalError: local variable 'n' referenced before assignment\n    def bSearch(q, l=0, mid=n>>1, r=n):\nLine 4 in answerQueries (Solution.py)\n    ret = Solution().answerQueries(param_1, param_2)\nLine 40 in _driver (Solution.py)\n    _driver()\nLine 51 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16464000,
            "question_id": "2469",
            "elapsed_time": 52,
            "compare_result": "000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[4,5,2,1]\n[3,10,21]",
            "expected_output": "[2,3,4]",
            "task_finish_time": 1699922842205,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 57,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098279025",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "making-file-names-unique",
        "description": "Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\nSince two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\nReturn an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.",
        "examples": [
            "Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nOutput: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nExplanation: Let's see how the file system creates folder names:\n\"pes\" --> not assigned before, remains \"pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\"",
            "Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\nOutput: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\nExplanation: Let's see how the file system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\"",
            "Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\nOutput: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\nExplanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\"."
        ],
        "constrains": "1 <= names.length <= 5 * 104\n1 <= names[i].length <= 20\nnames[i] consists of lowercase English letters, digits, and/or round brackets.",
        "release_time": 1678465781,
        "oracle_code": "from typing import List\n\n\"\"\"\n1487. Making File Names Unique\n\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\n\nSince 2 files cannot have the same name,\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\n\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\n\n\nEX:\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n\nEX:\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\n\nEx:\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    if it's already in the seen dictionary,\n    append a suffix k to the name until a unique name is found.\n\n    Time: O(n^2) in the worst case where all file names are the same\n    space: O(n)\n    \"\"\"\n    def getFolderNames(self, names: List[str]) -> List[str]:\n\n        ans = []  # stores unique file names\n        seen = {}\n\n        for name in names:\n            if name not in seen:\n                ans.append(name)\n                seen[name] = 1\n            else:\n                k = seen[name]\n                # creating variants\n                while True:\n                    new_name = name + '(' + str(k) + ')'\n                    if new_name not in seen:\n                        ans.append(new_name)\n                        seen[new_name] = 1\n                        break\n                    else:\n                        k += 1\n\n                # save the latest version of variant so to avaoid above while\n                # loop calculation\n                seen[name] = k\n            \n\n        return ans",
        "content": "\\n```\\nfrom typing import List\\n\\n\"\"\"\\n1487. Making File Names Unique\\n\\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\\n\\nSince 2 files cannot have the same name,\\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\\n\\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\\n\\n\\nEX:\\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\n\\nEX:\\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\\n\\nEx:\\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\\n\"\"\"\\n\\n\\nclass Solution:\\n    \"\"\"\\n    if it\\'s already in the seen dictionary,\\n    append a suffix k to the name until a unique name is found.\\n\\n    Time: O(n^2) in the worst case where all file names are the same\\n    space: O(n)\\n    \"\"\"\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        ans = []  # stores unique file names\\n        seen = {}\\n\\n        for name in names:\\n            if name not in seen:\\n                ans.append(name)\\n                seen[name] = 1\\n            else:\\n                k = seen[name]\\n                # creating variants\\n                while True:\\n                    new_name = name + \\'(\\' + str(k) + \\')\\'\\n                    if new_name not in seen:\\n                        ans.append(new_name)\\n                        seen[new_name] = 1\\n                        break\\n                    else:\\n                        k += 1\\n\\n                # save the latest version of variant so to avaoid above while\\n                # loop calculation\\n                seen[name] = k\\n            \\n\\n        return ans\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        folder_names = {}\n        result = []\n        \n        for name in names:\n            if name not in folder_names:\n                folder_names[name] = 1\n                result.append(name)\n            else:\n                k = folder_names[name]\n                new_name = name + \"(\" + str(k) + \")\"\n                while new_name in folder_names:\n                    k += 1\n                    new_name = name + \"(\" + str(k) + \")\"\n                folder_names[name] = k + 1\n                folder_names[new_name] = 1\n                result.append(new_name)\n                \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "333 ms",
            "memory": 29600000,
            "question_id": "1611",
            "elapsed_time": 351,
            "compare_result": "111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922857480,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 33,
            "total_testcases": 33,
            "runtime_percentile": 76.07349999999998,
            "status_memory": "29.6 MB",
            "memory_percentile": 63.19,
            "pretty_lang": "Python3",
            "submission_id": "1098279122",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constrains": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.",
        "release_time": 1688138300,
        "oracle_code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        # initialize counts of red, white, and blue\n        red_count = 0\n        white_count = 0\n        blue_count = 0\n        \n        # count the occurrences of each color in the array\n        for num in nums:\n            if num == 0: # red color\n                red_count += 1\n            elif num == 1: # white color\n                white_count += 1\n            else: # blue color\n                blue_count += 1\n        \n        # update the array with sorted colors\n        for i in range(red_count):\n            nums[i] = 0 # set red color\n        \n        for i in range(red_count, red_count+white_count):\n            nums[i] = 1 # set white color\n        \n        for i in range(red_count+white_count, red_count+white_count+blue_count):\n            nums[i] = 2 # set blue color\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 16440000,
            "question_id": "75",
            "elapsed_time": 60,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922872246,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 87,
            "total_testcases": 87,
            "runtime_percentile": 55.47130000000005,
            "status_memory": "16.4 MB",
            "memory_percentile": 7.1634999999999955,
            "pretty_lang": "Python3",
            "submission_id": "1098279225",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "release_time": 1673526978,
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        l = []\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                l.append(\"FizzBuzz\")\\n\\n            elif i%3!=0 and i%5!=0:\\n                l.append(str(i))\\n            elif i%3==0:\\n                l.append(\"Fizz\")\\n            elif i%5==0:\\n                l.append(\"Buzz\")\\n            \\n        return l\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        result = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            else:\n                result.append(str(i))\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "38 ms",
            "memory": 17404000,
            "question_id": "412",
            "elapsed_time": 63,
            "compare_result": "11111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922887463,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 8,
            "runtime_percentile": 96.69129999999998,
            "status_memory": "17.4 MB",
            "memory_percentile": 31.985300000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098279333",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1690819672,
        "oracle_code": "class Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        # make a mapping of deque lists called indexes \n        indexes = collections.defaultdict(collections.deque)\n        # enumerate s \n        for index, character in enumerate(s) :\n            # indexes at the int cast of character has this index added to it  \n            indexes[int(character)].append(index)\n\n        # get unique values in t \n        unique_t_values = set([int(t_i) for t_i in t])\n        # for t_v in unique t values \n        for t_v in unique_t_values : \n            # if not in indexes \n            if t_v not in indexes :\n                # return False as we are missing pieces  \n                return False \n        \n        # loop over t in order given  \n        for character in t : \n            # get the characters integer designation \n            character_designation = int(character)\n            # update may cause new misses which may prevent future searches \n            if character_designation not in indexes : \n                return False \n            # for index in range up to character designation \n            for lesser_character in range(character_designation) : \n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    # our lists are not transformable, False \n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \n                    # this is detailed in the problem statement where they note that values must be in ascending order \n                    return False \n            # after consideration using this most recent index, remove it \n            indexes[character_designation].popleft()\n            # if length is now zero, remove it \n            if len(indexes[character_designation]) == 0 : \n                indexes.pop(character_designation)\n        \n        # if all characters able to sort, return it \n        return True",
        "content": "# Intuition\\nFaced with any substring sorting problems, I\\'m drawn to maps and graphs for ease of search space. As such, we can consider this one with not too much of a stretch of the mind. \\n\\nEach integer value in our selected string has a list of indices at which it appears. IF we make a mapping of these list of indices for each value in order of appearance in s, we can use that against the ordering of appearance of list of values in t (we do not necessarily need to make said list of t, but could if we so chose) \\n\\nOnce we have this map, our first bet is to actually get the set of unique items in t, which can be done rather nicely with generators that will do the autoskip inclusions as needed. \\n\\nUsing unique t, our first check is that all of the unique t values are present. If not, then we can skip to returning False. \\n\\nOtherwise, we need to loop over t, and for each character check if it is in our map. If not, also False. \\n\\nIf we then loop over values up to this point (such that if we drew say 5 we\\'d go from 0 to 4 inclusive) we need to find that the value is in indexes and that the indexes at that point has a starting value at least as advanced or more so than the indexes for the drawn values first appearance. If this does not occur, then they are not in ascending order and may also return False. \\n\\nIf all of that passes, we need to discard the current item at the front of indexes at the drawn character. If in doing so we now eliminate that list, we need to eliminate the character drawn from indices entirely (this is why we have that second check for inclusion near the top). \\n\\nIf we manage all of that, there\\'s nothing to stop the transformation and can return True. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse collections default dict with collections deque for each character valuation in s \\n\\nMake a map of the character values -> list of indices of occurrence in order from first to last \\n\\nMake a set of unique t values \\n\\n- For each unique t value in unique t values \\n    - if that value is not in our mapping \\n        - return False \\n\\nLoop over t (effectively getting the unique indices for each value of t) \\n- as you do, convert your character into its designated key (This is here for other mapping versions of the problem) \\n- if we do not have that designated ky in our map \\n    - return false \\n- otherwise, loop over lesser character designations in range to character designation \\n    - if we have the map at lesser character designation and the map at lesser character designation points to a list whose first index of occurrence is less than the first index of occurrence of our current character designation, it must be that they are not in order, and can return False \\n- after completing lesser character loop, remove the most recent occurrence of indexes at character designation by popping left from the map at the character designation \\n- if the map now points to an empty list for character designation, remove character designation from the map entirely.    \\n\\n# Complexity\\n- Time complexity : O(S + T)\\n    - O(S) to build s mapping \\n    - O(T) to build t unique characters \\n    - O(T) to loop over characters in T \\n        - within which we do at most O(5) work to loop in range of lesser characters on average \\n    - Total then is O(S + T + ~5T) -> O(S + C * T) -> O(S + T)  \\n\\n\\n- Space complexity : O(S + t) \\n    - Store O(s) lists of size to account for S, so O(S) \\n    - Store O(t) \\n    - Remove storage for potentially all of O(S) \\n    - Averages out to O(S + t) at worst  \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool :\\n        # make a mapping of deque lists called indexes \\n        indexes = collections.defaultdict(collections.deque)\\n        # enumerate s \\n        for index, character in enumerate(s) :\\n            # indexes at the int cast of character has this index added to it  \\n            indexes[int(character)].append(index)\\n\\n        # get unique values in t \\n        unique_t_values = set([int(t_i) for t_i in t])\\n        # for t_v in unique t values \\n        for t_v in unique_t_values : \\n            # if not in indexes \\n            if t_v not in indexes :\\n                # return False as we are missing pieces  \\n                return False \\n        \\n        # loop over t in order given  \\n        for character in t : \\n            # get the characters integer designation \\n            character_designation = int(character)\\n            # update may cause new misses which may prevent future searches \\n            if character_designation not in indexes : \\n                return False \\n            # for index in range up to character designation \\n            for lesser_character in range(character_designation) : \\n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \\n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \\n                    # our lists are not transformable, False \\n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \\n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \\n                    # this is detailed in the problem statement where they note that values must be in ascending order \\n                    return False \\n            # after consideration using this most recent index, remove it \\n            indexes[character_designation].popleft()\\n            # if length is now zero, remove it \\n            if len(indexes[character_designation]) == 0 : \\n                indexes.pop(character_designation)\\n        \\n        # if all characters able to sort, return it \\n        return True \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        if sorted(s) != sorted(t):  # check if the sorted characters of s and t are the same\n            return False\n        \n        n = len(s)\n        indices = [[] for _ in range(10)]  # create empty lists for each digit from 0 to 9\n        \n        for i in range(n):  # store the indices of each digit in s\n            digit = int(s[i])\n            indices[digit].append(i)\n            \n            for j in range(digit):  # check if there are any smaller digits in t with higher indices\n                if indices[j] and indices[j][0] < i:\n                    return False\n        \n        return True  # if all conditions are satisfied, return True\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 20788000,
            "question_id": "1707",
            "elapsed_time": 189,
            "compare_result": "001101001111110100000111110000011111000001111100000111110000011111000000000000000111111111111111000000000001111111111111000011111001011111",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "\"84532\"\n\"34852\"",
            "expected_output": "true",
            "task_finish_time": 1699922902446,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 74,
            "total_testcases": 138,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098279436",
            "input_formatted": "\"84532\", \"34852\"",
            "input": "\"84532\"\n\"34852\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "description": "You are given a positive integer num. You may swap any two digits of num that have the same parity (i.e. both odd digits or both even digits).\nReturn the largest possible value of num after any number of swaps.",
        "examples": [
            "Input: num = 1234\nOutput: 3412\nExplanation: Swap the digit 3 with the digit 1, this results in the number 3214.\nSwap the digit 2 with the digit 4, this results in the number 3412.\nNote that there may be other sequences of swaps but it can be shown that 3412 is the largest possible number.\nAlso note that we may not swap the digit 4 with the digit 1 since they are of different parities.",
            "Input: num = 65875\nOutput: 87655\nExplanation: Swap the digit 8 with the digit 6, this results in the number 85675.\nSwap the first digit 5 with the digit 7, this results in the number 87655.\nNote that there may be other sequences of swaps but it can be shown that 87655 is the largest possible number."
        ],
        "constrains": "1 <= num <= 109",
        "release_time": 1672166650,
        "oracle_code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def largestInteger(self, num: int) -> int:\n        # Convert number to list of digits\n        digits = list(str(num))\n        \n        # Iterate through the digits from left to right\n        for i in range(len(digits)):\n            # For each digit, iterate through the remaining digits\n            for j in range(i+1, len(digits)):\n                # Check if both digits have the same parity (even or odd)\n                if int(digits[i]) % 2 == int(digits[j]) % 2:\n                    # Swap the digits\n                    digits[i], digits[j] = digits[j], digits[i]\n        \n        # Convert the list of digits back to an integer\n        largest_num = int(''.join(digits))\n        \n        return largest_num\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16172000,
            "question_id": "2327",
            "elapsed_time": 55,
            "compare_result": "1011111010111011011010111010111100011111000110101010000100000000000010010001010110100100000000000000000000000000000000000100000000000010000000000000001000000000000000000000000000000000000000000000000000000000000000000000001111111111111011",
            "code_output": "85675",
            "std_output": "",
            "last_testcase": "65875",
            "expected_output": "87655",
            "task_finish_time": 1699922917403,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 60,
            "total_testcases": 238,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098279534",
            "input_formatted": "65875",
            "input": "65875",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-sum-queries",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi].\nFor the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no j satisfying the constraints.\nReturn an array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\nOutput: [6,10,7]\nExplanation: \nFor the 1st query xi = 4\u00a0and\u00a0yi = 1, we can select index\u00a0j = 0\u00a0since\u00a0nums1[j] >= 4\u00a0and\u00a0nums2[j] >= 1. The sum\u00a0nums1[j] + nums2[j]\u00a0is 6, and we can show that 6 is the maximum we can obtain.\n\nFor the 2nd query xi = 1\u00a0and\u00a0yi = 3, we can select index\u00a0j = 2\u00a0since\u00a0nums1[j] >= 1\u00a0and\u00a0nums2[j] >= 3. The sum\u00a0nums1[j] + nums2[j]\u00a0is 10, and we can show that 10 is the maximum we can obtain. \n\nFor the 3rd query xi = 2\u00a0and\u00a0yi = 5, we can select index\u00a0j = 3\u00a0since\u00a0nums1[j] >= 2\u00a0and\u00a0nums2[j] >= 5. The sum\u00a0nums1[j] + nums2[j]\u00a0is 7, and we can show that 7 is the maximum we can obtain.\n\nTherefore, we return\u00a0[6,10,7].",
            "Input: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\nOutput: [9,9,9]\nExplanation: For this example, we can use index\u00a0j = 2\u00a0for all the queries since it satisfies the constraints for each query.",
            "Input: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\nOutput: [-1]\nExplanation: There is one query in this example with xi = 3 and yi = 3. For every index, j, either nums1[j] < xi or nums2[j] < yi. Hence, there is no solution."
        ],
        "constrains": "nums1.length == nums2.length\u00a0\nn ==\u00a0nums1.length\u00a0\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= 109\u00a0\n1 <= queries.length <= 105\nqueries[i].length ==\u00a02\nxi\u00a0== queries[i][1]\nyi == queries[i][2]\n1 <= xi, yi <= 109",
        "release_time": 1686457004,
        "oracle_code": "import math\nfrom typing import List\nimport bisect\n\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        def buildSparseTable(arr, n):\n            k = int(math.log2(n))\n            st = [[None for j in range(n)] for i in range(k + 1)]\n            for i in range(k + 1):\n                for j in range(n - (1 << i) + 1):\n                    if i == 0:\n                        st[i][j] = arr[j]\n                    else:\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\n            return st\n\n        def getMax(st, l, r):\n            i = int(math.log2(r - l + 1))\n            return max(st[i][l], st[i][r - (1 << i) + 1])\n\n        n = len(nums1)\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\n        max_y = [v[1] for v in a]\n        for i in range(n - 2, -1, -1):\n            max_y[i] = max(max_y[i], max_y[i + 1])\n        _sum = [v[0] + v[1] for v in a]\n        st_max_sum = buildSparseTable(_sum, n)\n        res = []\n        for x, y in queries:\n            i = bisect.bisect_left(a, [x, y])\n            if i == n or max_y[i] < y:\n                res.append(-1)\n                continue\n            left, right = i, n - 1\n            while left < right:\n                m = (left + right + 1) // 2\n                if max_y[m] >= y:\n                    left = m\n                else:\n                    right = m - 1\n            j = right\n            res.append(getMax(st_max_sum, i, j))\n        return res",
        "content": "* Approach:\\n1. Sort array (num1[i], nums2[i]), called array \\'a\\'\\n2. build max_y table max_y[i]= max(a[i][1], a[i+1][1])\\n3. build sparse table max of array [sum(a[i][0], a[i][1]) , i from 1 to n]\\n4. using binarysearch to get range i, j satisfy queries\\n5. using sparse table to get max of range\\n* Sparse table Ref:\\nhttps://cp-algorithms.com/data_structures/sparse-table.html\\n* Code\\n```\\nimport math\\nfrom typing import List\\nimport bisect\\n\\n\\nclass Solution:\\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        def buildSparseTable(arr, n):\\n            k = int(math.log2(n))\\n            st = [[None for j in range(n)] for i in range(k + 1)]\\n            for i in range(k + 1):\\n                for j in range(n - (1 << i) + 1):\\n                    if i == 0:\\n                        st[i][j] = arr[j]\\n                    else:\\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\\n            return st\\n\\n        def getMax(st, l, r):\\n            i = int(math.log2(r - l + 1))\\n            return max(st[i][l], st[i][r - (1 << i) + 1])\\n\\n        n = len(nums1)\\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\\n        max_y = [v[1] for v in a]\\n        for i in range(n - 2, -1, -1):\\n            max_y[i] = max(max_y[i], max_y[i + 1])\\n        _sum = [v[0] + v[1] for v in a]\\n        st_max_sum = buildSparseTable(_sum, n)\\n        res = []\\n        for x, y in queries:\\n            i = bisect.bisect_left(a, [x, y])\\n            if i == n or max_y[i] < y:\\n                res.append(-1)\\n                continue\\n            left, right = i, n - 1\\n            while left < right:\\n                m = (left + right + 1) // 2\\n                if max_y[m] >= y:\\n                    left = m\\n                else:\\n                    right = m - 1\\n            j = right\\n            res.append(getMax(st_max_sum, i, j))\\n        return res\\n```",
        "level": "hard",
        "completed_code": "\nimport math\nfrom typing import List\nimport bisect\n\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        def buildSparseTable(arr, n):\n            st = [[0] * (int(math.log2(n)) + 1) for _ in range(n)]\n\n            for i in range(n):\n                st[i][0] = arr[i]\n\n            j = 1\n            while (1 << j) <= n:\n                i = 0\n                while (i + (1 << j) - 1) < n:\n                    st[i][j] = max(st[i][j - 1], st[i + (1 << (j - 1))][j - 1])\n                    i += 1\n                j += 1\n\n            return st\n\n        def getMax(st, l, r):\n            j = int(math.log2(r - l + 1))\n            return max(st[l][j], st[r - (1 << j) + 1][j])\n\n        n = len(nums1)\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\n        res = []\n        st = buildSparseTable([x[1] for x in a], n)\n\n        for q in queries:\n            xi, yi = q\n            idx = bisect.bisect_left(a, [xi, yi])\n            if idx == n:\n                res.append(-1)\n            elif a[idx][0] == xi:\n                res.append(a[idx][1])\n            else:\n                res.append(getMax(st, idx, n - 1))\n\n        return res\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 68376000,
            "question_id": "2839",
            "elapsed_time": 2139,
            "compare_result": "0011110110011010000011000000000000001100110001010000000010010010100101000000000010000000000000010000000000000000000010000100000000001011000000000101000101000000000000000000000000000000000000000000000000001000000000000000000000110001000000000000000000000000000000000000000000000000000000010100100000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000011",
            "code_output": "[2,9,5]",
            "std_output": "",
            "last_testcase": "[4,3,1,2]\n[2,4,9,5]\n[[4,1],[1,3],[2,5]]",
            "expected_output": "[6,10,7]",
            "task_finish_time": 1699922938980,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 47,
            "total_testcases": 1414,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098279676",
            "input_formatted": "[4,3,1,2], [2,4,9,5], [[4,1],[1,3],[2,5]]",
            "input": "[4,3,1,2]\n[2,4,9,5]\n[[4,1],[1,3],[2,5]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"leetcode\", t = \"coats\"\nOutput: 7\nExplanation: \n- In 2 steps, we can append the letters in \"as\" onto s = \"leetcode\", forming s = \"leetcodeas\".\n- In 5 steps, we can append the letters in \"leede\" onto t = \"coats\", forming t = \"coatsleede\".\n\"leetcodeas\" and \"coatsleede\" are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.",
            "Input: s = \"night\", t = \"thing\"\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps."
        ],
        "constrains": "1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.",
        "release_time": 1674972392,
        "oracle_code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        # Create a dictionary to store the frequency of characters in both strings\n        freq_s = {}\n        freq_t = {}\n\n        # Iterate over s and increment the frequency of each character\n        for char in s:\n            if char in freq_s:\n                freq_s[char] += 1\n            else:\n                freq_s[char] = 1\n\n        # Iterate over t and increment the frequency of each character\n        for char in t:\n            if char in freq_t:\n                freq_t[char] += 1\n            else:\n                freq_t[char] = 1\n\n        # Initialize the number of steps needed to make s and t anagrams\n        steps = 0\n\n        # Iterate over the characters in freq_s and check if the same character exists in freq_t\n        # If it exists, decrease the frequency in freq_t\n        # If it doesn't exist, increase the number of steps\n        for char in freq_s:\n            if char in freq_t:\n                if freq_s[char] > freq_t[char]:\n                    steps += freq_s[char] - freq_t[char]\n            else:\n                steps += freq_s[char]\n\n        # Iterate over the characters in freq_t and check if the same character exists in freq_s\n        # If it exists, decrease the frequency in freq_s\n        # If it doesn't exist, increase the number of steps\n        for char in freq_t:\n            if char in freq_s:\n                if freq_t[char] > freq_s[char]:\n                    steps += freq_t[char] - freq_s[char]\n            else:\n                steps += freq_t[char]\n\n        return steps\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "396 ms",
            "memory": 18832000,
            "question_id": "2293",
            "elapsed_time": 409,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922953499,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 70,
            "total_testcases": 70,
            "runtime_percentile": 32.57909999999998,
            "status_memory": "18.8 MB",
            "memory_percentile": 11.935500000000012,
            "pretty_lang": "Python3",
            "submission_id": "1098279790",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constrains": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
        "release_time": 1674441057,
        "oracle_code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minCost(self, nums, k):\n        def trimmed(sub):\n            count = {}\n            for num in sub:\n                if num in count:\n                    count[num] += 1\n                else:\n                    count[num] = 1\n            trimmed_sub = []\n            for num in sub:\n                if count[num] > 1:\n                    trimmed_sub.append(num)\n            return trimmed_sub\n        \n        n = len(nums)\n        \n        dp = [float('inf')] * (n+1)\n        dp[0] = 0\n        \n        for i in range(1, n+1):\n            sub = []\n            for j in range(i-1, -1, -1):\n                sub.insert(0, nums[j])\n                importance = k + len(trimmed(sub))\n                dp[i] = min(dp[i], dp[j] + importance)\n        \n        return dp[n]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "binary-tree-inorder-traversal",
        "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
        "examples": [
            "Input: root = [1,null,2,3]\nOutput: [1,3,2]",
            "Input: root = []\nOutput: []",
            "Input: root = [1]\nOutput: [1]"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100",
        "release_time": 1688586459,
        "oracle_code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans",
        "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        result = []\n        self.traverse(root, result)\n        return result\n\n    def traverse(self, node, result):\n        if node is None:\n            return\n        self.traverse(node.left, result)\n        result.append(node.val)\n        self.traverse(node.right, result)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "47 ms",
            "memory": 16376000,
            "question_id": "94",
            "elapsed_time": 76,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922983258,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 70,
            "total_testcases": 70,
            "runtime_percentile": 7.401399999999997,
            "status_memory": "16.4 MB",
            "memory_percentile": 8.028799999999997,
            "pretty_lang": "Python3",
            "submission_id": "1098279995",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "move-zeroes",
        "description": "Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.",
        "examples": [
            "Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]",
            "Input: nums = [0]\nOutput: [0]"
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1585994303,
        "oracle_code": "class Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1",
        "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def moveZeroes(self, nums: list) -> None:\n        zero_count = 0\n        n = len(nums)\n        \n        # Count the number of 0's\n        for num in nums:\n            if num == 0:\n                zero_count += 1\n        \n        # Rearrange the non-zero elements to the front\n        zero_idx = 0\n        for num in nums:\n            if num != 0:\n                nums[zero_idx] = num\n                zero_idx += 1\n        \n        # Append the 0's to the end\n        for i in range(zero_count):\n            nums[zero_idx] = 0\n            zero_idx += 1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "153 ms",
            "memory": 18000000,
            "question_id": "283",
            "elapsed_time": 185,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699922998393,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 74,
            "total_testcases": 74,
            "runtime_percentile": 32.67509999999999,
            "status_memory": "18 MB",
            "memory_percentile": 12.448100000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098280102",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691129463,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        j = 0\n        count = 1\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[j]:\n                count += 1\n            else:\n                count = 1\n            \n            if count <= 2:\n                j += 1\n                nums[j] = nums[i]\n        \n        return j + 1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "64 ms",
            "memory": 16416000,
            "question_id": "80",
            "elapsed_time": 78,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923013558,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 165,
            "total_testcases": 165,
            "runtime_percentile": 21.3757,
            "status_memory": "16.4 MB",
            "memory_percentile": 19.87059999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098280190",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constrains": "1 <= nums.length <= 16\n1 <= nums[i] <= 105",
        "release_time": 1680970308,
        "oracle_code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```",
        "level": "medium",
        "completed_code": "\nimport functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        max_or = functools.reduce(lambda x, y: x | y, nums)\n        def backtrack(i, curr_or):\n            if i == len(nums):\n                return curr_or == max_or\n            count = 0\n            if backtrack(i+1, curr_or | nums[i]):\n                count += 1\n            count += backtrack(i+1, curr_or)\n            return count\n        return backtrack(0, 0)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16448000,
            "question_id": "2170",
            "elapsed_time": 414,
            "compare_result": "000000011111111110011100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[3,1]",
            "expected_output": "2",
            "task_finish_time": 1699923028760,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 13,
            "total_testcases": 111,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098280299",
            "input_formatted": "[3,1]",
            "input": "[3,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "can-you-eat-your-favorite-candy-on-your-favorite-day",
        "description": "You are given a (0-indexed) array of positive integers candiesCount where candiesCount[i] represents the number of candies of the\u00a0ith\u00a0type you have. You are also given a 2D array queries where queries[i] = [favoriteTypei, favoriteDayi, dailyCapi].\nYou play a game with the following rules:\n\nYou start eating candies on day 0.\nYou cannot eat any candy of type i unless you have eaten all candies of type i - 1.\nYou must eat at least one candy per day until you have eaten all the candies.\n\nConstruct a boolean array answer such that answer.length == queries.length and answer[i] is true if you can eat a candy of type favoriteTypei on day favoriteDayi without eating more than dailyCapi candies on any day, and false otherwise. Note that you can eat different types of candy on the same day, provided that you follow rule 2.\nReturn the constructed array answer.",
        "examples": [
            "Input: candiesCount = [7,4,5,3,8], queries = [[0,2,2],[4,2,4],[2,13,1000000000]]\nOutput: [true,false,true]\nExplanation:\n1- If you eat 2 candies (type 0) on day 0 and 2 candies (type 0) on day 1, you will eat a candy of type 0 on day 2.\n2- You can eat at most 4 candies each day.\n   If you eat 4 candies every day, you will eat 4 candies (type 0) on day 0 and 4 candies (type 0 and type 1) on day 1.\n   On day 2, you can only eat 4 candies (type 1 and type 2), so you cannot eat a candy of type 4 on day 2.\n3- If you eat 1 candy each day, you will eat a candy of type 2 on day 13.",
            "Input: candiesCount = [5,2,6,4,1], queries = [[3,1,2],[4,10,3],[3,10,100],[4,100,30],[1,3,1]]\nOutput: [false,true,true,false,false]"
        ],
        "constrains": "1 <= candiesCount.length <= 105\n1 <= candiesCount[i] <= 105\n1 <= queries.length <= 105\nqueries[i].length == 3\n0 <= favoriteTypei < candiesCount.length\n0 <= favoriteDayi <= 109\n1 <= dailyCapi <= 109",
        "release_time": 1612065726,
        "oracle_code": "class Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        prefix = [0]\n        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum \n        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",
        "content": "**Algo**\\nCompute the prefix sum of `candiesCount`. For a given query (`t`, `day` and `cap`), the condition for `True` is \\n`prefix[t] < (day + 1) * cap and day < prefix[t+1]`\\nwhere the first half reflects the fact that if we eat maximum candies every day we can reach the preferred one and the second half means that if we eat minimum candies (i.e. one candy) every day we won\\'t pass the preferred one. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum \\n        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        n = len(candiesCount)\n        m = len(queries)\n        \n        prefix_sum = [0] * (n+1)\n        for i in range(1, n+1):\n            prefix_sum[i] = prefix_sum[i-1] + candiesCount[i-1]\n        \n        ans = []\n        for i in range(m):\n            favoriteType, favoriteDay, dailyCap = queries[i]\n            \n            min_candies = favoriteDay + 1\n            max_candies = (favoriteDay + 1) * dailyCap\n            \n            if max_candies >= prefix_sum[favoriteType] and min_candies <= prefix_sum[favoriteType + 1]:\n                ans.append(True)\n            else:\n                ans.append(False)\n        \n        return ans\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 74676000,
            "question_id": "1872",
            "elapsed_time": 1457,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111101",
            "code_output": "[true,false,true]",
            "std_output": "",
            "last_testcase": "[7,11,5,3,8]\n[[2,2,6],[4,2,4],[2,13,1000000000]]",
            "expected_output": "[false,false,true]",
            "task_finish_time": 1699923045141,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 62,
            "total_testcases": 63,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098280416",
            "input_formatted": "[7,11,5,3,8], [[2,2,6],[4,2,4],[2,13,1000000000]]",
            "input": "[7,11,5,3,8]\n[[2,2,6],[4,2,4],[2,13,1000000000]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-anagrams",
        "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\"\u00a0and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".",
            "Input: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
        "release_time": 1675229602,
        "oracle_code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n        # Split the input string into individual words\n        words = s.split()\n\n        # Create a list to store the counts of each word's anagrams\n        counts = []\n\n        # Count the frequencies of each word's characters and store them in a dictionary\n        for word in words:\n            char_freq = {}\n            for char in word:\n                if char in char_freq:\n                    char_freq[char] += 1\n                else:\n                    char_freq[char] = 1\n            counts.append(char_freq)\n\n        # Initialize the number of distinct anagrams\n        distinct_anagrams = 1\n\n        # Iterate through the words and check for anagram property\n        for i in range(len(words)):\n            # Check if the current word has already been checked\n            if counts[i] is None:\n                continue\n\n            # Count the number of occurrences of the current word's anagrams\n            anagram_count = 1\n\n            # Iterate through the remaining words\n            for j in range(i + 1, len(words)):\n                # Check if the remaining words match the current word's anagrams\n                if counts[i] == counts[j]:\n                    # Increment the count of the current word's anagrams\n                    anagram_count += 1\n\n                    # Mark the remaining word as already checked\n                    counts[j] = None\n\n            # Multiply the number of distinct anagrams by the count of the current word's anagrams\n            distinct_anagrams = (distinct_anagrams * anagram_count) % (10 ** 9 + 7)\n\n        # Return the number of distinct anagrams\n        return distinct_anagrams\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 29436000,
            "question_id": "2605",
            "elapsed_time": 125,
            "compare_result": "01000000000001000000000000000000001111100",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "\"too hot\"",
            "expected_output": "18",
            "task_finish_time": 1699923058862,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 7,
            "total_testcases": 41,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098280517",
            "input_formatted": "\"too hot\"",
            "input": "\"too hot\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.",
        "examples": [
            "Input: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.",
            "Input: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i\n0 <= node1, node2 < n",
        "release_time": 1674617837,
        "oracle_code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
        "level": "medium",
        "completed_code": "\nfrom typing import List\n\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges) -> List:\n        if distArray[distArrayIndex] == -1:\n            return\n        if it in distArray:\n            return distArray\n        distArray.append(distArrayIndex)\n        return self.cdist(it, distArray, edges[distArrayIndex], edges)\n\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        distArray1 = self.cdist(node1, [], node1, edges)\n        distArray2 = self.cdist(node2, [], node2, edges)\n        \n        commonNodes = set(distArray1) & set(distArray2)\n        \n        if len(commonNodes) == 0:\n            return -1\n        \n        return min(commonNodes)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 6: IndexError: list index out of range",
            "full_runtime_error": "IndexError: list index out of range\n    if distArray[distArrayIndex] == -1:\nLine 6 in cdist (Solution.py)\n    distArray1 = self.cdist(node1, [], node1, edges)\nLine 14 in closestMeetingNode (Solution.py)\n    ret = Solution().closestMeetingNode(param_1, param_2, param_3)\nLine 52 in _driver (Solution.py)\n    _driver()\nLine 63 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16540000,
            "question_id": "2438",
            "elapsed_time": 53,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[2,2,3,-1]\n0\n1",
            "expected_output": "2",
            "task_finish_time": 1699923073888,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 77,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098280624",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "description": "You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d].\nYou may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]).\nReturn a string representing the largest possible integer after mutating (or choosing not to) a single substring of num.\nA substring is a contiguous sequence of characters within the string.",
        "examples": [
            "Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8]\nOutput: \"832\"\nExplanation: Replace the substring \"1\":\n- 1 maps to change[1] = 8.\nThus, \"132\" becomes \"832\".\n\"832\" is the largest number that can be created, so return it.",
            "Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6]\nOutput: \"934\"\nExplanation: Replace the substring \"021\":\n- 0 maps to change[0] = 9.\n- 2 maps to change[2] = 3.\n- 1 maps to change[1] = 4.\nThus, \"021\" becomes \"934\".\n\"934\" is the largest number that can be created, so return it.",
            "Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4]\nOutput: \"5\"\nExplanation: \"5\" is already the largest number that can be created, so return it."
        ],
        "constrains": "1 <= num.length <= 105\nnum consists of only digits 0-9.\nchange.length == 10\n0 <= change[d] <= 9",
        "release_time": 1627185674,
        "oracle_code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        # Convert string to list of integers\n        num_list = list(map(int, num))\n        \n        # Track if we have started replacing digits\n        started_replacing = False\n        \n        # Iterate over each digit in the list\n        for i, digit in enumerate(num_list):\n            # Get the replacement digit from change list\n            replacement = change[digit]\n            \n            # If the replacement is larger than the original digit, replace it\n            if replacement > digit:\n                num_list[i] = replacement\n                started_replacing = True\n            \n            # If we have started replacing and the replacement is smaller than the original digit, stop replacing\n            elif replacement < digit and started_replacing:\n                break\n        \n        # Convert the list back to a string\n        return ''.join(map(str, num_list))\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "317 ms",
            "memory": 25508000,
            "question_id": "2077",
            "elapsed_time": 360,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923089154,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 279,
            "total_testcases": 279,
            "runtime_percentile": 30.9371000000001,
            "status_memory": "25.5 MB",
            "memory_percentile": 9.353200000000005,
            "pretty_lang": "Python3",
            "submission_id": "1098280727",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "description": "You are given two strings s1 and s2 of equal length. A string swap is an operation where you choose two indices in a string (not necessarily different) and swap the characters at these indices.\nReturn true if it is possible to make both strings equal by performing at most one string swap on exactly one of the strings. Otherwise, return false.",
        "examples": [
            "Input: s1 = \"bank\", s2 = \"kanb\"\nOutput: true\nExplanation: For example, swap the first character with the last character of s2 to make \"bank\".",
            "Input: s1 = \"attack\", s2 = \"defend\"\nOutput: false\nExplanation: It is impossible to make them equal with one string swap.",
            "Input: s1 = \"kelb\", s2 = \"kelb\"\nOutput: true\nExplanation: The two strings are already equal, so no string swap operation is required."
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1.length == s2.length\ns1 and s2 consist of only lowercase English letters.",
        "release_time": 1690179451,
        "oracle_code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        # if the strings are already equal, return True\n        if s1 == s2:\n            return True\n        \n        # find the indices where the characters are different\n        diff_indices = []\n        for i in range(len(s1)):\n            if s1[i] != s2[i]:\n                diff_indices.append(i)\n        \n        # if there are more than 2 different characters, return False\n        if len(diff_indices) != 2:\n            return False\n        \n        # check if swapping characters at the different indices makes the strings equal\n        if s1[diff_indices[0]] == s2[diff_indices[1]] and s1[diff_indices[1]] == s2[diff_indices[0]]:\n            return True\n        \n        # if swapping does not make the strings equal, return False\n        return False\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "33 ms",
            "memory": 16468000,
            "question_id": "1915",
            "elapsed_time": 55,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923103911,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 132,
            "total_testcases": 132,
            "runtime_percentile": 87.95040000000002,
            "status_memory": "16.5 MB",
            "memory_percentile": 9.680800000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098280816",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "alternating-digit-sum",
        "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.",
        "examples": [
            "Input: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.",
            "Input: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.",
            "Input: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
        ],
        "constrains": "1 <= n <= 109",
        "release_time": 1691755636,
        "oracle_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        num_str = str(n)\n        sum = int(num_str[0])\n        sign = 1\n        for i in range(1, len(num_str)):\n            if sign == 1:\n                sum += int(num_str[i])\n            else:\n                sum -= int(num_str[i])\n            sign *= -1\n        return sum\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16332000,
            "question_id": "2630",
            "elapsed_time": 54,
            "compare_result": "0101111111111000000010000000010010000000000100000000000000000000000000000000000000000000000000001000000100000000011000",
            "code_output": "6",
            "std_output": "",
            "last_testcase": "521",
            "expected_output": "4",
            "task_finish_time": 1699923119210,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 19,
            "total_testcases": 118,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098280916",
            "input_formatted": "521",
            "input": "521",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "ugly-number-iii",
        "description": "An ugly number is a positive integer that is divisible by a, b, or c.\nGiven four integers n, a, b, and c, return the nth ugly number.",
        "examples": [
            "Input: n = 3, a = 2, b = 3, c = 5\nOutput: 4\nExplanation: The ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10... The 3rd is 4.",
            "Input: n = 4, a = 2, b = 3, c = 4\nOutput: 6\nExplanation: The ugly numbers are 2, 3, 4, 6, 8, 9, 10, 12... The 4th is 6.",
            "Input: n = 5, a = 2, b = 11, c = 13\nOutput: 10\nExplanation: The ugly numbers are 2, 4, 6, 8, 10, 11, 12, 13... The 5th is 10."
        ],
        "constrains": "1 <= n, a, b, c <= 109\n1 <= a * b * c <= 1018\nIt is guaranteed that the result will be in range [1, 2 * 109].",
        "release_time": 1594093779,
        "oracle_code": "class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        # inclusion-exclusion principle\n        ab = a*b//gcd(a, b)\n        bc = b*c//gcd(b, c)\n        ca = c*a//gcd(c, a)\n        abc = ab*c//gcd(ab, c)\n        \n        lo, hi = 1, n*min(a, b, c)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\n            else: hi = mid \n        return lo",
        "content": "The term \"ugly number\" seems to reflect a poorly-defined concept. Upon Googling it, I can only find it in a few places such as LC, GFG, etc. Even in the few posts on LC, the concept varies. For example, in [263. Ugly Number](https://leetcode.com/problems/ugly-number/), an ugly number is a positive integer whose only factors are 2, 3 and 5, but 1 is treated as an ugly number. This definition is consistent with that of [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/). But in [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/), ugly number becomes positive integers divisible by given factors (let\\'s still use 2, 3, 5 unless stated otherwise), and 1 is not considered ugly any more. \\n\\nLet\\'s refer to the definition in 263 and 264 \"Def 1\" and the definition in 1201 \"Def 2\". Under Def 1, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... while under Def 2 the first few ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, ... . The similarity is obvious at first glance. But if you look deeper, a fundamental difference can be revealed. Namely, under Def 1, ugly number is self-generated, i.e. large ugly numbers are generated by multiplying factors with small ugly numbers. Because of this, ugly numbers become rarer as number becomes larger. However, under Def 2, ugly numbers are periodic. The pattern repeats when least common multiple is reached. \\n\\nTo reflect the \"self-generating\" property of ugly number under Def 1, 263 and 264 can be solved using dynamic programming. For example, this [post](https://leetcode.com/problems/ugly-number/discuss/719320/Python3-4-line-concise) and this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp) implement the solution using top-down approach. But 1201 needs to be solved in a completely different way. In the spirit of this difference, I think it is more confusing than helpful to put 1201 in the ugly number series. It is probably clearer if this is treated as a completely independent problem. \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        def gcd(a, b):\n            if b == 0:\n                return a\n            return gcd(b, a % b)\n        \n        def lcm(a, b):\n            return (a * b) // gcd(a, b)\n        \n        def countUglyNumbers(num, a, b, c, ab, ac, bc, abc):\n            return (num // a) + (num // b) + (num // c) - (num // ab) - (num // ac) - (num // bc) + (num // abc)\n        \n        ab = lcm(a, b)\n        ac = lcm(a, c)\n        bc = lcm(b, c)\n        abc = lcm(ab, c)\n        \n        left = 1\n        right = 2 * 10 ** 9\n        \n        while left < right:\n            mid = (left + right) // 2\n            count = countUglyNumbers(mid, a, b, c, ab, ac, bc, abc)\n            \n            if count < n:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "36 ms",
            "memory": 16472000,
            "question_id": "1307",
            "elapsed_time": 53,
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923133993,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 53,
            "total_testcases": 53,
            "runtime_percentile": 75.11140000000002,
            "status_memory": "16.5 MB",
            "memory_percentile": 17.777800000000013,
            "pretty_lang": "Python3",
            "submission_id": "1098281004",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "4sum-ii",
        "description": "Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that:\n\n0 <= i, j, k, l < n\nnums1[i] + nums2[j] + nums3[k] + nums4[l] == 0",
        "examples": [
            "Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]\nOutput: 2\nExplanation:\nThe two tuples are:\n1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0",
            "Input: nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]\nOutput: 1"
        ],
        "constrains": "n == nums1.length\nn == nums2.length\nn == nums3.length\nn == nums4.length\n1 <= n <= 200\n-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228",
        "release_time": 1672741417,
        "oracle_code": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        dictionary = defaultdict(int)\n        for n1 in nums1:\n            for n2 in nums2:\n                numberNeeded = -(n1 + n2)\n                dictionary[numberNeeded] += 1\n                \n        numberOfTuples = 0\n        for n3 in nums3:\n            for n4 in nums4:\n                numberOfTuples += dictionary[n3 + n4]\n            \n        return numberOfTuples",
        "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dictionary = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                numberNeeded = -(n1 + n2)\\n                dictionary[numberNeeded] += 1\\n                \\n        numberOfTuples = 0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                numberOfTuples += dictionary[n3 + n4]\\n            \\n        return numberOfTuples\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        count = 0\n        sums = {}\n        \n        # calculate the sums of all possible pairs from nums1 and nums2\n        for num1 in nums1:\n            for num2 in nums2:\n                if num1 + num2 in sums:\n                    sums[num1 + num2] += 1\n                else:\n                    sums[num1 + num2] = 1\n        \n        # count the number of tuples that sum to zero\n        for num3 in nums3:\n            for num4 in nums4:\n                if -(num3 + num4) in sums:\n                    count += sums[-(num3 + num4)]\n        \n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "595 ms",
            "memory": 16500000,
            "question_id": "454",
            "elapsed_time": 624,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923149645,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 132,
            "total_testcases": 132,
            "runtime_percentile": 29.768699999999857,
            "status_memory": "16.5 MB",
            "memory_percentile": 62.88659999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098281127",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "n-queens-ii",
        "description": "The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other.\nGiven an integer n, return the number of distinct solutions to the\u00a0n-queens puzzle.",
        "examples": [
            "Input: n = 4\nOutput: 2\nExplanation: There are two distinct solutions to the 4-queens puzzle as shown.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 9",
        "release_time": 1689338187,
        "oracle_code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def totalNQueens(self, n: int) -> int:\n        ans = []\n        board = [[\".\"]*n for _ in range(n)]\n        col = [False]*n\n        low = [False]*(2*n-1)\n        upper = [False]*(2*n-1)\n        lower = [False]*(2*n-1)\n        \n        def addans(board, ans):\n            res = []\n            for i in range(n):\n                res.append(\"\".join(board[i]))\n            ans.append(res)\n        \n        def solve(col, board, low, upper, lower, ans, n):\n            if n == 0:\n                addans(board, ans)\n                return\n            for i in range(n):\n                if col[i] or low[n-i-1] or upper[i+n-1]:\n                    continue\n                board[n-1][i] = \"Q\"\n                col[i] = low[n-i-1] = upper[i+n-1] = True\n                solve(col, board, low, upper, lower, ans, n-1)\n                col[i] = low[n-i-1] = upper[i+n-1] = False\n                board[n-1][i] = \".\"\n        \n        solve(col, board, low, upper, lower, ans, n)\n        return len(ans)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16512000,
            "question_id": "52",
            "elapsed_time": 62,
            "compare_result": "011100000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "4",
            "expected_output": "2",
            "task_finish_time": 1699923164768,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 3,
            "total_testcases": 9,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098281249",
            "input_formatted": "4",
            "input": "4",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "description": "An n x n matrix is valid if every row and every column contains all the integers from 1 to n (inclusive).\nGiven an n x n integer matrix matrix, return true if the matrix is valid. Otherwise, return false.",
        "examples": [
            "Input: matrix = [[1,2,3],[3,1,2],[2,3,1]]\nOutput: true\nExplanation: In this case, n = 3, and every row and column contains the numbers 1, 2, and 3.\nHence, we return true.",
            "Input: matrix = [[1,1,1],[1,2,3],[1,2,3]]\nOutput: false\nExplanation: In this case, n = 3, but the first row and the first column do not contain the numbers 2 or 3.\nHence, we return false."
        ],
        "constrains": "n == matrix.length == matrix[i].length\n1 <= n <= 100\n1 <= matrix[i][j] <= n",
        "release_time": 1667568355,
        "oracle_code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nfrom typing import List\n\nclass Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n        # Get the size of the matrix\n        n = len(matrix)\n        \n        # Check every row and column\n        for i in range(n):\n            # Initialize a set to store the numbers in the current row\n            row_set = set()\n            # Initialize a set to store the numbers in the current column\n            col_set = set()\n            \n            for j in range(n):\n                # Check if the number is already present in the row set\n                if matrix[i][j] in row_set:\n                    return False\n                # Add the number to the row set\n                row_set.add(matrix[i][j])\n                \n                # Check if the number is already present in the column set\n                if matrix[j][i] in col_set:\n                    return False\n                # Add the number to the column set\n                col_set.add(matrix[j][i])\n                \n        # If all rows and columns are valid, return True\n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "665 ms",
            "memory": 16888000,
            "question_id": "2254",
            "elapsed_time": 687,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923180504,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 227,
            "total_testcases": 227,
            "runtime_percentile": 56.1506,
            "status_memory": "16.9 MB",
            "memory_percentile": 46.527699999999996,
            "pretty_lang": "Python3",
            "submission_id": "1098281354",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "final-prices-with-a-special-discount-in-a-shop",
        "description": "You are given an integer array prices where prices[i] is the price of the ith item in a shop.\nThere is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j > i and prices[j] <= prices[i]. Otherwise, you will not receive any discount at all.\nReturn an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.",
        "examples": [
            "Input: prices = [8,4,6,2,3]\nOutput: [4,2,4,2,3]\nExplanation: \nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.",
            "Input: prices = [1,2,3,4,5]\nOutput: [1,2,3,4,5]\nExplanation: In this case, for all items, you will not receive any discount at all.",
            "Input: prices = [10,1,1,6]\nOutput: [9,0,1,6]"
        ],
        "constrains": "1 <= prices.length <= 500\n1 <= prices[i] <= 1000",
        "release_time": 1676047572,
        "oracle_code": "class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        ans=[]\n        for i in range(len(prices)):\n            for j in range(1,len(prices)):\n                if j>i and prices[j]<=prices[i]:\n                    ans.append(prices[i]-prices[j])\n                    break\n            else:\n                ans.append(prices[i])\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def finalPrices(self, prices: List[int]) -> List[int]:\\n        ans=[]\\n        for i in range(len(prices)):\\n            for j in range(1,len(prices)):\\n                if j>i and prices[j]<=prices[i]:\\n                    ans.append(prices[i]-prices[j])\\n                    break\\n            else:\\n                ans.append(prices[i])\\n        return ans\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        n = len(prices)\n        for i in range(n):\n            for j in range(i+1, n):\n                if prices[j] <= prices[i]:\n                    prices[i] -= prices[j]\n                    break\n        return prices\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "47 ms",
            "memory": 16476000,
            "question_id": "1570",
            "elapsed_time": 72,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923194928,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 103,
            "total_testcases": 103,
            "runtime_percentile": 93.3502,
            "status_memory": "16.5 MB",
            "memory_percentile": 14.756200000000007,
            "pretty_lang": "Python3",
            "submission_id": "1098281465",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
        "release_time": 1679838535,
        "oracle_code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]==i:\n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        max_length = -1\n        \n        for i in range(n):\n            visited = set()\n            length = 0\n            j = i\n            while j != -1:\n                if j in visited:\n                    if length == 0:\n                        break\n                    max_length = max(max_length, length)\n                    break\n                visited.add(j)\n                length += 1\n                j = edges[j]\n        \n        return max_length\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "find-the-middle-index-in-array",
        "description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.",
        "examples": [
            "Input: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4",
            "Input: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0",
            "Input: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex."
        ],
        "constrains": "1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n\n\u00a0\nNote: This question is the same as\u00a0724:\u00a0https://leetcode.com/problems/find-pivot-index/",
        "release_time": 1677668239,
        "oracle_code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        # Calculate the total sum of the array\n        total_sum = sum(nums)\n        \n        # Initialize the left sum as 0\n        left_sum = 0\n        \n        # Iterate through each index in the array\n        for i in range(len(nums)):\n            # Check if the left sum is equal to the right sum\n            if left_sum == total_sum - nums[i] - left_sum:\n                return i\n            \n            # Increment the left sum by the current number\n            left_sum += nums[i]\n        \n        # If no middle index is found, return -1\n        return -1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 16368000,
            "question_id": "2102",
            "elapsed_time": 64,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923225193,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 294,
            "total_testcases": 294,
            "runtime_percentile": 85.24589999999999,
            "status_memory": "16.4 MB",
            "memory_percentile": 6.967199999999988,
            "pretty_lang": "Python3",
            "submission_id": "1098281683",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constrains": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.",
        "release_time": 1669639917,
        "oracle_code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        win_count = {}\n        lose_count = {}\n        \n        # Count wins and losses for each player\n        for winner, loser in matches:\n            if winner in win_count:\n                win_count[winner] += 1\n            else:\n                win_count[winner] = 1\n            \n            if loser in lose_count:\n                lose_count[loser] += 1\n            else:\n                lose_count[loser] = 1\n        \n        # Find players who have not lost any matches\n        winners = [player for player in win_count if player not in lose_count]\n        \n        # Find players who have lost only one match\n        losers = [player for player in lose_count if lose_count[player] == 1 and player not in win_count]\n        \n        return [sorted(winners), sorted(losers)]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 71144000,
            "question_id": "1354",
            "elapsed_time": 1628,
            "compare_result": "0101010010000000000000110111101111111101111111011111111101111111101101010000100100000000000100100000000000000001100001010000000",
            "code_output": "[[1,2,10],[7,8]]",
            "std_output": "",
            "last_testcase": "[[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]",
            "expected_output": "[[1,2,10],[4,5,7,8]]",
            "task_finish_time": 1699923241646,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 54,
            "total_testcases": 127,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098281785",
            "input_formatted": "[[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]",
            "input": "[[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "release_time": 1691410928,
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append(\"FizzBuzz\")\\n            elif i%3==0:\\n                arr.append(\"Fizz\")\\n            elif i%5==0:\\n                arr.append(\"Buzz\")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        ans = []\n        for i in range(1, n + 1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "43 ms",
            "memory": 17476000,
            "question_id": "412",
            "elapsed_time": 65,
            "compare_result": "11111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923255185,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 8,
            "runtime_percentile": 82.6789,
            "status_memory": "17.5 MB",
            "memory_percentile": 31.985300000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098281894",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constrains": "1 <= n <= 1015",
        "release_time": 1689780826,
        "oracle_code": "class Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        even_count = (n + 1) // 2\n        odd_count = n // 2\n        \n        total_count = pow(5, even_count, 10**9 + 7) * pow(4, odd_count, 10**9 + 7)\n        total_count %= 10**9 + 7\n        \n        return total_count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "38 ms",
            "memory": 16348000,
            "question_id": "2050",
            "elapsed_time": 148,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923270554,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 166,
            "total_testcases": 166,
            "runtime_percentile": 64.6317,
            "status_memory": "16.3 MB",
            "memory_percentile": 10.233500000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098282000",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "description": "You are given a binary array nums.\nA subarray of an array is good if it contains exactly one element with the value 1.\nReturn an integer denoting the number of ways to split the array nums into good subarrays. As the number may be too large, return it modulo 109 + 7.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [0,1,0,0,1]\nOutput: 3\nExplanation: There are 3 ways to split nums into good subarrays:\n- [0,1] [0,0,1]\n- [0,1,0] [0,1]\n- [0,1,0,0] [1]",
            "Input: nums = [0,1,0]\nOutput: 1\nExplanation: There is 1 way to split nums into good subarrays:\n- [0,1,0]"
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 1",
        "release_time": 1687730663,
        "oracle_code": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1\")\n\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007",
        "content": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n       \\n        if 1 not in nums: return 0\\n\\n        nums = \\'\\'.join(map(str,nums)).strip(\\'0\\').split(\"1\")\\n\\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\\n```\\n[https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/submissions/979589101/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        # count the number of 1s in the nums array\n        count_ones = nums.count(1)\n        \n        # initialize the result\n        result = 0\n        \n        # iterate through the nums array\n        for i in range(len(nums)):\n            # if the current element is 1, decrement the count of 1s\n            if nums[i] == 1:\n                count_ones -= 1\n            \n            # if the count of 1s is 0, it means a good subarray is found\n            if count_ones == 0:\n                # count the number of zeros after the current element\n                count_zeros = 0\n                j = i + 1\n                while j < len(nums) and nums[j] == 0:\n                    count_zeros += 1\n                    j += 1\n                \n                # increment the result by the number of zeros + 1\n                result += count_zeros + 1\n        \n        return result % (10**9+7)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "valid-parenthesis-string",
        "description": "Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\nThe following rules define a valid string:\n\nAny left parenthesis '(' must have a corresponding right parenthesis ')'.\nAny right parenthesis ')' must have a corresponding left parenthesis '('.\nLeft parenthesis '(' must go before the corresponding right parenthesis ')'.\n'*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".",
        "examples": [
            "Input: s = \"()\"\nOutput: true",
            "Input: s = \"(*)\"\nOutput: true",
            "Input: s = \"(*))\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 100\ns[i] is '(', ')' or '*'.",
        "release_time": 1674151600,
        "oracle_code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def checkValidString(self, s):\n        stack = []\n        asterisk = []\n        \n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == '*':\n                asterisk.append(i)\n            else:\n                if stack: \n                    stack.pop()\n                elif asterisk: \n                    asterisk.pop()\n                else: \n                    return False\n        \n        while stack and asterisk:\n            if stack[-1] > asterisk[-1]:\n                return False\n            stack.pop()\n            asterisk.pop()\n        \n        return len(stack) == ",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 26: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n                         ^\n    return len(stack) ==\nLine 26  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 9068000,
            "question_id": "678",
            "elapsed_time": 22,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "\"()\"",
            "expected_output": "true",
            "task_finish_time": 1699923300282,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 83,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098282200",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "linked-list-in-binary-tree",
        "description": "Given a binary tree root and a\u00a0linked list with\u00a0head\u00a0as the first node.\u00a0\nReturn True if all the elements in the linked list starting from the head correspond to some downward path connected in the binary tree\u00a0otherwise return False.\nIn this context downward path means a path that starts at some node and goes downwards.",
        "examples": [
            "Input: head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true\nExplanation: Nodes in blue form a subpath in the binary Tree.",
            "Input: head = [1,4,2,6], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: true",
            "Input: head = [1,4,2,6,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]\nOutput: false\nExplanation: There is no path in the binary tree that contains all the elements of the linked list from head."
        ],
        "constrains": "The number of nodes in the tree will be in the range [1, 2500].\nThe number of nodes in the list will be in the range [1, 100].\n1 <= Node.val\u00a0<= 100\u00a0for each node in the linked list and binary tree.",
        "release_time": 1689594574,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n        if not head:\n            return True\n        if not root:\n            return False\n        return self.isSame(head, root) or \\\n               self.isSubPath(head, root.left) or \\\n               self.isSubPath(head, root.right)\n\n    def isSame(self, head, root):\n        if not head:\n            return True\n        if not root:\n            return False\n        if head.val != root.val:\n            return False\n        return self.isSame(head.next, root.left) or \\\n               self.isSame(head.next, root.right)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "87 ms",
            "memory": 18820000,
            "question_id": "1484",
            "elapsed_time": 105,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923315408,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 67,
            "total_testcases": 67,
            "runtime_percentile": 72.093,
            "status_memory": "18.8 MB",
            "memory_percentile": 35.21590000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098282301",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-the-repetitions",
        "description": "We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\nFor example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\nFor example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.",
        "examples": [
            "Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2",
            "Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1"
        ],
        "constrains": "1 <= s1.length, s2.length <= 100\ns1 and s2 consist of lowercase English letters.\n1 <= n1, n2 <= 106",
        "release_time": 1671908671,
        "oracle_code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n        if not s1 or not s2 or n1 == 0 or n2 == 0:\n            return 0\n        \n        count1, count2, j = 0, 0, 0\n        repeat = [0] * (len(s2) + 1)\n        for k in range(1, n1 + 1):\n            for i in range(len(s1)):\n                if s1[i] == s2[j]:\n                    j += 1\n                    if j == len(s2):\n                        j = 0\n                        count2 += 1\n            \n            count1 += 1\n            repeat[k] = count2\n            \n            if count1 == n1:\n                return repeat[n1] // n2\n            \n            if repeat[count1] == repeat[count1 - 1]:\n                pre_loop = count1 - 1\n                in_loop = (n1 - count1 + 1) // (count1 - pre_loop) * (repeat[count1] - repeat[pre_loop])\n                post_loop = (n1 - count1 + 1) % (count1 - pre_loop) + pre_loop\n                return (repeat[pre_loop] + in_loop + repeat[post_loop]) // n2\n        \n        return repeat[n1] // n2\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 18: IndexError: list assignment index out of range",
            "full_runtime_error": "IndexError: list assignment index out of range\n    repeat[k] = count2\nLine 18 in getMaxRepetitions (Solution.py)\n    ret = Solution().getMaxRepetitions(param_1, param_2, param_3, param_4)\nLine 64 in _driver (Solution.py)\n    _driver()\nLine 75 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16360000,
            "question_id": "466",
            "elapsed_time": 53,
            "compare_result": "0000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "\"acb\"\n4\n\"ab\"\n2",
            "expected_output": "2",
            "task_finish_time": 1699923330410,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 49,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098282423",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "description": "You are given a non-negative integer array nums. In one operation, you must:\n\nChoose a positive integer x such that x is less than or equal to the smallest non-zero element in nums.\nSubtract x from every positive element in nums.\n\nReturn the minimum number of operations to make every element in nums equal to 0.",
        "examples": [
            "Input: nums = [1,5,0,3,5]\nOutput: 3\nExplanation:\nIn the first operation, choose x = 1. Now, nums = [0,4,0,2,4].\nIn the second operation, choose x = 2. Now, nums = [0,2,0,0,2].\nIn the third operation, choose x = 2. Now, nums = [0,0,0,0,0].",
            "Input: nums = [0]\nOutput: 0\nExplanation: Each element in nums is already 0 so no operations are needed."
        ],
        "constrains": "1 <= nums.length <= 100\n0 <= nums[i] <= 100",
        "release_time": 1679755806,
        "oracle_code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA brute-force approach will be:\\n1. sort in increasing order\\n2. get first non-zero element\\n3. deduct all non-zero elements with the above\\n4. continue until all non-zero elements are zeroed out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition, leads to the following realization:\\n\\nIf we count unique non-zero elements in the array, that many\\nnumber of operations are required to zero out the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where is n is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m is the total number of unique non-zero elements in the array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        uniq_non_zero = set()\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            uniq_non_zero.add(num)\\n        return len(uniq_non_zero)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        \n        min_num = min(nums)\n        operations = 0\n        \n        for num in nums:\n            if num > 0:\n                operations += num // min_num\n        \n        return operations\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 12: ZeroDivisionError: integer division or modulo by zero",
            "full_runtime_error": "ZeroDivisionError: integer division or modulo by zero\n    operations += num // min_num\nLine 12 in minimumOperations (Solution.py)\n    ret = Solution().minimumOperations(param_1)\nLine 34 in _driver (Solution.py)\n    _driver()\nLine 45 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16244000,
            "question_id": "2436",
            "elapsed_time": 57,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[1,5,0,3,5]",
            "expected_output": "3",
            "task_finish_time": 1699923345786,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 95,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098282539",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i",
        "release_time": 1679810937,
        "oracle_code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n):\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=1\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx",
        "content": "![image.png](https://assets.leetcode.com/users/images/32aa55a9-332b-46f6-a6ba-0936acd42ead_1679810850.9233634.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n## Python3\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        bl=[0]*n\\n        mp=defaultdict(int)\\n        mx=-1\\n        for i in range(n):\\n            if(bl[i]==0):\\n                x=i\\n                l=0\\n                st=set()\\n                while x>-1 and bl[x]==0:\\n                    bl[x]=1\\n                    mp[x]=l\\n                    l+=1\\n                    st.add(x)\\n                    x=edges[x]\\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\\n        return mx\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n = len(edges)\n        visited = [False] * n\n        cycle_len = -1\n        \n        for i in range(n):\n            if not visited[i]:\n                cycle_len = max(cycle_len, self.dfs(i, edges, visited, []))\n                \n        return cycle_len\n    \n    def dfs(self, node, edges, visited, path):\n        if visited[node]:\n            if node in path:\n                return len(path) - path.index(node)\n            else:\n                return -1\n        \n        visited[node] = True\n        path.append(node)\n        next_node = edges[node]\n        \n        if next_node == -1:\n            return -1\n        else:\n            return self.dfs(next_node, edges, visited, path)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1005 ms",
            "memory": 129280000,
            "question_id": "2439",
            "elapsed_time": 1093,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923361692,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 81,
            "total_testcases": 81,
            "runtime_percentile": 64.81280000000012,
            "status_memory": "129.3 MB",
            "memory_percentile": 49.175000000000026,
            "pretty_lang": "Python3",
            "submission_id": "1098282645",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-ways-to-split-a-string",
        "description": "Given a binary string s, you can split s into 3 non-empty strings s1, s2, and s3 where s1 + s2 + s3 = s.\nReturn the number of ways s can be split such that the number of ones is the same in s1, s2, and s3. Since the answer may be too large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"10101\"\nOutput: 4\nExplanation: There are four ways to split s in 3 parts where each part contain the same number of letters '1'.\n\"1|010|1\"\n\"1|01|01\"\n\"10|10|1\"\n\"10|1|01\"",
            "Input: s = \"1001\"\nOutput: 0",
            "Input: s = \"0000\"\nOutput: 3\nExplanation: There are three ways to split s in 3 parts.\n\"0|0|00\"\n\"0|00|0\"\n\"00|0|0\""
        ],
        "constrains": "3 <= s.length <= 105\ns[i] is either '0' or '1'.",
        "release_time": 1687719570,
        "oracle_code": "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        cnt1 = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '1':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt1 += 1\n            if cnt1 == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(s)\\n        c1 = s.count(\\'1\\')\\n        if not c1:\\n            return (((N-1)*(N-2))//2) % MOD\\n        if c1 % 3:\\n            return 0\\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\\n        cnt = 0\\n        cnt1 = 0\\n        for i in range(N):\\n            if s[i] == \\'1\\':\\n                cnt += 1\\n            if cnt == c1//3:\\n                idx1 = i\\n                break\\n        for i in range(idx1+1,N):\\n            if s[i] == \\'1\\':\\n                idx2 = i\\n                break\\n        for i in range(N-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                cnt1 += 1\\n            if cnt1 == c1//3:\\n                idx4 = i\\n                break\\n        for i in range(idx4-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                idx3 = i\\n                break\\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def numWays(self, s: str) -> int:\n        # Count the number of ones in the given string\n        ones_count = s.count('1')\n        \n        # If the total number of ones is not divisible by 3, \n        # then it is not possible to split the string into 3 parts with equal number of ones\n        if ones_count % 3 != 0:\n            return 0\n        \n        # If the total number of ones is zero, then we can choose any two indices to split the string\n        # Here, the total number of ways will be (length - 1) choose 2\n        if ones_count == 0:\n            n = len(s)\n            return (n - 1) * (n - 2) // 2 % (10**9 + 7)\n        \n        # Calculate the number of ones in each part\n        ones_per_part = ones_count // 3\n        \n        # Iterate over the string to find the indices where the parts can be split\n        i = 0\n        part_one_index = part_two_index = 0\n        ones_count = 0\n        while i < len(s):\n            if s[i] == '1':\n                ones_count += 1\n            if ones_count == ones_per_part:\n                part_one_index = i\n            if ones_count == ones_per_part * 2:\n                part_two_index = i\n                break\n            i += 1\n        \n        # Count the number of zeros after the second split index\n        zeros_count = 0\n        while i < len(s) and s[i] == '0':\n            zeros_count += 1\n            i += 1\n        \n        # Return the number of ways to split the string\n        return (zeros_count + 1) % (10**9 + 7)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17236000,
            "question_id": "1678",
            "elapsed_time": 157,
            "compare_result": "01101101010011100010000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001011",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "\"10101\"",
            "expected_output": "4",
            "task_finish_time": 1699923375773,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 14,
            "total_testcases": 164,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098282739",
            "input_formatted": "\"10101\"",
            "input": "\"10101\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-bottom-left-tree-value",
        "description": "Given the root of a binary tree, return the leftmost value in the last row of the tree.",
        "examples": [
            "Input: root = [2,1,3]\nOutput: 1",
            "Input: root = [1,2,3,4,null,5,6,null,null,7]\nOutput: 7"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1",
        "release_time": 1680189729,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = {}\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n        return lvl[0]",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        # Base case: if root is None, return None\n        if not root:\n            return None\n        \n        # Initialize a queue to perform level order traversal\n        queue = [root]\n        # Initialize a variable to store the leftmost value in each level\n        leftmost_val = None\n        \n        # Perform level order traversal\n        while queue:\n            # Get the size of current level\n            level_size = len(queue)\n            \n            # Iterate through all nodes in the current level\n            for i in range(level_size):\n                # Pop the front node from the queue\n                node = queue.pop(0)\n                \n                # Set the leftmost value in the current level\n                if i == 0:\n                    leftmost_val = node.val\n                \n                # Append the left child to the queue if it exists\n                if node.left:\n                    queue.append(node.left)\n                # Append the right child to the queue if it exists\n                if node.right:\n                    queue.append(node.right)\n        \n        # Return the leftmost value in the last level\n        return leftmost_val\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "45 ms",
            "memory": 18772000,
            "question_id": "513",
            "elapsed_time": 66,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923390650,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 77,
            "total_testcases": 77,
            "runtime_percentile": 76.1814,
            "status_memory": "18.8 MB",
            "memory_percentile": 49.23370000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098282841",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-elegance-of-a-k-length-subsequence",
        "description": "You are given a 0-indexed 2D integer array items of length n and an integer k.\nitems[i] = [profiti, categoryi], where profiti and categoryi denote the profit and category of the ith item respectively.\nLet's define the elegance of a subsequence of items as total_profit + distinct_categories2, where total_profit is the sum of all profits in the subsequence, and distinct_categories is the number of distinct categories from all the categories in the selected subsequence.\nYour task is to find the maximum elegance from all subsequences of size k in items.\nReturn an integer denoting the maximum elegance of a subsequence of items with size exactly k.\nNote: A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order.",
        "examples": [
            "Input: items = [[3,2],[5,1],[10,1]], k = 2\nOutput: 17\nExplanation: In this example, we have to select a subsequence of size 2.\nWe can select items[0] = [3,2] and items[2] = [10,1].\nThe total profit in this subsequence is 3 + 10 = 13, and the subsequence contains 2 distinct categories [2,1].\nHence, the elegance is 13 + 22 = 17, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[3,1],[3,1],[2,2],[5,3]], k = 3\nOutput: 19\nExplanation: In this example, we have to select a subsequence of size 3. \nWe can select items[0] = [3,1], items[2] = [2,2], and items[3] = [5,3]. \nThe total profit in this subsequence is 3 + 2 + 5 = 10, and the subsequence contains 3 distinct categories [1,2,3]. \nHence, the elegance is 10 + 32 = 19, and we can show that it is the maximum achievable elegance.",
            "Input: items = [[1,1],[2,1],[3,1]], k = 3\nOutput: 7\nExplanation: In this example, we have to select a subsequence of size 3. \nWe should select all the items. \nThe total profit will be 1 + 2 + 3 = 6, and the subsequence contains 1 distinct category [1]. \nHence, the maximum elegance is 6 + 12 = 7."
        ],
        "constrains": "1 <= items.length == n <= 105\nitems[i].length == 2\nitems[i][0] == profiti\nitems[i][1] == categoryi\n1 <= profiti <= 109\n1 <= categoryi <= n \n1 <= k <= n",
        "release_time": 1691294879,
        "oracle_code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))",
        "content": "[Edit : This worked on all testcases during contest but @canlong found a testcase that my algorithm does not work on]\\n\\n# Intuition\\nThe elegance as a function of the number of distinct categories should look like a mountain with a peak.\\n\\n# Approach\\nBinary search the number of distinct categories by checking the elegance of p distinct categories and p+1 distinct categories.\\n\\nFor each number of distinct category p, take the categories with the p highest values, then add the greatest values of these p categories that are not the maximum. If there are not enough elements to reach k elements, we need to take additional categories.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\\n        dico=defaultdict(list)\\n        for profit,category in items:\\n            dico[category].append(profit)\\n        categories=[]\\n        for category in dico:\\n            categories.append(sorted(dico[category]))\\n        categories.sort(key=lambda x:x[-1],reverse=True)\\n        def elegance (distinct):\\n            res=0\\n            rest=[]\\n            for i in range (distinct):\\n                res+=categories[i][-1]\\n                for j in range (len(categories[i])-1):\\n                    rest.append(categories[i][j])\\n            rest.sort(reverse=True)\\n            if len(rest)<k-distinct:\\n                return -1\\n            return res+sum(rest[:k-distinct])+distinct**2\\n        l,r=1,min(len(categories)-1,k-1)\\n        mid=(l+r)//2\\n        while l<r:\\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\\n                l=mid+1\\n            else:\\n                r=mid\\n            mid=(l+r)//2\\n        return max(elegance(mid),elegance(mid+1))\\n            \\n                \\n                \\n                \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        n = len(items)\n        if k == 0:\n            return 0\n        \n        # Sort the items based on profit in descending order\n        items.sort(reverse=True, key=lambda x: x[0])\n        \n        # Create a dictionary to store the count of each category\n        category_count = {}\n        \n        # Initialize the total_profit and distinct_categories with the first k items\n        total_profit = 0\n        distinct_categories = 0\n        for i in range(k):\n            total_profit += items[i][0]\n            if items[i][1] not in category_count:\n                category_count[items[i][1]] = 1\n                distinct_categories += 1\n            else:\n                category_count[items[i][1]] += 1\n        \n        # Initialize the maximum elegance with the elegance of the first k items\n        max_elegance = total_profit + distinct_categories ** 2\n        \n        # Traverse the remaining items\n        for i in range(k, n):\n            # Skip the items with less profit than the lowest profit in the first k items\n            if items[i][0] < items[k-1][0]:\n                continue\n            \n            # Update the total_profit by subtracting the profit of the (i-k)th item and adding the profit of the ith item\n            total_profit = total_profit - items[i-k][0] + items[i][0]\n            \n            # Update the category_count and distinct_categories\n            if items[i-k][1] in category_count:\n                category_count[items[i-k][1]] -= 1\n                if category_count[items[i-k][1]] == 0:\n                    del category_count[items[i-k][1]]\n                    distinct_categories -= 1\n            if items[i][1] not in category_count:\n                category_count[items[i][1]] = 1\n                distinct_categories += 1\n            else:\n                category_count[items[i][1]] += 1\n            \n            # Update the maximum elegance if the new elegance is greater\n            elegance = total_profit + distinct_categories ** 2\n            max_elegance = max(max_elegance, elegance)\n        \n        return max_elegance\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 53460000,
            "question_id": "2894",
            "elapsed_time": 1396,
            "compare_result": "0011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111011111111111111101111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111110111111111111111111111111111111111101111111111111111111101111110111011101111111111111111111011111101101100111111111110111101111110111101111011111111111010110111111111111110111101111101111101111111111111011111111111111111111111111110101111110100110101111111010110100111011111110100111101111101101111110111001011111111011111010011111111101101110011010111011111111001000011111110011111001110110010110001111011001111111110101111111111010101111010011111000101101001011010101111101011011110001100001110010100101111010110110000110111011110111011111111100111001101111101100111010110110111001110110111111101111110101111011001001010011111110100101100101010011111111110101111010101110111110111010000100111101011101110011000001111001011100111000000101101000100010111011001010000001101101111000110001011100111101010110111101001010010001110110010001100001010101110111101110001111100011101100100011110011010001101111111110011000111110111110100001010010000101001011100011100001101101010001111011110111110100101111001100010011100111111100110111010011110000011000011101000100010110110101001101001100110111001110001011000110011110100110001110110111000010111001101101110000011011010110011100101001111111011000001100100000000101011110010110000001101001100011110111011000101111000100100101100100011101011101011101110100100110110010010001100001110000010110101001011110001000001101000010110010111111110011111111100101101100101001010010101100000000001111100100110100010011100010100100100100101010110000001101111001010001000010010100001000001010001010001010010101010010100000001001000110101000100000000000000011000100100000100000101010101001111001001101000000010111000001100000000111000000000101001100000010000001000100000100000100000011000000001011010000000000010101000010010100000000000100001000101010011000000101100110010010000000000000000001000100010000000001100000001000000000001000000000001000000010000000000011000010000000000000000000000000100000000100100000010000000000100000000000000010101000000001011000100000110000000001000000000110000000000000000000000001000010000000000000100000001001010100101010000010010101100100000010010000000000010100101000000000000000000000000001000000000000000000000101000000000000010000000000000001000000100010000000000000000000000000001000000000000000000000000001000010100000000001000000000100000000100000000000000000001000000000000000000000010000000011111001111011111111111110110101110101111111111001111110000011110010101110111111110100011011010011011101101010000010100100001",
            "code_output": "16",
            "std_output": "",
            "last_testcase": "[[3,2],[5,1],[10,1]]\n2",
            "expected_output": "17",
            "task_finish_time": 1699923411731,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1397,
            "total_testcases": 2728,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098282990",
            "input_formatted": "[[3,2],[5,1],[10,1]], 2",
            "input": "[[3,2],[5,1],[10,1]]\n2",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "n-th-tribonacci-number",
        "description": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.",
        "examples": [
            "Input: n = 4\r\nOutput: 4\r\nExplanation:\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4",
            "Input: n = 25\r\nOutput: 1389537"
        ],
        "constrains": "0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
        "release_time": 1691827777,
        "oracle_code": "class Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d))\n            d.pop(0)\n        return d[2]",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\na array of size 3 is there it has values of `fib(0),fib(1),fib(2)`\\nfurthur usig thier sum we append it to end of list and pop the first element\\nat end answer will be stored in last `a[2]` returning it does the job\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**______O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**______O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def tribonacci(self, n: int) -> int:\n        if n == 0:\n            return 0\n        if n == 1 or n == 2:\n            return 1\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        dp[2] = 1\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]\n        return dp[n]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "34 ms",
            "memory": 16260000,
            "question_id": "1236",
            "elapsed_time": 56,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923425412,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 78.0872,
            "status_memory": "16.3 MB",
            "memory_percentile": 33.306000000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098283092",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "powerful-integers",
        "description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.",
        "examples": [
            "Input: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32",
            "Input: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]"
        ],
        "constrains": "1 <= x, y <= 100\n0 <= bound <= 106",
        "release_time": 1685619256,
        "oracle_code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        result = set()\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        for i in get(x):\n            for j in get(y):\n                if i + j <= bound:\n                    result.add(i + j)\n                else:\n                    break\n        \n        return list(result)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 16240000,
            "question_id": "1010",
            "elapsed_time": 53,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923440486,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 104,
            "total_testcases": 104,
            "runtime_percentile": 54.21059999999996,
            "status_memory": "16.2 MB",
            "memory_percentile": 47.3685,
            "pretty_lang": "Python3",
            "submission_id": "1098283190",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sequential-digits",
        "description": "An\u00a0integer has sequential digits if and only if each digit in the number is one more than the previous digit.\nReturn a sorted list of all the integers\u00a0in the range [low, high]\u00a0inclusive that have sequential digits.",
        "examples": [
            "Input: low = 100, high = 300\nOutput: [123,234]",
            "Input: low = 1000, high = 13000\nOutput: [1234,2345,3456,4567,5678,6789,12345]"
        ],
        "constrains": "10 <= low <= high <= 10^9",
        "release_time": 1679044521,
        "oracle_code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sequentialDigits(self, low, high):\n        result = []\n        for i in range(1, 9):\n            num = i\n            while num <= high:\n                if self.isSequential(num) and num >= low:\n                    result.append(num)\n                lastDigit = num % 10\n                if lastDigit == 9:\n                    break\n                num = num * 10 + (lastDigit + 1)\n        return result\n    \n    def isSequential(self, num):\n        while num > 0:\n            lastDigit = num % 10\n            num = num // 10\n            if num > 0 and lastDigit - num % 10 != 1:\n                return False\n        return True\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16352000,
            "question_id": "1212",
            "elapsed_time": 55,
            "compare_result": "10010100011111111111100",
            "code_output": "[1234,12345,2345,3456,4567,5678,6789]",
            "std_output": "",
            "last_testcase": "1000\n13000",
            "expected_output": "[1234,2345,3456,4567,5678,6789,12345]",
            "task_finish_time": 1699923455561,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 15,
            "total_testcases": 23,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098283284",
            "input_formatted": "1000, 13000",
            "input": "1000\n13000",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "description": "There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\nReturn the original array nums. If there are multiple solutions, return any of them.",
        "examples": [
            "Input: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.",
            "Input: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.",
            "Input: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]"
        ],
        "constrains": "nums.length == n\nadjacentPairs.length == n - 1\nadjacentPairs[i].length == 2\n2 <= n <= 105\n-105 <= nums[i], ui, vi <= 105\nThere exists some nums that has adjacentPairs as its pairs.",
        "release_time": 1612065696,
        "oracle_code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        # Create a dictionary to store the adjacent pairs\n        adj_dict = {}\n        for pair in adjacentPairs:\n            adj_dict.setdefault(pair[0], []).append(pair[1])\n            adj_dict.setdefault(pair[1], []).append(pair[0])\n        \n        # Find the starting point (element with only one adjacent element)\n        start = None\n        for element, adjacent_elements in adj_dict.items():\n            if len(adjacent_elements) == 1:\n                start = element\n                break\n        \n        # Traverse the array to reconstruct the original array\n        nums = [start]\n        prev_element = None\n        \n        while True:\n            adjacent_elements = adj_dict[nums[-1]]\n            next_element = adjacent_elements[0] if adjacent_elements[0] != prev_element else adjacent_elements[1]\n            nums.append(next_element)\n            prev_element = nums[-2]\n            \n            # Check if we have reached the end of the array\n            if len(adj_dict[next_element]) == 1:\n                break\n        \n        return nums\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "903 ms",
            "memory": 65036000,
            "question_id": "1866",
            "elapsed_time": 955,
            "compare_result": "1111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923471753,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 46,
            "total_testcases": 46,
            "runtime_percentile": 63.858800000000095,
            "status_memory": "65 MB",
            "memory_percentile": 69.66600000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098283402",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "removing-minimum-and-maximum-from-array",
        "description": "You are given a 0-indexed array of distinct integers nums.\nThere is an element in nums that has the lowest value and an element that has the highest value. We call them the minimum and maximum respectively. Your goal is to remove both these elements from the array.\nA deletion is defined as either removing an element from the front of the array or removing an element from the back of the array.\nReturn the minimum number of deletions it would take to remove both the minimum and maximum element from the array.",
        "examples": [
            "Input: nums = [2,10,7,5,4,1,8,6]\nOutput: 5\nExplanation: \nThe minimum element in the array is nums[5], which is 1.\nThe maximum element in the array is nums[1], which is 10.\nWe can remove both the minimum and maximum by removing 2 elements from the front and 3 elements from the back.\nThis results in 2 + 3 = 5 deletions, which is the minimum number possible.",
            "Input: nums = [0,-4,19,1,8,-2,-3,5]\nOutput: 3\nExplanation: \nThe minimum element in the array is nums[1], which is -4.\nThe maximum element in the array is nums[2], which is 19.\nWe can remove both the minimum and maximum by removing 3 elements from the front.\nThis results in only 3 deletions, which is the minimum number possible.",
            "Input: nums = [101]\nOutput: 1\nExplanation:  \nThere is only one element in the array, which makes it both the minimum and maximum element.\nWe can remove it with 1 deletion."
        ],
        "constrains": "1 <= nums.length <= 105\n-105 <= nums[i] <= 105\nThe integers in nums are distinct.",
        "release_time": 1688723249,
        "oracle_code": "class Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        min_num = min(nums)\n        max_num = max(nums)\n        \n        min_index = nums.index(min_num)\n        max_index = nums.index(max_num)\n        \n        num_deletions_front = min(min_index, len(nums) - max_index - 1)\n        num_deletions_back = min(max_index, len(nums) - min_index - 1)\n        \n        return min(num_deletions_front, num_deletions_back)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 31632000,
            "question_id": "2212",
            "elapsed_time": 777,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[2,10,7,5,4,1,8,6]",
            "expected_output": "5",
            "task_finish_time": 1699923486461,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 62,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098283496",
            "input_formatted": "[2,10,7,5,4,1,8,6]",
            "input": "[2,10,7,5,4,1,8,6]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).",
        "examples": [
            "Input: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.",
            "Input: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]"
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104",
        "release_time": 1680986222,
        "oracle_code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        prefix_sum = [0] * n\n        suffix_sum = [0] * n\n        result = [0] * n\n        \n        prefix_sum[0] = nums[0]\n        for i in range(1, n):\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\n            \n        suffix_sum[n-1] = nums[n-1]\n        for i in range(n-2, -1, -1):\n            suffix_sum[i] = suffix_sum[i+1] + nums[i]\n            \n        for i in range(n):\n            result[i] = i * nums[i] - prefix_sum[i] + suffix_sum[i] - (n-i-1) * nums[i]\n            \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "795 ms",
            "memory": 32792000,
            "question_id": "1787",
            "elapsed_time": 827,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923501503,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 59,
            "total_testcases": 59,
            "runtime_percentile": 15.327800000000103,
            "status_memory": "32.8 MB",
            "memory_percentile": 6.569100000000022,
            "pretty_lang": "Python3",
            "submission_id": "1098283586",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constrains": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
        "release_time": 1680295273,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```",
        "level": "medium",
        "completed_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nfrom typing import Optional\nimport heapq\n\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        if not root:\n            return -1\n        \n        level_sums = []\n        queue = [(0, root)]\n        \n        while queue:\n            level, node = heapq.heappop(queue)\n            \n            if level < len(level_sums):\n                level_sums[level] += node.val\n            else:\n                level_sums.append(node.val)\n            \n            if node.left:\n                heapq.heappush(queue, (level + 1, node.left))\n            if node.right:\n                heapq.heappush(queue, (level + 1, node.right))\n        \n        if k <= len(level_sums):\n            return -1\n        \n        level_sums.sort(reverse=True)\n        return level_sums[k - 1]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 31: TypeError: '<' not supported between instances of 'TreeNode' and 'TreeNode'",
            "full_runtime_error": "TypeError: '<' not supported between instances of 'TreeNode' and 'TreeNode'\n    heapq.heappush(queue, (level + 1, node.right))\nLine 31 in kthLargestLevelSum (Solution.py)\n    ret = Solution().kthLargestLevelSum(param_1, param_2)\nLine 62 in _driver (Solution.py)\n    _driver()\nLine 73 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16436000,
            "question_id": "2646",
            "elapsed_time": 53,
            "compare_result": "000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[5,8,9,2,1,3,7,4,6]\n2",
            "expected_output": "13",
            "task_finish_time": 1699923515757,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 45,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098283662",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1682922615,
        "oracle_code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass BIT():\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0] * (n + 1)\n\n    def sum(self, i):\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & -i\n        return res\n\n    def update(self, i, value):\n        while i <= self.n:\n            self.bit[i] += value\n            i += i & -i\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        n = len(s)\n        m = len(t)\n        if n != m:\n            return False\n\n        pos = [[] for _ in range(10)]\n        bit = BIT(n)\n\n        for i in range(n - 1, -1, -1):\n            digit = int(s[i])\n            pos[digit].append(i + 1)\n\n        for i in range(n):\n            digit = int(t[i])\n            if not pos[digit]:\n                return False\n            if bit.sum(pos[digit][-1]) > 0:\n                return False\n            for j in range(digit):\n                if pos[j] and bit.sum(pos[j][-1]) > 0:\n                    return False\n            bit.update(pos[digit][-1], 1)\n            pos[digit].pop()\n\n        return True\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 22420000,
            "question_id": "1707",
            "elapsed_time": 172,
            "compare_result": "001101000110110100000111110000011111000001111100000111110000011111000000000000000111111111111111000000000001111111111111000011111001010100",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "\"84532\"\n\"34852\"",
            "expected_output": "true",
            "task_finish_time": 1699923533534,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 69,
            "total_testcases": 138,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098283780",
            "input_formatted": "\"84532\", \"34852\"",
            "input": "\"84532\"\n\"34852\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-word-in-dictionary-through-deleting",
        "description": "Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.",
        "examples": [
            "Input: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\nOutput: \"apple\"",
            "Input: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\nOutput: \"a\""
        ],
        "constrains": "1 <= s.length <= 1000\n1 <= dictionary.length <= 1000\n1 <= dictionary[i].length <= 1000\ns and dictionary[i] consist of lowercase English letters.",
        "release_time": 1678402227,
        "oracle_code": "class Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        longest_word = ''\n        for word in d:\n            i , j =0 , 0\n            while i < len(word) and j < len(s):\n                if word[i] == s[j]:\n                    i+=1\n                    j+=1\n                else:\n                    j+=1\n            if i == len(word):\n                if len(longest_word) < len(word):\n                    longest_word = word\n                elif len(word) == len(longest_word):\n                    longest_word = min(longest_word , word)\n        return longest_word\n\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        res = ''\n        for cand in d:\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\n                res = cand\n        return res\n    \n\n    def find(self , s ,d):\n        i , j = 0 , 0\n        while i < len(s) and j < len(d):\n            if s[i] == d[j]:\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return j == len(d)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        longest_word = \\'\\'\\n        for word in d:\\n            i , j =0 , 0\\n            while i < len(word) and j < len(s):\\n                if word[i] == s[j]:\\n                    i+=1\\n                    j+=1\\n                else:\\n                    j+=1\\n            if i == len(word):\\n                if len(longest_word) < len(word):\\n                    longest_word = word\\n                elif len(word) == len(longest_word):\\n                    longest_word = min(longest_word , word)\\n        return longest_word\\n\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        res = \\'\\'\\n        for cand in d:\\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\\n                res = cand\\n        return res\\n    \\n\\n    def find(self , s ,d):\\n        i , j = 0 , 0\\n        while i < len(s) and j < len(d):\\n            if s[i] == d[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return j == len(d)\\n",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        def is_subsequence(s1, s2):\n            i = 0\n            for ch in s2:\n                if i < len(s1) and ch == s1[i]:\n                    i += 1\n            return i == len(s1)\n        \n        longest_word = \"\"\n        for word in d:\n            if is_subsequence(word, s):\n                if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word):\n                    longest_word = word\n        \n        return longest_word\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "267 ms",
            "memory": 18868000,
            "question_id": "524",
            "elapsed_time": 284,
            "compare_result": "1111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923548837,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 31,
            "total_testcases": 31,
            "runtime_percentile": 70.06799999999996,
            "status_memory": "18.9 MB",
            "memory_percentile": 27.28860000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098283888",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-equal-and-divisible-pairs-in-an-array",
        "description": "Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) where 0 <= i < j < n, such that nums[i] == nums[j] and (i * j) is divisible by k.",
        "examples": [
            "Input: nums = [3,1,2,2,2,1,3], k = 2\nOutput: 4\nExplanation:\nThere are 4 pairs that meet all the requirements:\n- nums[0] == nums[6], and 0 * 6 == 0, which is divisible by 2.\n- nums[2] == nums[3], and 2 * 3 == 6, which is divisible by 2.\n- nums[2] == nums[4], and 2 * 4 == 8, which is divisible by 2.\n- nums[3] == nums[4], and 3 * 4 == 12, which is divisible by 2.",
            "Input: nums = [1,2,3,4], k = 1\nOutput: 0\nExplanation: Since no value in nums is repeated, there are no pairs (i,j) that meet all the requirements."
        ],
        "constrains": "1 <= nums.length <= 100\n1 <= nums[i], k <= 100",
        "release_time": 1691512838,
        "oracle_code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        d={}\n        for i,v in enumerate(nums):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        s=0\n        def make(a,n):\n            c=0\n            for i in range(n-1):\n                for j in range(i+1,n):\n                    if a[i]*a[j]%k==0:\n                        c+=1\n            return c\n        for i in d:\n            if len(d[i])==1:\n                continue\n            s+=make(d[i],len(d[i]))\n        return s",
        "content": "# stats\\n![Screenshot 2023-08-08 at 10.04.55 PM.png](https://assets.leetcode.com/users/images/50204932-e423-445f-a363-604c06a10146_1691512534.2270777.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have a dictionary to store the indices in a array by looping through the array   \\n    We have function make which tries all combinations in the indices and checks if their product id dicvisible by k returning c\\nif length of indices is 1 we can skip the iteration\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N) due to make function\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) due to dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d={}\\n        for i,v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        s=0\\n        def make(a,n):\\n            c=0\\n            for i in range(n-1):\\n                for j in range(i+1,n):\\n                    if a[i]*a[j]%k==0:\\n                        c+=1\\n            return c\\n        for i in d:\\n            if len(d[i])==1:\\n                continue\\n            s+=make(d[i],len(d[i]))\\n        return s\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        count = 0\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] == nums[j] and (i * j) % k == 0:\n                    count += 1\n        \n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "92 ms",
            "memory": 16280000,
            "question_id": "2277",
            "elapsed_time": 107,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923563632,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 238,
            "total_testcases": 238,
            "runtime_percentile": 28.12910000000004,
            "status_memory": "16.3 MB",
            "memory_percentile": 37.03210000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098283976",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "distribute-repeating-integers",
        "description": "You are given an array of n integers, nums, where there are at most 50 unique values in the array. You are also given an array of m customer order quantities, quantity, where quantity[i] is the amount of integers the ith customer ordered. Determine if it is possible to distribute nums such that:\n\nThe ith customer gets exactly quantity[i] integers,\nThe integers the ith customer gets are all equal, and\nEvery customer is satisfied.\n\nReturn true if it is possible to distribute nums according to the above conditions.",
        "examples": [
            "Input: nums = [1,2,3,4], quantity = [2]\nOutput: false\nExplanation: The 0th customer cannot be given two different integers.",
            "Input: nums = [1,2,3,3], quantity = [2]\nOutput: true\nExplanation: The 0th customer is given [3,3]. The integers [1,2] are not used.",
            "Input: nums = [1,1,2,2], quantity = [2,2]\nOutput: true\nExplanation: The 0th customer is given [1,1], and the 1st customer is given [2,2]."
        ],
        "constrains": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= 1000\nm == quantity.length\n1 <= m <= 10\n1 <= quantity[i] <= 105\nThere are at most 50 unique values in nums.",
        "release_time": 1626405953,
        "oracle_code": "from collections import Counter, defaultdict\n\nclass Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        quantity.sort(reverse=True)\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\n        def backtrack(i: int = 0) -> bool:\n            if i == len(quantity):\n                return True\n            \n            for freq, count in list(freqCounts.items()):\n                if freq >= quantity[i] and count > 0:\n                    freqCounts[freq] -= 1\n                    freqCounts[freq - quantity[i]] += 1\n                    if backtrack(i + 1):\n                        return True\n                    freqCounts[freq] += 1\n                    freqCounts[freq - quantity[i]] -= 1\n            \n            return False\n        \n        return backtrack()",
        "content": "1. Sort the `quantity` array in reverse order, since allocating larger quantities first will more quickly reduce the search space.\\n2. Get the frequency of each number in `nums`, ignoring the actual numbers.\\n3. Then further get the count of each frequency, storing this in `freqCounts`. We do this so that in our backtracking step, we don\\'t try allocating a quantity to two different but equal frequencies, as they would have an equivalent result.\\n4. In the backtracking, we try allocating each quantity to each unique frequency, simply decrementing and incrementing the frequency counts in each step.\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```",
        "level": "hard",
        "completed_code": "\nfrom collections import Counter\n\nclass Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        counts = Counter(nums) # count the occurrences of each integer in nums\n        return self.helper(counts, quantity)\n    \n    def helper(self, counts: Counter, quantity: List[int]) -> bool:\n        if len(quantity) == 0: # all customers are satisfied\n            return True\n        \n        curr_quantity = quantity.pop() # get the quantity for the current customer\n        for num in counts:\n            if counts[num] >= curr_quantity: # if there are enough integers of the same value for the current customer\n                counts[num] -= curr_quantity # reduce the count for the current value\n                if self.helper(counts, quantity): # recursively check for the remaining customers\n                    return True\n                counts[num] += curr_quantity # revert the reduction\n                \n        quantity.append(curr_quantity) # restore the popped quantity\n        return False\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "linked-list-cycle",
        "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the\u00a0next\u00a0pointer. Internally, pos\u00a0is used to denote the index of the node that\u00a0tail's\u00a0next\u00a0pointer is connected to.\u00a0Note that\u00a0pos\u00a0is not passed as a parameter.\nReturn\u00a0true if there is a cycle in the linked list. Otherwise, return false.",
        "examples": [
            "Input: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).",
            "Input: head = [1,2], pos = 0\nOutput: true\nExplanation: There is a cycle in the linked list, where the tail connects to the 0th node.",
            "Input: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle in the linked list."
        ],
        "constrains": "The number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.",
        "release_time": 1692180651,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```",
        "level": "easy",
        "completed_code": "s Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        # if head is None or head.next is None, there is no cycle in the linked list\n        if head is None or head.next is None:\n            return False\n        \n        # initialize two pointers, slow and fast, both starting from the head\n        slow = head\n        fast = head\n        \n        # iterate until fast reaches the end of the linked list or fast.next reaches the end of the linked list\n        while fast is not None and fast.next is not None:\n            # move slow pointer one step\n            slow = slow.next\n            # move fast pointer two steps\n            fast = fast.next.next\n            \n            # if slow and fast meet, there is a cycle in the linked list\n            if slow == fast:\n                return True\n        \n        # if there is no cycle, return False\n        return False\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 1: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n      ^^^^^^^^\n    s Solution:\nLine 1  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 8988000,
            "question_id": "141",
            "elapsed_time": 19,
            "compare_result": "0000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[3,2,0,-4]\n1",
            "expected_output": "true",
            "task_finish_time": 1699923593670,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 25,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098284176",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "third-maximum-number",
        "description": "Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.",
        "examples": [
            "Input: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.",
            "Input: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.",
            "Input: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1."
        ],
        "constrains": "1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1688789383,
        "oracle_code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        # Remove duplicates in the array\n        nums = list(set(nums))\n        # If there are less than 3 unique numbers, return the maximum number\n        if len(nums) < 3:\n            return max(nums)\n        # Find the third maximum number\n        third_max = float('-inf')\n        max_num = float('-inf')\n        second_max = float('-inf')\n        for num in nums:\n            if num > max_num:\n                third_max = second_max\n                second_max = max_num\n                max_num = num\n            elif num < max_num and num > second_max:\n                third_max = second_max\n                second_max = num\n            elif num < second_max and num > third_max:\n                third_max = num\n        return third_max\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "65 ms",
            "memory": 17980000,
            "question_id": "414",
            "elapsed_time": 76,
            "compare_result": "1111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923609387,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 34,
            "total_testcases": 34,
            "runtime_percentile": 13.707500000000003,
            "status_memory": "18 MB",
            "memory_percentile": 21.40330000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098284290",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "self-dividing-numbers",
        "description": "A self-dividing number is a number that is divisible by every digit it contains.\n\nFor example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].",
        "examples": [
            "Input: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]",
            "Input: left = 47, right = 85\nOutput: [48,55,66,77]"
        ],
        "constrains": "1 <= left <= right <= 104",
        "release_time": 1691392822,
        "oracle_code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        result = []\n        for num in range(left, right+1):\n            if self.isSelfDividing(num):\n                result.append(num)\n        return result\n\n    def isSelfDividing(self, num: int) -> bool:\n        original_num = num\n        while num > 0:\n            digit = num % 10\n            if digit == 0 or original_num % digit != 0:\n                return False\n            num //= 10\n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "47 ms",
            "memory": 16388000,
            "question_id": "728",
            "elapsed_time": 60,
            "compare_result": "1111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923623849,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 31,
            "total_testcases": 31,
            "runtime_percentile": 78.26920000000001,
            "status_memory": "16.4 MB",
            "memory_percentile": 11.6461,
            "pretty_lang": "Python3",
            "submission_id": "1098284393",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "create-components-with-same-value",
        "description": "There is an undirected tree with n nodes labeled from 0 to n - 1.\nYou are given a 0-indexed integer array nums of length n where nums[i] represents the value of the ith node. You are also given a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nYou are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all nums[i] for which node i is in the component.\nReturn the maximum number of edges you can delete, such that every connected component in the tree has the same value.",
        "examples": [
            "Input: nums = [6,2,2,2,6], edges = [[0,1],[1,2],[1,3],[3,4]] \nOutput: 2 \nExplanation: The above figure shows how we can delete the edges [0,1] and [3,4]. The created components are nodes [0], [1,2,3] and [4]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.",
            "Input: nums = [2], edges = []\nOutput: 0\nExplanation: There are no edges to be deleted."
        ],
        "constrains": "1 <= n <= 2 * 104\nnums.length == n\n1 <= nums[i] <= 50\nedges.length == n - 1\nedges[i].length == 2\n0 <= edges[i][0], edges[i][1] <= n - 1\nedges represents a valid tree.",
        "release_time": 1665861689,
        "oracle_code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        graph = [[] for _ in range(len(nums))]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        def dfs(node, parent):\n            total_value = nums[node]\n            total_edges = 0\n            for neighbor in graph[node]:\n                if neighbor == parent:\n                    continue\n                edge_value, edge_edges = dfs(neighbor, node)\n                total_value += edge_value\n                total_edges += edge_edges\n            if total_value == 0:\n                return 0, total_edges\n            return total_value, total_edges + 1\n        \n        max_edges = 0\n        for i in range(len(nums)):\n            if nums[i] == 0:\n                continue\n            value, edges = dfs(i, None)\n            max_edges = max(max_edges, edges - 1)\n        \n        return max_edges\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "longest-happy-prefix",
        "description": "A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself).\nGiven a string s, return the longest happy prefix of s. Return an empty string \"\" if no such prefix exists.",
        "examples": [
            "Input: s = \"level\"\nOutput: \"l\"\nExplanation: s contains 4 prefix excluding itself (\"l\", \"le\", \"lev\", \"leve\"), and suffix (\"l\", \"el\", \"vel\", \"evel\"). The largest prefix which is also suffix is given by \"l\".",
            "Input: s = \"ababab\"\nOutput: \"abab\"\nExplanation: \"abab\" is the largest prefix which is also suffix. They can overlap in the original string."
        ],
        "constrains": "1 <= s.length <= 105\ns contains only lowercase English letters.",
        "release_time": 1672917990,
        "oracle_code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def longestPrefix(self, s: str) -> str:\n        # Initialize two pointers\n        start = 0\n        end = len(s) - 1\n        prefix = \"\"\n        \n        # Loop through the string from left to right\n        for i in range(len(s)):\n            # Check if the current substring from start to i is a suffix of s\n            if s[start:i+1] == s[end-i:end+1]:\n                prefix = s[start:i+1]\n        \n        return prefix\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17748000,
            "question_id": "1508",
            "elapsed_time": 2720,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "\"level\"",
            "std_output": "",
            "last_testcase": "\"level\"",
            "expected_output": "\"l\"",
            "task_finish_time": 1699923656748,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 82,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098284627",
            "input_formatted": "\"level\"",
            "input": "\"level\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "k-similar-strings",
        "description": "Strings s1 and s2 are k-similar (for some non-negative integer k) if we can swap the positions of two letters in s1 exactly k times so that the resulting string equals s2.\nGiven two anagrams s1 and s2, return the smallest k for which s1 and s2 are k-similar.",
        "examples": [
            "Input: s1 = \"ab\", s2 = \"ba\"\nOutput: 1\nExplanation: The two string are 1-similar because we can use one swap to change s1 to s2: \"ab\" --> \"ba\".",
            "Input: s1 = \"abc\", s2 = \"bca\"\nOutput: 2\nExplanation: The two strings are 2-similar because we can use two swaps to change s1 to s2: \"abc\" --> \"bac\" --> \"bca\"."
        ],
        "constrains": "1 <= s1.length <= 20\ns2.length == s1.length\ns1 and s2 contain only lowercase letters from the set {'a', 'b', 'c', 'd', 'e', 'f'}.\ns2 is an anagram of s1.",
        "release_time": 1659752487,
        "oracle_code": "class Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        #the deque keeps track of the set of strings that we want to perform swaps on\n        #at the start, the deque contains only s1\n        deque = collections.deque([s1])\n        \n        #this set wasn't mentioned in the \"intuition\" part. it helps us avoid doing repeated work by adding the same strings to our deque\n        seen = set() \n        \n        answ=0 #counter for the number of \"swaps\" done so far\n        \n        \n        while deque:\n            for _ in range(len(deque)): #loops through each string in the deque\n                \n                string = deque.popleft() #gets the first string in the deque\n                if string ==s2: return answ\n                \n                #finds the first non-matching letter in s1\n                #this satisfies condition 1 of a \"useful\" swap\n                #ex: this would be s1[3] in the above example\n                i=0\n                while string[i]==s2[i]:\n                    i+=1\n                \n                #checks all the other letters for potential swaps\n                for j in range(i+1, len(string)):\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\n                        \n                        #swaps the letters at positions i and j\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n                        \n                        #adds the \"new string\" if it was not previously added\n                        if new not in seen:\n                            seen.add(new)\n                            deque.append(new)\n            \n            #record that one more swap was done for each string in the deque\n            answ+=1",
        "content": "# **Intuition**\\n\\nFirst, let\\'s understand how the BFS works with some examples.\\n\\n\\ts1: \"aaabcbea\"\\n\\ts2: \"aaaebcba\"\\n\\nA **swap** is when we switch two letters, s1[i] and s1[j]. Not all **swaps** are useful to us. In the above example, we don\\'t want to swap s1[0] with any s1[j].\\n\\n**Swaps** are only useful if they satisfy these conditions:\\n1. s1[i] != s2[i] *(the letter isn\\'t already in the correct position)*\\n2. s1[i] = s2[j]   *(we are moving s1[i] to a location where it matches)*\\n3. s1[j]! = s2[j]   *(the SECOND letter isn\\'t already in the correct position*)\\n\\n**Our approach is to find the first non-matching letter in s1. Then, we try all possible \"useful\" swaps.**\\n\\nSo, in the above example, the first non-matching letter is s1[3], or \"b\". Performing a **swap** with s1[4] and s1[6] are both \"useful\", because the \"b\" is moved to the right position.\\n\\nWe do both of these swaps. This gives us two strings:\\n\\n\\toriginal s1: \"aaabcbea\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew string 1: \"aaacbbea\"\\n\\tnew string 2: \"aaaecbba\"\\n\\t\\nWe keep track that we made **1** change so far. Then, we repeat the same process on BOTH \"new string 1\" and \"new string 2\".\\n\\nFor new string 1, there is only one possible swap.\\n\\n\\tnew string 1: \"aaacbbea\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew new string 1: \"aaaebbca\"\\n\\t\\nFor new string 2, there is also only one possible swap.\\n\\n\\tnew string 2: \"aaaecbba\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew new string 2: \"aaaebcba\"\\n\\t\\nAt this point, new new string 2 matches s2, so we are done. We return the number of swaps made so far, which is 2.\\n\\n\\n# **Code**\\n```\\nclass Solution:\\n    def kSimilarity(self, s1: str, s2: str) -> int:\\n        #the deque keeps track of the set of strings that we want to perform swaps on\\n        #at the start, the deque contains only s1\\n        deque = collections.deque([s1])\\n        \\n        #this set wasn\\'t mentioned in the \"intuition\" part. it helps us avoid doing repeated work by adding the same strings to our deque\\n        seen = set() \\n        \\n        answ=0 #counter for the number of \"swaps\" done so far\\n        \\n        \\n        while deque:\\n            for _ in range(len(deque)): #loops through each string in the deque\\n                \\n                string = deque.popleft() #gets the first string in the deque\\n                if string ==s2: return answ\\n                \\n                #finds the first non-matching letter in s1\\n                #this satisfies condition 1 of a \"useful\" swap\\n                #ex: this would be s1[3] in the above example\\n                i=0\\n                while string[i]==s2[i]:\\n                    i+=1\\n                \\n                #checks all the other letters for potential swaps\\n                for j in range(i+1, len(string)):\\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\\n                        \\n                        #swaps the letters at positions i and j\\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\\n                        \\n                        #adds the \"new string\" if it was not previously added\\n                        if new not in seen:\\n                            seen.add(new)\\n                            deque.append(new)\\n            \\n            #record that one more swap was done for each string in the deque\\n            answ+=1\\n\\n```\\n\\n**Still Confused?**\\nIf you thoroughly read through this explanation and don\\'t get it, I\\'d recommend checking out this explanation on 2x speed:\\nhttps://www.youtube.com/watch?v=GacKZ1-p3-0&t=1292s&ab_channel=HappyCoding",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        def dfs(s1, s2, i):\n            if i == len(s1):\n                return 0\n            if s1[i] == s2[i]:\n                return dfs(s1, s2, i+1)\n            \n            min_swaps = float('inf')\n            for j in range(i+1, len(s1)):\n                if s1[j] == s2[i]:\n                    # swap s1[i] and s1[j]\n                    s1 = s1[:i] + s1[j] + s1[i+1:j] + s1[i] + s1[j+1:]\n                    min_swaps = min(min_swaps, dfs(s1, s2, i+1) + 1)\n                    # backtrack\n                    s1 = s1[:i] + s1[i+1:j] + s1[i] + s1[j+1:]\n            return min_swaps\n        \n        return dfs(s1, s2, 0)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 12: IndexError: string index out of range",
            "full_runtime_error": "IndexError: string index out of range\n    if s1[j] == s2[i]:\nLine 12 in dfs (Solution.py)\n    return dfs(s1, s2, 0)\nLine 20 in kSimilarity (Solution.py)\n    ret = Solution().kSimilarity(param_1, param_2)\nLine 45 in _driver (Solution.py)\n    _driver()\nLine 56 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16492000,
            "question_id": "884",
            "elapsed_time": 60,
            "compare_result": "100000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "\"abc\"\n\"bca\"",
            "expected_output": "2",
            "task_finish_time": 1699923669174,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1,
            "total_testcases": 66,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098284723",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "description": "Given the radius and the position of the center of a circle, implement the function randPoint which generates a uniform random point inside the circle.\nImplement the Solution class:\n\nSolution(double radius, double x_center, double y_center) initializes the object with the radius of the circle radius and the position of the center (x_center, y_center).\nrandPoint() returns a random point inside the circle. A point on the circumference of the circle is considered to be in the circle. The answer is returned as an array [x, y].",
        "examples": [
            "Input\n[\"Solution\", \"randPoint\", \"randPoint\", \"randPoint\"]\n[[1.0, 0.0, 0.0], [], [], []]\nOutput\n[null, [-0.02493, -0.38077], [0.82314, 0.38945], [0.36572, 0.17248]]\n\nExplanation\nSolution solution = new Solution(1.0, 0.0, 0.0);\nsolution.randPoint(); // return [-0.02493, -0.38077]\nsolution.randPoint(); // return [0.82314, 0.38945]\nsolution.randPoint(); // return [0.36572, 0.17248]"
        ],
        "constrains": "0 <\u00a0radius <= 108\n-107 <= x_center, y_center <= 107\nAt most 3 * 104 calls will be made to randPoint.",
        "release_time": 1673625736,
        "oracle_code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```",
        "level": "medium",
        "completed_code": "\nimport random\nimport math\nfrom typing import List\n\nclass Solution:\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n\n    def randPoint(self) -> List[float]:\n        angle = random.uniform(0, 2 * math.pi)\n        distance = math.sqrt(random.uniform(0, 1)) * self.radius\n        x = self.x_center + distance * math.cos(angle)\n        y = self.y_center + distance * math.sin(angle)\n        return [x, y]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "126 ms",
            "memory": 26660000,
            "question_id": "915",
            "elapsed_time": 167,
            "compare_result": "11111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923684732,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 8,
            "runtime_percentile": 57.45580000000003,
            "status_memory": "26.7 MB",
            "memory_percentile": 7.894699999999997,
            "pretty_lang": "Python3",
            "submission_id": "1098284809",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reverse-bits",
        "description": "Reverse bits of a given 32 bits unsigned integer.\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.",
        "examples": [
            "Input: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.",
            "Input: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111."
        ],
        "constrains": "The input must be a binary string of length 32",
        "release_time": 1691409836,
        "oracle_code": "class Solution:\n    def f(self,n,r,count):\n        if n<1:return r<<(32-count)\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def f(self,n,r,count):\\n        if n<1:return r<<(32-count)\\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)\\n```",
        "level": "easy",
        "completed_code": "thon\nclass Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            res = (res << 1) | (n & 1)\n            n = n >> 1\n        return res\n``",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 9: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n    ^\n    ``\nLine 9  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 8964000,
            "question_id": "190",
            "elapsed_time": 19,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "00000010100101000001111010011100",
            "expected_output": "   964176192 (00111001011110000010100101000000)",
            "task_finish_time": 1699923699105,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 600,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098284915",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "release_time": 1686286240,
        "oracle_code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        # check if array contains less than two elements\n        if len(nums) < 2:\n            return 0\n        \n        # sort the array\n        nums.sort()\n        \n        max_gap = 0\n        for i in range(len(nums)-1):\n            # calculate the difference between two successive elements\n            gap = nums[i+1] - nums[i]\n            \n            # update the maximum gap if the calculated gap is larger\n            if gap > max_gap:\n                max_gap = gap\n        \n        return max_gap\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "801 ms",
            "memory": 30876000,
            "question_id": "164",
            "elapsed_time": 830,
            "compare_result": "11111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923715007,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 41,
            "runtime_percentile": 92.24859999999993,
            "status_memory": "30.9 MB",
            "memory_percentile": 40.11819999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098285026",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "convert-sorted-list-to-binary-search-tree",
        "description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.",
        "examples": [
            "Input: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.",
            "Input: head = []\nOutput: []"
        ],
        "constrains": "The number of nodes in head is in the range [0, 2 * 104].\n-105 <= Node.val <= 105",
        "release_time": 1678550489,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums=[]\n        curr=head\n        while curr:\n            nums.append(curr.val)\n            curr=curr.next\n        def helper(l,r):\n            if l>r:\n                return None\n            mid=(l+r)//2\n            root=TreeNode(nums[mid])\n            root.left=helper(l,mid-1)\n            root.right=helper(mid+1,r)\n            return root\n        return helper(0,len(nums)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        nums=[]\\n        curr=head\\n        while curr:\\n            nums.append(curr.val)\\n            curr=curr.next\\n        def helper(l,r):\\n            if l>r:\\n                return None\\n            mid=(l+r)//2\\n            root=TreeNode(nums[mid])\\n            root.left=helper(l,mid-1)\\n            root.right=helper(mid+1,r)\\n            return root\\n        return helper(0,len(nums)-1)\\n\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        # Base case\n        if head is None:\n            return None\n\n        # Find the middle of the linked list\n        mid = self.findMiddle(head)\n\n        # The middle element becomes the root of the BST\n        root = TreeNode(mid.val)\n\n        # If there is only one element in the linked list, return the root\n        if head == mid:\n            return root\n\n        # Recursively construct the left subtree\n        root.left = self.sortedListToBST(head)\n\n        # Recursively construct the right subtree\n        root.right = self.sortedListToBST(mid.next)\n\n        return root\n\n    def findMiddle(self, head):\n        # Use fast and slow pointers to find the middle of the linked list\n        prev = None\n        slow = head\n        fast = head\n\n        while fast is not None and fast.next is not None:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n\n        # Disconnect the left half from the middle node\n        if prev is not None:\n            prev.next = None\n\n        return slow\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "123 ms",
            "memory": 20092000,
            "question_id": "109",
            "elapsed_time": 132,
            "compare_result": "11111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923729663,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 32,
            "total_testcases": 32,
            "runtime_percentile": 17.46340000000001,
            "status_memory": "20.1 MB",
            "memory_percentile": 73.1005,
            "pretty_lang": "Python3",
            "submission_id": "1098285129",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "description": "A string originalText is encoded using a slanted transposition cipher to a string encodedText with the help of a matrix having a fixed number of rows rows.\noriginalText is placed first in a top-left to bottom-right manner.\n\nThe blue cells are filled first, followed by the red cells, then the yellow cells, and so on, until we reach the end of originalText. The arrow indicates the order in which the cells are filled. All empty cells are filled with ' '. The number of columns is chosen such that the rightmost column will not be empty after filling in originalText.\nencodedText is then formed by appending all characters of the matrix in a row-wise fashion.\n\nThe characters in the blue cells are appended first to encodedText, then the red cells, and so on, and finally the yellow cells. The arrow indicates the order in which the cells are accessed.\nFor example, if originalText = \"cipher\" and rows = 3, then we encode it in the following manner:\n\nThe blue arrows depict how originalText is placed in the matrix, and the red arrows denote the order in which encodedText is formed. In the above example, encodedText = \"ch ie pr\".\nGiven the encoded string encodedText and number of rows rows, return the original string originalText.\nNote: originalText does not have any trailing spaces ' '. The test cases are generated such that there is only one possible originalText.",
        "examples": [
            "Input: encodedText = \"ch   ie   pr\", rows = 3\nOutput: \"cipher\"\nExplanation: This is the same example described in the problem description.",
            "Input: encodedText = \"iveo    eed   l te   olc\", rows = 4\nOutput: \"i love leetcode\"\nExplanation: The figure above denotes the matrix that was used to encode originalText. \nThe blue arrows show how we can find originalText from encodedText.",
            "Input: encodedText = \"coding\", rows = 1\nOutput: \"coding\"\nExplanation: Since there is only 1 row, both originalText and encodedText are the same."
        ],
        "constrains": "0 <= encodedText.length <= 106\nencodedText consists of lowercase English letters and ' ' only.\nencodedText is a valid encoding of some originalText that does not have trailing spaces.\n1 <= rows <= 1000\nThe testcases are generated such that there is only one possible originalText.",
        "release_time": 1681219442,
        "oracle_code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        # Calculate the number of columns in the matrix\n        cols = len(encoded_text) // rows\n        \n        # Create the matrix with the given number of rows and columns\n        matrix = [[''] * cols for _ in range(rows)]\n        \n        # Fill the matrix with the characters from encoded_text\n        for i, char in enumerate(encoded_text):\n            # Calculate the row and column index of the current cell\n            row = i % rows\n            col = i // rows\n            \n            # Place the character in the current cell of the matrix\n            matrix[row][col] = char\n        \n        # Create a list to store the characters of the originalText\n        original_text = []\n        \n        # Traverse the matrix in the specified order and append the characters to original_text\n        for col in range(cols):\n            for row in range(rows):\n                original_text.append(matrix[row][col])\n        \n        # Convert the list of characters to a string and return it\n        return ''.join(original_text)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 43188000,
            "question_id": "2197",
            "elapsed_time": 643,
            "compare_result": "0010110010000010100000000000000000000100",
            "code_output": "\"ch   ie   pr\"",
            "std_output": "",
            "last_testcase": "\"ch   ie   pr\"\n3",
            "expected_output": "\"cipher\"",
            "task_finish_time": 1699923744902,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 7,
            "total_testcases": 40,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098285228",
            "input_formatted": "\"ch   ie   pr\", 3",
            "input": "\"ch   ie   pr\"\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constrains": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i.",
        "release_time": 1689939984,
        "oracle_code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "50 ms",
            "memory": 16468000,
            "question_id": "162",
            "elapsed_time": 66,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923759814,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 66,
            "total_testcases": 66,
            "runtime_percentile": 65.63000000000002,
            "status_memory": "16.5 MB",
            "memory_percentile": 28.625100000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098285326",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "delete-operation-for-two-strings",
        "description": "Given two strings word1 and word2, return the minimum number of steps required to make word1 and word2 the same.\nIn one step, you can delete exactly one character in either string.",
        "examples": [
            "Input: word1 = \"sea\", word2 = \"eat\"\nOutput: 2\nExplanation: You need one step to make \"sea\" to \"ea\" and another step to make \"eat\" to \"ea\".",
            "Input: word1 = \"leetcode\", word2 = \"etco\"\nOutput: 4"
        ],
        "constrains": "1 <= word1.length, word2.length <= 500\nword1 and word2 consist of only lowercase English letters.",
        "release_time": 1667237998,
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        # Initialize a 2D dp table with dimensions len(word1)+1 and len(word2)+1\n        dp = [[0] * (len(word2)+1) for _ in range(len(word1)+1)]\n\n        # Fill in the first row and first column with increasing numbers\n        # representing the number of deletions needed to make the substring empty\n        for i in range(len(word1)+1):\n            dp[i][0] = i\n        for j in range(len(word2)+1):\n            dp[0][j] = j\n\n        # Iterate through the dp table and fill in the values using the following rules:\n        # If the current characters of word1 and word2 are the same, take the value diagonally left above\n        # If the current characters are different, take the minimum value of the three adjacent cells (left, above, and diagonally left above) and add 1\n        for i in range(1, len(word1)+1):\n            for j in range(1, len(word2)+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n\n        # Return the value in the bottom right cell of the dp table\n        return dp[-1][-1]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 20392000,
            "question_id": "583",
            "elapsed_time": 252,
            "compare_result": "1110111010100100110000000010100001100000001011000110000000000000000000000000000000000000001100110100000000100010000000000001000000101010100000001100000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000100000100010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001110000000000000000100100000000000100010000000000000000000000000000011000111100000000000001000000000000000000110100000100000000000000001000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011010000000001100100000000000000010000001000000000000000000000000000000010000000000000000000000000000000110000010000000000000000100000100000000000000000000000110000000110000000000001000000000000000000001010001000001100000000011000000000100000010000100000000100000001000000000000000000000000000000000000100000000000000111111111111111111111111111111111111111100000000000000000000000000000000000000000000000000000000000010",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "\"a\"\n\"b\"",
            "expected_output": "2",
            "task_finish_time": 1699923778044,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 134,
            "total_testcases": 1306,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098285427",
            "input_formatted": "\"a\", \"b\"",
            "input": "\"a\"\n\"b\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "construct-quad-tree",
        "description": "Given a n * n matrix grid of 0's and 1's only. We want to represent grid with a Quad-Tree.\nReturn the root of the Quad-Tree representing grid.\nA Quad-Tree is a tree data structure in which each internal node has exactly four children. Besides, each node has two attributes:\n\nval: True if the node represents a grid of 1's or False if the node represents a grid of 0's. Notice that you can assign the val to True or False when isLeaf is False, and both are accepted in the answer.\nisLeaf: True if the node is a leaf node on the tree or False if the node has four children.\n\n\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n}\nWe can construct a Quad-Tree from a two-dimensional area using the following steps:\n\nIf the current grid has the same value (i.e all 1's or all 0's) set isLeaf True and set val to the value of the grid and set the four children to Null and stop.\nIf the current grid has different values, set isLeaf to False and set val to any value and divide the current grid into four sub-grids as shown in the photo.\nRecurse for each of the children with the proper sub-grid.\n\n\nIf you want to know more about the Quad-Tree, you can refer to the wiki.\nQuad-Tree format:\nYou don't need to read this section for solving the problem. This is only if you want to understand the output format here. The output represents the serialized format of a Quad-Tree using level order traversal, where null signifies a path terminator where no node exists below.\nIt is very similar to the serialization of the binary tree. The only difference is that the node is represented as a list [isLeaf, val].\nIf the value of isLeaf or val is True we represent it as 1 in the list [isLeaf, val] and if the value of isLeaf or val is False we represent it as 0.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: [[0,1],[1,0],[1,1],[1,1],[1,0]]\nExplanation: The explanation of this example is shown below:\nNotice that 0 represents False and 1 represents True in the photo representing the Quad-Tree.",
            "Input: grid = [[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]\nOutput: [[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]\nExplanation: All values in the grid are not the same. We divide the grid into four sub-grids.\nThe topLeft, bottomLeft and bottomRight each has the same value.\nThe topRight have different values so we divide it into 4 sub-grids where each has the same value.\nExplanation is shown in the photo below:"
        ],
        "constrains": "n == grid.length == grid[i].length\nn == 2x where 0 <= x <= 6",
        "release_time": 1677459150,
        "oracle_code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        return self.buildTree(grid, 0, len(grid)-1, 0, len(grid)-1, 0)\n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if rs == re and cs == ce:\n            node = Node()\n            node.val = grid[rs][cs] == 1\n            node.isLeaf = True\n            return node\n        \n        node = Node()    \n        node.isLeaf = False\n        node.topLeft = self.buildTree(grid, rs, int((rs+re)/2), cs, int((cs+ce)/2), level+1)\n        node.topRight = self.buildTree(grid, rs, int((rs+re)/2), int((cs+ce)/2)+1, ce, level+1)\n        node.bottomLeft = self.buildTree(grid, int((rs+re)/2)+1, re, cs, int((cs+ce)/2), level+1)\n        node.bottomRight = self.buildTree(grid, int((rs+re)/2)+1, re, int((cs+ce)/2)+1, ce, level+1)\n        \n        if node.topLeft.isLeaf and node.topRight.isLeaf and node.bottomLeft.isLeaf and node.bottomRight.isLeaf and node.topLeft.val == node.topRight.val == node.bottomLeft.val == node.bottomRight.val:\n            node.isLeaf = True\n            node.val = node.topLeft.val\n            \n        return node\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 19388000,
            "question_id": "772",
            "elapsed_time": 135,
            "compare_result": "1001001000000000000001",
            "code_output": "Invalid Quad Tree.",
            "std_output": "",
            "last_testcase": "[[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
            "expected_output": "[[0,1],[1,1],[0,1],[1,1],[1,0],null,null,null,null,[1,0],[1,0],[1,1],[1,1]]",
            "task_finish_time": 1699923796557,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 22,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098285559",
            "input_formatted": "[[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
            "input": "[[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0],[1,1,1,1,0,0,0,0]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "rank-transform-of-an-array",
        "description": "Given an array of integers\u00a0arr, replace each element with its rank.\nThe rank represents how large the element is. The rank has the following rules:\n\nRank is an integer starting from 1.\nThe larger the element, the larger the rank. If two elements are equal, their rank must be the same.\nRank should be as small as possible.",
        "examples": [
            "Input: arr = [40,10,20,30]\nOutput: [4,1,2,3]\nExplanation: 40 is the largest element. 10 is the smallest. 20 is the second smallest. 30 is the third smallest.",
            "Input: arr = [100,100,100]\nOutput: [1,1,1]\nExplanation: Same elements share the same rank.",
            "Input: arr = [37,12,28,9,100,56,80,5,12]\nOutput: [5,3,4,2,8,6,7,1,3]"
        ],
        "constrains": "0 <= arr.length <= 105\n-109\u00a0<= arr[i] <= 109",
        "release_time": 1679115737,
        "oracle_code": "class Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        list1=[]\n        x=sorted(set(arr))\n        dict1={}\n        for i in range(len(x)):\n            dict1[x[i]]=i+1\n        for j in arr:\n            y=dict1[j]\n            list1.append(y)\n        return list1\n    #please do upvote it will help alot to gain my love in coding",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```\\n# consider upvoting if found helpful![57jfh9.jpg](https://assets.leetcode.com/users/images/18e346ce-ffbb-46f1-995f-cfc301972ca0_1679115728.6807754.jpeg)\\n",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        # create a dictionary to store each unique element in the array and its corresponding rank\n        rank_dict = {}\n        \n        # sort the array in ascending order\n        sorted_arr = sorted(arr)\n        \n        # initialize rank as 1\n        rank = 1\n        \n        # iterate through the sorted array\n        for num in sorted_arr:\n            # check if the element already exists in the rank_dict\n            if num not in rank_dict:\n                # assign the current rank to the element in the rank_dict\n                rank_dict[num] = rank\n                # increment the rank by 1\n                rank += 1\n        \n        # create a new array to store the ranks of the input array\n        ranks = []\n        \n        # iterate through the input array\n        for num in arr:\n            # append the rank of each element to the ranks array\n            ranks.append(rank_dict[num])\n        \n        # return the ranks array\n        return ranks\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "281 ms",
            "memory": 33504000,
            "question_id": "1256",
            "elapsed_time": 320,
            "compare_result": "11111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923811689,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 38,
            "total_testcases": 38,
            "runtime_percentile": 54.62209999999999,
            "status_memory": "33.5 MB",
            "memory_percentile": 67.88179999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098285653",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "description": "Given two positive integers n and k, the binary string Sn is formed as follows:\n\nS1 = \"0\"\nSi = Si - 1 + \"1\" + reverse(invert(Si - 1)) for i > 1\n\nWhere + denotes the concatenation operation, reverse(x) returns the reversed string x, and invert(x) inverts all the bits in x (0 changes to 1 and 1 changes to 0).\nFor example, the first four strings in the above sequence are:\n\nS1 = \"0\"\nS2 = \"011\"\nS3 = \"0111001\"\nS4 = \"011100110110001\"\n\nReturn the kth bit in Sn. It is guaranteed that k is valid for the given n.",
        "examples": [
            "Input: n = 3, k = 1\nOutput: \"0\"\nExplanation: S3 is \"0111001\".\nThe 1st bit is \"0\".",
            "Input: n = 4, k = 11\nOutput: \"1\"\nExplanation: S4 is \"011100110110001\".\nThe 11th bit is \"1\"."
        ],
        "constrains": "1 <= n <= 20\n1 <= k <= 2n - 1",
        "release_time": 1669030599,
        "oracle_code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findKthBit(self, N, K, R = True):\n        # Generate the binary string up to N\n        S = self.generateBinaryString(N, R)\n        \n        # Return the kth bit in the binary string\n        return S[K-1]\n    \n    def generateBinaryString(self, N, R):\n        # Base case\n        if N == 1:\n            return \"0\"\n        \n        # Generate the previous binary string\n        S_prev = self.generateBinaryString(N-1, R)\n        \n        # Invert and reverse the previous binary string\n        S_invert = self.invertString(S_prev)\n        S_reverse = self.reverseString(S_invert)\n        \n        # Concatenate the previous binary string, \"1\", and the reversed binary string\n        S = S_prev + \"1\" + S_reverse\n        \n        # Return the generated binary string\n        return S\n    \n    def invertString(self, S):\n        # Invert all the bits in the string\n        inverted = \"\"\n        for bit in S:\n            if bit == \"0\":\n                inverted += \"1\"\n            else:\n                inverted += \"0\"\n        \n        # Return the inverted string\n        return inverted\n    \n    def reverseString(self, S):\n        # Reverse the string\n        reversed_str = S[::-1]\n        \n        # Return the reversed string\n        return reversed_str\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "631 ms",
            "memory": 19316000,
            "question_id": "1667",
            "elapsed_time": 648,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923829014,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 63,
            "total_testcases": 63,
            "runtime_percentile": 31.354500000000158,
            "status_memory": "19.3 MB",
            "memory_percentile": 65.01650000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098285759",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "description": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.\nGiven an integer n, return a list of two integers [a, b] where:\n\na and b are No-Zero integers.\na + b = n\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",
        "examples": [
            "Input: n = 2\nOutput: [1,1]\nExplanation: Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.",
            "Input: n = 11\nOutput: [2,9]\nExplanation: Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 9 = n.\nNote that there are other valid answers as [8, 3] that can be accepted."
        ],
        "constrains": "2 <= n <= 104",
        "release_time": 1679182204,
        "oracle_code": "class Solution:\n    def getNoZeroIntegers(self, n: int) -> List[int]:\n        for i in range(n-1, -1, -1):\n            if '0' not in str(i) and '0' not in str(n - i):\n                return [i, n-i ]\n\n        #Oneliner\n\n        return next([i, n-i] for i in range(n-1, -1, -1) if '0' not in str(i) and '0' not in str(n-i))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n-1, -1, -1):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n                return [i, n-i ]\\n\\n        #Oneliner\\n\\n        return next([i, n-i] for i in range(n-1, -1, -1) if \\'0\\' not in str(i) and \\'0\\' not in str(n-i))\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def getNoZeroIntegers(self, n: int) -> List[int]:\n        # iterate through the integers from 1 to n-1\n        for i in range(1, n):\n            # check if i and (n-i) do not contain any zeroes\n            if '0' not in str(i) and '0' not in str(n-i):\n                return [i, n-i]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16328000,
            "question_id": "1440",
            "elapsed_time": 55,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923843583,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 207,
            "total_testcases": 207,
            "runtime_percentile": 29.41159999999999,
            "status_memory": "16.3 MB",
            "memory_percentile": 29.667500000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098285865",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "range-sum-query-immutable",
        "description": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).",
        "examples": [
            "Input\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
        ],
        "constrains": "1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n0 <= left <= right < nums.length\nAt most 104 calls will be made to sumRange.",
        "release_time": 1674748439,
        "oracle_code": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.nums=[0]+list(accumulate(nums))\n        print(self.nums)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.nums[right+1]-self.nums[left]\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
        "level": "easy",
        "completed_code": "\nclass NumArray:\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n\n    def sumRange(self, left: int, right: int) -> int:\n        # Iterate over the array and calculate the sum of the elements between left and right inclusive\n        sum = 0\n        for i in range(left, right+1):\n            sum += self.nums[i]\n        return sum\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "excel-sheet-column-title",
        "description": "Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...",
        "examples": [
            "Input: columnNumber = 1\nOutput: \"A\"",
            "Input: columnNumber = 28\nOutput: \"AB\"",
            "Input: columnNumber = 701\nOutput: \"ZY\""
        ],
        "constrains": "1 <= columnNumber <= 231 - 1",
        "release_time": 1692672791,
        "oracle_code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        if n<27:\\n            return chr(ord(\\'A\\')+(n-1)%26)\\n        ans=\"\"\\n        while n>0:\\n            if n%26==0:\\n                ans+=chr(ord(\\'A\\')+25)\\n                n-=1\\n            else:\\n                ans+=chr(ord(\\'A\\')+n%26-1)\\n            n//=26\\n        return ans[::-1]\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def convertToTitle(self, n: int) -> str:\n        result = \"\"\n        while n > 0:\n            n -= 1\n            result = chr(n % 26 + ord('A')) + result\n            n = n // 26\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "40 ms",
            "memory": 16248000,
            "question_id": "168",
            "elapsed_time": 71,
            "compare_result": "111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923873567,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 21,
            "total_testcases": 21,
            "runtime_percentile": 39.79339999999999,
            "status_memory": "16.2 MB",
            "memory_percentile": 28.318600000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098286041",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "description": "Given two arrays of integers with equal lengths, return the maximum value of:\n|arr1[i] - arr1[j]| + |arr2[i] - arr2[j]| + |i - j|\nwhere the maximum is taken over all 0 <= i, j < arr1.length.",
        "examples": [
            "Input: arr1 = [1,2,3,4], arr2 = [-1,4,5,6]\nOutput: 13",
            "Input: arr1 = [1,-2,-5,0,10], arr2 = [0,-2,-1,-7,-4]\nOutput: 20"
        ],
        "constrains": "2 <= arr1.length == arr2.length <= 40000\n-10^6 <= arr1[i], arr2[i] <= 10^6",
        "release_time": 1669133768,
        "oracle_code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        n = len(arr1)\n        max_val = 0\n        for i in range(n):\n            for j in range(n):\n                val = abs(arr1[i] - arr1[j]) + abs(arr2[i] - arr2[j]) + abs(i - j)\n                max_val = max(max_val, val)\n        return max_val\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "description": "Given two numbers arr1 and arr2 in base -2, return the result of adding them together.\nEach number is given in array format:\u00a0 as an array of 0s and 1s, from most significant bit to least significant bit.\u00a0 For example, arr = [1,1,0,1] represents the number (-2)^3\u00a0+ (-2)^2 + (-2)^0 = -3.\u00a0 A number arr in array, format is also guaranteed to have no leading zeros: either\u00a0arr == [0] or arr[0] == 1.\nReturn the result of adding arr1 and arr2 in the same format: as an array of 0s and 1s with no leading zeros.",
        "examples": [
            "Input: arr1 = [1,1,1,1,1], arr2 = [1,0,1]\nOutput: [1,0,0,0,0]\nExplanation: arr1 represents 11, arr2 represents 5, the output represents 16.",
            "Input: arr1 = [0], arr2 = [0]\nOutput: [0]",
            "Input: arr1 = [0], arr2 = [1]\nOutput: [1]"
        ],
        "constrains": "1 <= arr1.length,\u00a0arr2.length <= 1000\narr1[i]\u00a0and arr2[i] are\u00a00 or 1\narr1 and arr2 have no leading zeros",
        "release_time": 1674727355,
        "oracle_code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def addBinary(self, A, B):\n        # convert A and B from base -2 to base 10\n        num1 = self.convertToBase10(A)\n        num2 = self.convertToBase10(B)\n        \n        # calculate the sum of the converted numbers in base 10\n        sum_base10 = num1 + num2\n        \n        # convert the sum back to base -2\n        result = self.convertToBaseNegabinary(sum_base10)\n        \n        return result\n        \n    \n    def convertToBase10(self, arr):\n        # initialize the base 10 number \n        num = 0\n        \n        # iterate through the array from left to right\n        for i in range(len(arr)):\n            # multiply the digit by (-2) raised to the power of its index\n            num += arr[i] * (-2) ** (len(arr) - i - 1)\n        \n        return num\n    \n    \n    def convertToBaseNegabinary(self, num):\n        # if the number is 0, return [0]\n        if num == 0:\n            return [0]\n        \n        # initialize an empty list to store the negabinary digits\n        arr = []\n        \n        # iterate until the number becomes 0\n        while num != 0:\n            # calculate the remainder after dividing the number by -2\n            remainder = num % (-2)\n            \n            # if the remainder is negative, add 2 to it and divide the number by -2 again\n            if remainder < 0:\n                remainder += 2\n                num = (num // -2) + 1\n            else:\n                num = num // -2\n            \n            # add the remainder to the front of the array\n            arr.insert(0, remainder)\n        \n        return arr\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 77: AttributeError: 'Solution' object has no attribute 'addNegabinary'",
            "full_runtime_error": "AttributeError: 'Solution' object has no attribute 'addNegabinary'\n    ret = Solution().addNegabinary(param_1, param_2)\nLine 77 in _driver (Solution.py)\n    _driver()\nLine 88 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16444000,
            "question_id": "1148",
            "elapsed_time": 54,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[1,1,1,1,1]\n[1,0,1]",
            "expected_output": "[1,0,0,0,0]",
            "task_finish_time": 1699923908177,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 267,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098286245",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-repeating-character-replacement",
        "description": "You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.",
        "examples": [
            "Input: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with two 'B's or vice versa.",
            "Input: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'A' in the middle with 'B' and form \"AABBBBA\".\nThe substring \"BBBB\" has the longest repeating letters, which is 4.\nThere may exists other ways to achive this answer too."
        ],
        "constrains": "1 <= s.length <= 105\ns consists of only uppercase English letters.\n0 <= k <= s.length",
        "release_time": 1687778319,
        "oracle_code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        left = right = 0\n        max_len = 0\n        count = collections.Counter()\n        for right in range(1, len(s) + 1):\n            count[s[right - 1]] += 1\n\n            #find the most frequent character from left to right(window)\n            most = count.most_common()[0][1]\n\n            #replace other characters to maxf character \n            #remain refers to the num of characters to be replaced\n            remain = right - left - most\n            \n            #if the num of characters to be replaced > num of operations\n            #then decrease the size of window => left += 1\n            if remain > k: \n                count[s[left]] -= 1\n                left += 1\n                \n            # right - left => current window size\n            max_len = max(right - left, max_len)\n\n        return max_len",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        max_len = 0\\n        count = collections.Counter()\\n        for right in range(1, len(s) + 1):\\n            count[s[right - 1]] += 1\\n\\n            #find the most frequent character from left to right(window)\\n            most = count.most_common()[0][1]\\n\\n            #replace other characters to maxf character \\n            #remain refers to the num of characters to be replaced\\n            remain = right - left - most\\n            \\n            #if the num of characters to be replaced > num of operations\\n            #then decrease the size of window => left += 1\\n            if remain > k: \\n                count[s[left]] -= 1\\n                left += 1\\n                \\n            # right - left => current window size\\n            max_len = max(right - left, max_len)\\n\\n        return max_len\\n\\n\\n\\n\\n        \\n\\n\\n            \\n            \\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        max_length = 0\n        start = 0\n        max_count = 0\n        char_count = [0] * 26\n\n        for end in range(len(s)):\n            char_count[ord(s[end]) - ord('A')] += 1\n            max_count = max(max_count, char_count[ord(s[end]) - ord('A')])\n\n            if (end - start + 1 - max_count) > k:\n                char_count[ord(s[start]) - ord('A')] -= 1\n                start += 1\n\n            max_length = max(max_length, end - start + 1)\n\n        return max_length\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "109 ms",
            "memory": 16456000,
            "question_id": "424",
            "elapsed_time": 121,
            "compare_result": "11111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923923480,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 41,
            "runtime_percentile": 50.89399999999999,
            "status_memory": "16.5 MB",
            "memory_percentile": 10.9668,
            "pretty_lang": "Python3",
            "submission_id": "1098286336",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "description": "You are given an integer array nums. A number x is lonely when it appears only once, and no adjacent numbers (i.e. x + 1 and x - 1) appear in the array.\nReturn all lonely numbers in nums. You may return the answer in any order.",
        "examples": [
            "Input: nums = [10,6,5,8]\nOutput: [10,8]\nExplanation: \n- 10 is a lonely number since it appears exactly once and 9 and 11 does not appear in nums.\n- 8 is a lonely number since it appears exactly once and 7 and 9 does not appear in nums.\n- 5 is not a lonely number since 6 appears in nums and vice versa.\nHence, the lonely numbers in nums are [10, 8].\nNote that [8, 10] may also be returned.",
            "Input: nums = [1,3,5,3]\nOutput: [1,5]\nExplanation: \n- 1 is a lonely number since it appears exactly once and 0 and 2 does not appear in nums.\n- 5 is a lonely number since it appears exactly once and 4 and 6 does not appear in nums.\n- 3 is not a lonely number since it appears twice.\nHence, the lonely numbers in nums are [1, 5].\nNote that [5, 1] may also be returned."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 106",
        "release_time": 1689511881,
        "oracle_code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        # create a dictionary to count the frequency of each number\n        num_count = {}\n        for num in nums:\n            if num in num_count:\n                num_count[num] += 1\n            else:\n                num_count[num] = 1\n        \n        # iterate over the dictionary and check if each number is lonely\n        lonely_nums = []\n        for num, count in num_count.items():\n            if count == 1:\n                # check if no adjacent numbers exist in the array\n                if num - 1 not in num_count and num + 1 not in num_count:\n                    lonely_nums.append(num)\n        \n        return lonely_nums\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1055 ms",
            "memory": 41716000,
            "question_id": "2270",
            "elapsed_time": 1111,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923941266,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 75,
            "total_testcases": 75,
            "runtime_percentile": 82.27799999999988,
            "status_memory": "41.7 MB",
            "memory_percentile": 17.720999999999894,
            "pretty_lang": "Python3",
            "submission_id": "1098286437",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "release_time": 1673532723,
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        result = []\n        stack = []\n        next_greater = {}\n        \n        # Iterate through nums2 from right to left\n        for i in range(len(nums2)-1, -1, -1):\n            \n            # Pop elements from stack smaller than the current element\n            while stack and stack[-1] < nums2[i]:\n                stack.pop()\n            \n            # If stack is empty, there is no next greater element\n            if not stack:\n                next_greater[nums2[i]] = -1\n            # Otherwise, next greater element is the top of stack\n            else:\n                next_greater[nums2[i]] = stack[-1]\n            \n            # Push current element into stack\n            stack.append(nums2[i])\n        \n        # Iterate through nums1 to find the next greater elements\n        for num in nums1:\n            result.append(next_greater[num])\n        \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "59 ms",
            "memory": 16780000,
            "question_id": "496",
            "elapsed_time": 86,
            "compare_result": "1111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923953528,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 16,
            "runtime_percentile": 39.16539999999999,
            "status_memory": "16.8 MB",
            "memory_percentile": 10.337199999999992,
            "pretty_lang": "Python3",
            "submission_id": "1098286525",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-cost-to-cut-a-stick",
        "description": "Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\n\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\nReturn the minimum total cost of the cuts.",
        "examples": [
            "Input: n = 7, cuts = [1,3,4,5]\nOutput: 16\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).",
            "Input: n = 9, cuts = [5,6,1,4,2]\nOutput: 22\nExplanation: If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible."
        ],
        "constrains": "2 <= n <= 106\n1 <= cuts.length <= min(n - 1, 100)\n1 <= cuts[i] <= n - 1\nAll the integers in cuts array are distinct.",
        "release_time": 1685244609,
        "oracle_code": "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        cuts = sorted(chain(cuts,[0,n]))\n        \n        @lru_cache(None)\n        def dfs(l, r):\n            length, M = cuts[r] - cuts[l], range(l+1, r)\n            return min((dfs(l,i) + dfs(i,r) for i in M),\n                       default = -length) + length\n        \n        return dfs(0, len(cuts)-1)",
        "content": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts = sorted(chain(cuts,[0,n]))\\n        \\n        @lru_cache(None)\\n        def dfs(l, r):\\n            length, M = cuts[r] - cuts[l], range(l+1, r)\\n            return min((dfs(l,i) + dfs(i,r) for i in M),\\n                       default = -length) + length\\n        \\n        return dfs(0, len(cuts)-1)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/958717387/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^3) and space complexity is *O*(*N*^2), in which *N* ~`n`.",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        cuts = [0] + cuts + [n]\n        dp = [[0] * (len(cuts) + 1) for _ in range(len(cuts) + 1)]\n\n        for length in range(2, len(cuts)):\n            for left in range(len(cuts) - length):\n                right = left + length\n                dp[left][right] = float('inf')\n                for mid in range(left + 1, right):\n                    dp[left][right] = min(dp[left][right], dp[left][mid] + dp[mid][right] + cuts[right] - cuts[left])\n                    \n        return dp[0][-1]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16700000,
            "question_id": "1669",
            "elapsed_time": 682,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "7\n[1,3,4,5]",
            "expected_output": "16",
            "task_finish_time": 1699923969182,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 101,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098286634",
            "input_formatted": "7, [1,3,4,5]",
            "input": "7\n[1,3,4,5]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimize-maximum-pair-sum-in-array",
        "description": "The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\nFor example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\nEach element of nums is in exactly one pair, and\nThe maximum pair sum is minimized.\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.",
        "examples": [
            "Input: nums = [3,5,2,3]\r\nOutput: 7\r\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.",
            "Input: nums = [3,5,4,2,4,6]\r\nOutput: 8\r\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8."
        ],
        "constrains": "n == nums.length\n2 <= n <= 105\nn is even.\n1 <= nums[i] <= 105",
        "release_time": 1677615909,
        "oracle_code": "class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)-1\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort() # sort the array\n        n = len(nums)\n        result = -float('inf')\n        left = 0\n        right = n - 1\n        while left < right: # iterate until left pointer is less than right pointer\n            pair_sum = nums[left] + nums[right] # calculate pair sum\n            result = max(result, pair_sum) # update result if pair sum is greater\n            left += 1\n            right -= 1\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "960 ms",
            "memory": 30904000,
            "question_id": "1988",
            "elapsed_time": 990,
            "compare_result": "1111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699923984568,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 37,
            "total_testcases": 37,
            "runtime_percentile": 90.7333,
            "status_memory": "30.9 MB",
            "memory_percentile": 7.6072999999999995,
            "pretty_lang": "Python3",
            "submission_id": "1098286729",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1"
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
        "release_time": 1673811505,
        "oracle_code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost += 1\n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)",
        "content": "We re-use grid to keep track of `seen`.\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n\\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\\n        M, N = range(m), range(n)\\n\\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\\n\\n        def dfs(x: int,y: int)->None:\\n            while not seen(x,y):\\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\\n                queue.append((x,y))\\n                x,y = x+dx, y+dy\\n            return\\n\\n        dfs(0, 0)\\n\\n        while queue:\\n            if (m-1, n-1) in queue: return cost\\n            cost += 1\\n            q = len(queue)\\n\\n            for _ in range(q):\\n                x, y = queue.popleft()\\n                for dx,dy in dir[1:]:\\n                    dfs(x+dx, y+dy)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/submissions/878791604/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is worstcase\\n *O*(*MN*).",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # right, left, down, up\n        queue = [(0, 0, 0)] # (x, y, cost)\n        visited = set()\n        \n        while queue:\n            x, y, cost = queue.pop(0)\n            visited.add((x, y))\n            \n            if x == m-1 and y == n-1:\n                return cost\n            \n            for i in range(4):\n                dx, dy = directions[i]\n                nx, ny = x + dx, y + dy\n                \n                while 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    queue.append((nx, ny, cost))\n                    visited.add((nx, ny))\n                    if grid[nx][ny] == i + 1:\n                        break\n                    \n                    queue[-1] = (nx, ny, cost + 1)\n                    nx, ny = nx + dx, ny + dy\n        \n        return -1\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 18084000,
            "question_id": "1485",
            "elapsed_time": 278,
            "compare_result": "00101000001000000000000000001000000000000000000000000000000000000000",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]",
            "expected_output": "3",
            "task_finish_time": 1699923999096,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 68,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098286824",
            "input_formatted": "[[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]",
            "input": "[[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-missing-observations",
        "description": "You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls.\nYou are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n.\nReturn an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array.\nThe average value of a set of k numbers is the sum of the numbers divided by k.\nNote that mean is an integer, so the sum of the n + m rolls should be divisible by n + m.",
        "examples": [
            "Input: rolls = [3,2,4,3], mean = 4, n = 2\nOutput: [6,6]\nExplanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.",
            "Input: rolls = [1,5,6], mean = 3, n = 4\nOutput: [2,3,2,2]\nExplanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.",
            "Input: rolls = [1,2,3,4], mean = 6, n = 4\nOutput: []\nExplanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are."
        ],
        "constrains": "m == rolls.length\n1 <= n, m <= 105\n1 <= rolls[i], mean <= 6",
        "release_time": 1687268962,
        "oracle_code": "class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        curSum=sum(rolls)\n        obv=n+len(rolls)\n        missSum=mean*obv-curSum\n        if missSum>6*n or missSum<0 or missSum<n:\n            return []\n        x=missSum//n\n        res=[x]*n\n        remain=missSum-x*n\n        if remain>0:\n            more=6-x\n            add=remain//more\n            res=res[add:]+[6]*add\n            final=remain%more\n            res[0]+=final\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        curSum=sum(rolls)\\n        obv=n+len(rolls)\\n        missSum=mean*obv-curSum\\n        if missSum>6*n or missSum<0 or missSum<n:\\n            return []\\n        x=missSum//n\\n        res=[x]*n\\n        remain=missSum-x*n\\n        if remain>0:\\n            more=6-x\\n            add=remain//more\\n            res=res[add:]+[6]*add\\n            final=remain%more\\n            res[0]+=final\\n        return res\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        total = mean * (n + len(rolls))\n        current_sum = sum(rolls)\n        missing_sum = total - current_sum\n        \n        if missing_sum <= 0 or missing_sum > n * 6:\n            return []\n        \n        average = missing_sum // n\n        remaining = missing_sum % n\n        \n        result = [average] * n\n        for i in range(remaining):\n            result[i] += 1\n        \n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 26604000,
            "question_id": "2155",
            "elapsed_time": 1261,
            "compare_result": "1111111111111111101111111011111011111111111111111111111111111111",
            "code_output": "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0]",
            "std_output": "",
            "last_testcase": "[4,2,2,5,4,5,4,5,3,3,6,1,2,4,2,1,6,5,4,2,3,4,2,3,3,5,4,1,4,4,5,3,6,1,5,2,3,3,6,1,6,4,1,3]\n2\n53",
            "expected_output": "[]",
            "task_finish_time": 1699924015207,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 61,
            "total_testcases": 64,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098286922",
            "input_formatted": "[4,2,2,5,4,5,4,5,3,3,6,1,2,4,2,1,6,5,4,2,3,4,2,3,3,5,4,1,4,4,5,3,6,1,5,2,3,3,6,1,6,4,1,3], 2, 53",
            "input": "[4,2,2,5,4,5,4,5,3,3,6,1,2,4,2,1,6,5,4,2,3,4,2,3,3,5,4,1,4,4,5,3,6,1,5,2,3,3,6,1,6,4,1,3]\n2\n53",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-strength-of-a-group",
        "description": "You are given a 0-indexed integer array nums representing the score of students in an exam. The teacher would like to form one non-empty group of students with maximal strength, where the strength of a group of students of indices i0, i1, i2, ... , ik is defined as nums[i0] * nums[i1] * nums[i2] * ... * nums[ik\u200b].\nReturn the maximum strength of a group the teacher can create.",
        "examples": [
            "Input: nums = [3,-1,-5,2,5,-9]\nOutput: 1350\nExplanation: One way to form a group of maximal strength is to group the students at indices [0,2,3,4,5]. Their strength is 3 * (-5) * 2 * 5 * (-9) = 1350, which we can show is optimal.",
            "Input: nums = [-4,-5,-4]\nOutput: 20\nExplanation: Group the students at indices [0, 1] . Then, we\u2019ll have a resulting strength of 20. We cannot achieve greater strength."
        ],
        "constrains": "1 <= nums.length <= 13\n-9 <= nums[i] <= 9",
        "release_time": 1685204639,
        "oracle_code": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_memo, min_memo = nums[0], nums[0]\n        for num in nums[1:]:\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\n        return max_memo",
        "content": "# Approach\\nKeep track of minimum and maximum combinations.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_memo, min_memo = nums[0], nums[0]\\n        for num in nums[1:]:\\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\\n        return max_memo\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        n = len(nums)\n        max_prod = 0\n        \n        for i in range(n):\n            for j in range(i, n):\n                prod = 1\n                for k in range(i, j+1):\n                    prod *= nums[k]\n                max_prod = max(max_prod, prod)\n        \n        return max_prod\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16404000,
            "question_id": "2754",
            "elapsed_time": 98,
            "compare_result": "01110100110000010100010000011111001100110011011111111111011101111111110001001101100110001001101111101001100100101000001110001110100110011100101111111100100010000001110001101001000011111110101100101000110001101010111011110111010001110110100111101110111011100000111110010000111110110001111111101010010111010110001111101110111111011000110100100111111011100100011100011111001110000011100111101011111000010111011010011011110111111001111111001000001111010000010001001101101101100010011111110110110011100111101010111011101110000110111110110110110100001000010101110110101011111100011001101001111101011010001101111001010100011111111111100110001011001101110000101100111001010110101111011001101101010011010110111100100100110100101110101111011100101101000000100110011101011111001100110111001111111000100110100011011010101011111100110111100000111101111011011110011110010000011101100111101011011110101010111110101101001010001010101100101001111101001011110000010000111000010111101111101001101101110100001101111110110000000100011011111100001110111001000101000010100011010010101101111100001010110110101011111100110011010110011111101001101110110110011110111001101110111000100101001101111011111011111011110101100011111101111100101101110011011010011000101011100100011000000101011111101011000101100101100011100011110110011100011110101000000011101100010110000000001101110111010101001000111110000100101001001011010111100111100011111001111101111100010110011111010101111101000000001001011101010110100001111101001101100110000110111111111111111000011001100100001111000001111100011110000100010111101011000101010001101011010110010101010000111101010011101010011110111100011110101110110010011010101101101011000101101011111110000000001111010111111111101100100110101101001100010011110101011101101011011010110100111110101100111001111011001110111110011101010101110000011110110111110110000110110011111011000101000101111011011110100111101110111000111011000010011000010011000011111111110111010101111111110011100101111010100101111110111111011111111111",
            "code_output": "450",
            "std_output": "",
            "last_testcase": "[3,-1,-5,2,5,-9]",
            "expected_output": "1350",
            "task_finish_time": 1699924029010,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1155,
            "total_testcases": 2012,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098287016",
            "input_formatted": "[3,-1,-5,2,5,-9]",
            "input": "[3,-1,-5,2,5,-9]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "design-a-text-editor",
        "description": "Design a text editor with a cursor that can do the following:\n\nAdd text to where the cursor is.\nDelete text from where the cursor is (simulating the backspace key).\nMove the cursor either left or right.\n\nWhen deleting text, only characters to the left of the cursor will be deleted. The cursor will also remain within the actual text and cannot be moved beyond it. More formally, we have that 0 <= cursor.position <= currentText.length always holds.\nImplement the TextEditor class:\n\nTextEditor() Initializes the object with empty text.\nvoid addText(string text) Appends text to where the cursor is. The cursor ends to the right of text.\nint deleteText(int k) Deletes k characters to the left of the cursor. Returns the number of characters actually deleted.\nstring cursorLeft(int k) Moves the cursor to the left k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.\nstring cursorRight(int k) Moves the cursor to the right k times. Returns the last min(10, len) characters to the left of the cursor, where len is the number of characters to the left of the cursor.",
        "examples": [
            "Input\n[\"TextEditor\", \"addText\", \"deleteText\", \"addText\", \"cursorRight\", \"cursorLeft\", \"deleteText\", \"cursorLeft\", \"cursorRight\"]\n[[], [\"leetcode\"], [4], [\"practice\"], [3], [8], [10], [2], [6]]\nOutput\n[null, null, 4, null, \"etpractice\", \"leet\", 4, \"\", \"practi\"]\n\nExplanation\nTextEditor textEditor = new TextEditor(); // The current text is \"|\". (The '|' character represents the cursor)\ntextEditor.addText(\"leetcode\"); // The current text is \"leetcode|\".\ntextEditor.deleteText(4); // return 4\n                          // The current text is \"leet|\". \n                          // 4 characters were deleted.\ntextEditor.addText(\"practice\"); // The current text is \"leetpractice|\". \ntextEditor.cursorRight(3); // return \"etpractice\"\n                           // The current text is \"leetpractice|\". \n                           // The cursor cannot be moved beyond the actual text and thus did not move.\n                           // \"etpractice\" is the last 10 characters to the left of the cursor.\ntextEditor.cursorLeft(8); // return \"leet\"\n                          // The current text is \"leet|practice\".\n                          // \"leet\" is the last min(10, 4) = 4 characters to the left of the cursor.\ntextEditor.deleteText(10); // return 4\n                           // The current text is \"|practice\".\n                           // Only 4 characters were deleted.\ntextEditor.cursorLeft(2); // return \"\"\n                          // The current text is \"|practice\".\n                          // The cursor cannot be moved beyond the actual text and thus did not move. \n                          // \"\" is the last min(10, 0) = 0 characters to the left of the cursor.\ntextEditor.cursorRight(6); // return \"practi\"\n                           // The current text is \"practi|ce\".\n                           // \"practi\" is the last min(10, 6) = 6 characters to the left of the cursor."
        ],
        "constrains": "1 <= text.length, k <= 40\ntext consists of lowercase English letters.\nAt most 2 * 104 calls in total will be made to addText, deleteText, cursorLeft and cursorRight.\n\n\u00a0\nFollow-up: Could you find a solution with time complexity of O(k) per call?",
        "release_time": 1671134501,
        "oracle_code": "class TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n            \n\n\n\n       \n        \n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```",
        "level": "hard",
        "completed_code": "\nclass TextEditor:\n    def __init__(self):\n        self.currentText = \"\"\n        self.cursorPosition = 0\n\n    def addText(self, text: str) -> None:\n        self.currentText = self.currentText[:self.cursorPosition] + text + self.currentText[self.cursorPosition:]\n        self.cursorPosition += len(text)\n\n    def deleteText(self, k: int) -> int:\n        if k >= self.cursorPosition:\n            deleted = self.cursorPosition\n            self.currentText = self.currentText[self.cursorPosition:]\n            self.cursorPosition = 0\n            return deleted\n        else:\n            deleted = k\n            self.currentText = self.currentText[:self.cursorPosition - k] + self.currentText[self.cursorPosition:]\n            self.cursorPosition -= k\n            return deleted\n\n    def cursorLeft(self, k: int) -> str:\n        minLen = min(10, self.cursorPosition)\n        leftText = self.currentText[self.cursorPosition - k:self.cursorPosition]\n        self.cursorPosition = max(0, self.cursorPosition - k)\n        return leftText\n\n    def cursorRight(self, k: int) -> str:\n        minLen = min(10, len(self.currentText) - self.cursorPosition)\n        rightText = self.currentText[self.cursorPosition:self.cursorPosition + minLen]\n        self.cursorPosition = min(self.cursorPosition + k, len(self.currentText))\n        return rightText\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 31056000,
            "question_id": "2389",
            "elapsed_time": 1415,
            "compare_result": "001100111111110000000100010001000000001000000",
            "code_output": "[null,null,4,null,\"\",\"practice\",4,\"\",\"practice\"]",
            "std_output": "",
            "last_testcase": "[\"TextEditor\",\"addText\",\"deleteText\",\"addText\",\"cursorRight\",\"cursorLeft\",\"deleteText\",\"cursorLeft\",\"cursorRight\"]\n[[],[\"leetcode\"],[4],[\"practice\"],[3],[8],[10],[2],[6]]",
            "expected_output": "[null,null,4,null,\"etpractice\",\"leet\",4,\"\",\"practi\"]",
            "task_finish_time": 1699924046250,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 14,
            "total_testcases": 45,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098287123",
            "input_formatted": "[\"TextEditor\",\"addText\",\"deleteText\",\"addText\",\"cursorRight\",\"cursorLeft\",\"deleteText\",\"cursorLeft\",\"cursorRight\"], [[],[\"leetcode\"],[4],[\"practice\"],[3],[8],[10],[2],[6]]",
            "input": "[\"TextEditor\",\"addText\",\"deleteText\",\"addText\",\"cursorRight\",\"cursorLeft\",\"deleteText\",\"cursorLeft\",\"cursorRight\"]\n[[],[\"leetcode\"],[4],[\"practice\"],[3],[8],[10],[2],[6]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "description": "You are given a string s of length n where s[i] is either:\n\n'D' means decreasing, or\n'I' means increasing.\n\nA permutation perm of n + 1 integers of all the integers in the range [0, n] is called a valid permutation if for all valid i:\n\nIf s[i] == 'D', then perm[i] > perm[i + 1], and\nIf s[i] == 'I', then perm[i] < perm[i + 1].\n\nReturn the number of valid permutations perm. Since the answer may be large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"DID\"\nOutput: 5\nExplanation: The 5 valid permutations of (0, 1, 2, 3) are:\n(1, 0, 3, 2)\n(2, 0, 3, 1)\n(2, 1, 3, 0)\n(3, 0, 2, 1)\n(3, 1, 2, 0)",
            "Input: s = \"D\"\nOutput: 1"
        ],
        "constrains": "n == s.length\n1 <= n <= 200\ns[i] is either 'I' or 'D'.",
        "release_time": 1664693730,
        "oracle_code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        n = len(s)\n        mod = 10**9 + 7\n        dp = [[0] * (n+1) for _ in range(n+1)]\n        \n        # Initialization\n        dp[0][0] = 1\n               \n        # Dynamic Programming\n        for i in range(1, n+1):\n            for j in range(i+1):\n                \n                if s[i-1] == 'I':\n                    for k in range(j, i):\n                        dp[i][j] += dp[i-1][k]\n                        dp[i][j] %= mod\n                else:\n                    for k in range(j+1):\n                        dp[i][j] += dp[i-1][k]\n                        dp[i][j] %= mod\n        \n        # Calculate the total number of valid permutations\n        total = sum(dp[n])\n        total %= mod\n        \n        return total\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17164000,
            "question_id": "939",
            "elapsed_time": 1070,
            "compare_result": "00100010000000100000000000000010000000000000000000000000000000100000000000000000000",
            "code_output": "11",
            "std_output": "",
            "last_testcase": "\"DID\"",
            "expected_output": "5",
            "task_finish_time": 1699924060903,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 5,
            "total_testcases": 83,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098287210",
            "input_formatted": "\"DID\"",
            "input": "\"DID\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "partition-labels",
        "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.",
        "examples": [
            "Input: s = \"ababcbacadefegdehijhklij\"\nOutput: [9,7,8]\nExplanation:\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.",
            "Input: s = \"eccbbbbdec\"\nOutput: [10]"
        ],
        "constrains": "1 <= s.length <= 500\ns consists of lowercase English letters.",
        "release_time": 1647825179,
        "oracle_code": "class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        L = len(s)\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\n        i, ans = 0, []\n        while i < L:\n            end, j = last[s[i]], i + 1\n            while j < end: # validation of the part [i, end]\n                if last[s[j]] > end:\n                    end = last[s[j]] # extend the part\n                j += 1\n           \n            ans.append(end - i + 1)\n            i = end + 1\n            \n        return ans",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nSince each letter can appear only in one part, we cannot form a part shorter than the index of the last appearance of a letter subtracted by an index of the first appearance. For example here (**a**bsf**a**b) the lengths of the first part are limited by the positions of the letter `a`. So it\\'s important to know at what index each letter appears in the string last time. We can create a hash map and fill it with the last indexes for letters.\\n\\nAlso, we have to validate a candidate part. For the same example (**a***b*sfa**b**) we see that letter `a` cannot form a border for the first part because of a nasty letter `b` inside. So we need to expand the range of the initial part.\\n\\nTime: **O(n)** - 2 sweeps\\nSpace: **O(1)** - hashmap consist of max 26 keys\\n\\nRuntime: 36 ms, faster than **96.88%** of Python3 online submissions for Partition Labels.\\nMemory Usage: 13.8 MB, less than **98.78%** of Python3 online submissions for Partition Labels.\\n\\n```\\nclass Solution:\\n    def partitionLabels(self, s: str) -> List[int]:\\n        L = len(s)\\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\\n        i, ans = 0, []\\n        while i < L:\\n            end, j = last[s[i]], i + 1\\n            while j < end: # validation of the part [i, end]\\n                if last[s[j]] > end:\\n                    end = last[s[j]] # extend the part\\n                j += 1\\n           \\n            ans.append(end - i + 1)\\n            i = end + 1\\n            \\n        return ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        last_index = {}\n        for i, char in enumerate(s):\n            last_index[char] = i\n        \n        result = []\n        start = 0\n        end = 0\n        for i, char in enumerate(s):\n            end = max(end, last_index[char])\n            if i == end:\n                result.append(end - start + 1)\n                start = i + 1\n                \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "45 ms",
            "memory": 16220000,
            "question_id": "768",
            "elapsed_time": 80,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924074937,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 118,
            "total_testcases": 118,
            "runtime_percentile": 58.9011,
            "status_memory": "16.2 MB",
            "memory_percentile": 39.3264,
            "pretty_lang": "Python3",
            "submission_id": "1098287300",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constrains": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic.",
        "release_time": 1658785219,
        "oracle_code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        # Create the adjacency list representation of the graph\n        graph = [[] for _ in range(n)]\n        for edge in edges:\n            from_node, to_node = edge\n            graph[to_node].append(from_node)\n        \n        # Create a list to store the ancestors for each node\n        ancestors = [[] for _ in range(n)]\n        \n        # DFS function to find ancestors for a node\n        def dfs(node, path):\n            for parent in graph[node]:\n                path.append(parent)\n                dfs(parent, path)\n        \n        # Find ancestors for each node using DFS\n        for node in range(n):\n            path = [node]\n            dfs(node, path)\n            ancestors[node] = sorted(path)\n        \n        return ancestors\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "node-with-highest-edge-score",
        "description": "You are given a directed graph with n nodes labeled from 0 to n - 1, where each node has exactly one outgoing edge.\nThe graph is represented by a given 0-indexed integer array edges of length n, where edges[i] indicates that there is a directed edge from node i to node edges[i].\nThe edge score of a node i is defined as the sum of the labels of all the nodes that have an edge pointing to i.\nReturn the node with the highest edge score. If multiple nodes have the same edge score, return the node with the smallest index.",
        "examples": [
            "Input: edges = [1,0,0,0,0,7,7,5]\nOutput: 7\nExplanation:\n- The nodes 1, 2, 3 and 4 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 + 3 + 4 = 10.\n- The node 0 has an edge pointing to node 1. The edge score of node 1 is 0.\n- The node 7 has an edge pointing to node 5. The edge score of node 5 is 7.\n- The nodes 5 and 6 have an edge pointing to node 7. The edge score of node 7 is 5 + 6 = 11.\nNode 7 has the highest edge score so return 7.",
            "Input: edges = [2,0,0,2]\nOutput: 0\nExplanation:\n- The nodes 1 and 2 have an edge pointing to node 0. The edge score of node 0 is 1 + 2 = 3.\n- The nodes 0 and 3 have an edge pointing to node 2. The edge score of node 2 is 0 + 3 = 3.\nNodes 0 and 2 both have an edge score of 3. Since node 0 has a smaller index, we return 0."
        ],
        "constrains": "n == edges.length\n2 <= n <= 105\n0 <= edges[i] < n\nedges[i] != i",
        "release_time": 1673006370,
        "oracle_code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n = len(edges)\n        scores = [0] * n\n        \n        for i in range(n):\n            if edges[i] != -1:\n                scores[edges[i]] += i\n        \n        max_score = max(scores)\n        highest_score_node = scores.index(max_score)\n        return highest_score_node\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1035 ms",
            "memory": 30280000,
            "question_id": "2455",
            "elapsed_time": 1121,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924106175,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 118,
            "total_testcases": 118,
            "runtime_percentile": 44.34279999999994,
            "status_memory": "30.3 MB",
            "memory_percentile": 70.58819999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098287499",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "plates-between-candles",
        "description": "There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle.\nYou are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring.\n\nFor example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: s = \"**|**|***|\", queries = [[2,5],[5,9]]\nOutput: [2,3]\nExplanation:\n- queries[0] has two plates between candles.\n- queries[1] has three plates between candles.",
            "Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]]\nOutput: [9,0,0,0,0]\nExplanation:\n- queries[0] has nine plates between candles.\n- The other queries have zero plates between candles."
        ],
        "constrains": "3 <= s.length <= 105\ns consists of '*' and '|' characters.\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= lefti <= righti < s.length",
        "release_time": 1689465278,
        "oracle_code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        def bns(x: int) -> int:\n            left_plate = right_plate = 0\n            for i in range(len(s)):\n                if s[i] == '|':\n                    if i < x:\n                        left_plate += 1\n                    else:\n                        right_plate += 1\n            return min(left_plate, right_plate)\n        \n        res = []\n        for query in queries:\n            left, right = query\n            res.append(bns(right) - bns(left))\n            \n        return res\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "longest-harmonious-subsequence",
        "description": "We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\nGiven an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\nA subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.",
        "examples": [
            "Input: nums = [1,3,2,2,5,2,3,7]\r\nOutput: 5\r\nExplanation: The longest harmonious subsequence is [3,2,2,2,3].",
            "Input: nums = [1,2,3,4]\r\nOutput: 2",
            "Input: nums = [1,1,1,1]\r\nOutput: 0"
        ],
        "constrains": "1 <= nums.length <= 2 * 104\n-109 <= nums[i] <= 109",
        "release_time": 1690719700,
        "oracle_code": "class Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] += 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 1], result)\n        return result",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a count map holding occurences on elements and loop on keys to check if next consecutive element is present in the map.\\nIf present, compare the result with the max variable\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findLHS(self, nums: List[int]) -> int:\\n        result = 0\\n        count_map = {}\\n        for num in nums:\\n            if num not in count_map:\\n                count_map[num] = 1\\n            else:\\n                count_map[num] += 1\\n        for num, count in count_map.items():\\n            if num + 1 in count_map:\\n                result = max(count + count_map[num + 1], result)\\n        return result\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        frequency = {}\n        for num in nums:\n            frequency[num] = frequency.get(num, 0) + 1\n        \n        longest_subsequence = 0\n        for num in nums:\n            if num + 1 in frequency:\n                longest_subsequence = max(longest_subsequence, frequency[num] + frequency[num + 1])\n        \n        return longest_subsequence\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "276 ms",
            "memory": 18296000,
            "question_id": "594",
            "elapsed_time": 297,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924135481,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 206,
            "total_testcases": 206,
            "runtime_percentile": 41.612899999999975,
            "status_memory": "18.3 MB",
            "memory_percentile": 58.0201,
            "pretty_lang": "Python3",
            "submission_id": "1098287694",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "description": "Given an integer array nums and an integer k, return the kth largest element in the array.\nNote that it is the kth largest element in the sorted order, not the kth distinct element.\nCan you solve it without sorting?",
        "examples": [
            "Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5",
            "Input: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-104 <= nums[i] <= 104",
        "release_time": 1691989741,
        "oracle_code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```",
        "level": "medium",
        "completed_code": "\nimport heapq\n\nclass Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        # Initialize a minHeap\n        minHeap = []\n        \n        # Iterate through the nums\n        for num in nums:\n            # If the heap size is less than k, push the number into the heap\n            if len(minHeap) < k:\n                heapq.heappush(minHeap, num)\n            \n            # If the heap size is equal to k, push the number into the heap and pop the smallest number\n            elif num > minHeap[0]:\n                heapq.heappushpop(minHeap, num)\n        \n        # After the iteration, the kth largest element will be at the top of the heap\n        return minHeap[0]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "508 ms",
            "memory": 29520000,
            "question_id": "215",
            "elapsed_time": 551,
            "compare_result": "11111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924150711,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 41,
            "runtime_percentile": 78.02680000000004,
            "status_memory": "29.5 MB",
            "memory_percentile": 37.29500000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098287791",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-subtrees-with-max-distance-between-cities",
        "description": "There are n cities numbered from 1 to n. You are given an array edges of size n-1, where edges[i] = [ui, vi] represents a bidirectional edge between cities ui and vi. There exists a unique path between each pair of cities. In other words, the cities form a tree.\nA subtree is a subset of cities where every city is reachable from every other city in the subset, where the path between each pair passes through only the cities from the subset. Two subtrees are different if there is a city in one subtree that is not present in the other.\nFor each d from 1 to n-1, find the number of subtrees in which the maximum distance between any two cities in the subtree is equal to d.\nReturn an array of size n-1 where the dth element (1-indexed) is the number of subtrees in which the maximum distance between any two cities is equal to d.\nNotice\u00a0that\u00a0the distance between the two cities is the number of edges in the path between them.",
        "examples": [
            "Input: n = 4, edges = [[1,2],[2,3],[2,4]]\r\nOutput: [3,4,0]\r\nExplanation:\r\nThe subtrees with subsets {1,2}, {2,3} and {2,4} have a max distance of 1.\r\nThe subtrees with subsets {1,2,3}, {1,2,4}, {2,3,4} and {1,2,3,4} have a max distance of 2.\r\nNo subtree has two nodes where the max distance between them is 3.",
            "Input: n = 2, edges = [[1,2]]\r\nOutput: [1]",
            "Input: n = 3, edges = [[1,2],[2,3]]\r\nOutput: [2,1]"
        ],
        "constrains": "2 <= n <= 15\nedges.length == n-1\nedges[i].length == 2\n1 <= ui, vi <= n\nAll pairs (ui, vi) are distinct.",
        "release_time": 1687072167,
        "oracle_code": "class Solution:\n    # odd/even diameter couned individually\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(n)]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\n            if len(q)<len(p): p,q = q,p\n            res = [0]*len(q)\n            res[0] = p[0]*q[0]\n            for i in range(1,len(p)): p[i] += p[i-1]\n            for i in range(1,len(q)): q[i] += q[i-1]\n            for i in range(1,len(p)):\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\n            for i in range(len(p),len(q)):\n                res[i] = (q[i]-q[i-1])*p[-1]\n            return res\n            \n        def dfs(r,p): # num of subtree rooted at r with given depth\n            d = [1]\n            for v in adj[r]:\n                if v==p: continue\n                t = [1]+dfs(v,r)\n                d = comb(t,d)\n            return d\n        #end dfs\n        ans = [0]*n\n        # odd diameter with (u,v) as center edge\n        for u,v in edges:\n            u -= 1; v-=1\n            p = dfs(u,v)\n            q = dfs(v,u)\n            for i in range(min(len(p),len(q))):\n                ans[i+i+1] += p[i]*q[i]\n        #even diamter with v as center vertex\n        for v in range(n): \n            if len(adj[v])==1: continue \n            tree = [1]+dfs(adj[v][0],v) #tree with depth\n            curr = [0]*n\n            for u in adj[v][1:]:\n                q = [1]+dfs(u,v)\n                # curr tree + new small\n                j = 1; t = q[1]+1 # prefix sum of q\n                for i in range(4,n,2):\n                    while j+1<min(i//2,len(q)):\n                        j += 1; t += q[j]\n                    curr[i] *= t\n                # curr tree + same height\n                for i in range(min(len(tree),len(q))):\n                    curr[i+i] += tree[i]*q[i]\n                tree = comb(tree,q)\n            for i in range(2,n,2):\n                ans[i] += curr[i]\n        #end\n        return ans[1:]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA (sub)tree may have many diameters, but there is exactly one or two centers. To simplfying the implementation, we divide into two cases: diameter is even or odd. For the case of even diameter, we  count the subtrees by enumerating each vertex as the center. For the case of odd diameter, we enumerate each edge as the center. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each node $v$ as the center, we root the tree at $v$ and do a DFS. When visiting a vertex $u$, we recursively compute the number of subtrees rooted at $u$ and with depth $i$, for each possible $i$.\\nWhen combining the results from the children of $u$, a naive implementation takes $O(deg(u)\\\\times n^2)$ time. By using prefix sum, it can be reduced to $O(deg(u)\\\\times n)$ time. Thus a DFS takes $O(n^2)$ since the total degree of a tree is $O(n)$.\\nAt root $v$, we combine the results from its children. Since we care about only even diameter and centered at $v$, two branches of same depth $i$ form a subtree of diamter $2i$. When combining the branches one by one, we need to count the way that a current subtree is merged with a small incoming subtree which does not change its diameter.\\nThe case of odd diameter is similar and simpler since there are only two branches for each center edge.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^3)$ since each center vertex takes $O(n^2)$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLinear.\\n\\n# Code\\n```\\nclass Solution:\\n    # odd/even diameter couned individually\\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\\n        adj = [[] for i in range(n)]\\n        for u,v in edges:\\n            adj[u-1].append(v-1)\\n            adj[v-1].append(u-1)\\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\\n            if len(q)<len(p): p,q = q,p\\n            res = [0]*len(q)\\n            res[0] = p[0]*q[0]\\n            for i in range(1,len(p)): p[i] += p[i-1]\\n            for i in range(1,len(q)): q[i] += q[i-1]\\n            for i in range(1,len(p)):\\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\\n            for i in range(len(p),len(q)):\\n                res[i] = (q[i]-q[i-1])*p[-1]\\n            return res\\n            \\n        def dfs(r,p): # num of subtree rooted at r with given depth\\n            d = [1]\\n            for v in adj[r]:\\n                if v==p: continue\\n                t = [1]+dfs(v,r)\\n                d = comb(t,d)\\n            return d\\n        #end dfs\\n        ans = [0]*n\\n        # odd diameter with (u,v) as center edge\\n        for u,v in edges:\\n            u -= 1; v-=1\\n            p = dfs(u,v)\\n            q = dfs(v,u)\\n            for i in range(min(len(p),len(q))):\\n                ans[i+i+1] += p[i]*q[i]\\n        #even diamter with v as center vertex\\n        for v in range(n): \\n            if len(adj[v])==1: continue \\n            tree = [1]+dfs(adj[v][0],v) #tree with depth\\n            curr = [0]*n\\n            for u in adj[v][1:]:\\n                q = [1]+dfs(u,v)\\n                # curr tree + new small\\n                j = 1; t = q[1]+1 # prefix sum of q\\n                for i in range(4,n,2):\\n                    while j+1<min(i//2,len(q)):\\n                        j += 1; t += q[j]\\n                    curr[i] *= t\\n                # curr tree + same height\\n                for i in range(min(len(tree),len(q))):\\n                    curr[i+i] += tree[i]*q[i]\\n                tree = comb(tree,q)\\n            for i in range(2,n,2):\\n                ans[i] += curr[i]\\n        #end\\n        return ans[1:]\\n\\n\\n```\\n",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        def comb(p, q):\n            # Helper function to calculate the combination of p choose q\n            if q > p:\n                return 0\n            num = 1\n            den = 1\n            for i in range(q):\n                num *= (p-i)\n                den *= (i+1)\n            return num // den\n\n        def dfs(r, p):\n            # Depth-first search to calculate the maximum distance in a tree/subtree\n            # r: current node\n            # p: previous node\n            max_distance = 0\n            for neighbor in graph[r]:\n                if neighbor != p:\n                    distance = dfs(neighbor, r) + 1\n                    max_distance = max(max_distance, distance)\n            return max_distance\n\n        # Create an adjacency list to represent the graph\n        graph = [[] for _ in range(n+1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        result = [0] * (n-1)\n\n        # Enumerate all possible subsets of cities\n        for subset in range(1, 1 << n):\n            # Check if the subset forms a tree\n            valid = True\n            for i in range(1, n+1):\n                if (subset >> (i-1)) & 1:\n                    if len(graph[i]) < 2:\n                        valid = False\n                        break\n            if not valid:\n                continue\n\n            # Calculate the maximum distance in the tree/subtree\n            max_distance = 0\n            for i in range(1, n+1):\n                if (subset >> (i-1)) & 1:\n                    max_distance = max(max_distance, dfs(i, 0))\n\n            # Count the number of subtrees with maximum distance equal to d\n            for d in range(1, max_distance+1):\n                result[d-1] += 1\n        \n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16412000,
            "question_id": "1740",
            "elapsed_time": 508,
            "compare_result": "0000000000000000000000000000000",
            "code_output": "[1,0,0]",
            "std_output": "",
            "last_testcase": "4\n[[1,2],[2,3],[2,4]]",
            "expected_output": "[3,4,0]",
            "task_finish_time": 1699924170717,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 31,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098287919",
            "input_formatted": "4, [[1,2],[2,3],[2,4]]",
            "input": "4\n[[1,2],[2,3],[2,4]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constrains": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "release_time": 1677700522,
        "oracle_code": "class Solution:                                 \n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\n\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\n\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]",
        "content": "I think the time% and space% on this problem are extremely skewed because of the scofflaws who used`sort()`,`sorted`or`heapq`, not heeding the admonition on using \"built-in functions.\".\\n\\nUsing `Counter`,`chain`,`max`,or,`mn` techically makes me a scofflaw too, so I included a non-scofflaw version below as well.\\n\\nMy scofflaw version:\\n```\\nclass Solution:                                 \\n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\\n\\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\\n\\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \\n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]   \\n                    \\n\\n```\\n\\nNon-scofflaw:\\n```\\nclass Solution:\\n    def sortArray(self, nums: list[int]) -> list[int]: \\n\\n        ans, nSet, mx, mn = [],set(nums),nums[0],nums[0]\\n        d = {n:0 for n in nSet}\\n\\n        for n in nums: d[n]+= 1\\n\\n        for n in d:\\n            if n > mx: mx = n\\n            if n < mn: mn = n\\n\\n        for i in range(mn, mx+1):\\n            if i not in d: continue\\n            ans+= [i]*d[i]\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/sort-an-array/submissions/1007234945/](http://)\\n\\n\\nI could be wrong, but I think for each that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sortArray(self,nums:list[int]) -> list[int]:\n        if len(nums) <= 1:\n            return nums\n        \n        pivot = nums[len(nums)//2]\n        left = [num for num in nums if num < pivot]\n        middle = [num for num in nums if num == pivot]\n        right = [num for num in nums if num > pivot]\n        \n        return self.sortArray(left) + middle + self.sortArray(right)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "find-a-value-of-a-mysterious-function-closest-to-target",
        "description": "Winston was given the above mysterious function func. He has an integer array arr and an integer target and he wants to find the values l and r that make the value |func(arr, l, r) - target| minimum possible.\nReturn the minimum possible value of |func(arr, l, r) - target|.\nNotice that func should be called with the values l and r where 0 <= l, r < arr.length.",
        "examples": [
            "Input: arr = [9,12,3,7,15], target = 5\nOutput: 2\nExplanation: Calling func with all the pairs of [l,r] = [[0,0],[1,1],[2,2],[3,3],[4,4],[0,1],[1,2],[2,3],[3,4],[0,2],[1,3],[2,4],[0,3],[1,4],[0,4]], Winston got the following results [9,12,3,7,15,8,0,3,7,0,0,3,0,0,0]. The value closest to 5 is 7 and 3, thus the minimum difference is 2.",
            "Input: arr = [1000000,1000000,1000000], target = 1\nOutput: 999999\nExplanation: Winston called the func with all possible values of [l,r] and he always got 1000000, thus the min difference is 999999.",
            "Input: arr = [1,2,4,8,16], target = 0\nOutput: 0"
        ],
        "constrains": "1 <= arr.length <= 105\n1 <= arr[i] <= 106\n0 <= target <= 107",
        "release_time": 1595299867,
        "oracle_code": "class Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        ans, seen = inf, set()\n        for x in arr: \n            seen = {ss & x for ss in seen} | {x}\n            ans = min(ans, min(abs(ss - target) for ss in seen))\n        return ans",
        "content": "Algo\\n[Bitwise operations](https://en.wikipedia.org/wiki/Bitwise_operation) can be efficiently carried out in the bit space. Here, the focus is \"bitwise and\", and an important property of \"bitwise and\" is that its result cannot be larger than its operands since no unset bits could be set. Furthermore, given a series of number `x1, x2, ..., xn`, their prefix \"bitwise and\", e..g `x1, x1&x2, x1&x2&x3, ...` can only populate a very small space due to the fact that the bits got unset **sequentially**. For example, if `x1` has `p` set bits, then the above series has at most `p` distinctive numbers. This is a very small set for any numbering system be it 32-bit or 64-bit. \\n\\nUtilizing this property, this question can be solved in `O(N)` time in contrast to the brute force `O(N^2)` like below which I learned from @qqwqert007 in this [post](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743381/Python-6-lines-O(nlogm)-solution). \\n\\n```\\nclass Solution:\\n    def closestToTarget(self, arr: List[int], target: int) -> int:\\n        ans, seen = inf, set()\\n        for x in arr: \\n            seen = {ss & x for ss in seen} | {x}\\n            ans = min(ans, min(abs(ss - target) for ss in seen))\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def closestToTarget(self, arr: List[int], target: int) -> int:\\n        ans, seen = inf, set()\\n        for x in arr: \\n            tmp = set() #new set \\n            seen.add(0xffffffff)\\n            for ss in seen:\\n                ss &= x\\n                ans = min(ans, abs(ss - target))\\n                if ss > target: tmp.add(ss) #fine tuning \\n            seen = tmp\\n        return ans \\n```\\n\\nA related question is [201. Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range/) for which bitwise and is applied to a range. This again can be computed very efficiently if we focus on the much smaller space of possible bits instead of the vast range of numbers. \\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m: \\n            n &= n-1 #unset last set bit\\n        return n \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        n = len(arr)\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i, n):\n                diff = abs(func(arr, i, j) - target)\n                min_diff = min(min_diff, diff)\n        return min_diff\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 8: NameError: name 'func' is not defined. Did you mean: 'trunc'?",
            "full_runtime_error": "NameError: name 'func' is not defined. Did you mean: 'trunc'?\n    diff = abs(func(arr, i, j) - target)\nLine 8 in closestToTarget (Solution.py)\n    ret = Solution().closestToTarget(param_1, param_2)\nLine 35 in _driver (Solution.py)\n    _driver()\nLine 46 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16424000,
            "question_id": "1645",
            "elapsed_time": 53,
            "compare_result": "0000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[9,12,3,7,15]\n5",
            "expected_output": "2",
            "task_finish_time": 1699924200529,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 43,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098288122",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "description": "Given a rectangular pizza represented as a rows x cols\u00a0matrix containing the following characters: 'A' (an apple) and '.' (empty cell) and given the integer k. You have to cut the pizza into k pieces using k-1 cuts.\u00a0\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\nReturn the number of ways of cutting the pizza such that each piece contains at least one apple.\u00a0Since the answer can be a huge number, return this modulo 10^9 + 7.",
        "examples": [
            "Input: pizza = [\"A..\",\"AAA\",\"...\"], k = 3\nOutput: 3 \nExplanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.",
            "Input: pizza = [\"A..\",\"AA.\",\"...\"], k = 3\nOutput: 1",
            "Input: pizza = [\"A..\",\"A..\",\"...\"], k = 1\nOutput: 1"
        ],
        "constrains": "1 <= rows, cols <= 50\nrows ==\u00a0pizza.length\ncols ==\u00a0pizza[i].length\n1 <= k <= 10\npizza consists of characters 'A'\u00a0and '.' only.",
        "release_time": 1680234826,
        "oracle_code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.rows = len(pizza)\n        self.cols = len(pizza[0])\n        self.dp = [[[-1] * k for _ in range(self.cols)] for _ in range(self.rows)]\n        self.prefix = [[0] * (self.cols + 1) for _ in range(self.rows + 1)]\n        for i in range(self.rows):\n            for j in range(self.cols):\n                self.prefix[i+1][j+1] = self.prefix[i+1][j] + self.prefix[i][j+1] - self.prefix[i][j] + (pizza[i][j] == 'A')\n        return self.getWays(0, 0, k-1)\n\n    def getWays(self, i, j, k):\n        if k == 0:\n            return self.prefix[self.rows][self.cols] > 0\n        if self.dp[i][j][k] != -1:\n            return self.dp[i][j][k]\n        ways = 0\n        for r in range(i+1, self.rows):\n            if self.prefix[r][self.cols] - self.prefix[i][self.cols] > 0 and self.prefix[self.rows][self.cols] - self.prefix[r][self.cols] > 0:\n                ways += self.getWays(r, j, k-1)\n        for c in range(j+1, self.cols):\n            if self.prefix[self.rows][c] - self.prefix[self.rows][j] > 0 and self.prefix[self.rows][self.cols] - self.prefix[self.rows][c] > 0:\n                ways += self.getWays(i, c, k-1)\n        self.dp[i][j][k] = ways % 1000000007\n        return self.dp[i][j][k]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17144000,
            "question_id": "1555",
            "elapsed_time": 299,
            "compare_result": "000001000000110001100000000000001000100010000000100000",
            "code_output": "5",
            "std_output": "",
            "last_testcase": "[\"A..\",\"AAA\",\"...\"]\n3",
            "expected_output": "3",
            "task_finish_time": 1699924220081,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 9,
            "total_testcases": 54,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098288260",
            "input_formatted": "[\"A..\",\"AAA\",\"...\"], 3",
            "input": "[\"A..\",\"AAA\",\"...\"]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constrains": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.",
        "release_time": 1692505877,
        "oracle_code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        n = len(digits)\n        \n        # Start from rightmost digit\n        for i in range(n-1, -1, -1):\n            # If current digit < 9, then we can simply increment it by 1 and return\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                # If current digit is 9, then set it to 0 and continue to the next digit\n                digits[i] = 0\n        \n        # If all digits are 9, then we need to add an additional digit 1 at the beginning\n        digits.insert(0, 1)\n        return digits\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "40 ms",
            "memory": 16292000,
            "question_id": "66",
            "elapsed_time": 60,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924234567,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 111,
            "total_testcases": 111,
            "runtime_percentile": 54.357499999999995,
            "status_memory": "16.3 MB",
            "memory_percentile": 32.1566,
            "pretty_lang": "Python3",
            "submission_id": "1098288356",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "most-common-word",
        "description": "Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.",
        "examples": [
            "Input: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.",
            "Input: paragraph = \"a.\", banned = []\nOutput: \"a\""
        ],
        "constrains": "1 <= paragraph.length <= 1000\nparagraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n0 <= banned.length <= 100\n1 <= banned[i].length <= 10\nbanned[i] consists of only lowercase English letters.",
        "release_time": 1663933249,
        "oracle_code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]",
        "level": "easy",
        "completed_code": "\nimport re\nfrom typing import List\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        word_count = {}\n        words = re.findall(r'\\w+', paragraph.lower())\n        \n        for word in words:\n            if word not in banned:\n                if word in word_count:\n                    word_count[word] += 1\n                else:\n                    word_count[word] = 1\n        \n        most_common_word = max(word_count, key=word_count.get)\n        \n        return most_common_word.lower()\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "45 ms",
            "memory": 16260000,
            "question_id": "837",
            "elapsed_time": 58,
            "compare_result": "111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924249544,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 48,
            "total_testcases": 48,
            "runtime_percentile": 42.94799999999999,
            "status_memory": "16.3 MB",
            "memory_percentile": 64.93019999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098288459",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "rings-and-rods",
        "description": "There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\nYou are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n\nThe first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\nThe second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n\nFor example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\nReturn the number of rods that have all three colors of rings on them.",
        "examples": [
            "Input: rings = \"B0B6G0R6R0R6G9\"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.",
            "Input: rings = \"B0R0G0R9R0B0G0\"\nOutput: 1\nExplanation: \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.",
            "Input: rings = \"G4\"\nOutput: 0\nExplanation: \nOnly one ring is given. Thus, no rods have all three colors."
        ],
        "constrains": "rings.length == 2 * n\n1 <= n <= 100\nrings[i] where i is even is either 'R', 'G', or 'B' (0-indexed).\nrings[i] where i is odd is a digit from '0' to '9' (0-indexed).",
        "release_time": 1689053900,
        "oracle_code": "class Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1])\n                if len(set(rgb))==3:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPoints(self, rings: str) -> int:\\n        lst=[]\\n        rgb=[]\\n        count=0\\n        for i in range(1,len(rings),2):\\n            rgb=[]\\n            if rings[i] not in lst:\\n                lst.append(rings[i])\\n                for j in range(1,len(rings),2):\\n                    if rings[j]==rings[i]:\\n                        if rings[j-1]==\\'R\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'G\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'B\\':\\n                            rgb.append(rings[j-1])\\n                if len(set(rgb))==3:\\n                    count+=1\\n        return count\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def countPoints(self, rings: str) -> int:\n        rods = [0] * 10\n        count = 0\n        \n        for i in range(0, len(rings), 2):\n            color = rings[i]\n            rod = int(rings[i+1])\n            \n            if rods[rod] == 2:\n                count += 1\n            \n            rods[rod] += 1\n            \n            if rods[rod] == 3:\n                count -= 1\n        \n        return count\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16228000,
            "question_id": "2226",
            "elapsed_time": 53,
            "compare_result": "001111101111111110000101110100010000000000000010000000000011111000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "\"B0B6G0R6R0R6G9\"",
            "expected_output": "1",
            "task_finish_time": 1699924264582,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 26,
            "total_testcases": 66,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098288573",
            "input_formatted": "\"B0B6G0R6R0R6G9\"",
            "input": "\"B0B6G0R6R0R6G9\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "row-with-maximum-ones",
        "description": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.",
        "examples": [
            "Input: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1].",
            "Input: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].",
            "Input: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2]."
        ],
        "constrains": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 100\u00a0\nmat[i][j] is either 0 or 1.",
        "release_time": 1692366523,
        "oracle_code": "class Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        maxValue = 0\n        index = 0\n        for m in range(len(mat)):\n            sumN = 0\n            sumN = sum(mat[m])\n            if sumN > maxValue:\n                index =  m\n            maxValue=max(maxValue,sumN)\n        return [index,maxValue]",
        "content": "![Screenshot_307.png](https://assets.leetcode.com/users/images/13fcd1a5-36fc-46f8-9070-42c6b3c3ae79_1692366483.620762.png)\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        row_count = len(mat)\n        col_count = len(mat[0])\n        \n        max_ones = 0\n        max_ones_row = 0\n        \n        for row in range(row_count):\n            count = 0\n            for col in range(col_count):\n                if mat[row][col] == 1:\n                    count += 1\n            if count > max_ones:\n                max_ones = count\n                max_ones_row = row\n        \n        return [max_ones_row, max_ones]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "851 ms",
            "memory": 16816000,
            "question_id": "2737",
            "elapsed_time": 1006,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924280628,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1049,
            "total_testcases": 1049,
            "runtime_percentile": 30.28269999999998,
            "status_memory": "16.8 MB",
            "memory_percentile": 30.781999999999982,
            "pretty_lang": "Python3",
            "submission_id": "1098288666",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1684130489,
        "oracle_code": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return b",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        n = len(derived)\n        for i in range(n):\n            if derived[i] == (derived[i-1] ^ derived[(i+1)%n]):\n                return False\n        return True\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 20124000,
            "question_id": "2792",
            "elapsed_time": 1990,
            "compare_result": "011000111000000000110101100101110101010110101001101001100011011101010010110001001101101000001100101101010010001000101100100111000101000010011111110010110000110011001001110101100010010100010001011100001101000010011111010100011010000011011001111101111000110001011001011001011011001100101011010100110010001001100011011011001010111001010001010000111001001101101111100111110000101010101101100101100110111010010101101000000001110100010100110001000100101000010011011000100101010101010011100000000000100001100000010010111110000111100010011111101100010110101100010000110101111100111001000001111101100110111000111000101110111101100110011100000001111001101010111101000111000000010000100011101011111001111100111000000101001110001101010011111111101110100001110101101101000011001000110100010101011000110111101011111111101101001000111111110001000111010100010010101101100000001111000110011101101100101100011100001001100011011100110011000000010010000010110111100000011010101010110001011011010111000010000101110000001001111101011111101010001000011110000010010101001001111111000010100101010001010110010110011101000010101111110010111000111101011011111000111100100101100010000001010011110100101100110101010111000011111101111001011010110011001100001001011111010001011110011101000110011101100001110111111011011000101011011100000000100000000011000010110001101010100110100100010110010100100000011011101111100011101010110110100111010101000001110110010",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "[1,1,0]",
            "expected_output": "true",
            "task_finish_time": 1699924296727,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 694,
            "total_testcases": 1425,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098288770",
            "input_formatted": "[1,1,0]",
            "input": "[1,1,0]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-the-value-of-the-partition",
        "description": "You are given a positive integer array nums.\nPartition nums into two arrays,\u00a0nums1 and nums2, such that:\n\nEach element of the array nums belongs to either the array nums1 or the array nums2.\nBoth arrays are non-empty.\nThe value of the partition is minimized.\n\nThe value of the partition is |max(nums1) - min(nums2)|.\nHere, max(nums1) denotes the maximum element of the array nums1, and min(nums2) denotes the minimum element of the array nums2.\nReturn the integer denoting the value of such partition.",
        "examples": [
            "Input: nums = [1,3,2,4]\nOutput: 1\nExplanation: We can partition the array nums into nums1 = [1,2] and nums2 = [3,4].\n- The maximum element of the array nums1 is equal to 2.\n- The minimum element of the array nums2 is equal to 3.\nThe value of the partition is |2 - 3| = 1. \nIt can be proven that 1 is the minimum value out of all partitions.",
            "Input: nums = [100,1,10]\nOutput: 9\nExplanation: We can partition the array nums into nums1 = [10] and nums2 = [100,1].\n- The maximum element of the array nums1 is equal to 10.\n- The minimum element of the array nums2 is equal to 1.\nThe value of the partition is |10 - 1| = 9.\nIt can be proven that 9 is the minimum value out of all partitions."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 109",
        "release_time": 1687111553,
        "oracle_code": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n            \n        return min_diff",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem tells us that we must make a partition where nums1 and nums2 are non empty. \\n\\n2. If we sort the array, we can make a partition between each pair of adajacent elements where the left element would always be the max of nums1 and the right element in the pair will always be the min of nums2.\\n3. In this way, we can check all possible partitions, save the min as we go, and return it once were through every pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initialize a min variable to save the min partition value\\n2. sort nums\\n3. iterate over nums array from 1->len(nums)\\n4. compare each adajacent pair with the calculation given in the problem: abs(nums[i] - nums[i-1])\\n5. return the min diff\\n\\n~If this was helpful please upvote! \\n~Thanks for reading :)\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe sort nums and then iterate over nums which is bounded by nlogn for sorting.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur only additional space comes from min_diff\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        # Sort the array in ascending order\n        nums.sort()\n        \n        # Initialize nums1 and nums2 as empty arrays\n        nums1 = []\n        nums2 = []\n        \n        # Distribute the elements of nums into nums1 and nums2 alternatively\n        for i in range(len(nums)):\n            if i % 2 == 0:\n                nums1.append(nums[i])\n            else:\n                nums2.append(nums[i])\n        \n        # Return the difference between the maximum element of nums1 and the minimum element of nums2\n        return abs(max(nums1) - min(nums2))\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 29944000,
            "question_id": "2845",
            "elapsed_time": 439,
            "compare_result": "10000001001000010001100000100010000000011000010011000000100000100000001001011000100000010000010000111100001100010100010000010000001000000000101010010000000000000000000100000000101000010000001000010101000000000101100000000000000000000010000000011111101000000100000000100000011000000000010000001000010011000101100110100001001000000000000000000001000100100001010000001000001010000000000000000000001100001000001000000000000010010001000000010100000000100000000110001000011000010000000000000000001100000011000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010",
            "code_output": "90",
            "std_output": "",
            "last_testcase": "[100,1,10]",
            "expected_output": "9",
            "task_finish_time": 1699924310138,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 103,
            "total_testcases": 806,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098288871",
            "input_formatted": "[100,1,10]",
            "input": "[100,1,10]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sliding-puzzle",
        "description": "On an 2 x 3 board, there are five tiles labeled from 1 to 5, and an empty square represented by 0. A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.\nThe state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].\nGiven the puzzle board board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.",
        "examples": [
            "Input: board = [[1,2,3],[4,0,5]]\nOutput: 1\nExplanation: Swap the 0 and the 5 in one move.",
            "Input: board = [[1,2,3],[5,4,0]]\nOutput: -1\nExplanation: No number of moves will make the board solved.",
            "Input: board = [[4,1,2],[5,0,3]]\nOutput: 5\nExplanation: 5 is the smallest number of moves that solves the board.\nAn example path:\nAfter move 0: [[4,1,2],[5,0,3]]\nAfter move 1: [[4,1,2],[0,5,3]]\nAfter move 2: [[0,1,2],[4,5,3]]\nAfter move 3: [[1,0,2],[4,5,3]]\nAfter move 4: [[1,2,0],[4,5,3]]\nAfter move 5: [[1,2,3],[4,5,0]]"
        ],
        "constrains": "board.length == 2\nboard[i].length == 3\n0 <= board[i][j] <= 5\nEach value board[i][j] is unique.",
        "release_time": 1673813066,
        "oracle_code": "class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = [row[:] for row in board]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [4, 5, 0]]:\n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that this problem can be solved using a breadth-first search (BFS) algorithm, where we start with the initial board state and explore all possible moves (by swapping the empty space with its neighboring tiles) until we reach the desired board state.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a BFS algorithm to explore all possible moves from the initial board state. The function starts by initializing a queue and adding the initial board state and the number of moves (0) to the queue. It also initializes a set to keep track of the board states that have already been seen. The function then enters a while loop that continues until the queue is empty. In each iteration, the function takes the first board state and move count from the queue, and checks if the board state is the desired state. If it is, the function returns the number of moves. If not, the function uses a helper function get_neighbors to find all possible moves (by swapping the empty space with its neighboring tiles) and adds them to the queue. The function also adds the new board states to the set of seen states. If the queue becomes empty, the function returns -1 indicating that the desired board state was not reached.\\n\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\\n        def get_neighbors(board):\\n            neighbors = []\\n            r, c = 0, 0\\n            for i in range(2):\\n                for j in range(3):\\n                    if board[i][j] == 0:\\n                        r, c = i, j\\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                new_r, new_c = r + i, c + j\\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\\n                    new_board = [row[:] for row in board]\\n                    new_board[r][c] = new_board[new_r][new_c]\\n                    new_board[new_r][new_c] = 0\\n                    neighbors.append(new_board)\\n            return neighbors\\n\\n        queue = deque()\\n        queue.append((board, 0))\\n        seen = set()\\n        seen.add(tuple(tuple(row) for row in board))\\n\\n        while queue:\\n            board, moves = queue.popleft()\\n            if board == [[1, 2, 3], [4, 5, 0]]:\\n                return moves\\n            for neighbor in get_neighbors(board):\\n                if tuple(tuple(row) for row in neighbor) not in seen:\\n                    queue.append((neighbor, moves + 1))\\n                    seen.add(tuple(tuple(row) for row in neighbor))\\n        return -1\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        # Convert the board to a string for easy comparison and manipulation\n        board_str = \"\".join(str(num) for row in board for num in row)\n        \n        # Define the target state\n        target = \"123450\"\n        \n        # Initialize a queue for BFS\n        queue = collections.deque([(board_str, 0)])\n        \n        # Define the possible positions of the empty square\n        directions = [(1, 3), (-1, -3), (3, 1), (-3, -1)]\n        \n        # Initialize a set to store visited states\n        visited = set([board_str])\n        \n        while queue:\n            state, moves = queue.popleft()\n            \n            if state == target:\n                return moves\n            \n            # Find the position of the empty square\n            empty_idx = state.index(\"0\")\n            \n            # Move the empty square to possible positions\n            for direction in directions:\n                new_idx = empty_idx + direction[0]\n                if new_idx >= 0 and new_idx < len(state) and \\\n                   not (empty_idx in [2, 5] and new_idx in [3, 6]) and \\\n                   not (empty_idx in [3, 6] and new_idx in [2, 5]):\n                    new_state = list(state)\n                    new_state[empty_idx], new_state[new_idx] = new_state[new_idx], new_state[empty_idx]\n                    new_state = \"\".join(new_state)\n                    if new_state not in visited:\n                        queue.append((new_state, moves + 1))\n                        visited.add(new_state)\n        \n        return -1\n\n    def get_neighbors(board):\n        # Helper function to get the neighbors of a given board state\n        # ...\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 47: IndentationError: expected an indented block after function definition on line 93",
            "full_runtime_error": "IndentationError: expected an indented block after function definition on line 93\n    import sys\nLine 47  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 8984000,
            "question_id": "787",
            "elapsed_time": 22,
            "compare_result": "00000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[1,2,3],[4,0,5]]",
            "expected_output": "1",
            "task_finish_time": 1699924327430,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 32,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098289007",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1692290595,
        "oracle_code": "from collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 1:\n                nums[index] = num\n                index += 1\n\n        return index",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```",
        "level": "medium",
        "completed_code": "\nfrom collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        count = Counter(nums)\n        index = 0\n        for num, freq in count.items():\n            for _ in range(min(2, freq)):\n                nums[index] = num\n                index += 1\n        return index\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "54 ms",
            "memory": 16308000,
            "question_id": "80",
            "elapsed_time": 75,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924342724,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 165,
            "total_testcases": 165,
            "runtime_percentile": 79.0369,
            "status_memory": "16.3 MB",
            "memory_percentile": 19.87059999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098289128",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "description": "A bit flip of a number x is choosing a bit in the binary representation of x and flipping it from either 0 to 1 or 1 to 0.\n\nFor example, for x = 7, the binary representation is 111 and we may choose any bit (including any leading zeros not shown) and flip it. We can flip the first bit from the right to get 110, flip the second bit from the right to get 101, flip the fifth bit from the right (a leading zero) to get 10111, etc.\n\nGiven two integers start and goal, return the minimum number of bit flips to convert start to goal.",
        "examples": [
            "Input: start = 10, goal = 7\nOutput: 3\nExplanation: The binary representation of 10 and 7 are 1010 and 0111 respectively. We can convert 10 to 7 in 3 steps:\n- Flip the first bit from the right: 1010 -> 1011.\n- Flip the third bit from the right: 1011 -> 1111.\n- Flip the fourth bit from the right: 1111 -> 0111.\nIt can be shown we cannot convert 10 to 7 in less than 3 steps. Hence, we return 3.",
            "Input: start = 3, goal = 4\nOutput: 3\nExplanation: The binary representation of 3 and 4 are 011 and 100 respectively. We can convert 3 to 4 in 3 steps:\n- Flip the first bit from the right: 011 -> 010.\n- Flip the second bit from the right: 010 -> 000.\n- Flip the third bit from the right: 000 -> 100.\nIt can be shown we cannot convert 3 to 4 in less than 3 steps. Hence, we return 3."
        ],
        "constrains": "0 <= start, goal <= 109",
        "release_time": 1677410468,
        "oracle_code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```",
        "level": "easy",
        "completed_code": "",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 25: NameError: name 'Solution' is not defined",
            "full_runtime_error": "NameError: name 'Solution' is not defined\n    ret = Solution().minBitFlips(param_1, param_2)\nLine 25 in _driver (Solution.py)\n    _driver()\nLine 36 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16428000,
            "question_id": "2323",
            "elapsed_time": 58,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "10\n7",
            "expected_output": "3",
            "task_finish_time": 1699924357529,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 250,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098289228",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "unique-number-of-occurrences",
        "description": "Given an array of integers arr, return true if the number of occurrences of each value in the array is unique or false otherwise.",
        "examples": [
            "Input: arr = [1,2,2,1,1,3]\nOutput: true\nExplanation:\u00a0The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.",
            "Input: arr = [1,2]\nOutput: false",
            "Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]\nOutput: true"
        ],
        "constrains": "1 <= arr.length <= 1000\n-1000 <= arr[i] <= 1000",
        "release_time": 1669786839,
        "oracle_code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```",
        "level": "easy",
        "completed_code": "\nfrom collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        counter = Counter(arr)\n        occurrences = counter.values()\n        return len(set(occurrences)) == len(occurrences)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "46 ms",
            "memory": 16572000,
            "question_id": "1319",
            "elapsed_time": 60,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924372561,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 67,
            "total_testcases": 67,
            "runtime_percentile": 47.11049999999997,
            "status_memory": "16.6 MB",
            "memory_percentile": 19.243399999999994,
            "pretty_lang": "Python3",
            "submission_id": "1098289336",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "make-costs-of-paths-equal-in-a-binary-tree",
        "description": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.",
        "examples": [
            "Input: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.",
            "Input: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed."
        ],
        "constrains": "3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104",
        "release_time": 1683566460,
        "oracle_code": "class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n\n        ans = 0\n        n//=2                                               # <-- 1)\n\n        for i in reversed(range(n)):\n        \n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\n\n            ans+= mx - mn\n            cost[i]+= mx\n\n        return ans",
        "content": "A couple of notes:\\n1. The iteration covers only the parents, so we can prune the leaves from the iteration.\\n2. We add `1` each to `2i` and `2i+1` because `cost` is zero-indexed and the tree is one-indexed.\\n\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/submissions/946746736/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n        def dfs(node):\n            nonlocal res, cur\n            if node > len(cost) or cur < 0: return\n            cur += cost[node-1] # add current node's cost to cur\n            if node * 2 > len(cost): # leaf node\n                res += max(0, cur - 1) # increment res by max(0, cur - 1)\n            dfs(node * 2) # go to left child\n            dfs(node * 2 + 1) # go to right child\n            cur -= 1 # subtract 1 from cur to go back to parent node\n        \n        res, cur = 0, 0\n        dfs(1) # start dfs from root node\n        return res\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 51732000,
            "question_id": "2780",
            "elapsed_time": 1343,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "40",
            "std_output": "",
            "last_testcase": "7\n[1,5,2,2,3,3,1]",
            "expected_output": "6",
            "task_finish_time": 1699924389053,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 1565,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098289443",
            "input_formatted": "7, [1,5,2,2,3,3,1]",
            "input": "7\n[1,5,2,2,3,3,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-the-kth-largest-integer-in-the-array",
        "description": "You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros.\nReturn the string that represents the kth largest integer in nums.\nNote: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer.",
        "examples": [
            "Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4\nOutput: \"3\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"].\nThe 4th largest integer in nums is \"3\".",
            "Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3\nOutput: \"2\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"].\nThe 3rd largest integer in nums is \"2\".",
            "Input: nums = [\"0\",\"0\"], k = 2\nOutput: \"0\"\nExplanation:\nThe numbers in nums sorted in non-decreasing order are [\"0\",\"0\"].\nThe 2nd largest integer in nums is \"0\"."
        ],
        "constrains": "1 <= k <= nums.length <= 104\n1 <= nums[i].length <= 100\nnums[i] consists of only digits.\nnums[i] will not have any leading zeros.",
        "release_time": 1688963881,
        "oracle_code": "class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        ls = []\n        for i in nums:\n            ls.append(int(i))\n        sorted_ = sorted(ls)\n        return str(sorted_[-1*k])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        ls = []\\n        for i in nums:\\n            ls.append(int(i))\\n        sorted_ = sorted(ls)\\n        return str(sorted_[-1*k])\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        nums.sort(reverse=True)\n        return nums[k-1]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 25132000,
            "question_id": "2113",
            "elapsed_time": 266,
            "compare_result": "001111111111111111111111111111111111111111111111101111111111101100101010110001000001110010010110100100011000000000111000010010001110000000000100000000000000000000000000100110000000000101000000000000000000001111111011101",
            "code_output": "\"10\"",
            "std_output": "",
            "last_testcase": "[\"3\",\"6\",\"7\",\"10\"]\n4",
            "expected_output": "\"3\"",
            "task_finish_time": 1699924403012,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 102,
            "total_testcases": 219,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098289540",
            "input_formatted": "[\"3\",\"6\",\"7\",\"10\"], 4",
            "input": "[\"3\",\"6\",\"7\",\"10\"]\n4",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-ways-to-split-array",
        "description": "You are given a 0-indexed integer array nums of length n.\nnums contains a valid split at index i if the following are true:\n\nThe sum of the first i + 1 elements is greater than or equal to the sum of the last n - i - 1 elements.\nThere is at least one element to the right of i. That is, 0 <= i < n - 1.\n\nReturn the number of valid splits in nums.",
        "examples": [
            "Input: nums = [10,4,-8,7]\nOutput: 2\nExplanation: \nThere are three ways of splitting nums into two non-empty parts:\n- Split nums at index 0. Then, the first part is [10], and its sum is 10. The second part is [4,-8,7], and its sum is 3. Since 10 >= 3, i = 0 is a valid split.\n- Split nums at index 1. Then, the first part is [10,4], and its sum is 14. The second part is [-8,7], and its sum is -1. Since 14 >= -1, i = 1 is a valid split.\n- Split nums at index 2. Then, the first part is [10,4,-8], and its sum is 6. The second part is [7], and its sum is 7. Since 6 < 7, i = 2 is not a valid split.\nThus, the number of valid splits in nums is 2.",
            "Input: nums = [2,3,1,0]\nOutput: 2\nExplanation: \nThere are two valid splits in nums:\n- Split nums at index 1. Then, the first part is [2,3], and its sum is 5. The second part is [1,0], and its sum is 1. Since 5 >= 1, i = 1 is a valid split. \n- Split nums at index 2. Then, the first part is [2,3,1], and its sum is 6. The second part is [0], and its sum is 0. Since 6 >= 0, i = 2 is a valid split."
        ],
        "constrains": "2 <= nums.length <= 105\n-105 <= nums[i] <= 105",
        "release_time": 1687160167,
        "oracle_code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        cnt=0\n        left=nums[0]\n        right=sum(nums[1:])\n        if left>=right:\n            cnt+=1\n        for i in range(1,len(nums)-1):\n            left+=nums[i]\n            right-=nums[i]\n            if left>=right:\n                cnt+=1\n        return cnt",
        "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cnt=0\\n        left=nums[0]\\n        right=sum(nums[1:])\\n        if left>=right:\\n            cnt+=1\\n        for i in range(1,len(nums)-1):\\n            left+=nums[i]\\n            right-=nums[i]\\n            if left>=right:\\n                cnt+=1\\n        return cnt\\n\\n```\\n\\n***Please Upvote***",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        prefix_sum = [0] * n\n        prefix_sum[0] = nums[0]\n        \n        # Calculate the prefix sum of the input array\n        for i in range(1, n):\n            prefix_sum[i] = prefix_sum[i-1] + nums[i]\n        \n        num_of_splits = 0\n        \n        # Iterate through all possible split points\n        for i in range(n-2):\n            # Binary search to find rightmost split point j\n            left_sum = prefix_sum[i]  # sum of elements from index 0 to i\n            mid_sum = 0  # sum of elements from index i+1 to j\n            right_sum = prefix_sum[n-1] - prefix_sum[i]  # sum of elements from index j+1 to n-1\n            \n            left = i + 1\n            right = n-2\n            while left <= right:\n                mid = (left + right) // 2\n                mid_sum = prefix_sum[mid] - prefix_sum[i]\n                right_sum = prefix_sum[n-1] - prefix_sum[mid]\n                \n                if left_sum <= mid_sum and mid_sum <= right_sum:\n                    num_of_splits += 1\n                    # Find rightmost split point j\n                    right = mid - 1\n                elif mid_sum < left_sum:\n                    # Move right pointer to the right\n                    left = mid + 1\n                else:\n                    # Move left pointer to the left\n                    right = mid - 1\n        \n        return num_of_splits\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 31140000,
            "question_id": "2358",
            "elapsed_time": 2834,
            "compare_result": "0011010001101000010000101101010000000000000000000000000000000010000000000000000000000000000000000000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[10,4,-8,7]",
            "expected_output": "2",
            "task_finish_time": 1699924421944,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 13,
            "total_testcases": 100,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098289650",
            "input_formatted": "[10,4,-8,7]",
            "input": "[10,4,-8,7]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "neither-minimum-nor-maximum",
        "description": "Given an integer array nums containing distinct positive integers, find and return any number from the array that is neither the minimum nor the maximum value in the array, or -1 if there is no such number.\nReturn the selected integer.",
        "examples": [
            "Input: nums = [3,2,1,4]\nOutput: 2\nExplanation: In this example, the minimum value is 1 and the maximum value is 4. Therefore, either 2 or 3 can be valid answers.",
            "Input: nums = [1,2]\nOutput: -1\nExplanation: Since there is no number in nums that is neither the maximum nor the minimum, we cannot select a number that satisfies the given condition. Therefore, there is no answer.",
            "Input: nums = [2,1,3]\nOutput: 2\nExplanation: Since 2 is neither the maximum nor the minimum value in nums, it is the only valid answer."
        ],
        "constrains": "1 <= nums.length <= 100\n1 <= nums[i] <= 100\nAll values in nums are distinct",
        "release_time": 1686456982,
        "oracle_code": "class Solution:\n    def findNonMinOrMax(self, nums: List[int]) -> int:\n        if len(nums) <= 2:\n            return -1\n        else:\n            return sorted(nums)[-2]",
        "content": "# Intuition\\nThe problem asks us to find a number from the given array that is neither the minimum nor the maximum value. This means that we need to exclude the smallest and largest values from consideration and return any other number. To solve this, we can sort the array and select the second largest element, as it will not be the maximum value.\\n\\n\\n# Approach\\nThe provided solution suggests using the sorted() function to sort the given array in ascending order. Since the array contains distinct positive integers, sorting the array will arrange the numbers in increasing order. If the length of the array is less than or equal to 2, we return -1, as there would be no number that satisfies the given condition. Otherwise, we return the second largest element, which can be accessed using the [-2] index.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the solution depends on the sorting algorithm used. If we consider the default sorting algorithm used by Python\\'s sorted() function, the time complexity is O(n log n), where n is the length of the input array nums. Sorting the array is the most time-consuming step in this approach.\\n\\n\\n- Space complexity:\\nSpace complexity: The space complexity is O(1) since we are not using any additional data structures that grow with the size of the input. The sorting operation is performed in-place, so it does not require additional space proportional to the input size.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findNonMinOrMax(self, nums: List[int]) -> int:\n        # sort the array in ascending order\n        nums.sort()\n        \n        # if the array has less than 3 elements, return -1\n        if len(nums) < 3:\n            return -1\n        \n        # return the second last element in the sorted array\n        return nums[-2]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "328 ms",
            "memory": 16388000,
            "question_id": "2836",
            "elapsed_time": 402,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924434752,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 9558,
            "total_testcases": 9558,
            "runtime_percentile": 88.71999999999994,
            "status_memory": "16.4 MB",
            "memory_percentile": 10.201299999999968,
            "pretty_lang": "Python3",
            "submission_id": "1098289760",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "description": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\nThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\nBoth the left and right subtrees must also be binary search trees.",
        "examples": [
            "Input: root = [1,null,2,2]\nOutput: [2]",
            "Input: root = [0]\nOutput: [0]"
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105",
        "release_time": 1675923228,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        if not root:\n            return []\n        \n        mode_count = {}\n        max_count = 0\n        \n        def traverse(node):\n            nonlocal max_count\n            \n            if not node:\n                return\n            \n            mode_count[node.val] = mode_count.get(node.val, 0) + 1\n            max_count = max(max_count, mode_count[node.val])\n            \n            traverse(node.left)\n            traverse(node.right)\n        \n        traverse(root)\n        \n        return [key for key, value in mode_count.items() if value == max_count]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "53 ms",
            "memory": 20996000,
            "question_id": "501",
            "elapsed_time": 74,
            "compare_result": "111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924449365,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 24,
            "total_testcases": 24,
            "runtime_percentile": 73.12360000000001,
            "status_memory": "21 MB",
            "memory_percentile": 9.637700000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098289873",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "corporate-flight-bookings",
        "description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.",
        "examples": [
            "Input: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]",
            "Input: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]"
        ],
        "constrains": "1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104",
        "release_time": 1671743412,
        "oracle_code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*).",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        # create an array to store the number of seats reserved for each flight\n        result = [0] * n\n        \n        # iterate through each booking\n        for booking in bookings:\n            first = booking[0] - 1\n            last = booking[1] - 1\n            seats = booking[2]\n            \n            # increment the seat count for each flight in the range of the booking\n            for i in range(first, last+1):\n                result[i] += seats\n        \n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constrains": "1 <= hours.length <= 104\n0 <= hours[i] <= 16",
        "release_time": 1664031594,
        "oracle_code": "class Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans",
        "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(n)`\\n```\\nclass Solution:\\n    def longestWPI(self, A):\\n        curr, ans, D = 0, 0, {}\\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\\n            curr += i\\n            D[curr] = D.get(curr, e)\\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\\n        return ans\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def longestWPI(self, A):\n        count = 0\n        max_len = 0\n        score = 0\n        score_map = {}\n        \n        for i in range(len(A)):\n            if A[i] > 8:\n                count += 1\n            else:\n                count -= 1\n            \n            if count > 0:\n                max_len = i + 1\n            \n            if count not in score_map:\n                score_map[count] = i\n            \n            if count - 1 in score_map:\n                max_len = max(max_len, i - score_map[count - 1])\n        \n        return max_len\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "183 ms",
            "memory": 16968000,
            "question_id": "1219",
            "elapsed_time": 250,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924479861,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 98,
            "total_testcases": 98,
            "runtime_percentile": 60.96239999999998,
            "status_memory": "17 MB",
            "memory_percentile": 42.780800000000006,
            "pretty_lang": "Python3",
            "submission_id": "1098290076",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "description": "You are given a 0-indexed integer array nums, where nums[i] represents the score of the ith student. You are also given an integer k.\nPick the scores of any k students from the array so that the difference between the highest and the lowest of the k scores is minimized.\nReturn the minimum possible difference.",
        "examples": [
            "Input: nums = [90], k = 1\nOutput: 0\nExplanation: There is one way to pick score(s) of one student:\n- [90]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.",
            "Input: nums = [9,4,1,7], k = 2\nOutput: 2\nExplanation: There are six ways to pick score(s) of two students:\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 4 = 5.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 1 = 8.\n- [9,4,1,7]. The difference between the highest and lowest score is 9 - 7 = 2.\n- [9,4,1,7]. The difference between the highest and lowest score is 4 - 1 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 4 = 3.\n- [9,4,1,7]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2."
        ],
        "constrains": "1 <= k <= nums.length <= 1000\n0 <= nums[i] <= 105",
        "release_time": 1664874410,
        "oracle_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        res = 100000\n        \n        for i in range(len(nums) - k + 1):\n            arr = nums[i:i + k]\n            res = min(res, arr[-1] - arr[0])\n            \n        return res",
        "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 100000\\n        \\n        for i in range(len(nums) - k + 1):\\n            arr = nums[i:i + k]\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        arr = nums[:k]\\n        res = arr[-1] - arr[0]\\n        \\n        for i in range(k, len(nums)):\\n            arr.pop(0)\\n            arr.append(nums[i])\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        min_diff = float('inf')\n        for i in range(len(nums)-k+1):\n            min_diff = min(min_diff, nums[i+k-1] - nums[i])\n        return min_diff\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "100 ms",
            "memory": 16584000,
            "question_id": "2112",
            "elapsed_time": 125,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924494658,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 118,
            "total_testcases": 118,
            "runtime_percentile": 51.28619999999998,
            "status_memory": "16.6 MB",
            "memory_percentile": 16.80959999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098290185",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b\u00a0or any child of a is an ancestor of b.",
        "examples": [
            "Input: root = [8,3,10,1,6,null,14,null,null,4,7,13]\nOutput: 7\nExplanation: We have various ancestor-node differences, some of which are given below :\n|8 - 3| = 5\n|3 - 7| = 4\n|8 - 1| = 7\n|10 - 13| = 3\nAmong all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.",
            "Input: root = [1,null,2,null,0,3]\nOutput: 3"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105",
        "release_time": 1670557881,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def find_max_difference(node, max_val, min_val):\n            if not node:\n                return max_val - min_val\n            \n            max_val = max(max_val, node.val)\n            min_val = min(min_val, node.val)\n            \n            left_diff = find_max_difference(node.left, max_val, min_val)\n            right_diff = find_max_difference(node.right, max_val, min_val)\n            \n            return max(left_diff, right_diff)\n        \n        if not root:\n            return 0\n        \n        return find_max_difference(root, root.val, root.val)\n\nsolution = Solution()\nresult = solution.maxAncestorDiff(root)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 22: NameError: name 'root' is not defined",
            "full_runtime_error": "NameError: name 'root' is not defined\n    result = solution.maxAncestorDiff(root)\nLine 22 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16280000,
            "question_id": "1092",
            "elapsed_time": 54,
            "compare_result": "0000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[8,3,10,1,6,null,14,null,null,4,7,13]",
            "expected_output": "7",
            "task_finish_time": 1699924509413,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 28,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098290296",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "description": "You are given a 0-indexed 2D integer array grid of size m x n. Each cell has one of two values:\n\n0 represents an empty cell,\n1 represents an obstacle that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\nReturn the minimum number of obstacles to remove so you can move from the upper left corner (0, 0) to the lower right corner (m - 1, n - 1).",
        "examples": [
            "Input: grid = [[0,1,1],[1,1,0],[1,1,0]]\nOutput: 2\nExplanation: We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.",
            "Input: grid = [[0,1,0,0,0],[0,1,0,1,0],[0,0,0,1,0]]\nOutput: 0\nExplanation: We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n2 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 0",
        "release_time": 1688233113,
        "oracle_code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "completed_code": "\nfrom typing import List\n\nclass Solution:\n    def minimumObstacles(grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[float('inf')] * n for _ in range(m)]\n        dp[0][0] = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if grid[i][j] == 1:\n                    dp[i][j] += 1\n                \n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i-1][j])\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j-1])\n        \n        return dp[m-1][n-1]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 42: TypeError: Solution.minimumObstacles() takes 1 positional argument but 2 were given",
            "full_runtime_error": "TypeError: Solution.minimumObstacles() takes 1 positional argument but 2 were given\n    ret = Solution().minimumObstacles(param_1)\nLine 42 in _driver (Solution.py)\n    _driver()\nLine 53 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16376000,
            "question_id": "2375",
            "elapsed_time": 56,
            "compare_result": "000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[0,1,1],[1,1,0],[1,1,0]]",
            "expected_output": "2",
            "task_finish_time": 1699924524533,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 54,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098290419",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1669544244,
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums);ans = 0\n        dp = defaultdict(Counter)\n        for i in range(1,n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                dp[i][d] += dp[j][d] + 1\n            ans += sum(dp[i].values()) - i\n        return ans",
        "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n**2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n**2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums);ans = 0\\n        dp = defaultdict(Counter)\\n        for i in range(1,n):\\n            for j in range(i):\\n                d = nums[i] - nums[j]\\n                dp[i][d] += dp[j][d] + 1\\n            ans += sum(dp[i].values()) - i\\n        return ans\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        count = 0\n        dp = [{} for _ in range(len(nums))]\n        \n        for i in range(1, len(nums)):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                if diff in dp[j]:\n                    dp[i][diff] = dp[j][diff] + dp[i].get(diff, 0)\n                    count += dp[j][diff]\n                    count += dp[i][diff]\n                else:\n                    dp[i][diff] = dp[i].get(diff, 0) + 1\n        \n        return count\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 54768000,
            "question_id": "446",
            "elapsed_time": 440,
            "compare_result": "00110001000000111100000000000000000000000000000000000000000000000000000000000000000000000000000000010",
            "code_output": "8",
            "std_output": "",
            "last_testcase": "[2,4,6,8,10]",
            "expected_output": "7",
            "task_finish_time": 1699924539894,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 101,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098290541",
            "input_formatted": "[2,4,6,8,10]",
            "input": "[2,4,6,8,10]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "scramble-string",
        "description": "We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\n\t\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly\u00a0decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\n\n\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.",
        "examples": [
            "Input: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.",
            "Input: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false",
            "Input: s1 = \"a\", s2 = \"a\"\nOutput: true"
        ],
        "constrains": "s1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.",
        "release_time": 1680718887,
        "oracle_code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        # If the strings are equal, return True\n        if s1 == s2:\n            return True\n        \n        # If the lengths of the strings are unequal, return False\n        if len(s1) != len(s2):\n            return False\n        \n        # If the sorted strings are not equal, return False\n        if sorted(s1) != sorted(s2):\n            return False\n        \n        # Iterate over the length of the strings\n        for i in range(1, len(s1)):\n            # Recursive call with swapped substrings\n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n            # Recursive call without swapping substrings\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n        \n        # Return False if no valid scramble is found\n        return False\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "48 ms",
            "memory": 18244000,
            "question_id": "87",
            "elapsed_time": 70,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924554617,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 290,
            "total_testcases": 290,
            "runtime_percentile": 90.8871,
            "status_memory": "18.2 MB",
            "memory_percentile": 18.590199999999992,
            "pretty_lang": "Python3",
            "submission_id": "1098290644",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-number-of-consecutive-values-you-can-make",
        "description": "You are given an integer array coins of length n which represents the n coins that you own. The value of the ith coin is coins[i]. You can make some value x if you can choose some of your n coins such that their values sum up to x.\nReturn the maximum number of consecutive integer values that you can make with your coins starting from and including 0.\nNote that you may have multiple coins of the same value.",
        "examples": [
            "Input: coins = [1,3]\nOutput: 2\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\nYou can make 2 consecutive integer values starting from 0.",
            "Input: coins = [1,1,1,4]\nOutput: 8\nExplanation: You can make the following values:\n- 0: take []\n- 1: take [1]\n- 2: take [1,1]\n- 3: take [1,1,1]\n- 4: take [4]\n- 5: take [4,1]\n- 6: take [4,1,1]\n- 7: take [4,1,1,1]\nYou can make 8 consecutive integer values starting from 0.",
            "Input: nums = [1,4,10,3,1]\nOutput: 20"
        ],
        "constrains": "coins.length == n\n1 <= n <= 4 * 104\n1 <= coins[i] <= 4 * 104",
        "release_time": 1686412278,
        "oracle_code": "class Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\\n    ans = 1  # next value we want to make\\n\\n    for coin in sorted(coins):\\n      if coin > ans:\\n        return ans\\n      ans += coin\\n\\n    return ans\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getMaximumConsecutive(self, coins: List[int]) -> int:\n        coins.sort()   #Sort the coins in ascending order\n        max_consecutive = 1   #Initialize the maximum consecutive value to 1\n        for coin in coins:\n            if coin <= max_consecutive:\n                max_consecutive += coin   #Add the coin value to the current maximum consecutive value\n            else:\n                break   #Break the loop if the coin value is greater than the current maximum consecutive value\n        return max_consecutive\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "622 ms",
            "memory": 22028000,
            "question_id": "1930",
            "elapsed_time": 643,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924570234,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 72,
            "total_testcases": 72,
            "runtime_percentile": 86.66649999999997,
            "status_memory": "22 MB",
            "memory_percentile": 26.66659999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098290747",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "remove-linked-list-elements",
        "description": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.",
        "examples": [
            "Input: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]",
            "Input: head = [], val = 1\nOutput: []",
            "Input: head = [7,7,7,7], val = 7\nOutput: []"
        ],
        "constrains": "The number of nodes in the list is in the range [0, 104].\n1 <= Node.val <= 50\n0 <= val <= 50",
        "release_time": 1691723920,
        "oracle_code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        result = ListNode(0)\n        result.next = head\n        cur = result\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return result.next",
        "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        result = ListNode(0)\\n        result.next = head\\n        cur = result\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return result.next\\n```",
        "level": "easy",
        "completed_code": "thon\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.val == val:\n                prev.next = curr.next\n            else:\n                prev = curr\n            \n            curr = curr.next\n        \n        return dummy.next\n``",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 19: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n    ^\n    ``\nLine 19  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 8944000,
            "question_id": "203",
            "elapsed_time": 19,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[1,2,6,3,4,5,6]\n6",
            "expected_output": "[1,2,3,4,5]",
            "task_finish_time": 1699924584653,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 66,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098290854",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-distance-between-a-pair-of-values",
        "description": "You are given two non-increasing 0-indexed integer arrays nums1\u200b\u200b\u200b\u200b\u200b\u200b and nums2\u200b\u200b\u200b\u200b\u200b\u200b.\nA pair of indices (i, j), where 0 <= i < nums1.length and 0 <= j < nums2.length, is valid if both i <= j and nums1[i] <= nums2[j]. The distance of the pair is j - i\u200b\u200b\u200b\u200b.\nReturn the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.\nAn array arr is non-increasing if arr[i-1] >= arr[i] for every 1 <= i < arr.length.",
        "examples": [
            "Input: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\nOutput: 2\nExplanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\nThe maximum distance is 2 with pair (2,4).",
            "Input: nums1 = [2,2,2], nums2 = [10,10,1]\nOutput: 1\nExplanation: The valid pairs are (0,0), (0,1), and (1,1).\nThe maximum distance is 1 with pair (0,1).",
            "Input: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\nOutput: 2\nExplanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\nThe maximum distance is 2 with pair (2,4)."
        ],
        "constrains": "1 <= nums1.length, nums2.length <= 105\n1 <= nums1[i], nums2[j] <= 105\nBoth nums1 and nums2 are non-increasing.",
        "release_time": 1681830538,
        "oracle_code": "class Solution:\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        def binary(left, right, num):\n            farthestPos = 0\n            while left < right:\n                mid = (left + right) // 2\n                if nums2[mid] < num:\n                    right = mid\n                else:\n                    farthestPos = max(farthestPos, mid)\n                    left = mid + 1\n            if nums2[left] >= num:\n                farthestPos = max(farthestPos, left)\n            return farthestPos\n        maxDiff = 0\n        for i in range(min(len(nums1), len(nums2))):\n            if nums1[i] > nums2[i]:\n                continue\n            else:\n                j = binary(i, len(nums2)-1, nums1[i])\n                maxDiff = max(maxDiff, (j-i))\n        return maxDiff",
        "content": "# Intuition\\nThrough the given problem we have few conditions\\n`1. j >= i`\\n`2. nums2[j] > nums1[i]`\\n\\nNow to satisfy these conditions for every element in of nums1 we have to iterate over nums2(i, len(nums2))\\n\\nso we will use **binary search** having the above range always\\nnow if we find *nums[mid] < nums1[i] => we can\\'t consider* this thus shift ur right\\n\\nif *nums[mid] >= nums1[i] => we know the array is in descending order so store this mid index values as farthestSeen* now and shift left pointer.\\n\\n`why not return here?` Because to get the farthest position we have to find element > nums1[i] as far as possible from i\\n\\nCalculate the diff(j-i) and return the maxDiff as your ans :)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\\n        def binary(left, right, num):\\n            farthestPos = 0\\n            while left < right:\\n                mid = (left + right) // 2\\n                if nums2[mid] < num:\\n                    right = mid\\n                else:\\n                    farthestPos = max(farthestPos, mid)\\n                    left = mid + 1\\n            if nums2[left] >= num:\\n                farthestPos = max(farthestPos, left)\\n            return farthestPos\\n        maxDiff = 0\\n        for i in range(min(len(nums1), len(nums2))):\\n            if nums1[i] > nums2[i]:\\n                continue\\n            else:\\n                j = binary(i, len(nums2)-1, nums1[i])\\n                maxDiff = max(maxDiff, (j-i))\\n        return maxDiff\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        def binary(left, right, num):\n            while left <= right:\n                mid = (left + right) // 2\n                if nums2[mid] >= num:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return right\n        \n        maxDiff = 0\n        for i in range(len(nums1)):\n            j = binary(i, len(nums2)-1, nums1[i])\n            if j - i > maxDiff:\n                maxDiff = j - i\n        \n        return maxDiff\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1341 ms",
            "memory": 35400000,
            "question_id": "1984",
            "elapsed_time": 1368,
            "compare_result": "11111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924601061,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 32,
            "total_testcases": 32,
            "runtime_percentile": 23.82479999999981,
            "status_memory": "35.4 MB",
            "memory_percentile": 36.28839999999995,
            "pretty_lang": "Python3",
            "submission_id": "1098290962",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
        "description": "We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\nWhen two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\nWhen an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\nGiven an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.",
        "examples": [
            "Input: n = 4, left = [4,3], right = [0,1]\nOutput: 4\nExplanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).",
            "Input: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\nOutput: 7\nExplanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.",
            "Input: n = 7, left = [0,1,2,3,4,5,6,7], right = []\nOutput: 7\nExplanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall."
        ],
        "constrains": "1 <= n <= 104\n0 <= left.length <= n + 1\n0 <= left[i] <= n\n0 <= right.length <= n + 1\n0 <= right[i] <= n\n1 <= left.length + right.length <= n + 1\nAll values of left and right are unique, and each value can appear only in one of the two arrays.",
        "release_time": 1674935019,
        "oracle_code": "class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left, default=0), n - min(right, default=n))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to find the last moment when any of the ants are still on the line. This can be done by looking at the leftmost ant\\'s position and the rightmost ant\\'s position. The answer will be whichever of these two is greater.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use a two-pass approach. In the first pass, we will find the maximum position of any of the ants in the left array. In the second pass, we will find the minimum position of any of the ants in the right array. Finally, we will compare these two values and return the greater of the two. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        # Find the maximum position of ants moving to the left\n        max_left = max(left) if left else 0\n        # Find the minimum position of ants moving to the right\n        min_right = min(right) if right else n\n        # Find the time when the last ant(s) fall out of the plank\n        return max(max_left, n - min_right)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "149 ms",
            "memory": 17376000,
            "question_id": "1627",
            "elapsed_time": 164,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924614978,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 167,
            "total_testcases": 167,
            "runtime_percentile": 54.40819999999998,
            "status_memory": "17.4 MB",
            "memory_percentile": 32.2284,
            "pretty_lang": "Python3",
            "submission_id": "1098291075",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "capitalize-the-title",
        "description": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.",
        "examples": [
            "Input: title = \"capiTalIze tHe titLe\"\nOutput: \"Capitalize The Title\"\nExplanation:\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"First leTTeR of EACH Word\"\nOutput: \"First Letter of Each Word\"\nExplanation:\nThe word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"i lOve leetcode\"\nOutput: \"i Love Leetcode\"\nExplanation:\nThe word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
        ],
        "constrains": "1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty.",
        "release_time": 1672637914,
        "oracle_code": "class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = l.lower()\n            else:\n                li[i] = l[0].upper() + l[1:].lower()\n        return ' '.join(li)",
        "content": "# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        words = title.split()\n        capitalized_words = []\n        for word in words:\n            if len(word) <= 2:\n                capitalized_words.append(word.lower())\n            else:\n                capitalized_words.append(word[0].upper() + word[1:].lower())\n        return ' '.join(capitalized_words)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "43 ms",
            "memory": 16328000,
            "question_id": "2235",
            "elapsed_time": 55,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924629821,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 200,
            "total_testcases": 200,
            "runtime_percentile": 26.067100000000003,
            "status_memory": "16.3 MB",
            "memory_percentile": 33.91,
            "pretty_lang": "Python3",
            "submission_id": "1098291172",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constrains": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters.",
        "release_time": 1689480141,
        "oracle_code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        def is_valid(substring):\n            for f in forbidden:\n                if f in substring:\n                    return False\n            return True\n        \n        longest_length = 0\n        n = len(word)\n        \n        for i in range(n):\n            for j in range(i+1, n+1):\n                substring = word[i:j]\n                if is_valid(substring):\n                    length = len(substring)\n                    if length > longest_length:\n                        longest_length = length\n        \n        return longest_length\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\n\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\n\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.",
        "examples": [
            "Input: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.",
            "Input: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.",
            "Input: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark."
        ],
        "constrains": "n == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.",
        "release_time": 1690342800,
        "oracle_code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        def can_reach_office(speed):\n            total_time = sum(math.ceil(d / speed) for d in dist[:-1]) + dist[-1] / speed\n            return total_time <= hour\n\n        left, right = 1, 10**7 + 1\n        while left < right:\n            mid = (left + right) // 2\n            if can_reach_office(mid):\n                right = mid\n            else:\n                left = mid + 1\n\n        return left if left != 10**7 + 1 else -1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "2518 ms",
            "memory": 30380000,
            "question_id": "2000",
            "elapsed_time": 2558,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924662565,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 66,
            "total_testcases": 66,
            "runtime_percentile": 51.669399999999825,
            "status_memory": "30.4 MB",
            "memory_percentile": 79.8941,
            "pretty_lang": "Python3",
            "submission_id": "1098291384",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "release_time": 1583640064,
        "oracle_code": "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res",
        "content": "**Idea**\\nFirst we build an adjacency list using `edges`.\\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\\n2. Use set to record all the visited nodes along the way **(method 2)**\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3, DFS with recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        visited, res = set(), 0.\\n        def dfs(leaf_id, p, time):\\n            nonlocal res\\n            if time >= t:\\n                if leaf_id == target: res = p\\n                return\\n            visited.add(leaf_id)\\n            neighbors = nei[leaf_id] - visited\\n            for n in neighbors or [leaf_id]:\\n                dfs(n, p / (len(neighbors) or 1), time + 1)\\n        dfs(1, 1, 0)\\n        return res\\n```\\n\\n**Python 3, BFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.popleft()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS on tree without recursion, method 1**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n                    \\n        dp = collections.deque([1])\\n        while dp:\\n            leaf = dp.popleft()\\n            for n_ in nei[leaf]:\\n                nei[n_].remove(leaf)\\n                dp += n_,\\n                \\n        dp = [(1, 1, 0)]\\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            for n in nei[leaf] or [leaf]:\\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\\n        return 0.0\\n```\\n",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        # Create an adjacency list to represent the connections between vertices\n        adj_list = [[] for _ in range(n+1)]\n        for edge in edges:\n            u, v = edge\n            adj_list[u].append(v)\n            adj_list[v].append(u)\n        \n        # Perform depth-first search to calculate the probability at each vertex\n        def dfs(vertex, time, parent):\n            # Base case: if the target vertex has been reached\n            if vertex == target:\n                # If there is still time left and the target vertex is a leaf node, the probability is 1\n                if time == 0 or (time > 0 and not adj_list[vertex]):\n                    return 1.0\n                # If there is still time left and the target vertex is not a leaf node, the probability is 0\n                else:\n                    return 0.0\n            \n            # Check if the current vertex is a leaf node\n            is_leaf = True\n            for neighbor in adj_list[vertex]:\n                if neighbor != parent:\n                    is_leaf = False\n                    break\n            \n            # If the current vertex is a leaf node, check if there is still time left\n            if is_leaf:\n                if time == 1:\n                    return 1.0\n                else:\n                    return 0.0\n            \n            # Calculate the probability at each neighbor vertex\n            probability = 0.0\n            for neighbor in adj_list[vertex]:\n                if neighbor != parent:\n                    probability += dfs(neighbor, time-1, vertex)\n            \n            # Divide the probability by the number of unvisited neighbor vertices\n            return probability / (len(adj_list[vertex]) - (1 if parent != -1 else 0))\n        \n        return dfs(1, t, -1)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16388000,
            "question_id": "1493",
            "elapsed_time": 105,
            "compare_result": "01011111101101110011111110101010100010011001011011110000000000110001110101001100001110001011110011010111101111001000110111000000010110110010101101110101100100001101111100000000110010000111001110011100000110",
            "code_output": "0.50000",
            "std_output": "",
            "last_testcase": "7\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\n2\n4",
            "expected_output": "0.16667",
            "task_finish_time": 1699924680042,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 104,
            "total_testcases": 206,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098291516",
            "input_formatted": "7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 2, 4",
            "input": "7\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\n2\n4",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constrains": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107",
        "release_time": 1678177862,
        "oracle_code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def satisfiesTrip(self, mid, time, totalTrips):\n        trips = 0\n        for t in time:\n            trips += mid // t\n        \n        return trips >= totalTrips\n    \n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        left = 1\n        right = max(time) * totalTrips\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "2040 ms",
            "memory": 30584000,
            "question_id": "2294",
            "elapsed_time": 2119,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924697286,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 124,
            "total_testcases": 124,
            "runtime_percentile": 29.15560000000043,
            "status_memory": "30.6 MB",
            "memory_percentile": 81.7531,
            "pretty_lang": "Python3",
            "submission_id": "1098291606",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "online-election",
        "description": "You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\nImplement the TopVotedCandidate class:\n\nTopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\nint q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.",
        "examples": [
            "Input\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1"
        ],
        "constrains": "1 <= persons.length <= 5000\ntimes.length == persons.length\n0 <= persons[i] < persons.length\n0 <= times[i] <= 109\ntimes is sorted in a strictly increasing order.\ntimes[0] <= t <= 109\nAt most 104 calls will be made to q.",
        "release_time": 1683431208,
        "oracle_code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```",
        "level": "medium",
        "completed_code": "\nfrom typing import List\n\nclass TopVotedCandidate:\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = persons\n        self.times = times\n        self.leaders = []\n        \n        # Initialize the vote count dictionary\n        votes = {}\n        \n        # Initialize the leading candidate and vote count\n        leader = -1\n        max_votes = 0\n        \n        # Iterate over the persons and times arrays\n        for i in range(len(persons)):\n            person = persons[i]\n            time = times[i]\n            \n            # Add the vote count of the person\n            if person in votes:\n                votes[person] += 1\n            else:\n                votes[person] = 1\n                \n            # Update the leading candidate if necessary\n            if votes[person] >= max_votes:\n                leader = person\n                max_votes = votes[person]\n                \n            # Append the leader at each time\n            self.leaders.append((time, leader))\n        \n    def q(self, t: int) -> int:\n        # Perform binary search to find the leader at time t\n        left = 0\n        right = len(self.leaders) - 1\n        \n        while left < right:\n            mid = (left + right + 1) // 2\n            \n            if self.leaders[mid][0] > t:\n                right = mid - 1\n            else:\n                left = mid\n                \n        return self.leaders[left][1]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "667 ms",
            "memory": 22028000,
            "question_id": "947",
            "elapsed_time": 762,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924714324,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 98,
            "total_testcases": 98,
            "runtime_percentile": 33.80079999999984,
            "status_memory": "22 MB",
            "memory_percentile": 21.4084,
            "pretty_lang": "Python3",
            "submission_id": "1098291727",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "description": "You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti.\nReturn any valid arrangement of pairs.\nNote: The inputs will be generated such that there exists a valid arrangement of pairs.",
        "examples": [
            "Input: pairs = [[5,1],[4,5],[11,9],[9,4]]\nOutput: [[11,9],[9,4],[4,5],[5,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 9 == 9 = start1 \nend1 = 4 == 4 = start2\nend2 = 5 == 5 = start3",
            "Input: pairs = [[1,3],[3,2],[2,1]]\nOutput: [[1,3],[3,2],[2,1]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 3 == 3 = start1\nend1 = 2 == 2 = start2\nThe arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid.",
            "Input: pairs = [[1,2],[1,3],[2,1]]\nOutput: [[1,2],[2,1],[1,3]]\nExplanation:\nThis is a valid arrangement since endi-1 always equals starti.\nend0 = 2 == 2 = start1\nend1 = 1 == 1 = start2"
        ],
        "constrains": "1 <= pairs.length <= 105\npairs[i].length == 2\n0 <= starti, endi <= 109\nstarti != endi\nNo two pairs are exactly the same.\nThere exists a valid arrangement of pairs.",
        "release_time": 1638676934,
        "oracle_code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        # Sort the pairs based on their start index\n        pairs.sort(key=lambda x: x[0])\n        \n        # Initialize the valid arrangement list\n        valid_arrangement = []\n        \n        # Iterate through the pairs\n        for i in range(len(pairs)):\n            # For the first pair, append it to the valid arrangement list\n            if i == 0:\n                valid_arrangement.append(pairs[i])\n            else:\n                # For subsequent pairs, check if the end index of the previous pair is equal to the start index of the current pair\n                if valid_arrangement[i-1][1] == pairs[i][0]:\n                    valid_arrangement.append(pairs[i])\n                else:\n                    # If not, swap the current pair with the next pair to make it valid\n                    valid_arrangement.append([pairs[i][0], pairs[i+1][1]])\n                    valid_arrangement.append([pairs[i+1][0], pairs[i][1]])\n                    \n                    # Skip the next pair in the iteration as it has been processed above\n                    i += 1\n        \n        return valid_arrangement\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 21: IndexError: list index out of range",
            "full_runtime_error": "IndexError: list index out of range\n    valid_arrangement.append([pairs[i][0], pairs[i+1][1]])\nLine 21 in validArrangement (Solution.py)\n    ret = Solution().validArrangement(param_1)\nLine 47 in _driver (Solution.py)\n    _driver()\nLine 58 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16428000,
            "question_id": "2201",
            "elapsed_time": 53,
            "compare_result": "000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[5,1],[4,5],[11,9],[9,4]]",
            "expected_output": "[[11,9],[9,4],[4,5],[5,1]]",
            "task_finish_time": 1699924728808,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 39,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098291823",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "all-elements-in-two-binary-search-trees",
        "description": "Given two binary search trees root1 and root2, return a list containing all the integers from both trees sorted in ascending order.",
        "examples": [
            "Input: root1 = [2,1,4], root2 = [1,0,3]\nOutput: [0,1,1,2,3,4]",
            "Input: root1 = [1,null,8], root2 = [8,1]\nOutput: [1,1,8,8]"
        ],
        "constrains": "The number of nodes in each tree is in the range [0, 5000].\n-105 <= Node.val <= 105",
        "release_time": 1689964880,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        l=list()\n        def traversal(root):\n            if root is None :\n                return\n            l.append(root.val)\n            traversal(root.left)\n            traversal(root.right)\n        traversal(root1)\n        traversal(root2)\n        l.sort()\n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/be31fa66-f14d-4430-a166-5f23f990b4cf_1689964875.4489777.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\\n        l=list()\\n        def traversal(root):\\n            if root is None :\\n                return\\n            l.append(root.val)\\n            traversal(root.left)\\n            traversal(root.right)\\n        traversal(root1)\\n        traversal(root2)\\n        l.sort()\\n        return l\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        # Function to perform inorder traversal of a binary tree\n        def inorder(root, result):\n            if root:\n                # Traverse the left subtree\n                inorder(root.left, result)\n                # Add the root value to the result list\n                result.append(root.val)\n                # Traverse the right subtree\n                inorder(root.right, result)\n        \n        # Initialize two empty lists to store the inorder traversal of each tree\n        tree1 = []\n        tree2 = []\n        \n        # Perform inorder traversal on root1 and store the elements in tree1 list\n        inorder(root1, tree1)\n        \n        # Perform inorder traversal on root2 and store the elements in tree2 list\n        inorder(root2, tree2)\n        \n        # Merge the two lists and return the result\n        return sorted(tree1 + tree2)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "249 ms",
            "memory": 25036000,
            "question_id": "1427",
            "elapsed_time": 281,
            "compare_result": "111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924743890,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 48,
            "total_testcases": 48,
            "runtime_percentile": 72.35109999999997,
            "status_memory": "25 MB",
            "memory_percentile": 34.850799999999985,
            "pretty_lang": "Python3",
            "submission_id": "1098291945",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "description": "Given a sentence\u00a0text (A\u00a0sentence\u00a0is a string of space-separated words) in the following format:\n\nFirst letter is in upper case.\nEach word in text are separated by a single space.\n\nYour task is to rearrange the words in text such that\u00a0all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text\u00a0following the format shown above.",
        "examples": [
            "Input: text = \"Leetcode is cool\"\nOutput: \"Is cool leetcode\"\nExplanation: There are 3 words, \"Leetcode\" of length 8, \"is\" of length 2 and \"cool\" of length 4.\nOutput is ordered by length and the new first word starts with capital letter.",
            "Input: text = \"Keep calm and code on\"\nOutput: \"On and keep calm code\"\nExplanation: Output is ordered as follows:\n\"On\" 2 letters.\n\"and\" 3 letters.\n\"keep\" 4 letters in case of tie order by position in original text.\n\"calm\" 4 letters.\n\"code\" 4 letters.",
            "Input: text = \"To be or not to be\"\nOutput: \"To be or to be not\""
        ],
        "constrains": "text begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5",
        "release_time": 1589688242,
        "oracle_code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def arrangeWords(self, text: str) -> str:\n        # Split the text into a list of words\n        words = text.split()\n        \n        # Sort the words based on their lengths\n        words.sort(key=lambda x: len(x))\n        \n        # Capitalize the first word and convert the rest to lowercase\n        words[0] = words[0].capitalize()\n        for i in range(1, len(words)):\n            words[i] = words[i].lower()\n        \n        # Join the words back into a sentence\n        new_text = ' '.join(words)\n        \n        return new_text\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "56 ms",
            "memory": 18520000,
            "question_id": "1561",
            "elapsed_time": 65,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924758851,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 74,
            "total_testcases": 74,
            "runtime_percentile": 29.6737,
            "status_memory": "18.5 MB",
            "memory_percentile": 70.6231,
            "pretty_lang": "Python3",
            "submission_id": "1098292042",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constrains": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109",
        "release_time": 1672545654,
        "oracle_code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        dp = [[float('inf')] * (k + 1) for _ in range(len(s) + 1)]\n        dp[0][0] = 0\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, k + 1):\n                for l in range(i, 0, -1):\n                    if int(s[l-1:i]) <= j:\n                        dp[i][j] = min(dp[i][j], dp[l-1][j-int(s[l-1:i])] + 1)\n\n        return dp[-1][-1] if dp[-1][-1] != float('inf') else -1\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "frog-position-after-t-seconds",
        "description": "Given an undirected tree consisting of n vertices numbered from 1 to n. A frog starts jumping from vertex 1. In one second, the frog jumps from its current vertex to another unvisited vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\nThe edges of the undirected tree are given in the array edges, where edges[i] = [ai, bi] means that exists an edge connecting the vertices ai and bi.\nReturn the probability that after t seconds the frog is on the vertex target. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\nOutput: 0.16666666666666666 \nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after second 1 and then jumping with 1/2 probability to vertex 4 after second 2. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666.",
            "Input: n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\nOutput: 0.3333333333333333\nExplanation: The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after second 1."
        ],
        "constrains": "1 <= n <= 100\nedges.length == n - 1\nedges[i].length == 2\n1 <= ai, bi <= n\n1 <= t <= 50\n1 <= target <= n",
        "release_time": 1687584099,
        "oracle_code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
        "level": "hard",
        "completed_code": "\nfrom queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        # Create an adjacency list representation of the tree\n        adj_list = [[] for _ in range(n+1)]\n        for a, b in edges:\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n        \n        # Create a boolean array to keep track of visited vertices\n        visited = [False] * (n+1)\n        \n        # Create a probability array to keep track of the probability of being at each vertex\n        probability = [0] * (n+1)\n        \n        # Create a queue to perform breadth-first search\n        queue = Queue()\n        \n        # Initialize the queue with the starting vertex and its probability\n        queue.put((1, 1.0))\n        \n        # Mark the starting vertex as visited\n        visited[1] = True\n        \n        while not queue.empty() and t > 0:\n            size = queue.qsize()\n            \n            for _ in range(size):\n                vertex, prob = queue.get()\n                children = 0\n                \n                # Count the number of unvisited children of the vertex\n                for neighbor in adj_list[vertex]:\n                    if not visited[neighbor]:\n                        children += 1\n                \n                # If the vertex is the target, return its probability\n                if vertex == target:\n                    return prob\n                \n                # Calculate the probability of each unvisited child and add it to the queue\n                for neighbor in adj_list[vertex]:\n                    if not visited[neighbor]:\n                        queue.put((neighbor, prob/children))\n                        visited[neighbor] = True\n                \n                # Update the probability array for the current vertex\n                probability[vertex] = prob\n            \n            t -= 1\n        \n        # If the target is not reached in t seconds, return the probability of the last visited vertex\n        return probability[target]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16480000,
            "question_id": "1493",
            "elapsed_time": 116,
            "compare_result": "00100010011011001110010001010101011101000000100100001111111110000110001010110011010011001100000100101000010000110111101000101111101001000101010010001000010001101110000011111110000101111000110101110011111010",
            "code_output": "0.00000",
            "std_output": "",
            "last_testcase": "7\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\n2\n4",
            "expected_output": "0.16667",
            "task_finish_time": 1699924792712,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 96,
            "total_testcases": 206,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098292294",
            "input_formatted": "7, [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], 2, 4",
            "input": "7\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\n2\n4",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-arithmetic-subsequence-of-given-difference",
        "description": "Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\nA subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.",
        "examples": [
            "Input: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].",
            "Input: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.",
            "Input: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1]."
        ],
        "constrains": "1 <= arr.length <= 105\n-104 <= arr[i], difference <= 104",
        "release_time": 1689295566,
        "oracle_code": "class Solution:\n    def longestSubsequence(self, arr: List[int], d: int) -> int:\n\n        subseqs = {}\n        for n in arr:\n            cnt_prev = subseqs.get(n, 0)\n            cnt_next = subseqs.get(n+d,0)\n            subseqs[n+d] = max(cnt_prev + 1, cnt_next)\n        \n        return max(subseqs.values())",
        "content": "The key idea here is to maintain a dictionary with:\\n1. **keys** being the numbers that we *expect* to encounter in order to increase subsequence, and \\n2. the respective **values** representing lengths of currently constructed subsequences.\\n\\nEvery time we hit one of the expected numbers `n`, we increase the subsequence by updating the `n+d`-th entry of the dictionary. Notice that multiple subsequences of different length sharing some number may be present. To prevent overwriting of large subsequence length by a smaller value, we store a maximal of these (`max(...)`). \\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, arr: List[int], d: int) -> int:\\n\\n        subseqs = {}\\n        for n in arr:\\n            cnt_prev = subseqs.get(n, 0)\\n            cnt_next = subseqs.get(n+d,0)\\n            subseqs[n+d] = max(cnt_prev + 1, cnt_next)\\n        \\n        return max(subseqs.values())\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def longestSubsequence(self, arr: List[int], d: int) -> int:\n        subseq_lengths = {}\n        for num in arr:\n            if num - d in subseq_lengths:\n                subseq_lengths[num] = subseq_lengths[num - d] + 1\n            else:\n                subseq_lengths[num] = 1\n        \n        return max(subseq_lengths.values())\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "445 ms",
            "memory": 30080000,
            "question_id": "1330",
            "elapsed_time": 470,
            "compare_result": "11111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924808201,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 41,
            "runtime_percentile": 91.21759999999999,
            "status_memory": "30.1 MB",
            "memory_percentile": 30.23960000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098292388",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "word-subsets",
        "description": "You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\n\nFor example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.",
        "examples": [
            "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\nOutput: [\"facebook\",\"google\",\"leetcode\"]",
            "Input: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\nOutput: [\"apple\",\"google\",\"leetcode\"]"
        ],
        "constrains": "1 <= words1.length, words2.length <= 104\n1 <= words1[i].length, words2[i].length <= 10\nwords1[i] and words2[i] consist only of lowercase English letters.\nAll the strings of words1 are unique.",
        "release_time": 1659140727,
        "oracle_code": "class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        w2 = reduce(operator.or_, map(Counter, words2))\n        return [w1 for w1 in words1 if Counter(w1) >= w2]",
        "content": "```\\nclass Solution:\\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        w2 = reduce(operator.or_, map(Counter, words2))\\n        return [w1 for w1 in words1 if Counter(w1) >= w2]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        # create a list to store the counts of all letters in words2\n        counts = [0] * 26\n        for word2 in words2:\n            # create a temp list to store the counts of letters in the current word2\n            temp_counts = [0] * 26\n            for char in word2:\n                # update the counts of letters in temp_counts\n                temp_counts[ord(char) - ord('a')] += 1\n            # update the global counts with maximum counts of each letter from all word2\n            for i in range(26):\n                counts[i] = max(counts[i], temp_counts[i])\n\n        result = []\n        for word1 in words1:\n            # create a temp list to store the counts of letters in the current word1\n            temp_counts = [0] * 26\n            for char in word1:\n                # update the counts of letters in temp_counts\n                temp_counts[ord(char) - ord('a')] += 1\n            is_universal = True\n            # check if all letters in words2 are subset of word1\n            for i in range(26):\n                if counts[i] > temp_counts[i]:\n                    is_universal = False\n                    break\n            if is_universal:\n                result.append(word1)\n\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "897 ms",
            "memory": 20756000,
            "question_id": "952",
            "elapsed_time": 914,
            "compare_result": "11111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924824938,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 56,
            "total_testcases": 56,
            "runtime_percentile": 36.24990000000017,
            "status_memory": "20.8 MB",
            "memory_percentile": 34.30420000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098292510",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "magic-squares-in-grid",
        "description": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col\u00a0grid\u00a0of integers, how many 3 x 3 \"magic square\" subgrids are there?\u00a0 (Each subgrid is contiguous).",
        "examples": [
            "Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.",
            "Input: grid = [[8]]\nOutput: 0"
        ],
        "constrains": "row == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
        "release_time": 1690032442,
        "oracle_code": "class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        res = 0\n\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\n\n\n        for i in range(M):\n            for j in range(N):\n                arr = []\n\n                for k in range(3):\n                    if k + i >= M:\n                        break\n                    arr.append(tuple(grid[i + k][j:j + 3]))\n                \n                arr.sort(key=lambda x: x[0])\n\n                if tuple(arr) in solution:\n                    res += 1\n                else:\n                    for row in arr:\n                        row = row[::-1]\n\n                    if tuple(arr) in solution:\n                        res += 1\n\n        \n        return res\n\n\n\n        '''\n        logic: find answer for 3 by 3 grid\n\n        4 3 8 \n        9 5 1\n        2 7 6\n\n\n        8 3 4\n        1 5 9 \n        2 7 6\n\n\n        have a solution key with all possible answers\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\n\n\n        '''",
        "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        count = 0\n        \n        def isMagicSquare(subgrid):\n            # check if subgrid is a magic square\n            \n            # create a set to check for distinct numbers\n            num_set = set()\n            \n            # check if all numbers are unique and between 1 and 9\n            for row in subgrid:\n                for num in row:\n                    if num < 1 or num > 9 or num in num_set:\n                        return False\n                    num_set.add(num)\n            \n            # check if the sums of each row, column, and diagonal are equal\n            row_sum = sum(subgrid[0])\n            \n            # check rows\n            for row in subgrid[1:]:\n                if sum(row) != row_sum:\n                    return False\n            \n            # check columns\n            for col in range(3):\n                if subgrid[0][col] + subgrid[1][col] + subgrid[2][col] != row_sum:\n                    return False\n            \n            # check diagonals\n            if subgrid[0][0] + subgrid[1][1] + subgrid[2][2] != row_sum or subgrid[0][2] + subgrid[1][1] + subgrid[2][0] != row_sum:\n                return False\n            \n            # if all checks pass, subgrid is a magic square\n            return True\n        \n        # iterate over each 3x3 subgrid\n        for i in range(len(grid) - 2):\n            for j in range(len(grid[0]) - 2):\n                subgrid = [grid[i][j:j+3], grid[i+1][j:j+3], grid[i+2][j:j+3]]\n                if isMagicSquare(subgrid):\n                    count += 1\n        \n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "39 ms",
            "memory": 16232000,
            "question_id": "870",
            "elapsed_time": 60,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924842984,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 93,
            "total_testcases": 93,
            "runtime_percentile": 88.63640000000001,
            "status_memory": "16.2 MB",
            "memory_percentile": 69.3181,
            "pretty_lang": "Python3",
            "submission_id": "1098292638",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "description": "Given the array nums, for each nums[i] find out how many numbers in the array are smaller than it. That is, for each nums[i] you have to count the number of valid j's\u00a0such that\u00a0j != i and nums[j] < nums[i].\nReturn the answer in an array.",
        "examples": [
            "Input: nums = [8,1,2,2,3]\nOutput: [4,0,1,1,3]\nExplanation: \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).",
            "Input: nums = [6,5,4,8]\nOutput: [2,1,0,3]",
            "Input: nums = [7,7,7,7]\nOutput: [0,0,0,0]"
        ],
        "constrains": "2 <= nums.length <= 500\n0 <= nums[i] <= 100",
        "release_time": 1691334542,
        "oracle_code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count = [0] * len(nums)\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j and nums[j] < nums[i]:\n                    count[i] += 1\n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "435 ms",
            "memory": 16488000,
            "question_id": "1482",
            "elapsed_time": 457,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924858502,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 103,
            "total_testcases": 103,
            "runtime_percentile": 5.03850000000008,
            "status_memory": "16.5 MB",
            "memory_percentile": 5.125399999999992,
            "pretty_lang": "Python3",
            "submission_id": "1098292740",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1691087840,
        "oracle_code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) <= 2:\n            return len(nums)\n        \n        i = 2\n        for num in nums[2:]:\n            if num != nums[i-2]:\n                nums[i] = num\n                i += 1\n        \n        return i\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "55 ms",
            "memory": 16468000,
            "question_id": "80",
            "elapsed_time": 72,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924873196,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 165,
            "total_testcases": 165,
            "runtime_percentile": 74.6357,
            "status_memory": "16.5 MB",
            "memory_percentile": 19.87059999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098292827",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "description": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.",
        "examples": [
            "Input: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.",
            "Input: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.",
            "Input: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\"."
        ],
        "constrains": "1 <= s.length <= 104\ns[i] is either '0' or '1'.",
        "release_time": 1679330768,
        "oracle_code": "class Solution:\n    def minOperations(self, s: str) -> int:\n        return min(\n            sum(int(bit) == i & 1 for i, bit in enumerate(s)),\n            sum(int(bit) != i & 1 for i, bit in enumerate(s)),\n        )",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, s: str) -> int:\\n        return min(\\n            sum(int(bit) == i & 1 for i, bit in enumerate(s)),\\n            sum(int(bit) != i & 1 for i, bit in enumerate(s)),\\n        )\\n```\\n",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def minOperations(self, s: str) -> int:\n        operations = 0\n        for i in range(len(s)-1):\n            if s[i] == s[i+1]:\n                operations += 1\n        return (operations + 1) // 2\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16516000,
            "question_id": "1884",
            "elapsed_time": 63,
            "compare_result": "11100110010011000010110111010010000100000010011000001000000000000000000000000011111111111",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "\"110010\"",
            "expected_output": "2",
            "task_finish_time": 1699924888724,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 32,
            "total_testcases": 89,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098292939",
            "input_formatted": "\"110010\"",
            "input": "\"110010\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-time-to-type-word-using-special-typewriter",
        "description": "There is a special typewriter with lowercase English letters 'a' to 'z' arranged in a circle with a pointer. A character can only be typed if the pointer is pointing to that character. The pointer is initially pointing to the character 'a'.\n\nEach second, you may perform one of the following operations:\n\nMove the pointer one character counterclockwise or clockwise.\nType the character the pointer is currently on.\n\nGiven a string word, return the minimum number of seconds to type out the characters in word.",
        "examples": [
            "Input: word = \"abc\"\nOutput: 5\nExplanation: \nThe characters are printed as follows:\n- Type the character 'a' in 1 second since the pointer is initially on 'a'.\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer clockwise to 'c' in 1 second.\n- Type the character 'c' in 1 second.",
            "Input: word = \"bza\"\nOutput: 7\nExplanation:\nThe characters are printed as follows:\n- Move the pointer clockwise to 'b' in 1 second.\n- Type the character 'b' in 1 second.\n- Move the pointer counterclockwise to 'z' in 2 seconds.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'a' in 1 second.\n- Type the character 'a' in 1 second.",
            "Input: word = \"zjpc\"\nOutput: 34\nExplanation:\nThe characters are printed as follows:\n- Move the pointer counterclockwise to 'z' in 1 second.\n- Type the character 'z' in 1 second.\n- Move the pointer clockwise to 'j' in 10 seconds.\n- Type the character 'j' in 1 second.\n- Move the pointer clockwise to 'p' in 6 seconds.\n- Type the character 'p' in 1 second.\n- Move the pointer counterclockwise to 'c' in 13 seconds.\n- Type the character 'c' in 1 second."
        ],
        "constrains": "1 <= word.length <= 100\nword consists of lowercase English letters.",
        "release_time": 1629561712,
        "oracle_code": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        ans = len(word)\n        prev = \"a\"\n        for ch in word: \n            val = (ord(ch) - ord(prev)) % 26 \n            ans += min(val, 26 - val)\n            prev = ch\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def minTimeToType(self, word: str) -> int:\\n        ans = len(word)\\n        prev = \"a\"\\n        for ch in word: \\n            val = (ord(ch) - ord(prev)) % 26 \\n            ans += min(val, 26 - val)\\n            prev = ch\\n        return ans \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def minTimeToType(self, word: str) -> int:\n        current = 'a'\n        time = 0\n        for char in word:\n            diff = abs(ord(char) - ord(current))\n            time += min(diff, 26-diff) + 1\n            current = char\n        return time\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16352000,
            "question_id": "2088",
            "elapsed_time": 54,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924903320,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 135,
            "total_testcases": 135,
            "runtime_percentile": 35.70399999999999,
            "status_memory": "16.4 MB",
            "memory_percentile": 7.256899999999995,
            "pretty_lang": "Python3",
            "submission_id": "1098293049",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.",
        "examples": [
            "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.",
            "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.",
            "Input: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0."
        ],
        "constrains": "n == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
        "release_time": 1684312110,
        "oracle_code": "class Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)",
        "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        score1 = 0\n        score2 = 0\n        \n        for i in range(len(nums1)):\n            if i >= 2 and nums1[i] == 10 and nums1[i-1] == 10:\n                score1 += 2 * nums1[i]\n            elif i >= 1 and nums1[i] == 10 and nums1[i-1] < 10:\n                score1 += 2 * nums1[i]\n            else:\n                score1 += nums1[i]\n                \n            if i >= 2 and nums2[i] == 10 and nums2[i-1] == 10:\n                score2 += 2 * nums2[i]\n            elif i >= 1 and nums2[i] == 10 and nums2[i-1] < 10:\n                score2 += 2 * nums2[i]\n            else:\n                score2 += nums2[i]\n        \n        if score1 > score2:\n            return 1\n        elif score1 < score2:\n            return 2\n        else:\n            return 0\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16340000,
            "question_id": "2684",
            "elapsed_time": 261,
            "compare_result": "11110111111111111011011111111111111111001111111111111111111110011111111111111111111111111111111111110011111111111111111111111111111111111110111011111011111111111111101111111101111110011111111111111111111111011111111111111111011111111111111111111111111111011111111111111111111111111111101111111111111111111111111111111111110111111111101111111111110111111111111111111111111111111100111111111111111111011111111111111111111110011111111111111111111111111111111111110111111111111111111111101111111111111111111111111111111111101111110111111111111111101111011101111111111111111111111111110111111011111111111111111111111111000111101111111111111111111111111101011111111111111111110111101010111111111111111111111111111111110011111111110111111111111011111011111111111111111111111111101111111111111111101111111111111111111101111111111111111111111111111111111111111111111111110101111111111111111111111111111111111111111111111111110111111101011111111111111111111111111111111111111111111111111111111111111011111111111111111110111110111111111111101111111101110111111110111101111110101111110111111011111111111100111111100111111111101111111111111110111111011111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[5,6,1,10]\n[5,1,10,5]",
            "expected_output": "2",
            "task_finish_time": 1699924918704,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1126,
            "total_testcases": 1205,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098293161",
            "input_formatted": "[5,6,1,10], [5,1,10,5]",
            "input": "[5,6,1,10]\n[5,1,10,5]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "release_time": 1678875810,
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        i=0\\n        c=0\\n        j=len(nums)-1\\n        while(i<=j):\\n            if(i==j):\\n                c=c+nums[i]\\n                break\\n            s=str(nums[i])+str(nums[j])\\n            c=c+int(s)\\n            i=i+1\\n            j=j-1\\n        return c\\n                \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        conc_val = 0\n        \n        while nums:\n            # If there's only one element\n            if len(nums) == 1:\n                conc_val += nums[0]\n                nums.pop(0)\n            else:\n                first_num = str(nums[0])\n                last_num = str(nums[-1])\n                \n                conc_val += int(first_num + last_num)\n                nums.pop(0)\n                nums.pop(-1)\n        \n        return conc_val\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "63 ms",
            "memory": 16412000,
            "question_id": "2698",
            "elapsed_time": 76,
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924933592,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 53,
            "total_testcases": 53,
            "runtime_percentile": 39.1023,
            "status_memory": "16.4 MB",
            "memory_percentile": 32.37179999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098293280",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "stone-game-vi",
        "description": "Alice and Bob take turns playing a game, with Alice starting first.\nThere are n stones in a pile. On each player's turn, they can remove a stone from the pile and receive points based on the stone's value. Alice and Bob may value the stones differently.\nYou are given two integer arrays of length n, aliceValues and bobValues. Each aliceValues[i] and bobValues[i] represents how Alice and Bob, respectively, value the ith stone.\nThe winner is the person with the most points after all the stones are chosen. If both players have the same amount of points, the game results in a draw. Both players will play optimally.\u00a0Both players know the other's values.\nDetermine the result of the game, and:\n\nIf Alice wins, return 1.\nIf Bob wins, return -1.\nIf the game results in a draw, return 0.",
        "examples": [
            "Input: aliceValues = [1,3], bobValues = [2,1]\nOutput: 1\nExplanation:\nIf Alice takes stone 1 (0-indexed) first, Alice will receive 3 points.\nBob can only choose stone 0, and will only receive 2 points.\nAlice wins.",
            "Input: aliceValues = [1,2], bobValues = [3,1]\nOutput: 0\nExplanation:\nIf Alice takes stone 0, and Bob takes stone 1, they will both have 1 point.\nDraw.",
            "Input: aliceValues = [2,4,3], bobValues = [1,6,7]\nOutput: -1\nExplanation:\nRegardless of how Alice plays, Bob will be able to have more points than Alice.\nFor example, if Alice takes stone 1, Bob can take stone 2, and Alice takes stone 0, Alice will have 6 points to Bob's 7.\nBob wins."
        ],
        "constrains": "n == aliceValues.length == bobValues.length\n1 <= n <= 105\n1 <= aliceValues[i], bobValues[i] <= 100",
        "release_time": 1690568814,
        "oracle_code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # Calculate the sum of values for each stone for both players\n        alice_sum = sum(a)\n        bob_sum = sum(b)\n        \n        # Create a list to store the calculated scores for each stone\n        stone_scores = []\n        \n        # Calculate the score for each stone and store it in stone_scores\n        for i in range(len(a)):\n            score = a[i] + b[i]\n            stone_scores.append((score, i))\n        \n        # Sort the stone_scores list in descending order based on the calculated scores\n        stone_scores.sort(reverse=True)\n        \n        # Create variables to keep track of the total score for each player\n        alice_total = 0\n        bob_total = 0\n        \n        # Iterate through the sorted stone_scores list\n        for score, index in stone_scores:\n            # Check if it's Alice's turn\n            if (alice_total + a[index] <= bob_total + b[index]):\n                # Bob will choose this stone\n                bob_total += b[index]\n            else:\n                # Alice will choose this stone\n                alice_total += a[index]\n        \n        # Compare the total scores of both players\n        if alice_total > bob_total:\n            return 1\n        elif alice_total < bob_total:\n            return -1\n        else:\n            return 0\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 30728000,
            "question_id": "1788",
            "elapsed_time": 1094,
            "compare_result": "10101010010010100010001000110000001110100010111100110001101110110110001000010001011110010100110",
            "code_output": "-1",
            "std_output": "",
            "last_testcase": "[1,2]\n[3,1]",
            "expected_output": "0",
            "task_finish_time": 1699924950731,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 42,
            "total_testcases": 95,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098293390",
            "input_formatted": "[1,2], [3,1]",
            "input": "[1,2]\n[3,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "design-hashmap",
        "description": "Design a HashMap without using any built-in hash table libraries.\nImplement the MyHashMap class:\n\nMyHashMap() initializes the object with an empty map.\nvoid put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.\nint get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.\nvoid remove(key) removes the key and its corresponding value if the map contains the mapping for the key.",
        "examples": [
            "Input\n[\"MyHashMap\", \"put\", \"put\", \"get\", \"get\", \"put\", \"get\", \"remove\", \"get\"]\n[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]\nOutput\n[null, null, null, 1, -1, null, 1, null, -1]\n\nExplanation\nMyHashMap myHashMap = new MyHashMap();\nmyHashMap.put(1, 1); // The map is now [[1,1]]\nmyHashMap.put(2, 2); // The map is now [[1,1], [2,2]]\nmyHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]\nmyHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]\nmyHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)\nmyHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]\nmyHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]\nmyHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]"
        ],
        "constrains": "0 <= key, value <= 106\nAt most 104 calls will be made to put, get, and remove.",
        "release_time": 1684521147,
        "oracle_code": "class MyHashMap:\n\n    def __init__(self):\n        self.h = {}\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.h:\n            self.h[key] = value\n        else:\n            self.h[key] = value\n\n    def get(self, key: int) -> int:\n        if key not in self.h:\n            return -1\n        else:\n            return self.h[key]\n\n    def remove(self, key: int) -> None:\n        if key in self.h:\n            del self.h[key]\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyHashMap:\\n\\n    def __init__(self):\\n        self.h = {}\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.h:\\n            self.h[key] = value\\n        else:\\n            self.h[key] = value\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.h:\\n            return -1\\n        else:\\n            return self.h[key]\\n\\n    def remove(self, key: int) -> None:\\n        if key in self.h:\\n            del self.h[key]\\n\\n# Your MyHashMap object will be instantiated and called as such:\\n# obj = MyHashMap()\\n# obj.put(key,value)\\n# param_2 = obj.get(key)\\n# obj.remove(key)\\n```",
        "level": "easy",
        "completed_code": "\nclass MyHashMap:\n    def __init__(self):\n        # Initialize an empty list to store key-value pairs\n        self.hashmap = []\n\n    def put(self, key: int, value: int) -> None:\n        # Iterate over the existing key-value pairs in the hashmap\n        for pair in self.hashmap:\n            # If the key already exists, update the value\n            if pair[0] == key:\n                pair[1] = value\n                return\n        # If the key doesn't exist, add a new key-value pair\n        self.hashmap.append([key, value])\n\n    def get(self, key: int) -> int:\n        # Iterate over the key-value pairs in the hashmap\n        for pair in self.hashmap:\n            # If the key is found, return the corresponding value\n            if pair[0] == key:\n                return pair[1]\n        # If the key is not found, return -1\n        return -1\n\n    def remove(self, key: int) -> None:\n        # Find the index of the key-value pair in the hashmap\n        index = -1\n        for i, pair in enumerate(self.hashmap):\n            if pair[0] == key:\n                index = i\n                break\n        # If the index is found, remove the key-value pair\n        if index != -1:\n            del self.hashmap[index]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "2264 ms",
            "memory": 19460000,
            "question_id": "817",
            "elapsed_time": 2314,
            "compare_result": "1111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924968721,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 37,
            "total_testcases": 37,
            "runtime_percentile": 6.927299999999801,
            "status_memory": "19.5 MB",
            "memory_percentile": 67.87640000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098293520",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "fizz-buzz",
        "description": "Given an integer n, return a string array answer (1-indexed) where:\n\nanswer[i] == \"FizzBuzz\" if i is divisible by 3 and 5.\nanswer[i] == \"Fizz\" if i is divisible by 3.\nanswer[i] == \"Buzz\" if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.",
        "examples": [
            "Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]",
            "Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]",
            "Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]"
        ],
        "constrains": "1 <= n <= 104",
        "release_time": 1691389137,
        "oracle_code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        # Create an empty list to store the result\n        result = []\n        \n        # Iterate from 1 to n\n        for i in range(1, n+1):\n            # Check if i is divisible by both 3 and 5\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # Check if i is divisible by 3\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # Check if i is divisible by 5\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # If none of the above conditions are true, append i as a string\n            else:\n                result.append(str(i))\n        \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "51 ms",
            "memory": 17348000,
            "question_id": "412",
            "elapsed_time": 64,
            "compare_result": "11111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699924981454,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 8,
            "runtime_percentile": 31.25,
            "status_memory": "17.3 MB",
            "memory_percentile": 31.985300000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098293635",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "description": "You are given a 0-indexed integer array nums. You have to partition the array into one or more contiguous subarrays.\nWe call a partition of the array valid if each of the obtained subarrays satisfies one of the following conditions:\n\nThe subarray consists of exactly 2 equal elements. For example, the subarray [2,2] is good.\nThe subarray consists of exactly 3 equal elements. For example, the subarray [4,4,4] is good.\nThe subarray consists of exactly 3 consecutive increasing elements, that is, the difference between adjacent elements is 1. For example, the subarray [3,4,5] is good, but the subarray [1,3,5] is not.\n\nReturn true if the array has at least one valid partition. Otherwise, return false.",
        "examples": [
            "Input: nums = [4,4,4,5,6]\nOutput: true\nExplanation: The array can be partitioned into the subarrays [4,4] and [4,5,6].\nThis partition is valid, so we return true.",
            "Input: nums = [1,1,1,2]\nOutput: false\nExplanation: There is no valid partition for this array."
        ],
        "constrains": "2 <= nums.length <= 105\n1 <= nums[i] <= 106",
        "release_time": 1691945158,
        "oracle_code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`.",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        if n == 0:\n            return False\n        \n        # check for valid partition for each subarray\n        for i in range(n):\n            if self.isValid(nums[i]):\n                return True\n        \n        return False\n    \n    def isValid(self, subarray):\n        s = len(subarray)\n        \n        # check for subarray with exactly 2 equal elements\n        if s == 2 and subarray[0] == subarray[1]:\n            return True\n        \n        # check for subarray with exactly 3 equal elements\n        if s == 3 and subarray[0] == subarray[1] and subarray[1] == subarray[2]:\n            return True\n        \n        # check for subarray with exactly 3 consecutive increasing elements\n        if s == 3 and subarray[0] + 1 == subarray[1] and subarray[1] + 1 == subarray[2]:\n            return True\n        \n        return False\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 16: TypeError: object of type 'int' has no len()",
            "full_runtime_error": "TypeError: object of type 'int' has no len()\n    s = len(subarray)\nLine 16 in isValid (Solution.py)\n    if self.isValid(nums[i]):\nLine 10 in validPartition (Solution.py)\n    ret = Solution().validPartition(param_1)\nLine 50 in _driver (Solution.py)\n    _driver()\nLine 61 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16472000,
            "question_id": "2443",
            "elapsed_time": 54,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[4,4,4,5,6]",
            "expected_output": "true",
            "task_finish_time": 1699924996622,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 117,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098293733",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "description": "Given an integer array nums that does not contain any zeros, find the largest positive integer k such that -k also exists in the array.\nReturn the positive integer k. If there is no such integer, return -1.",
        "examples": [
            "Input: nums = [-1,2,-3,3]\nOutput: 3\nExplanation: 3 is the only valid k we can find in the array.",
            "Input: nums = [-1,10,6,7,-7,1]\nOutput: 7\nExplanation: Both 1 and 7 have their corresponding negative values in the array. 7 has a larger value.",
            "Input: nums = [-10,8,6,7,-2,-3]\nOutput: -1\nExplanation: There is no a single valid k, we return -1."
        ],
        "constrains": "1 <= nums.length <= 1000\n-1000 <= nums[i] <= 1000\nnums[i] != 0",
        "release_time": 1665895358,
        "oracle_code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        \n        num_set = set(nums)  # Create a set of the input array\n        \n        max_k = -1  # Initialize the maximum positive integer as -1\n        \n        for num in num_set:  # For each number in the set\n            if -num in num_set:  # If the negative of the number also exists in the set\n                max_k = max(max_k, num)  # Update the maximum positive integer\n        \n        return max_k  # Return the maximum positive integer, or -1 if no such integer exists\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "123 ms",
            "memory": 16596000,
            "question_id": "2524",
            "elapsed_time": 158,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925011891,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 337,
            "total_testcases": 337,
            "runtime_percentile": 51.889100000000035,
            "status_memory": "16.6 MB",
            "memory_percentile": 19.7778,
            "pretty_lang": "Python3",
            "submission_id": "1098293835",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1"
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4",
        "release_time": 1688294967,
        "oracle_code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            c, i, j = q.popleft()\n            if c > distance[i][j]: continue\n            if i == m - 1 and j == n - 1: return c\n            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if c + int(d != grid[i][j]) < distance[ci][cj]:\n                        distance[ci][cj] = c + int(d != grid[i][j])\n                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))\n                        else: q.append((distance[ci][cj], ci, cj))\n        \n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            c, i, j = q.popleft()\\n            if c > distance[i][j]: continue\\n            if i == m - 1 and j == n - 1: return c\\n            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if c + int(d != grid[i][j]) < distance[ci][cj]:\\n                        distance[ci][cj] = c + int(d != grid[i][j])\\n                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))\\n                        else: q.append((distance[ci][cj], ci, cj))\\n        \\n        return distance[m - 1][n - 1]\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        if not grid:\n            return 0\n        \n        m, n = len(grid), len(grid[0])\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        queue = deque([(0, 0, 0)])\n        visited = set([(0, 0)])\n        \n        while queue:\n            x, y, cost = queue.popleft()\n            \n            if x == m - 1 and y == n - 1:\n                return cost\n            \n            for i in range(4):\n                dx, dy = directions[i]\n                nx, ny = x + dx, y + dy\n                \n                if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    \n                    if grid[x][y] == i + 1:\n                        queue.appendleft((nx, ny, cost))\n                    else:\n                        queue.append((nx, ny, cost + 1))\n        \n        return -1\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 18044000,
            "question_id": "1485",
            "elapsed_time": 255,
            "compare_result": "10111110110000000101000101111101101000000000000000000000000000000000",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[[1,1,3],[3,2,2],[1,1,4]]",
            "expected_output": "0",
            "task_finish_time": 1699925026823,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 19,
            "total_testcases": 68,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098293935",
            "input_formatted": "[[1,1,3],[3,2,2],[1,1,4]]",
            "input": "[[1,1,3],[3,2,2],[1,1,4]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "description": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.",
        "examples": [
            "Input: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.",
            "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.",
            "Input: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words."
        ],
        "constrains": "1 <= s.length <= 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.",
        "release_time": 1686875139,
        "oracle_code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        if not s or not words:\n            return []\n        \n        word_length = len(words[0])\n        total_words = len(words)\n        window_size = word_length * total_words\n        result = []\n        \n        word_count = {}\n        for word in words:\n            if word not in word_count:\n                word_count[word] = 0\n            word_count[word] += 1\n        \n        for i in range(len(s) - window_size + 1):\n            substring = s[i:i+window_size]\n            temp_count = {}\n            \n            for j in range(0, window_size, word_length):\n                current_word = substring[j:j+word_length]\n                if current_word not in word_count:\n                    break\n                \n                if current_word not in temp_count:\n                    temp_count[current_word] = 0\n                temp_count[current_word] += 1\n                \n                if temp_count[current_word] > word_count[current_word]:\n                    break\n                \n                if j == window_size - word_length:\n                    result.append(i)\n        \n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
        ],
        "constrains": "1 <= targetX, targetY\u00a0<= 109",
        "release_time": 1674321554,
        "oracle_code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=1:\n            if d&1:\n                return False\n            d>>=1\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite straightforward: a pair (a, b) is accessible if and only if the greatest common divisor of a and b, gcd(a, b), is a power of 2.\\nThe difficulty is proving this, which fortunately was not required during the contest. Anyway, here is the proof.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn one direction, note that all four operations preserve this property. The starting pair (1, 1) has it since $gcd(1, 1)=1=2^0$, the first two operations preserve the gcd, and the last two operations can multiply the gcd by 2 (or not). Thus, gcd(a, b) can only be a power of 2.\\n\\nConversely, starting from (1, 1) and multiplying the first term repeatedly by 2 we can obtain any pair of the form $(2^n, 1)$, then subtracting $1$ from $2^n$ repeatedly we can obtain any pair of the form $(n, 1)$.\\n\\nMultiplying the second term by 2 repeatedly we can obtain any pair of the form $(n, 2^m)$, then by subtracting $n$ from $2^m$ repeatedly we can obtain any pair of the form $(n,\\\\ 2^m \\\\mod n)$.\\n\\nSuppose we want to obtain the pair (n, k), where k<n and gcd(n, k)=1. Consider the infinite arithmetic progression (n, n+k, n+2k, ...). By Dirichlet\\'s theorem, this progression contains infinitely many primes. Consider one of them: p=n+jk for some $j \\\\geq 0$.\\n\\nBy a slight generalization of [Artin\\'s conjecture](https://mathworld.wolfram.com/ArtinsConjecture.html) (the generalization may need proof, but Artin\\'s conjecture was proved by Christopher Hooley, [\"On Artin\\'s Conjecture\"](https://eudml.org/doc/150785), in 1967, assuming the [Generalized Riemann Hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis)), there are infinitely many such p for which 2 is a primitive root of unity modulo p, meaning that $2^{p-1} \\\\equiv 1 \\\\mod p$ and $2^{k} \\\\not \\\\equiv 1 \\\\mod p$ for $0<k<p-1$.\\n\\nWe know we can obtain any pair of the form $(p,\\\\ 2^m \\\\mod p)$. Since p is prime, the multiplicative group $\\\\mathbb Z_p^*$ is cyclic. Since 2 is a generator (its order is equal to the order of the group), we can obtain any pair (p, k) where $1 \\\\leq k <p$ using powers of 2 modulo p, including the k we want.\\n\\nBut this is the same as (n+jk, k) and then by repeatedly subtracting k from n+jk we can obtain (n, k), as desired.\\n\\nBy symmetry (doing the same thing in reverse if necessary), we can obtain any pair (n, m) where gcd(m, n)=1. Finally, multiplying m and n by (possibly different) arbitrary powers of 2 we can obtain any pair whose gcd is a power of two.\\n\\nEdited: The initial proof was wrong and I corrected it.\\n\\n# Complexity\\n- Time complexity: Logarithmic: $O(\\\\max(\\\\log a, \\\\log b))$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        # base case: if targetX and targetY are both 1, return True\n        if targetX == 1 and targetY == 1:\n            return True\n\n        # base case: if targetX or targetY is 0, return False\n        if targetX == 0 or targetY == 0:\n            return False\n\n        # finding the GCD of targetX and targetY\n        gcd_val = self.gcd(targetX, targetY)\n\n        # if gcd is not 1, return False\n        if gcd_val != 1:\n            return False\n\n        # if targetX and targetY are both even, return False\n        if targetX % 2 == 0 and targetY % 2 == 0:\n            return False\n\n        # recursive check for new targetX and targetY values\n        new_targetX = abs(targetX - targetY)\n        new_targetY = min(targetX, targetY)\n        return self.isReachable(new_targetX, new_targetY)\n\n    def gcd(self, a, b):\n        # helper function to find the GCD of two numbers\n        while b:\n            a, b = b, a % b\n        return a\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16940000,
            "question_id": "2635",
            "elapsed_time": 57,
            "compare_result": "111110011110111011111110011011111111111011111010111111111111",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "536870912\n536870912",
            "expected_output": "true",
            "task_finish_time": 1699925057237,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 50,
            "total_testcases": 60,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098294166",
            "input_formatted": "536870912, 536870912",
            "input": "536870912\n536870912",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "replace-elements-in-an-array",
        "description": "You are given a 0-indexed array nums that consists of n distinct positive integers. Apply m operations to this array, where in the ith operation you replace the number operations[i][0] with operations[i][1].\nIt is guaranteed that in the ith operation:\n\noperations[i][0] exists in nums.\noperations[i][1] does not exist in nums.\n\nReturn the array obtained after applying all the operations.",
        "examples": [
            "Input: nums = [1,2,4,6], operations = [[1,3],[4,7],[6,1]]\nOutput: [3,2,7,1]\nExplanation: We perform the following operations on nums:\n- Replace the number 1 with 3. nums becomes [3,2,4,6].\n- Replace the number 4 with 7. nums becomes [3,2,7,6].\n- Replace the number 6 with 1. nums becomes [3,2,7,1].\nWe return the final array [3,2,7,1].",
            "Input: nums = [1,2], operations = [[1,3],[2,1],[3,2]]\nOutput: [2,1]\nExplanation: We perform the following operations to nums:\n- Replace the number 1 with 3. nums becomes [3,2].\n- Replace the number 2 with 1. nums becomes [3,1].\n- Replace the number 3 with 2. nums becomes [2,1].\nWe return the array [2,1]."
        ],
        "constrains": "n == nums.length\nm == operations.length\n1 <= n, m <= 105\nAll the values of nums are distinct.\noperations[i].length == 2\n1 <= nums[i], operations[i][0], operations[i][1] <= 106\noperations[i][0] will exist in nums when applying the ith operation.\noperations[i][1] will not exist in nums when applying the ith operation.",
        "release_time": 1687932229,
        "oracle_code": "class Solution:\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n    index_map = defaultdict(int)\n    for i, n in enumerate(nums):\n      index_map[n] = i\n    \n    for op in operations:\n      n1, n2 = op\n      nums[index_map[n1]] = n2\n      index_map[n2] = index_map[n1]\n    \n    return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n    index_map = defaultdict(int)\\n    for i, n in enumerate(nums):\\n      index_map[n] = i\\n    \\n    for op in operations:\\n      n1, n2 = op\\n      nums[index_map[n1]] = n2\\n      index_map[n2] = index_map[n1]\\n    \\n    return nums\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n    for operation in operations:\n        index = nums.index(operation[0])\n        nums[index] = operation[1]\n    return nums\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.",
        "examples": [
            "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.",
            "Input: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.",
            "Input: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges."
        ],
        "constrains": "3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
        "release_time": 1671397421,
        "oracle_code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        def dfs(node, visited, graph):\n            visited[node] = True\n            count = 0\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    count += 1 + dfs(neighbor, visited, graph)\n            return count\n        \n        degrees = [0] * (n+1)\n        graph = [[] for _ in range(n+1)]\n        for edge in edges:\n            u, v = edge\n            degrees[u] += 1\n            degrees[v] += 1\n            graph[u].append(v)\n            graph[v].append(u)\n        \n        for i in range(1, n+1):\n            if degrees[i] % 2 != 0:\n                return False\n        \n        visited = [False] * (n+1)\n        count = dfs(1, visited, graph)\n        \n        return count == 0 or count == 2\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 60824000,
            "question_id": "2596",
            "elapsed_time": 1337,
            "compare_result": "0010000000100000000000000000110010100110000000110011",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "5\n[[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]",
            "expected_output": "true",
            "task_finish_time": 1699925088537,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 12,
            "total_testcases": 52,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098294362",
            "input_formatted": "5, [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]",
            "input": "5\n[[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.",
        "examples": [
            "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.",
            "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve."
        ],
        "constrains": "1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi\u00a0<= n - 1",
        "release_time": 1681617659,
        "oracle_code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        # Construct the graph\n        graph = defaultdict(list)\n        for edge in edges:\n            a, b = edge\n            graph[a].append(b)\n            graph[b].append(a)\n        \n        # Initialize the dp table\n        dp = [[0] * (n+1) for _ in range(n)]\n        \n        # Perform DFS to calculate LCA and initialize dp table\n        def dfs(i, l, p):\n            dp[i][0] = p\n            for child in graph[i]:\n                if child != l:\n                    dfs(child, i, price[child])\n        \n        dfs(0, -1, price[0])\n        \n        # Calculate LCA for each pair of nodes\n        def LCA(a, b):\n            if a == b:\n                return a\n            if dp[a][b]:\n                return dp[a][b]\n            if dp[b][a]:\n                return dp[b][a]\n            lca = 0\n            for i in range(n):\n                if dp[a][i] and dp[b][i]:\n                    lca = i\n                    break\n            dp[a][b] = lca\n            dp[b][a] = lca\n            return lca\n        \n        # Perform dynamic programming on dp table\n        def dp(i, p):\n            ans = p\n            for j in range(n):\n                if dp[i][j]:\n                    ans += dp[j][0]\n            for trip in trips:\n                u, v = trip\n                lca = LCA(u, v)\n                ans -= dp[lca][0]\n            return ans\n        \n        return dp(0, price[0])\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 44: TypeError: 'function' object is not subscriptable",
            "full_runtime_error": "TypeError: 'function' object is not subscriptable\n    if dp[i][j]:\nLine 44 in dp (Solution.py)\n    return dp(0, price[0])\nLine 52 in minimumTotalPrice (Solution.py)\n    ret = Solution().minimumTotalPrice(param_1, param_2, param_3, param_4)\nLine 87 in _driver (Solution.py)\n    _driver()\nLine 98 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16528000,
            "question_id": "2739",
            "elapsed_time": 57,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "4\n[[0,1],[1,2],[1,3]]\n[2,2,10,6]\n[[0,3],[2,1],[2,3]]",
            "expected_output": "23",
            "task_finish_time": 1699925107118,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 407,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098294497",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "release_time": 1692254547,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            # If there are no elements to construct the tree\n            if left > right:\n                return None\n            # Pick current node from preorder traversal using preorder index\n            node_val = preorder[preorder_idx]\n            node = TreeNode(node_val)\n            preorder_idx += 1\n            # Construct the left and right subtrees recursively\n            # using the inorder index of current node\n            node.left = treeHelper(left, inorder_idx_map[node_val] - 1)\n            node.right = treeHelper(inorder_idx_map[node_val] + 1, right)\n            return node\n        \n        # Creating a hashmap to store the inorder index of each node\n        inorder_idx_map = {}\n        for idx, val in enumerate(inorder):\n            inorder_idx_map[val] = idx\n            \n        preorder_idx = 0\n        # Constructing the tree using the helper function\n        root = treeHelper(0, len(preorder) - 1)\n        return root\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "67 ms",
            "memory": 21044000,
            "question_id": "105",
            "elapsed_time": 83,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925122224,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 203,
            "total_testcases": 203,
            "runtime_percentile": 79.26230000000001,
            "status_memory": "21 MB",
            "memory_percentile": 83.41829999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098294602",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "nim-game",
        "description": "You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\n\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.",
        "examples": [
            "Input: n = 4\nOutput: false\nExplanation: These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.",
            "Input: n = 1\nOutput: true",
            "Input: n = 2\nOutput: true"
        ],
        "constrains": "1 <= n <= 231 - 1",
        "release_time": 1676816152,
        "oracle_code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0",
        "content": "This is a classic example of a game theory problem where both players play optimally. The game\\'s outcome depends on the number of stones in the heap. To determine whether you can win the game or not, we need to look at the number of stones in the heap and find a pattern.\\n\\nLet\\'s consider the base cases first:\\n\\n- If there is only one stone, you can remove it and win the game.\\n- If there are two stones, you can remove one stone and win the game.\\n- If there are three stones, you can remove two stones and win the game.\\n\\nFor n=4, you cannot win the game, as you can remove at most three stones on your turn, and your friend can remove the remaining stones on their turn. Therefore, your friend will win the game.\\n\\nFor n=5,6,7, you can win the game. If there are 5 stones, you can remove one stone and reduce it to four stones, and your friend will be forced to remove one to three stones. In any case, you will be able to remove the last stone and win the game.\\n\\nSimilarly, if there are six stones, you can remove two stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nIf there are seven stones, you can remove three stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nWe can observe that for any n that is a multiple of four, you cannot win the game. For any other value of n, you can win the game.\\n\\nTherefore, to solve this problem, we need to check if n is a multiple of four or not. If it is, return false; otherwise, return true.\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def canWinNim(self, n: int) -> bool:\n        if n % 4 != 0:\n            return True\n        else:\n            return False\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "40 ms",
            "memory": 16292000,
            "question_id": "292",
            "elapsed_time": 52,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925137486,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 60,
            "total_testcases": 60,
            "runtime_percentile": 41.54440000000003,
            "status_memory": "16.3 MB",
            "memory_percentile": 22.074999999999996,
            "pretty_lang": "Python3",
            "submission_id": "1098294707",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "palindrome-pairs",
        "description": "You are given a 0-indexed array of unique strings words.\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a palindrome.\n\nReturn an array of all the palindrome pairs of words.",
        "examples": [
            "Input: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]",
            "Input: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]",
            "Input: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]"
        ],
        "constrains": "1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.",
        "release_time": 1663377683,
        "oracle_code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        # Create a dictionary to store the indices of words\n        word_dict = {}\n        for i, word in enumerate(words):\n            word_dict[word] = i\n        \n        # Create an empty list to store palindrome pairs\n        palindrome_pairs = []\n        \n        for i, word in enumerate(words):\n            # Check if reverse of current word exists in the dictionary\n            if word[::-1] in word_dict:\n                j = word_dict[word[::-1]]\n                # Check if the reverse word is not the same as the current word\n                if i != j:\n                    palindrome_pairs.append([i, j])\n            \n            # Check if any prefix of current word is a palindrome\n            for k in range(1, len(word)):\n                prefix = word[:k]\n                if prefix == prefix[::-1] and word[::-1] + prefix in word_dict:\n                    j = word_dict[word[::-1] + prefix]\n                    palindrome_pairs.append([j, i])\n            \n            # Check if any suffix of current word is a palindrome\n            for k in range(1, len(word)):\n                suffix = word[k:]\n                if suffix == suffix[::-1] and suffix + word[::-1] in word_dict:\n                    j = word_dict[suffix + word[::-1]]\n                    palindrome_pairs.append([i, j])\n        \n        return palindrome_pairs\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 28780000,
            "question_id": "336",
            "elapsed_time": 2404,
            "compare_result": "0100000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011101000011111011111",
            "code_output": "[[0,1],[1,0]]",
            "std_output": "",
            "last_testcase": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
            "expected_output": "[[0,1],[1,0],[3,2],[2,4]]",
            "task_finish_time": 1699925156928,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 136,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098294835",
            "input_formatted": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
            "input": "[\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "description": "You are given a 0-indexed integer array nums and an integer pivot. Rearrange nums such that the following conditions are satisfied:\n\nEvery element less than pivot appears before every element greater than pivot.\nEvery element equal to pivot appears in between the elements less than and greater than pivot.\nThe relative order of the elements less than pivot and the elements greater than pivot is maintained.\n\t\nMore formally, consider every pi, pj where pi is the new position of the ith element and pj is the new position of the jth element. For elements less than pivot, if i < j and nums[i] < pivot and nums[j] < pivot, then pi < pj. Similarly for elements greater than pivot, if i < j and nums[i] > pivot and nums[j] > pivot, then pi < pj.\n\n\n\nReturn nums after the rearrangement.",
        "examples": [
            "Input: nums = [9,12,5,10,14,3,10], pivot = 10\nOutput: [9,5,3,10,10,12,14]\nExplanation: \nThe elements 9, 5, and 3 are less than the pivot so they are on the left side of the array.\nThe elements 12 and 14 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [9, 5, 3] and [12, 14] are the respective orderings.",
            "Input: nums = [-3,4,3,2], pivot = 2\nOutput: [-3,2,4,3]\nExplanation: \nThe element -3 is less than the pivot so it is on the left side of the array.\nThe elements 4 and 3 are greater than the pivot so they are on the right side of the array.\nThe relative ordering of the elements less than and greater than pivot is also maintained. [-3] and [4, 3] are the respective orderings."
        ],
        "constrains": "1 <= nums.length <= 105\n-106 <= nums[i] <= 106\npivot equals to an element of nums.",
        "release_time": 1675783420,
        "oracle_code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        less = []\n        equal = []\n        greater = []\n        \n        for num in nums:\n            if num < pivot:\n                less.append(num)\n            elif num > pivot:\n                greater.append(num)\n            else:\n                equal.append(num)\n        \n        return less + equal + greater\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1121 ms",
            "memory": 33336000,
            "question_id": "2265",
            "elapsed_time": 1174,
            "compare_result": "11111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925170605,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 44,
            "total_testcases": 44,
            "runtime_percentile": 52.834399999999945,
            "status_memory": "33.3 MB",
            "memory_percentile": 49.432900000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098294936",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.",
        "examples": [
            "Input: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.",
            "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.",
            "Input: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city."
        ],
        "constrains": "1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
        "release_time": 1676207658,
        "oracle_code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        n = len(roads) + 1\n        graph = [[] for _ in range(n)]\n        for i, j in roads:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        def dfs(node, parent):\n            total_seats = 0\n            fuel_cost = 0\n            \n            # calculate total seats and fuel cost for all child nodes\n            for child in graph[node]:\n                if child != parent:\n                    child_seats, child_fuel = dfs(child, node)\n                    total_seats += child_seats\n                    fuel_cost += child_fuel\n            \n            # calculate fuel cost to reach the capital city\n            if node == 0:\n                fuel_cost += (total_seats // seats)  # divide total seats by seats per car\n            \n            # calculate remaining seats after all child nodes have been visited\n            remaining_seats = max(0, total_seats - seats)\n            \n            return remaining_seats, fuel_cost\n        \n        _, fuel_cost = dfs(0, -1)\n        \n        return fuel_cost\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 156800000,
            "question_id": "2568",
            "elapsed_time": 1626,
            "compare_result": "00100000000001000010000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[[0,1],[0,2],[0,3]]\n5",
            "expected_output": "3",
            "task_finish_time": 1699925186536,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 131,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098295035",
            "input_formatted": "[[0,1],[0,2],[0,3]], 5",
            "input": "[[0,1],[0,2],[0,3]]\n5",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sliding-window-median",
        "description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.\n\nFor examples, if arr = [2,3,4], the median is 3.\nFor examples, if arr = [1,2,3,4], the median is (2 + 3) / 2 = 2.5.\n\nYou are given an integer array nums and an integer k. There is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the median array for each window in the original array. Answers within 10-5 of the actual value will be accepted.",
        "examples": [
            "Input: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]\nExplanation: \nWindow position                Median\n---------------                -----\n[1  3  -1] -3  5  3  6  7        1\n 1 [3  -1  -3] 5  3  6  7       -1\n 1  3 [-1  -3  5] 3  6  7       -1\n 1  3  -1 [-3  5  3] 6  7        3\n 1  3  -1  -3 [5  3  6] 7        5\n 1  3  -1  -3  5 [3  6  7]       6",
            "Input: nums = [1,2,3,4,2,3,1,4,2], k = 3\nOutput: [2.00000,3.00000,3.00000,3.00000,2.00000,3.00000,2.00000]"
        ],
        "constrains": "1 <= k <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1687587517,
        "oracle_code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```",
        "level": "hard",
        "completed_code": "\nfrom typing import List\nfrom heapq import heappush, heappop\n\nclass Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        result = []\n        min_heap, max_heap = [], []\n\n        for i in range(len(nums)):\n            # Add the number to the appropriate heap\n            if not min_heap or nums[i] > min_heap[0]:\n                heappush(min_heap, nums[i])\n            else:\n                heappush(max_heap, -nums[i])\n\n            # If the heaps are unbalanced, adjust them\n            if len(min_heap) - len(max_heap) > 1:\n                num = heappop(min_heap)\n                heappush(max_heap, -num)\n            elif len(max_heap) - len(min_heap) > 1:\n                num = -heappop(max_heap)\n                heappush(min_heap, num)\n\n            # If the window is of size k, calculate the median and add it to the result\n            if i >= k - 1:\n                if k % 2 == 0:\n                    median = (min_heap[0] - max_heap[0]) / 2\n                else:\n                    median = float(min_heap[0]) if len(min_heap) > len(max_heap) else float(-max_heap[0])\n                result.append(median)\n\n                # Remove the number from the heaps\n                if nums[i - k + 1] <= min_heap[0]:\n                    min_heap.remove(nums[i - k + 1])\n                    heappush(min_heap, nums[i - k + 1])\n                else:\n                    max_heap.remove(-nums[i - k + 1])\n                    heappush(max_heap, -nums[i - k + 1])\n\n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 35: ValueError: list.remove(x): x not in list",
            "full_runtime_error": "ValueError: list.remove(x): x not in list\n    min_heap.remove(nums[i - k + 1])\nLine 35 in medianSlidingWindow (Solution.py)\n    ret = Solution().medianSlidingWindow(param_1, param_2)\nLine 66 in _driver (Solution.py)\n    _driver()\nLine 77 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16308000,
            "question_id": "480",
            "elapsed_time": 53,
            "compare_result": "0000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[1,3,-1,-3,5,3,6,7]\n3",
            "expected_output": "[1.00000,-1.00000,-1.00000,3.00000,5.00000,6.00000]",
            "task_finish_time": 1699925206950,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 43,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098295186",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "watering-plants-ii",
        "description": "Alice and Bob want to water n plants in their garden. The plants are arranged in a row and are labeled from 0 to n - 1 from left to right where the ith plant is located at x = i.\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:\n\nAlice waters the plants in order from left to right, starting from the 0th plant. Bob waters the plants in order from right to left, starting from the (n - 1)th plant. They begin watering the plants simultaneously.\nIt takes the same amount of time to water each plant regardless of how much water it needs.\nAlice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.\nIn case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a 0-indexed integer array plants of n integers, where plants[i] is the amount of water the ith plant needs, and two integers capacityA and capacityB representing the capacities of Alice's and Bob's watering cans respectively, return the number of times they have to refill to water all the plants.",
        "examples": [
            "Input: plants = [2,2,3,3], capacityA = 5, capacityB = 5\nOutput: 1\nExplanation:\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.",
            "Input: plants = [2,2,3,3], capacityA = 3, capacityB = 4\nOutput: 2\nExplanation:\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.",
            "Input: plants = [5], capacityA = 10, capacityB = 8\nOutput: 0\nExplanation:\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0."
        ],
        "constrains": "n == plants.length\n1 <= n <= 105\n1 <= plants[i] <= 106\nmax(plants[i]) <= capacityA, capacityB <= 109",
        "release_time": 1639281726,
        "oracle_code": "class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        refills = 0\n        left = 0\n        right = len(plants) - 1\n        waterA = 0\n        waterB = 0\n        \n        while left <= right:\n            if plants[left] <= capacityA - waterA:\n                waterA += plants[left]\n                left += 1\n            else:\n                refills += 1\n                waterA = 0\n                \n            if left > right:\n                break\n                \n            if plants[right] <= capacityB - waterB:\n                waterB += plants[right]\n                right -= 1\n            else:\n                refills += 1\n                waterB = 0\n                \n        return refills\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 31620000,
            "question_id": "2228",
            "elapsed_time": 749,
            "compare_result": "011100011110011001101011011110100111110000100011100000010",
            "code_output": "2",
            "std_output": "",
            "last_testcase": "[2,2,3,3]\n5\n5",
            "expected_output": "1",
            "task_finish_time": 1699925222677,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 29,
            "total_testcases": 57,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098295290",
            "input_formatted": "[2,2,3,3], 5, 5",
            "input": "[2,2,3,3]\n5\n5",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reveal-cards-in-increasing-order",
        "description": "You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\nYou will do the following steps repeatedly until all cards are revealed:\n\nTake the top card of the deck, reveal it, and take it out of the deck.\nIf there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\nIf there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\nNote that the first entry in the answer is considered to be the top of the deck.",
        "examples": [
            "Input: deck = [17,13,11,2,3,5,7]\nOutput: [2,13,3,11,5,17,7]\nExplanation: \nWe get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.",
            "Input: deck = [1,1000]\nOutput: [1,1000]"
        ],
        "constrains": "1 <= deck.length <= 1000\n1 <= deck[i] <= 106\nAll the values of deck are unique.",
        "release_time": 1667400873,
        "oracle_code": "class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)",
        "content": "# Code\\n```\\nclass Solution:\\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        def reveal(n):\\n            lst = list(range(n))\\n            ans = []\\n            i = 0\\n            while lst:\\n                if not i&1: ans.append(lst.pop(0))\\n                else: lst.append(lst.pop(0))\\n                i += 1\\n            return ans\\n        ans = reveal(len(deck))\\n        ans = sorted([v, i] for i, v in enumerate(ans))\\n        deck.sort()\\n        return (deck[j] for i,j in ans)\\n```",
        "level": "medium",
        "completed_code": "\nfrom collections import deque\nclass Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        deck.sort(reverse=True)\n        result = deque()\n        for card in deck:\n            if result:\n                result.appendleft(result.pop())\n            result.appendleft(card)\n        return list(result)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "47 ms",
            "memory": 16600000,
            "question_id": "987",
            "elapsed_time": 68,
            "compare_result": "111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925237176,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 33,
            "total_testcases": 33,
            "runtime_percentile": 79.07690000000001,
            "status_memory": "16.6 MB",
            "memory_percentile": 14.153800000000004,
            "pretty_lang": "Python3",
            "submission_id": "1098295402",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "description": "There are n houses evenly lined up on the street, and each house is beautifully painted. You are given a 0-indexed integer array colors of length n, where colors[i] represents the color of the ith house.\nReturn the maximum distance between two houses with different colors.\nThe distance between the ith and jth houses is abs(i - j), where abs(x) is the absolute value of x.",
        "examples": [
            "Input: colors = [1,1,1,6,1,1,1]\nOutput: 3\nExplanation: In the above image, color 1 is blue, and color 6 is red.\nThe furthest two houses with different colors are house 0 and house 3.\nHouse 0 has color 1, and house 3 has color 6. The distance between them is abs(0 - 3) = 3.\nNote that houses 3 and 6 can also produce the optimal answer.",
            "Input: colors = [1,8,3,8,3]\nOutput: 4\nExplanation: In the above image, color 1 is blue, color 8 is yellow, and color 3 is green.\nThe furthest two houses with different colors are house 0 and house 4.\nHouse 0 has color 1, and house 4 has color 3. The distance between them is abs(0 - 4) = 4.",
            "Input: colors = [0,1]\nOutput: 1\nExplanation: The furthest two houses with different colors are house 0 and house 1.\nHouse 0 has color 0, and house 1 has color 1. The distance between them is abs(0 - 1) = 1."
        ],
        "constrains": "n ==\u00a0colors.length\n2 <= n <= 100\n0 <= colors[i] <= 100\nTest data are generated such that at least two houses have different colors.",
        "release_time": 1637467628,
        "oracle_code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        first_index = {}\n        last_index = {}\n        max_distance = 0\n        \n        # Iterate through the colors and store the first and last index of each color\n        for i in range(len(colors)):\n            color = colors[i]\n            \n            # Update the first index of the color if it is not already stored\n            if color not in first_index:\n                first_index[color] = i\n            \n            # Update the last index of the color\n            last_index[color] = i\n        \n        # Calculate the maximum distance between houses with different colors\n        for color in first_index:\n            max_distance = max(max_distance, last_index[color] - first_index[color])\n        \n        return max_distance\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16360000,
            "question_id": "2199",
            "elapsed_time": 59,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "6",
            "std_output": "",
            "last_testcase": "[1,1,1,6,1,1,1]",
            "expected_output": "3",
            "task_finish_time": 1699925252106,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 126,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098295525",
            "input_formatted": "[1,1,1,6,1,1,1]",
            "input": "[1,1,1,6,1,1,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "baseball-game",
        "description": "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\nAn integer x.\n\n\t\nRecord a new score of x.\n\n\n'+'.\n\t\nRecord a new score that is the sum of the previous two scores.\n\n\n'D'.\n\t\nRecord a new score that is the double of the previous score.\n\n\n'C'.\n\t\nInvalidate the previous score, removing it from the record.\n\n\n\nReturn the sum of all the scores on the record after applying all the operations.\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.",
        "examples": [
            "Input: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.",
            "Input: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.",
            "Input: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0."
        ],
        "constrains": "1 <= operations.length <= 1000\noperations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\nFor operation \"+\", there will always be at least two previous scores on the record.\nFor operations \"C\" and \"D\", there will always be at least one previous score on the record.",
        "release_time": 1681186635,
        "oracle_code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack = []\n        for op in operations:\n            if op == '+':\n                # add the sum of the previous two scores to the record\n                stack.append(stack[-1] + stack[-2])\n            elif op == 'D':\n                # double the previous score and add to the record\n                stack.append(stack[-1] * 2)\n            elif op == 'C':\n                # remove the previous score from the record\n                stack.pop()\n            else:\n                # add the integer score to the record\n                stack.append(int(op))\n        return sum(stack)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "47 ms",
            "memory": 16436000,
            "question_id": "682",
            "elapsed_time": 70,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925267126,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 61.93899999999998,
            "status_memory": "16.4 MB",
            "memory_percentile": 41.467000000000006,
            "pretty_lang": "Python3",
            "submission_id": "1098295636",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "description": "Given the root of a binary tree, return its maximum depth.\nA binary tree's maximum depth\u00a0is the number of nodes along the longest path from the root node down to the farthest leaf node.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: 3",
            "Input: root = [1,null,2]\nOutput: 2"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100",
        "release_time": 1686009664,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if root is None:\n            return 0\n        \n        left_depth = self.maxDepth(root.left)\n        right_depth = self.maxDepth(root.right)\n        \n        return max(left_depth, right_depth) + 1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 18580000,
            "question_id": "104",
            "elapsed_time": 62,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925282178,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 79.10730000000001,
            "status_memory": "18.6 MB",
            "memory_percentile": 62.87189999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098295767",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "release_time": 1686713202,
        "oracle_code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        MOD = 10**9 + 7\n        quotient, remainder = divmod(primeFactors, 3)\n        if remainder == 1:\n            return (4 * pow(3, quotient - 1, MOD)) % MOD\n        elif remainder == 2:\n            return (2 * pow(3, quotient, MOD)) % MOD\n        else:\n            return pow(3, quotient, MOD)\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n        if power == 1:\n            return base % MOD\n        result = calculateNiceDivisors(base, power // 2, MOD)\n        if power % 2 == 0:\n            return (result * result) % MOD\n        else:\n            return (base * result * result) % MOD\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "37 ms",
            "memory": 16360000,
            "question_id": "1936",
            "elapsed_time": 53,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925297304,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 213,
            "total_testcases": 213,
            "runtime_percentile": 68.70229999999998,
            "status_memory": "16.4 MB",
            "memory_percentile": 10.687100000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098295876",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "release_time": 1692256962,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.right = treeHelper(inorder_index+1, right)\n            root.left = treeHelper(left, inorder_index-1 )\n            \n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```",
        "level": "medium",
        "completed_code": "thon\n# Definition for a binary tree node\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def buildTree(self, inorder, postorder):\n        # Base case: if either inorder or postorder is empty, return None\n        if not inorder or not postorder:\n            return None\n        \n        # Extract the root node from the postorder list\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n        \n        # Find the index of the root node in the inorder list\n        root_index = inorder.index(root_val)\n        \n        # Recursively build the left and right subtrees\n        root.right = self.buildTree(inorder[root_index+1:], postorder)\n        root.left = self.buildTree(inorder[:root_index], postorder)\n        \n        return root\n``",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 27: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n    ^\n    ``\nLine 27  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 9144000,
            "question_id": "106",
            "elapsed_time": 18,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[9,3,15,20,7]\n[9,15,7,20,3]",
            "expected_output": "[3,9,20,null,null,15,7]",
            "task_finish_time": 1699925313962,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 202,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098296002",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "next-greater-element-iv",
        "description": "You are given a 0-indexed array of non-negative integers nums. For each integer in nums, you must find its respective second greater integer.\nThe second greater integer of nums[i] is nums[j] such that:\n\nj > i\nnums[j] > nums[i]\nThere exists exactly one index k such that nums[k] > nums[i] and i < k < j.\n\nIf there is no such nums[j], the second greater integer is considered to be -1.\n\nFor example, in the array [1, 2, 4, 3], the second greater integer of 1 is 4, 2 is 3,\u00a0and that of 3 and 4 is -1.\n\nReturn an integer array answer, where answer[i] is the second greater integer of nums[i].",
        "examples": [
            "Input: nums = [2,4,0,9,6]\nOutput: [9,6,6,-1,-1]\nExplanation:\n0th index: 4 is the first integer greater than 2, and 9 is the second integer greater than 2, to the right of 2.\n1st index: 9 is the first, and 6 is the second integer greater than 4, to the right of 4.\n2nd index: 9 is the first, and 6 is the second integer greater than 0, to the right of 0.\n3rd index: There is no integer greater than 9 to its right, so the second greater integer is considered to be -1.\n4th index: There is no integer greater than 6 to its right, so the second greater integer is considered to be -1.\nThus, we return [9,6,6,-1,-1].",
            "Input: nums = [3,3]\nOutput: [-1,-1]\nExplanation:\nWe return [-1,-1] since neither integer has any integer greater than it."
        ],
        "constrains": "1 <= nums.length <= 105\n0 <= nums[i] <= 109",
        "release_time": 1667071080,
        "oracle_code": "class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        ans = [-1] * len(nums)\n        s, ss = [], []\n        for i, x in enumerate(nums): \n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\n            buff = []\n            while s and nums[s[-1]] < x: buff.append(s.pop())\n            while buff: ss.append(buff.pop())\n            s.append(i)\n        return ans",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/a90ca3f9de0f99297262514c111f27700c24c04a) for solutions of biweekly 90. \\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ans = [-1] * len(nums)\\n        s, ss = [], []\\n        for i, x in enumerate(nums): \\n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\\n            buff = []\\n            while s and nums[s[-1]] < x: buff.append(s.pop())\\n            while buff: ss.append(buff.pop())\\n            s.append(i)\\n        return ans \\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        answer = []\n        \n        for i in range(n):\n            second_greater = -1\n            for j in range(i+1, n):\n                if nums[j] > nums[i]:\n                    second_greater = nums[j]\n                    break\n                    \n            answer.append(second_greater)\n            \n        return answer\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.",
        "examples": [
            "Input: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.",
            "Input: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.",
            "Input: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2."
        ],
        "constrains": "n == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.",
        "release_time": 1679828439,
        "oracle_code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        freq1 = [0] * 26\n        freq2 = [0] * 26\n        \n        for ch in word1:\n            freq1[ord(ch) - ord('a')] += 1\n        \n        for ch in word2:\n            freq2[ord(ch) - ord('a')] += 1\n        \n        for i in range(26):\n            if abs(freq1[i] - freq2[i]) > 3:\n                return False\n        \n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "43 ms",
            "memory": 16408000,
            "question_id": "2177",
            "elapsed_time": 56,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925343652,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 196,
            "total_testcases": 196,
            "runtime_percentile": 31.88540000000004,
            "status_memory": "16.4 MB",
            "memory_percentile": 7.212999999999994,
            "pretty_lang": "Python3",
            "submission_id": "1098296209",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "lexicographical-numbers",
        "description": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and uses O(1) extra space.",
        "examples": [
            "Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
            "Input: n = 2\nOutput: [1,2]"
        ],
        "constrains": "1 <= n <= 5 * 104",
        "release_time": 1673196351,
        "oracle_code": "class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]",
        "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        def dfs(num):\n            if num > n: # base case: if num exceeds n, return and stop the recursion\n                return\n            res.append(num) # add current number to result\n            for i in range(10):\n                if 10*num + i <= n: # generate next number by adding a digit from 0 to 9\n                    dfs(10*num + i)\n        \n        res = [] # list to store the result\n        for i in range(1, 10): # start with all single-digit numbers\n            dfs(i) # traverse all numbers starting with i\n        return res\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "134 ms",
            "memory": 24888000,
            "question_id": "386",
            "elapsed_time": 167,
            "compare_result": "11111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925359633,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 26,
            "total_testcases": 26,
            "runtime_percentile": 26.904299999999974,
            "status_memory": "24.9 MB",
            "memory_percentile": 7.039600000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098296311",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "isomorphic-strings",
        "description": "Given two strings s and t, determine if they are isomorphic.\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.",
        "examples": [
            "Input: s = \"egg\", t = \"add\"\nOutput: true",
            "Input: s = \"foo\", t = \"bar\"\nOutput: false",
            "Input: s = \"paper\", t = \"title\"\nOutput: true"
        ],
        "constrains": "1 <= s.length <= 5 * 104\nt.length == s.length\ns and t consist of any valid ascii character.",
        "release_time": 1681628917,
        "oracle_code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return len(set(s))==len(set(t))==len(set(zip(s,t)))",
        "content": "# One Line of Code Python Solution\\n```\\nclass Solution:\\n    def isIsomorphic(self, s: str, t: str) -> bool:\\n        return len(set(s))==len(set(t))==len(set(zip(s,t)))\\n```\\n# please upvote me it would encourage me alot\\n\\n```\\nclass Solution:\\n    def isIsomorphic(self, s: str, t: str) -> bool:\\n        dic1,dic2={},{}\\n        for s1,t1 in zip(s,t):\\n            if (s1 in dic1 and dic1[s1]!=t1) or ( t1 in dic2 and dic2[t1]!=s1):\\n                return False\\n            dic1[s1]=t1\\n            dic2[t1]=s1\\n        return True\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        if len(s) != len(t):  # check if the lengths of the two strings are equal\n            return False\n        \n        mapping = {}  # create a dictionary to store the mappings\n        \n        for i in range(len(s)):\n            if s[i] in mapping:  # if the character from s is already mapped to a character in t\n                if mapping[s[i]] != t[i]:  # check if the mapping is correct\n                    return False\n            else:\n                if t[i] in mapping.values():  # if the character from t is already mapped to a character in s\n                    return False\n                else:\n                    mapping[s[i]] = t[i]  # add the mapping to the dictionary\n        \n        return True  # if all characters are correctly mapped, return True\n        \n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16612000,
            "question_id": "205",
            "elapsed_time": 58,
            "compare_result": "11111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925373674,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 47,
            "total_testcases": 47,
            "runtime_percentile": 80.0301,
            "status_memory": "16.6 MB",
            "memory_percentile": 27.614700000000006,
            "pretty_lang": "Python3",
            "submission_id": "1098296407",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "description": "You are given an array of strings words and a string chars.\nA string is good if it can be formed by characters from chars (each character can only be used once).\nReturn the sum of lengths of all good strings in words.",
        "examples": [
            "Input: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.",
            "Input: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10."
        ],
        "constrains": "1 <= words.length <= 1000\n1 <= words[i].length, chars.length <= 100\nwords[i] and chars consist of lowercase English letters.",
        "release_time": 1670168918,
        "oracle_code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```",
        "level": "easy",
        "completed_code": "\nfrom typing import List\n\nclass Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        count = 0\n        for word in words:\n            if self.is_good_string(word, chars):\n                count += len(word)\n        return count\n    \n    def is_good_string(self, word: str, chars: str) -> bool:\n        char_count = {}\n        for char in chars:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        for char in word:\n            if char not in char_count or char_count[char] == 0:\n                return False\n            char_count[char] -= 1\n        return True\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "184 ms",
            "memory": 17044000,
            "question_id": "1112",
            "elapsed_time": 198,
            "compare_result": "111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925388889,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 36,
            "total_testcases": 36,
            "runtime_percentile": 29.595499999999895,
            "status_memory": "17 MB",
            "memory_percentile": 7.170099999999984,
            "pretty_lang": "Python3",
            "submission_id": "1098296506",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "examples": [
            "Input: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]",
            "Input: prices = [1]\nOutput: 0"
        ],
        "constrains": "1 <= prices.length <= 5000\n0 <= prices[i] <= 1000",
        "release_time": 1673716882,
        "oracle_code": "class Solution:\n    # def dp(self,i,buy,prices,n,dct):\n    #     if i>=n:\n    #         return 0\n    #     if (i,buy) in dct:\n    #         return dct[(i,buy)]\n    #     if buy:\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+1,0,prices,n,dct)-prices[i])\n    #     else:\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+2,1,prices,n,dct)+prices[i])\n    #     dct[(i,buy)]=x\n    #     return x\n\n    def maxProfit(self, prices: List[int]) -> int:\n        n=len(prices)\n        # dp=[[0]*2 for i in range(n+2)]\n        ahd=[0]*2\n        ahd2=[0]*2\n        for i in range(n-1,-1,-1):\n            curr=[0]*2\n            for buy in range(2):\n                if buy:\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\n                else:\n                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])\n            ahd2=ahd[:]\n            ahd=curr[:]\n        return ahd[1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((N+2)*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O((N+2)*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    # def dp(self,i,buy,prices,n,dct):\\n    #     if i>=n:\\n    #         return 0\\n    #     if (i,buy) in dct:\\n    #         return dct[(i,buy)]\\n    #     if buy:\\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+1,0,prices,n,dct)-prices[i])\\n    #     else:\\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+2,1,prices,n,dct)+prices[i])\\n    #     dct[(i,buy)]=x\\n    #     return x\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        # dp=[[0]*2 for i in range(n+2)]\\n        ahd=[0]*2\\n        ahd2=[0]*2\\n        for i in range(n-1,-1,-1):\\n            curr=[0]*2\\n            for buy in range(2):\\n                if buy:\\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\\n                else:\\n                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])\\n            ahd2=ahd[:]\\n            ahd=curr[:]\\n        return ahd[1]\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        n = len(prices)\n        # create memoization table to store max profit values\n        memo = [[-1 for _ in range(3)] for _ in range(n)]\n        \n        # recursive function to compute maximum profit\n        def dp(i, state):\n            # base case: if we reached the end of array, return 0\n            if i >= n:\n                return 0\n            \n            # if profit value is already calculated, return it\n            if memo[i][state] != -1:\n                return memo[i][state]\n            \n            # compute maximum profit based on current state\n            if state == 0:\n                # state 0 represents not holding any stock\n                memo[i][state] = max(dp(i+1, state), dp(i+1, state+1) - prices[i])\n            elif state == 1:\n                # state 1 represents holding a stock\n                memo[i][state] = max(dp(i+2, state+1) + prices[i], dp(i+1, state))\n            else:\n                # state 2 represents cooldown period\n                memo[i][state] = dp(i+1, state-1)\n            \n            return memo[i][state]\n        \n        return dp(0, 0)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 21136000,
            "question_id": "309",
            "elapsed_time": 70,
            "compare_result": "111111111111111001110000111111111111111111111111010111010111010111000000111111010111010111000000111111111111010111000000111111111111111111000000111111111111111111111111110000000000100000000100000000000000110000",
            "code_output": "9",
            "std_output": "",
            "last_testcase": "[6,1,3,2,4,7]",
            "expected_output": "6",
            "task_finish_time": 1699925404660,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 132,
            "total_testcases": 210,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098296617",
            "input_formatted": "[6,1,3,2,4,7]",
            "input": "[6,1,3,2,4,7]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).",
        "examples": [
            "Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.",
            "Input: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5."
        ],
        "constrains": "nums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106",
        "release_time": 1691292624,
        "oracle_code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Combine the two arrays\n        merged_array = nums1 + nums2\n        # Sort the merged array\n        merged_array.sort()\n        \n        # Calculate the length of the merged array\n        length = len(merged_array)\n        \n        # Check if the length is odd\n        if length % 2 != 0:\n            # Return the middle element if the length is odd\n            return merged_array[length // 2]\n        else:\n            # Return the average of the two middle elements if the length is even\n            mid1 = merged_array[length // 2]\n            mid2 = merged_array[length // 2 - 1]\n            return (mid1 + mid2) / 2\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "91 ms",
            "memory": 16576000,
            "question_id": "4",
            "elapsed_time": 110,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925419606,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 2094,
            "total_testcases": 2094,
            "runtime_percentile": 52.348699999999965,
            "status_memory": "16.6 MB",
            "memory_percentile": 42.29109999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098296721",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-subsequence-in-non-increasing-order",
        "description": "Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non\u00a0included elements in such subsequence.\u00a0\nIf there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.\u00a0\nNote that the solution with the given constraints is guaranteed to be\u00a0unique. Also return the answer sorted in non-increasing order.",
        "examples": [
            "Input: nums = [4,3,10,9,8]\nOutput: [10,9] \nExplanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included. However, the subsequence [10,9] has the maximum total sum of its elements.",
            "Input: nums = [4,4,7,6,7]\nOutput: [7,7,6] \nExplanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to be returned in non-decreasing order."
        ],
        "constrains": "1 <= nums.length <= 500\n1 <= nums[i] <= 100",
        "release_time": 1679055285,
        "oracle_code": "class Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        total = sum(nums)\n        nums.sort(reverse = True)\n        sub_sum, sub_seq = 0, []\n        for x in nums:\n            sub_sum += x\n            total -= x\n            sub_seq.append(x)\n            if sub_sum > total:\n                return sub_seq",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total = sum(nums)\\n        nums.sort(reverse = True)\\n        sub_sum, sub_seq = 0, []\\n        for x in nums:\\n            sub_sum += x\\n            total -= x\\n            sub_seq.append(x)\\n            if sub_sum > total:\\n                return sub_seq\\n```",
        "level": "easy",
        "completed_code": "thon\nclass Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        nums.sort(reverse=True)  # Sort the array in non-increasing order\n        \n        total_sum = sum(nums)  # Calculate the total sum of all elements\n        \n        current_sum = 0  # Initialize the current sum\n        \n        result = []  # Initialize the result list\n        \n        for num in nums:\n            current_sum += num  # Add the current element to the current sum\n            \n            result.append(num)  # Add the current element to the result list\n            \n            if current_sum > total_sum - current_sum:\n                return result  # Return the result if the current sum is strictly greater than the sum of the remaining elements\n        \n        return result  # If there is no possible solution, return the result lis",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 1: NameError: name 'thon' is not defined",
            "full_runtime_error": "NameError: name 'thon' is not defined\n    thon\nLine 1 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16292000,
            "question_id": "1519",
            "elapsed_time": 61,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[4,3,10,9,8]",
            "expected_output": "[10,9]",
            "task_finish_time": 1699925434450,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 103,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098296838",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "palindrome-partitioning-iii",
        "description": "You are given a string s containing lowercase letters and an integer k. You need to :\n\nFirst, change some characters of s to other lowercase English letters.\nThen divide s into k non-empty disjoint substrings such that each substring is a palindrome.\n\nReturn the minimal number of characters that you need to change to divide the string.",
        "examples": [
            "Input: s = \"abc\", k = 2\nOutput: 1\nExplanation:\u00a0You can split the string into \"ab\" and \"c\", and change 1 character in \"ab\" to make it palindrome.",
            "Input: s = \"aabbc\", k = 3\nOutput: 0\nExplanation:\u00a0You can split the string into \"aa\", \"bb\" and \"c\", all of them are palindrome.",
            "Input: s = \"leetcode\", k = 8\nOutput: 0"
        ],
        "constrains": "1 <= k <= s.length <= 100.\ns only contains lowercase English letters.",
        "release_time": 1663513046,
        "oracle_code": "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp:\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)",
        "content": "```\\nclass Solution:\\n    def palindromePartition(self, s: str, k: int) -> int:\\n        \\n        \\n\\t\\t#This is the cost function \\n        \\n        def Cost(s):\\n            i,j,c=0,len(s)-1,0\\n            \\n            while i<j:\\n                if s[i]!=s[j]:c+=1\\n                j-=1\\n                i+=1\\n            return c\\n        \\n        dp={}\\n        \\n\\t\\t# Recursion\\n\\t\\t\\n        def A(s,k):\\n\\t\\t\\t# Memoization\\n            if (s,k) in dp:\\n                return dp[(s,k)]\\n\\t\\t\\t# if k==1 then we want the whole string there is no other way \\n            if k==1:\\n                return Cost(s)\\n            \\n\\t\\t\\t#intial value to max\\n            f=float(\\'inf\\')\\n            \\n            #start checking whole string \\n            for x in range(1,len(s)+1):\\n                #check wheather if both the strings exist.\\n                if len(s[:x]) and len(s[x:]):\\n\\t\\t\\t\\t\\n                    #if exist we find the cost recursively assign min value \\n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\\n             #store the min value       \\n            dp[(s,k)]=f\\n\\t\\t\\t\\n            return dp[(s,k)]\\n        return A(s,k)\\n                \\n                    \\n            \\n            ```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        def Cost(s):\n            # helper function to calculate cost of converting a string to palindrome\n            cost = 0\n            left = 0\n            right = len(s) - 1\n            \n            while left < right:\n                if s[left] != s[right]:\n                    cost += 1\n                left += 1\n                right -= 1\n            return cost\n        \n        def A(s, k):\n            # dynamic programming function to calculate minimum cost of dividing a string into k palindromic substrings\n            if k == 1:\n                # when we reach k = 1, the whole string should be a palindrome\n                return Cost(s)\n            \n            if len(s) == k:\n                # when the length of the string is the same as k, we can convert each character into a separate palindrome\n                return len(s)\n            \n            min_cost = float('inf')\n            \n            # divide the string into smaller substrings and calculate the cost for each division\n            for i in range(1, len(s)-k+2):\n                min_cost = min(min_cost, Cost(s[:i]) + A(s[i:], k-1))\n            \n            return min_cost\n        \n        return A(s, k)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "closest-dessert-cost",
        "description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\n\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\n\nYou are given three inputs:\n\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\n\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.",
        "examples": [
            "Input: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.",
            "Input: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.",
            "Input: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost."
        ],
        "constrains": "n == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104",
        "release_time": 1614485176,
        "oracle_code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        closest = float('inf')\n        def fn(i, x):\n            nonlocal closest\n            if abs(x-target) < abs(closest-target) or (abs(x-target) == abs(closest-target) and x < closest):\n                closest = x\n            if i == len(toppingCosts): return\n            fn(i+1, x)\n            fn(i+1, x+toppingCosts[i])\n            fn(i+1, x+2*toppingCosts[i])\n        \n        for base in baseCosts:\n            fn(0, base)\n            \n        return closest\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "955 ms",
            "memory": 16344000,
            "question_id": "1900",
            "elapsed_time": 986,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925466678,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 89,
            "total_testcases": 89,
            "runtime_percentile": 23.417999999999843,
            "status_memory": "16.3 MB",
            "memory_percentile": 68.8965,
            "pretty_lang": "Python3",
            "submission_id": "1098297056",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
        "description": "Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target.",
        "examples": [
            "Input: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\"\nOutput: 4\nExplanation: Valid pairs are:\n- (0, 1): \"777\" + \"7\"\n- (1, 0): \"7\" + \"777\"\n- (2, 3): \"77\" + \"77\"\n- (3, 2): \"77\" + \"77\"",
            "Input: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\"\nOutput: 2\nExplanation: Valid pairs are:\n- (0, 1): \"123\" + \"4\"\n- (2, 3): \"12\" + \"34\"",
            "Input: nums = [\"1\",\"1\",\"1\"], target = \"11\"\nOutput: 6\nExplanation: Valid pairs are:\n- (0, 1): \"1\" + \"1\"\n- (1, 0): \"1\" + \"1\"\n- (0, 2): \"1\" + \"1\"\n- (2, 0): \"1\" + \"1\"\n- (1, 2): \"1\" + \"1\"\n- (2, 1): \"1\" + \"1\""
        ],
        "constrains": "2 <= nums.length <= 100\n1 <= nums[i].length <= 100\n2 <= target.length <= 100\nnums[i] and target consist of digits.\nnums[i] and target do not have leading zeros.",
        "release_time": 1683526112,
        "oracle_code": "class Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        d = defaultdict(int)\n        for char in nums:\n            d[char] += 1\n            \n        arr = []\n        for char in target:\n            arr.append(char)\n        \n        pairs = 0\n        num = \"\"\n        while len(arr) > 1:\n            num += arr.pop()\n            findNum = \"\".join(arr)\n            if num[::-1] not in d or findNum not in d:\n                continue\n\n            c1 = d[num[::-1]]\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\n            \n            c2 = d[findNum]\n            d[num[::-1]] += 1 # make the count again same.\n\n            pairs += c1 * c2\n        return pairs",
        "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = defaultdict(int)\\n        for char in nums:\\n            d[char] += 1\\n            \\n        arr = []\\n        for char in target:\\n            arr.append(char)\\n        \\n        pairs = 0\\n        num = \"\"\\n        while len(arr) > 1:\\n            num += arr.pop()\\n            findNum = \"\".join(arr)\\n            if num[::-1] not in d or findNum not in d:\\n                continue\\n\\n            c1 = d[num[::-1]]\\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\\n            \\n            c2 = d[findNum]\\n            d[num[::-1]] += 1 # make the count again same.\\n\\n            pairs += c1 * c2\\n        return pairs\\n        \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        count = 0\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i != j and nums[i] + nums[j] == target:\n                    count += 1\n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "82 ms",
            "memory": 16544000,
            "question_id": "2133",
            "elapsed_time": 91,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925480627,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 117,
            "total_testcases": 117,
            "runtime_percentile": 6.8104,
            "status_memory": "16.5 MB",
            "memory_percentile": 5.418000000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098297154",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "jump-game-ii",
        "description": "You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n0 <= j <= nums[i] and\ni + j < n\n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].",
        "examples": [
            "Input: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.",
            "Input: nums = [2,3,0,1,4]\nOutput: 2"
        ],
        "constrains": "1 <= nums.length <= 104\n0 <= nums[i] <= 1000\nIt's guaranteed that you can reach nums[n - 1].",
        "release_time": 1679374027,
        "oracle_code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        #print(nums)\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    #print(index-1,steps[index-1])\n                    steps.append(steps[index]+1)\n            #print(steps)\n        return steps[L-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        #print(nums)\\n        L=len(nums)\\n        if L==1:\\n            return 0\\n        steps=[0]\\n        for i in range(nums[0]):\\n            steps.append(1)\\n        for index in range(1,L):\\n            len_steps=len(steps)\\n            if len_steps >= nums[index]+index+1:\\n                index += 1\\n            elif len_steps < nums[index]+index+1:\\n                for j in range(nums[index]+index-len_steps+1):\\n                    #print(index-1,steps[index-1])\\n                    steps.append(steps[index]+1)\\n            #print(steps)\\n        return steps[L-1]\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def jump(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        # initialize variables\n        jumps = 0\n        current_position = 0\n        max_reach = 0\n        \n        # iterate through the array\n        for i in range(n):\n            # if we reach the end of the array, return the number of jumps\n            if current_position >= n - 1:\n                return jumps\n            # update the maximum reachable position from the current position\n            max_reach = max(max_reach, i + nums[i])\n            \n            # if we reach the maximum reachable position from the current position,\n            # update the current position and increment the number of jumps\n            if i == current_position:\n                current_position = max_reach\n                jumps += 1\n                \n        return jumps\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "121 ms",
            "memory": 17440000,
            "question_id": "45",
            "elapsed_time": 137,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925495608,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 109,
            "total_testcases": 109,
            "runtime_percentile": 54.6399,
            "status_memory": "17.4 MB",
            "memory_percentile": 21.180299999999978,
            "pretty_lang": "Python3",
            "submission_id": "1098297246",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "root-equals-sum-of-children",
        "description": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.",
        "examples": [
            "Input: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.",
            "Input: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false."
        ],
        "constrains": "The tree consists only of the root, its left child, and its right child.\n-100 <= Node.val <= 100",
        "release_time": 1675319094,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        return root.val==root.left.val + root.right.val",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return True\n        \n        if root.left is None or root.right is None:\n            return False\n        \n        return root.val == root.left.val + root.right.val\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 16364000,
            "question_id": "2384",
            "elapsed_time": 54,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925510982,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 309,
            "total_testcases": 309,
            "runtime_percentile": 41.31570000000002,
            "status_memory": "16.4 MB",
            "memory_percentile": 25.437500000000007,
            "pretty_lang": "Python3",
            "submission_id": "1098297360",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "distribute-candies",
        "description": "Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\nThe doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\nGiven the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.",
        "examples": [
            "Input: candyType = [1,1,2,2,3,3]\nOutput: 3\nExplanation: Alice can only eat 6 / 2 = 3 candies. Since there are only 3 types, she can eat one of each type.",
            "Input: candyType = [1,1,2,3]\nOutput: 2\nExplanation: Alice can only eat 4 / 2 = 2 candies. Whether she eats types [1,2], [1,3], or [2,3], she still can only eat 2 different types.",
            "Input: candyType = [6,6,6,6]\nOutput: 1\nExplanation: Alice can only eat 4 / 2 = 2 candies. Even though she can eat 2 candies, she only has 1 type."
        ],
        "constrains": "n == candyType.length\n2 <= n <= 104\nn\u00a0is even.\n-105 <= candyType[i] <= 105",
        "release_time": 1671696051,
        "oracle_code": "class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(set(candyType)))",
        "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        # Find the total number of candies\n        total_candies = len(candyType)\n        \n        # Calculate the number of candies Alice can eat\n        alice_candies = total_candies // 2\n        \n        # Find the number of unique candy types\n        unique_candies = len(set(candyType))\n        \n        # Return the minimum of alice_candies and unique_candies\n        return min(alice_candies, unique_candies)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "681 ms",
            "memory": 18644000,
            "question_id": "575",
            "elapsed_time": 703,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925526301,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 206,
            "total_testcases": 206,
            "runtime_percentile": 68.10240000000002,
            "status_memory": "18.6 MB",
            "memory_percentile": 22.933700000000016,
            "pretty_lang": "Python3",
            "submission_id": "1098297456",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "pascals-triangle",
        "description": "Given an integer numRows, return the first numRows of Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]",
            "Input: numRows = 1\nOutput: [[1]]"
        ],
        "constrains": "1 <= numRows <= 30",
        "release_time": 1689471598,
        "oracle_code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        # initialize the triangle with first row [1]\n        triangle = [[1]]\n        \n        # check if numRows is zero, return empty triangle\n        if numRows == 0:\n            return []\n        \n        # generate rest of the rows\n        for i in range(1, numRows):\n            # initialize new row with 1 at the beginning\n            row = [1]\n            \n            # calculate middle elements of the row\n            for j in range(1, i):\n                row.append(triangle[i-1][j-1] + triangle[i-1][j])\n            \n            # add 1 at the end of the row\n            row.append(1)\n            \n            # add the row to the triangle\n            triangle.append(row)\n        \n        return triangle\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16376000,
            "question_id": "118",
            "elapsed_time": 56,
            "compare_result": "111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925540614,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 30,
            "total_testcases": 30,
            "runtime_percentile": 46.44590000000003,
            "status_memory": "16.4 MB",
            "memory_percentile": 10.117200000000011,
            "pretty_lang": "Python3",
            "submission_id": "1098297561",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-distance-to-the-target-element",
        "description": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that\u00a0abs(x)\u00a0is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.",
        "examples": [
            "Input: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.",
            "Input: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.",
            "Input: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\n0 <= start < nums.length\ntarget is in nums.",
        "release_time": 1685865735,
        "oracle_code": "class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        curVal=len(nums)\n        for i in range(start,len(nums)):\n            if nums[i]==target:\n                curVal=min(curVal,abs(i-start))\n                break\n        j=start\n        while(j>=0):\n            if nums[j]==target:\n                curVal=min(curVal,abs(j-start))\n                break\n            j-=1\n        return curVal",
        "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        for i in range(len(nums)):\n            if nums[i] == target:\n                return abs(i - start)\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16508000,
            "question_id": "1975",
            "elapsed_time": 73,
            "compare_result": "111101010110111111111111111111111111111111111111111111111111111110100110",
            "code_output": "9",
            "std_output": "",
            "last_testcase": "[1,1,1,1,1,1,1,1,1,1]\n1\n9",
            "expected_output": "0",
            "task_finish_time": 1699925555730,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 64,
            "total_testcases": 72,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098297668",
            "input_formatted": "[1,1,1,1,1,1,1,1,1,1], 1, 9",
            "input": "[1,1,1,1,1,1,1,1,1,1]\n1\n9",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.",
        "examples": [
            "Input: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.",
            "Input: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4."
        ],
        "constrains": "n == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r\u00a0<= n - 1\n0 <= k\u00a0<= 109",
        "release_time": 1673114604,
        "oracle_code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        left, right = 0, sum(stations)\n        while left < right:\n            mid = (left + right) // 2\n            if self.check(stations, r, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left\n    \n    def check(self, stations, r, k, target):\n        n = len(stations)\n        dp = [0] * n\n        for i in range(n):\n            left = max(0, i - r)\n            right = min(n - 1, i + r)\n            dp[left] += stations[i]\n            if right + 1 < n:\n                dp[right + 1] -= stations[i]\n        for i in range(1, n):\n            dp[i] += dp[i - 1]\n        count = 0\n        for i in range(n):\n            if dp[i] < target:\n                count += (target - dp[i])\n                if count > k:\n                    return False\n        return True\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "description": "Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\nA string is represented by an array if the array elements concatenated in order forms the string.",
        "examples": [
            "Input: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.",
            "Input: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false",
            "Input: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true"
        ],
        "constrains": "1 <= word1.length, word2.length <= 103\n1 <= word1[i].length, word2[i].length <= 103\n1 <= sum(word1[i].length), sum(word2[i].length) <= 103\nword1[i] and word2[i] consist of lowercase letters.",
        "release_time": 1691924075,
        "oracle_code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        # Join the elements of word1 and word2\n        string1 = ''.join(word1)\n        string2 = ''.join(word2)\n        \n        # Check if the joined strings are equal\n        return string1 == string2\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "39 ms",
            "memory": 16360000,
            "question_id": "1781",
            "elapsed_time": 62,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925585801,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 110,
            "total_testcases": 110,
            "runtime_percentile": 65.10199999999999,
            "status_memory": "16.4 MB",
            "memory_percentile": 19.007300000000015,
            "pretty_lang": "Python3",
            "submission_id": "1098297883",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "restore-ip-addresses",
        "description": "A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.",
        "examples": [
            "Input: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]",
            "Input: s = \"0000\"\nOutput: [\"0.0.0.0\"]",
            "Input: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
        ],
        "constrains": "1 <= s.length <= 20\ns consists of digits only.",
        "release_time": 1674285009,
        "oracle_code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        def backtrack(i):\n            # Base case: we have placed 3 dots\n            if len(segments) == 4:\n                # Check if the string is exhausted\n                if i == n:\n                    # Join the segments into a valid IP address\n                    ip_address = \".\".join(segments)\n                    # Add the valid IP address to the result\n                    result.append(ip_address)\n                return\n            \n            # Place the dots at each possible position\n            for j in range(i, min(i + 3, n)):\n                segment = s[i:j+1]\n                \n                # Check if the segment is a valid IP address segment\n                if len(segment) > 1 and segment[0] == '0':\n                    continue\n                \n                if int(segment) <= 255:\n                    segments.append(segment)\n                    # Recurse to place the next dot\n                    backtrack(j+1)\n                    # Remove the segment for backtracking\n                    segments.pop()\n        \n        # Initialize variables\n        result = []\n        segments = []\n        n = len(s)\n        \n        # Start the backtracking process\n        backtrack(0)\n        \n        # Return the result\n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "28 ms",
            "memory": 16456000,
            "question_id": "93",
            "elapsed_time": 58,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925600864,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 146,
            "total_testcases": 146,
            "runtime_percentile": 99.4318,
            "status_memory": "16.5 MB",
            "memory_percentile": 5.46090000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098297986",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-profit-of-operating-a-centennial-wheel",
        "description": "You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you runningCost dollars.\nYou are given an array customers of length n where customers[i] is the number of new customers arriving just before the ith rotation (0-indexed). This means you must rotate the wheel i times before the customers[i] customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays boardingCost dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.\nYou can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.\nReturn the minimum number of rotations you need to perform to maximize your profit. If there is no scenario where the profit is positive, return -1.",
        "examples": [
            "Input: customers = [8,3], boardingCost = 5, runningCost = 6\nOutput: 3\nExplanation: The numbers written on the gondolas are the number of people currently there.\n1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 * $5 - 1 * $6 = $14.\n2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 * $5 - 2 * $6 = $28.\n3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 * $5 - 3 * $6 = $37.\nThe highest profit was $37 after rotating the wheel 3 times.",
            "Input: customers = [10,9,6], boardingCost = 6, runningCost = 4\nOutput: 7\nExplanation:\n1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 * $6 - 1 * $4 = $20.\n2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 * $6 - 2 * $4 = $40.\n3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 * $6 - 3 * $4 = $60.\n4. 4 board and 9 wait, the wheel rotates. Current profit is 16 * $6 - 4 * $4 = $80.\n5. 4 board and 5 wait, the wheel rotates. Current profit is 20 * $6 - 5 * $4 = $100.\n6. 4 board and 1 waits, the wheel rotates. Current profit is 24 * $6 - 6 * $4 = $120.\n7. 1 boards, the wheel rotates. Current profit is 25 * $6 - 7 * $4 = $122.\nThe highest profit was $122 after rotating the wheel 7 times.",
            "Input: customers = [3,4,0,5,1], boardingCost = 1, runningCost = 92\nOutput: -1\nExplanation:\n1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 * $1 - 1 * $92 = -$89.\n2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 2 * $92 = -$177.\n3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 * $1 - 3 * $92 = -$269.\n4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 * $1 - 4 * $92 = -$357.\n5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 * $1 - 5 * $92 = -$447.\nThe profit was never positive, so return -1."
        ],
        "constrains": "n == customers.length\n1 <= n <= 105\n0 <= customers[i] <= 50\n1 <= boardingCost, runningCost <= 100",
        "release_time": 1687863850,
        "oracle_code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans",
        "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        total_customers = sum(customers)\n        if total_customers == 0:\n            return 0\n        \n        max_profit = -1\n        max_rotations = -1\n        current_profit = 0\n        current_rotations = 0\n        current_customers = 0\n        \n        for i in range(len(customers)):\n            current_customers += customers[i]\n            \n            if current_customers >= 4:\n                current_profit += 4 * boardingCost - runningCost\n                current_rotations += 1\n                current_customers -= 4\n            else:\n                current_profit += current_customers * boardingCost - runningCost\n                current_rotations += 1\n                current_customers = 0\n                \n            if current_profit > max_profit:\n                max_profit = current_profit\n                max_rotations = current_rotations\n        \n        remaining_customers = total_customers - (max_rotations * 4)\n        \n        while remaining_customers > 0:\n            if remaining_customers >= 4:\n                current_profit += 4 * boardingCost - runningCost\n                current_rotations += 1\n                max_rotations = current_rotations\n                remaining_customers -= 4\n            else:\n                current_profit += remaining_customers * boardingCost - runningCost\n                current_rotations += 1\n                max_rotations = current_rotations\n                remaining_customers = 0\n        \n        if max_profit > 0:\n            return max_rotations\n        else:\n            return -1\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 19992000,
            "question_id": "1721",
            "elapsed_time": 1218,
            "compare_result": "111001101011111111111111111011010100111110111010111101111110111111111111110111111011011101011111111011110011111111001111110101011110011111010001",
            "code_output": "10",
            "std_output": "",
            "last_testcase": "[10,10,6,4,7]\n3\n8",
            "expected_output": "9",
            "task_finish_time": 1699925618925,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 111,
            "total_testcases": 144,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098298109",
            "input_formatted": "[10,10,6,4,7], 3, 8",
            "input": "[10,10,6,4,7]\n3\n8",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "release_time": 1666016205,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level_values = []\n            level_size = len(queue)\n            \n            for _ in range(level_size):\n                node = queue.pop(0)\n                level_values.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.insert(0, level_values)\n        \n        return result\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "maximum-number-of-moves-in-a-grid",
        "description": "You are given a 0-indexed m x n matrix grid consisting of positive integers.\nYou can start at any cell in the first column of the matrix, and traverse the grid in the following way:\n\nFrom a cell (row, col), you can move to any of the cells: (row - 1, col + 1), (row, col + 1) and (row + 1, col + 1) such that the value of the cell you move to, should be strictly bigger than the value of the current cell.\n\nReturn the maximum number of moves that you can perform.",
        "examples": [
            "Input: grid = [[2,4,3,5],[5,4,9,3],[3,4,2,11],[10,9,13,15]]\nOutput: 3\nExplanation: We can start at the cell (0, 0) and make the following moves:\n- (0, 0) -> (0, 1).\n- (0, 1) -> (1, 2).\n- (1, 2) -> (2, 3).\nIt can be shown that it is the maximum number of moves that can be made.",
            "Input: grid = [[3,2,4],[2,1,9],[1,1,7]]\nOutput: 0\nExplanation: Starting from any cell in the first column we cannot perform any moves."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n1 <= grid[i][j] <= 106",
        "release_time": 1684134022,
        "oracle_code": "class Solution:\n    def maxMoves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dq = deque(range(m))\n        moves = 0\n        while dq and moves < n-1:\n            nxt = set()\n            for _ in range(len(dq)):\n                idx = dq.popleft()\n                val = grid[idx][moves]\n                for i in range(max(0, idx-1), min(m, idx+2)):\n                    if grid[i][moves+1] > val:\n                        nxt.add(i)\n            if len(nxt) > 0:\n                moves += 1\n            dq.extend(nxt)\n        return moves",
        "content": "1. From left to right, for each column, save the row_indices of reachable cells in `dq`.\\n2. Row_indices of reachable cells in the next column are saved in `nxt`. If `nxt` is nonempty, we can move to the next column, hence add 1 to `moves`.\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque(range(m))\\n        moves = 0\\n        while dq and moves < n-1:\\n            nxt = set()\\n            for _ in range(len(dq)):\\n                idx = dq.popleft()\\n                val = grid[idx][moves]\\n                for i in range(max(0, idx-1), min(m, idx+2)):\\n                    if grid[i][moves+1] > val:\\n                        nxt.add(i)\\n            if len(nxt) > 0:\\n                moves += 1\\n            dq.extend(nxt)\\n        return moves\\n",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def maxMoves(self, grid: List[List[int]]) -> int:\n        m = len(grid)\n        n = len(grid[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        for j in range(n - 2, -1, -1):\n            for i in range(m):\n                if i > 0 and j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j + 1])\n                if j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i][j + 1])\n                if i < m - 1 and j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i + 1][j + 1])\n                dp[i][j] += 1 if grid[i][j] < grid[i][j + 1] else 0\n        \n        return max(dp[i][0] for i in range(m))\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 27424000,
            "question_id": "2794",
            "elapsed_time": 1623,
            "compare_result": "1011001010001100000000000110000010000000100110100000101010010010100100010001010100010001000001000011100001010110010000001100000000100000101010000000001000110100000010010010000100110000000000000000100001110000000000010100000001010001110001001100001101001110001000000010100010000111110001000000001010001000100101011001000000010000111100100110010000000001000000000111000111110110000010000011100000100100000101001010000000000001000000000000100011000001101000000110100000000000000011000000000010100000100000000000001100000000100001001100000010000010100010100000000001000000000000100000010000011000101100001010000000010100000000000000000000000000000100000000010000000000000000100000101100000000001000000100000000000001000100000010100000000000000110010000000000000000000000000100000010000000000000000000000000001000001101",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[[3,2,4],[2,1,9],[1,1,7]]",
            "expected_output": "0",
            "task_finish_time": 1699925649476,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 180,
            "total_testcases": 814,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098298326",
            "input_formatted": "[[3,2,4],[2,1,9],[1,1,7]]",
            "input": "[[3,2,4],[2,1,9],[1,1,7]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-suffix-flips",
        "description": "You are given a 0-indexed binary string target of length n. You have another binary string s of length n that is initially set to all zeros. You want to make s equal to target.\nIn one operation, you can pick an index i where 0 <= i < n and flip all bits in the inclusive range [i, n - 1]. Flip means changing '0' to '1' and '1' to '0'.\nReturn the minimum number of operations needed to make s equal to target.",
        "examples": [
            "Input: target = \"10111\"\nOutput: 3\nExplanation: Initially, s = \"00000\".\nChoose index i = 2: \"00000\" -> \"00111\"\nChoose index i = 0: \"00111\" -> \"11000\"\nChoose index i = 1: \"11000\" -> \"10111\"\nWe need at least 3 flip operations to form target.",
            "Input: target = \"101\"\nOutput: 3\nExplanation: Initially, s = \"000\".\nChoose index i = 0: \"000\" -> \"111\"\nChoose index i = 1: \"111\" -> \"100\"\nChoose index i = 2: \"100\" -> \"101\"\nWe need at least 3 flip operations to form target.",
            "Input: target = \"00000\"\nOutput: 0\nExplanation: We do not need any operations since the initial s already equals target."
        ],
        "constrains": "n == target.length\n1 <= n <= 105\ntarget[i] is either '0' or '1'.",
        "release_time": 1595736156,
        "oracle_code": "class Solution:\n    def minFlips(self, target: str) -> int:\n        return len(list(groupby(\"0\" + target)))-1",
        "content": "Algo: \\n\\nTo abstract this problem in math terms, the purpose of it is to simply convert a string composed of `0`\\'s and `1`\\'s to all `0`\\'s using a predefined flip operation that flips everything from a given position to the end. As a result, at any step, one could focus on the left-most `1`. By fliping it, a desirable byproduct is that a continous chunk of `1`\\'s connecting to the left-most `1` is set to `0`. An undesirable side effect is that the next `0` will become the left-most `1`. In the next step, you would have to flip this `1`. \\n\\nIt is not difficult to realize that this problem is to count the number of changes in the string. One caveat is the first character, for which one flip needs to be counted if it is `1`. To unify the operation, we could add a dummy `0` in front so that the string always starts with `0`. \\n\\nUsing the example given by the problem, the above argument would suggest 3 as the answer as there are in total 3 changes while scanning `010111` (a dummy `0` is added in front) from left to right. \\n`10111`\\n`01000` after 1st flip\\n`00111` after 2nd flip\\n`00000` after 3rd flip \\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return len(list(groupby(\"0\" + target)))-1\\n```\\n\\nHere, we leverage on `groupby` function of `itertools` module which groups the string for us though the only info we need is the number of groups minus one (`n` groups comes with `n-1` changes from group to group).\\n\\nFurthermore, the below elegant solution is due to @awice. \\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans = flip = 0\\n        for bulb in target: \\n            if flip ^ int(bulb): \\n                flip ^= 1\\n                ans += 1\\n        return ans\\n```\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0,\"0\"\\n        for c in target: \\n            if prev != c: ans += 1\\n            prev = c\\n        return ans \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minFlips(self, target: str) -> int:\n        n = len(target)\n        flips = 0\n        s = ['0'] * n\n        \n        for i in range(n):\n            if s[i] != target[i]:\n                flips += 1\n                for j in range(i, n):\n                    s[j] = '1' if s[j] == '0' else '0'\n        \n        return flips\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "substrings-of-size-three-with-distinct-characters",
        "description": "A string is good if there are no repeated characters.\nGiven a string s\u200b\u200b\u200b\u200b\u200b, return the number of good substrings of length three in s\u200b\u200b\u200b\u200b\u200b\u200b.\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\nA substring is a contiguous sequence of characters in a string.",
        "examples": [
            "Input: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".",
            "Input: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\"."
        ],
        "constrains": "1 <= s.length <= 100\ns\u200b\u200b\u200b\u200b\u200b\u200b consists of lowercase English letters.",
        "release_time": 1677600394,
        "oracle_code": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count=0\n        for i in range(len(s)-2):\n            x=s[i:i+3]\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count = 0\n        for i in range(len(s) - 2):\n            substring = s[i:i+3]\n            if len(set(substring)) == 3:\n                count += 1\n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "37 ms",
            "memory": 16308000,
            "question_id": "1987",
            "elapsed_time": 63,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925677821,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 160,
            "total_testcases": 160,
            "runtime_percentile": 77.0591,
            "status_memory": "16.3 MB",
            "memory_percentile": 7.186299999999989,
            "pretty_lang": "Python3",
            "submission_id": "1098298531",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reverse-subarray-to-maximize-array-value",
        "description": "You are given an integer array nums. The value of this array is defined as the sum of |nums[i] - nums[i + 1]| for all 0 <= i < nums.length - 1.\nYou are allowed to select any subarray of the given array and reverse it. You can perform this operation only once.\nFind maximum possible value of the final array.",
        "examples": [
            "Input: nums = [2,3,1,5,4]\nOutput: 10\nExplanation: By reversing the subarray [3,1,5] the array becomes [2,5,1,3,4] whose value is 10.",
            "Input: nums = [2,4,9,24,2,1,10]\nOutput: 68"
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-105 <= nums[i] <= 105",
        "release_time": 1684976469,
        "oracle_code": "class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = 0, len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        for idx in range(sz - 1):\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\\n        originalValue, sz = 0, len(nums)\\n        for idx in range(sz - 1):\\n            originalValue += abs(nums[idx] - nums[idx + 1])\\n        finalValue = originalValue\\n        for idx in range(1, sz - 1):\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\\n        minimum, maximum = inf, -inf\\n        for idx in range(sz - 1):\\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\\n            minimum = min(minimum, tempMax)\\n            maximum = max(maximum, tempMin)\\n        return finalValue\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n <= 1:\n            return 0\n        \n        original_sum = 0\n        for i in range(n-1):\n            original_sum += abs(nums[i] - nums[i+1])\n        \n        max_gain = 0\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                gain = abs(nums[i+1] - nums[j]) - abs(nums[i] - nums[i+1])\n                max_gain = max(max_gain, gain)\n        \n        for i in range(n-1):\n            for j in range(i+1, n):\n                gain = abs(nums[i] - nums[j]) - abs(nums[i] - nums[i+1])\n                max_gain = max(max_gain, gain)\n        \n        return original_sum + max_gain\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constrains": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/",
        "release_time": 1682091742,
        "oracle_code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        binary_num = bin(num)[2:]  # convert num to binary string\n        complement_num = ''.join('1' if bit == '0' else '0' for bit in binary_num)  # flip each bit\n        return int(complement_num, 2)  # convert binary string back to integer\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "41 ms",
            "memory": 16276000,
            "question_id": "476",
            "elapsed_time": 77,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925707896,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 149,
            "total_testcases": 149,
            "runtime_percentile": 32.28699999999998,
            "status_memory": "16.3 MB",
            "memory_percentile": 27.055300000000003,
            "pretty_lang": "Python3",
            "submission_id": "1098298725",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "next-greater-element-i",
        "description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 <= i < nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.",
        "examples": [
            "Input: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.",
            "Input: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1."
        ],
        "constrains": "1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.",
        "release_time": 1691487651,
        "oracle_code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        break\n                    if(j==len(nums2)-1):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        out=[]\\n        for i in range(0,len(nums1)):\\n            if(nums2.index(nums1[i])==len(nums2)-1):\\n                out.append(-1)\\n            else:\\n                j=nums2.index(nums1[i])+1\\n                while(1):\\n                    if(nums1[i]<nums2[j]):\\n                        out.append(nums2[j])\\n                        break\\n                    if(j==len(nums2)-1):\\n                        out.append(-1)\\n                        break\\n                    j+=1\\n        return out\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        stack = []\n        next_greater = {}\n        result = []\n        \n        # Iterate through nums2 to find the next greater element\n        for num in nums2:\n            # Keep popping from the stack while the current element is greater than the top of the stack\n            while stack and num > stack[-1]:\n                next_greater[stack.pop()] = num\n            stack.append(num)\n        \n        # Iterate through nums1 to find the next greater element for each element in nums2\n        for num in nums1:\n            result.append(next_greater.get(num, -1))\n        \n        return result\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "50 ms",
            "memory": 16748000,
            "question_id": "496",
            "elapsed_time": 73,
            "compare_result": "1111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925722950,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 16,
            "runtime_percentile": 79.296,
            "status_memory": "16.7 MB",
            "memory_percentile": 10.337199999999992,
            "pretty_lang": "Python3",
            "submission_id": "1098298819",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "description": "Given 3 positives numbers a, b and c. Return the minimum flips required in some bits of a and b to make (\u00a0a OR b == c\u00a0). (bitwise OR operation).\r\nFlip operation\u00a0consists of change\u00a0any\u00a0single bit 1 to 0 or change the bit 0 to 1\u00a0in their binary representation.",
        "examples": [
            "Input: a = 2, b = 6, c = 5\r\nOutput: 3\r\nExplanation: After flips a = 1 , b = 4 , c = 5 such that (a OR b == c)",
            "Input: a = 4, b = 2, c = 7\r\nOutput: 1",
            "Input: a = 1, b = 2, c = 3\r\nOutput: 0"
        ],
        "constrains": "1 <= a <= 10^9\n1 <= b\u00a0<= 10^9\n1 <= c\u00a0<= 10^9",
        "release_time": 1682793274,
        "oracle_code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        flips = 0\n        while a != 0 or b != 0 or c != 0:\n            bit_a = a & 1\n            bit_b = b & 1\n            bit_c = c & 1\n            if (bit_a | bit_b) != bit_c:\n                if bit_c == 1:\n                    flips += 1\n                else:\n                    flips += bit_a + bit_b\n            a >>= 1\n            b >>= 1\n            c >>= 1\n        return flips\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "42 ms",
            "memory": 16380000,
            "question_id": "1441",
            "elapsed_time": 56,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925737862,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 64,
            "total_testcases": 64,
            "runtime_percentile": 24.37530000000001,
            "status_memory": "16.4 MB",
            "memory_percentile": 11.273600000000002,
            "pretty_lang": "Python3",
            "submission_id": "1098298922",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "restore-the-array",
        "description": "A program was supposed to print an array of integers. The program forgot to print whitespaces and the array is printed as a string of digits s and all we know is that all integers in the array were in the range [1, k] and there are no leading zeros in the array.\nGiven the string s and the integer k, return the number of the possible arrays that can be printed as s using the mentioned program. Since the answer may be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: s = \"1000\", k = 10000\nOutput: 1\nExplanation: The only possible array is [1000]",
            "Input: s = \"1000\", k = 10\nOutput: 0\nExplanation: There cannot be an array that was printed this way and has all integer >= 1 and <= 10.",
            "Input: s = \"1317\", k = 2000\nOutput: 8\nExplanation: Possible arrays are [1317],[131,7],[13,17],[1,317],[13,1,7],[1,31,7],[1,3,17],[1,3,1,7]"
        ],
        "constrains": "1 <= s.length <= 105\ns consists of only digits and does not contain leading zeros.\n1 <= k <= 109",
        "release_time": 1682229291,
        "oracle_code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n        def rec(i=0):\n            if i == len(s):\n                return 1\n            if s[i] == '0':\n                return 0\n            res = 0\n            num = 0\n            for j in range(i, len(s)):\n                num = num * 10 + int(s[j])\n                if num > k:\n                    break\n                res += rec(j + 1)\n                res %= 1000000007\n            return res\n        \n        return rec()\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "amount-of-time-for-binary-tree-to-be-infected",
        "description": "You are given the root of a binary tree with unique values, and an integer start. At minute 0, an infection starts from the node with value start.\nEach minute, a node becomes infected if:\n\nThe node is currently uninfected.\nThe node is adjacent to an infected node.\n\nReturn the number of minutes needed for the entire tree to be infected.",
        "examples": [
            "Input: root = [1,5,3,null,4,10,6,9,2], start = 3\nOutput: 4\nExplanation: The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.",
            "Input: root = [1], start = 1\nOutput: 0\nExplanation: At minute 0, the only node in the tree is infected so we return 0."
        ],
        "constrains": "The number of nodes in the tree is in the range [1, 105].\n1 <= Node.val <= 105\nEach node has a unique value.\nA node with a value of start exists in the tree.",
        "release_time": 1661054544,
        "oracle_code": "class Solution: \t\t\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = defaultdict(list)\n        \n        stack = [(root, None)]\n        while stack: \n            n, p = stack.pop()\n            if p: \n                graph[p.val].append(n.val)\n                graph[n.val].append(p.val)\n            if n.left: stack.append((n.left, n))\n            if n.right: stack.append((n.right, n))\n        \n        ans = -1\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                u = queue.popleft()\n                for v in graph[u]: \n                    if v not in seen: \n                        seen.add(v)\n                        queue.append(v)\n            ans += 1\n        return ans",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nI find it easier to treat the tree as a graph. First, I convert the tree to graph. Then I run a BFS to find the furthest away point which represents the answer. \\n\\n**Analysis**\\nTime complexity O(N)\\nSpace complexity O(N)\\t\\t\\n\\n```\\nclass Solution: \\t\\t\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        stack = [(root, None)]\\n        while stack: \\n            n, p = stack.pop()\\n            if p: \\n                graph[p.val].append(n.val)\\n                graph[n.val].append(p.val)\\n            if n.left: stack.append((n.left, n))\\n            if n.right: stack.append((n.right, n))\\n        \\n        ans = -1\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                u = queue.popleft()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        seen.add(v)\\n                        queue.append(v)\\n            ans += 1\\n        return ans \\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        if not root:\n            return 0\n        \n        # Create a set to keep track of infected nodes\n        infected = set()\n        \n        # Create a queue to perform BFS traversal\n        queue = deque([(root, 0)])\n        \n        # Add the start node to the infected set\n        infected.add(start)\n        \n        # Variable to keep track of the maximum time taken\n        max_time = 0\n        \n        # Perform BFS traversal until the queue is empty\n        while queue:\n            node, time = queue.popleft()\n            \n            # Update the maximum time taken\n            max_time = max(max_time, time)\n            \n            # Check if the neighbors of the current node are infected or not\n            if node.left:\n                if node.left.val in infected:\n                    continue\n                else:\n                    queue.append((node.left, time + 1))\n                    infected.add(node.left.val)\n            \n            if node.right:\n                if node.right.val in infected:\n                    continue\n                else:\n                    queue.append((node.right, time + 1))\n                    infected.add(node.right.val)\n        \n        return max_time\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 58616000,
            "question_id": "2461",
            "elapsed_time": 419,
            "compare_result": "01100001000000110100000010101011101101100010010000000000000000000101001000001100",
            "code_output": "3",
            "std_output": "",
            "last_testcase": "[1,5,3,null,4,10,6,9,2]\n3",
            "expected_output": "4",
            "task_finish_time": 1699925768558,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 23,
            "total_testcases": 80,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098299125",
            "input_formatted": "[1,5,3,null,4,10,6,9,2], 3",
            "input": "[1,5,3,null,4,10,6,9,2]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-time-to-complete-all-tasks",
        "description": "There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\nReturn the minimum time during which the computer should be turned on to complete all tasks.",
        "examples": [
            "Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]\nOutput: 2\nExplanation: \n- The first task can be run in the inclusive time range [2, 2].\n- The second task can be run in the inclusive time range [5, 5].\n- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].\nThe computer will be on for a total of 2 seconds.",
            "Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]\nOutput: 4\nExplanation: \n- The first task can be run in the inclusive time range [2, 3].\n- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].\n- The third task can be run in the two inclusive time range [5, 6].\nThe computer will be on for a total of 4 seconds."
        ],
        "constrains": "1 <= tasks.length <= 2000\ntasks[i].length == 3\n1 <= starti, endi <= 2000\n1 <= durationi <= endi - starti + 1",
        "release_time": 1678595753,
        "oracle_code": "class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x:x[1])\n        on=[0]*2001\n        for s,e,d in tasks:\n            cr=sum(on[s:e+1])\n            while cr<d:\n                # Greedy: finish the task as late as you can which benefits later tasks\n                if on[e]!=1:on[e]=1; cr+=1\n                e-=1\n        return sum(on)",
        "content": "# Intuition\\nRun earlier task as late as you can which benefits later tasks.\\n\\n# Approach\\nGREEDY\\n\\n# Complexity\\n- Time complexity: $O(NT)$\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:x[1])\\n        on=[0]*2001\\n        for s,e,d in tasks:\\n            cr=sum(on[s:e+1])\\n            while cr<d:\\n                # Greedy: finish the task as late as you can which benefits later tasks\\n                if on[e]!=1:on[e]=1; cr+=1\\n                e-=1\\n        return sum(on)\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        # Sort tasks by start time\n        tasks.sort(key=lambda x: x[0])\n        \n        # Initialize variables\n        current_time = 0  # Current time\n        total_time = 0    # Total time that the computer is turned on\n        \n        # Iterate through tasks\n        for i in range(len(tasks)):\n            start_time = tasks[i][0]\n            end_time = tasks[i][1]\n            duration = tasks[i][2]\n            \n            # Check if the computer needs to be turned on\n            if current_time < start_time:\n                total_time += start_time - current_time\n                current_time = start_time\n            \n            # Update current time\n            current_time += duration\n            \n            # Update total time if current time is greater than end time\n            if current_time > end_time:\n                total_time += current_time - end_time\n                current_time = end_time\n        \n        return total_time\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 17340000,
            "question_id": "2657",
            "elapsed_time": 206,
            "compare_result": "000010000000010010000000000000000010010000001000000000000000100000000000001001000000000000000000001000000000000000000100000100000000010000000100000000001100001000000000010001000000000010000100000000000000000001000000010000000000000000000000000000100100001000000000000000000000110000000000000000000000001000000000100000000000000000100000000000000001000000000100001000001000000000000000000000000000000000000000000100010000000000010000000000010000000000000000000000100000000000000000000000110000000000000000000000000000001110010000010000000000000000000010000000000000000000000000001000000100000010000000000000010000010000101000000000100000000000100100000000000000000000000000001000000000100100000000000000000000000010100000001000000000100001000000000000100000000010000000010110000000000110100100000010000000000000010000000000000000000000100000000000000000000010000000011000000000010000000000001000010000000000100000000000100100000000000010000000010000000000000000000000100100000000000001000001000000100000001000000000000000000000000000000000000000000000000000000",
            "code_output": "3",
            "std_output": "",
            "last_testcase": "[[2,3,1],[4,5,1],[1,5,2]]",
            "expected_output": "2",
            "task_finish_time": 1699925783257,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 95,
            "total_testcases": 1059,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098299229",
            "input_formatted": "[[2,3,1],[4,5,1],[1,5,2]]",
            "input": "[[2,3,1],[4,5,1],[1,5,2]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "card-flipping-game",
        "description": "You are given two 0-indexed integer arrays fronts and backs of length n, where the ith card has the positive integer fronts[i] printed on the front and backs[i] printed on the back. Initially, each card is placed on a table such that the front number is facing up and the other is facing down. You may flip over any number of cards (possibly zero).\nAfter flipping the cards, an integer is considered good if it is facing down on some card and not facing up on any card.\nReturn the minimum possible good integer after flipping the cards. If there are no good integers, return 0.",
        "examples": [
            "Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]\nOutput: 2\nExplanation:\nIf we flip the second card, the face up numbers are [1,3,4,4,7] and the face down are [1,2,4,1,3].\n2 is the minimum good integer as it appears facing down but not facing up.\nIt can be shown that 2 is the minimum possible good integer obtainable after flipping some cards.",
            "Input: fronts = [1], backs = [1]\nOutput: 0\nExplanation:\nThere are no good integers no matter how we flip the cards, so we return 0."
        ],
        "constrains": "n == fronts.length == backs.length\n1 <= n <= 1000\n1 <= fronts[i], backs[i] <= 2000",
        "release_time": 1685678247,
        "oracle_code": "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs)):\n            if i in bad:\n                continue\n            return i\n        return 0",
        "content": "# Intuition\\nThe only way you can\\'t have a good integer is if you have a card with it on both sides.  You want the minimum, so just sort, giving you the lowest, and check if any card has it on both sides.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\\n        for i in sorted(set(fronts + backs)):\\n            if i in bad:\\n                continue\\n            return i\\n        return 0\\n\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        n = len(fronts)\n        min_good = float('inf')\n        for i in range(n):\n            if fronts[i] == backs[i]:\n                min_good = min(min_good, fronts[i])\n        \n        for i in range(n):\n            if fronts[i] != backs[i]:\n                if fronts[i] not in backs and fronts[i] < min_good:\n                    min_good = fronts[i]\n                if backs[i] not in fronts and backs[i] < min_good:\n                    min_good = backs[i]\n        \n        return 0 if min_good == float('inf') else min_good\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16684000,
            "question_id": "842",
            "elapsed_time": 188,
            "compare_result": "0010001000100011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "1",
            "std_output": "",
            "last_testcase": "[1,2,4,4,7]\n[1,3,4,1,3]",
            "expected_output": "2",
            "task_finish_time": 1699925798278,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 7,
            "total_testcases": 169,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098299335",
            "input_formatted": "[1,2,4,4,7], [1,3,4,1,3]",
            "input": "[1,2,4,4,7]\n[1,3,4,1,3]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes' values. (i.e., from left to right, level by level from leaf to root).",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]",
            "Input: root = [1]\nOutput: [[1]]",
            "Input: root = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000",
        "release_time": 1686416191,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root:\n            return []\n        \n        queue = deque([root])\n        result = []\n        \n        while queue:\n            level_result = []\n            level_size = len(queue)\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                level_result.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level_result)\n        \n        return result[::-1]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "44 ms",
            "memory": 16648000,
            "question_id": "107",
            "elapsed_time": 57,
            "compare_result": "1111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925813664,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 34,
            "total_testcases": 34,
            "runtime_percentile": 41.15779999999996,
            "status_memory": "16.6 MB",
            "memory_percentile": 30.674199999999985,
            "pretty_lang": "Python3",
            "submission_id": "1098299452",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "description": "Given an integer array nums of positive integers, return the average value of all even integers that are divisible by 3.\nNote that the average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.",
        "examples": [
            "Input: nums = [1,3,6,10,12,15]\nOutput: 9\nExplanation: 6 and 12 are even numbers that are divisible by 3. (6 + 12) / 2 = 9.",
            "Input: nums = [1,2,4,7,10]\nOutput: 0\nExplanation: There is no single number that satisfies the requirement, so return 0."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 1000",
        "release_time": 1676326760,
        "oracle_code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        count = 0\n        total = 0\n        for num in nums:\n            if num % 2 == 0 and num % 3 == 0:\n                count += 1\n                total += num\n        if count == 0:\n            return 0\n        return total // count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "83 ms",
            "memory": 16564000,
            "question_id": "2542",
            "elapsed_time": 97,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925828354,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 181,
            "total_testcases": 181,
            "runtime_percentile": 32.011799999999994,
            "status_memory": "16.6 MB",
            "memory_percentile": 33.039699999999996,
            "pretty_lang": "Python3",
            "submission_id": "1098299557",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constrains": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n",
        "release_time": 1690968356,
        "oracle_code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # Initialize an empty list to store the characters of the word\n        word = []\n        # Iterate over the rows of the lcp matrix\n        for i in range(len(lcp)):\n            # Initialize a variable to store the current character\n            current_char = None\n            # Iterate over the columns of the lcp matrix\n            for j in range(len(lcp[i])):\n                # If the current character variable is None, set it to the character at position j\n                if current_char is None:\n                    current_char = lcp[i][j]\n                # If the character at position j is less than the current character, update the current character\n                elif lcp[i][j] < current_char:\n                    current_char = lcp[i][j]\n            # Append the current character to the word list\n            word.append(current_char)\n        # Convert the word list to a string\n        word_string = ''.join(word)\n        return word_string\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 21: TypeError: sequence item 0: expected str instance, int found",
            "full_runtime_error": "TypeError: sequence item 0: expected str instance, int found\n    word_string = ''.join(word)\nLine 21 in findTheString (Solution.py)\n    ret = Solution().findTheString(param_1)\nLine 42 in _driver (Solution.py)\n    _driver()\nLine 53 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16368000,
            "question_id": "2708",
            "elapsed_time": 58,
            "compare_result": "0000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]",
            "expected_output": "\"abab\"",
            "task_finish_time": 1699925843360,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 55,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098299675",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "kth-missing-positive-number",
        "description": "Given an array arr of positive integers sorted in a strictly increasing order, and an integer k.\nReturn the kth positive integer that is missing from this array.",
        "examples": [
            "Input: arr = [2,3,4,7,11], k = 5\nOutput: 9\nExplanation: The missing positive integers are [1,5,6,8,9,10,12,13,...]. The 5th\u00a0missing positive integer is 9.",
            "Input: arr = [1,2,3,4], k = 2\nOutput: 6\nExplanation: The missing positive integers are [5,6,7,...]. The 2nd missing positive integer is 6."
        ],
        "constrains": "1 <= arr.length <= 1000\n1 <= arr[i] <= 1000\n1 <= k <= 1000\narr[i] < arr[j] for 1 <= i < j <= arr.length",
        "release_time": 1678126197,
        "oracle_code": "class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        l,h=0,len(arr)\n        while l<h:\n            mid=(h+l)//2\n            if arr[mid]-mid>k:h=mid\n            else: l=mid+1\n        return l+k",
        "content": "# Code\\n```\\nclass Solution:\\n    def findKthPositive(self, arr: List[int], k: int) -> int:\\n        l,h=0,len(arr)\\n        while l<h:\\n            mid=(h+l)//2\\n            if arr[mid]-mid>k:h=mid\\n            else: l=mid+1\\n        return l+k\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        n = 1\n        count = 0\n        \n        while count < k:\n            if n not in arr:\n                count += 1\n            if count == k:\n                return n\n            n += 1\n        \n        return -1\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "137 ms",
            "memory": 16388000,
            "question_id": "1646",
            "elapsed_time": 147,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925858454,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 86,
            "total_testcases": 86,
            "runtime_percentile": 5.190900000000008,
            "status_memory": "16.4 MB",
            "memory_percentile": 62.15480000000001,
            "pretty_lang": "Python3",
            "submission_id": "1098299784",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constrains": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique.",
        "release_time": 1690635827,
        "oracle_code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        stones.sort() # Sort the stones in ascending order\n        n = len(stones) # Get the total number of stones\n        \n        if stones[-1] - stones[0] + 1 == n: # If the stones are already in three consecutive positions, return [0, 0]\n            return [0, 0]\n        \n        max_moves = max(stones[-1] - stones[1] - n + 2, stones[-2] - stones[0] - n + 2) # Calculate the maximum number of moves\n        \n        for i in range(n): # Iterate through each stone position\n            if stones[i] - n + 1 in stones or stones[i] + n - 1 in stones: # Check if there is a vacant position on the left or right side of the stones\n                min_moves = min(min_moves, n - (stones[-1] - stones[0] + 1)) # Calculate the minimum number of moves\n        \n        return [min_moves, max_moves]\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 14: UnboundLocalError: local variable 'min_moves' referenced before assignment",
            "full_runtime_error": "UnboundLocalError: local variable 'min_moves' referenced before assignment\n    min_moves = min(min_moves, n - (stones[-1] - stones[0] + 1)) # Calculate the minimum number of moves\nLine 14 in numMovesStonesII (Solution.py)\n    ret = Solution().numMovesStonesII(param_1)\nLine 36 in _driver (Solution.py)\n    _driver()\nLine 47 in <module> (Solution.py)",
            "status_runtime": "N/A",
            "memory": 16444000,
            "question_id": "1113",
            "elapsed_time": 65,
            "compare_result": "000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[7,4,9]",
            "expected_output": "[1,2]",
            "task_finish_time": 1699925873855,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 27,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098299917",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "merge-k-sorted-lists",
        "description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.",
        "examples": [
            "Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6",
            "Input: lists = []\nOutput: []",
            "Input: lists = [[]]\nOutput: []"
        ],
        "constrains": "k == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.",
        "release_time": 1678579423,
        "oracle_code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in lists:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr):\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\n        head = temp = ListNode()\\n        arr = []\\n\\n        for ls in lists:\\n            while ls:\\n                arr.append(ls.val)\\n                ls = ls.next\\n\\n        for val in sorted(arr):\\n            temp.next = ListNode()\\n            temp = temp.next\\n            temp.val = val\\n\\n        return head.next\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        # Create an empty list to store the merged result\n        merged_list = []\n        \n        # Iterate over each linked list in the input array\n        for linked_list in lists:\n            # Traverse the linked list and append each node's value to the merged list\n            curr = linked_list\n            while curr:\n                merged_list.append(curr.val)\n                curr = curr.next\n        \n        # Sort the merged list in ascending order\n        merged_list.sort()\n        \n        # Create a new linked list from the sorted merged list\n        head = ListNode(-1)\n        curr = head\n        for val in merged_list:\n            curr.next = ListNode(val)\n            curr = curr.next\n        \n        # Return the head of the new merged linked list\n        return head.next\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "79 ms",
            "memory": 21188000,
            "question_id": "23",
            "elapsed_time": 122,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925888866,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 133,
            "total_testcases": 133,
            "runtime_percentile": 97.49299999999994,
            "status_memory": "21.2 MB",
            "memory_percentile": 8.426599999999972,
            "pretty_lang": "Python3",
            "submission_id": "1098300006",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constrains": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104",
        "release_time": 1677727583,
        "oracle_code": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython has a built in sort() function that can sort the list for you if you don\\'t want to learn sorting algorithms.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust run list.sort() on its own line and return the list. It\\'s that simple.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def sortArray(self, nums):\n        if len(nums) <= 1:\n            return nums\n        mid = len(nums) // 2\n        left = self.sortArray(nums[:mid])\n        right = self.sortArray(nums[mid:])\n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n    \nnums = [5,2,3,1]\nsol = Solution()\nsorted_nums = sol.sortArray(nums)\nprint(sorted_nums)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "1481 ms",
            "memory": 24852000,
            "question_id": "948",
            "elapsed_time": 1581,
            "compare_result": "111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925905380,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 21,
            "total_testcases": 21,
            "runtime_percentile": 61.36300000000094,
            "status_memory": "24.9 MB",
            "memory_percentile": 46.406000000000034,
            "pretty_lang": "Python3",
            "submission_id": "1098300108",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "construct-the-longest-new-string",
        "description": "You are given three integers x, y, and z.\nYou have x strings equal to \"AA\", y strings equal to \"BB\", and z strings equal to \"AB\". You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain \"AAA\" or \"BBB\" as a substring.\nReturn the maximum possible length of the new string.\nA substring is a contiguous non-empty sequence of characters within a string.",
        "examples": [
            "Input: x = 2, y = 5, z = 1\nOutput: 12\nExplanation: We can concactenate the strings \"BB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AB\" in that order. Then, our new string is \"BBAABBAABBAB\". \nThat string has length 12, and we can show that it is impossible to construct a string of longer length.",
            "Input: x = 3, y = 2, z = 2\nOutput: 14\nExplanation: We can concactenate the strings \"AB\", \"AB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AA\" in that order. Then, our new string is \"ABABAABBAABBAA\". \nThat string has length 14, and we can show that it is impossible to construct a string of longer length."
        ],
        "constrains": "1 <= x, y, z <= 50",
        "release_time": 1687711912,
        "oracle_code": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n\n        if x > y: x,y = y,x\n\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;",
        "content": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        if x > y: x,y = y,x\\n\\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;\\n```\\n[https://leetcode.com/problems/construct-the-longest-new-string/submissions/985072631/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n        # Find the maximum length of the new string based on the given constraints\n        # Start by concatenating all \"AA\" strings\n        new_string_length = x * 2\n        \n        # If there are remaining \"BB\" strings, add them to the new string\n        if y > 0:\n            new_string_length += 2\n        \n        # If there are remaining \"AB\" strings, add them to the new string\n        if z > 0:\n            new_string_length += 2\n        \n        return new_string_length\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 16348000,
            "question_id": "2850",
            "elapsed_time": 60,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000001000000000000000000000000000000000000000000",
            "code_output": "8",
            "std_output": "",
            "last_testcase": "2\n5\n1",
            "expected_output": "12",
            "task_finish_time": 1699925918897,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 8,
            "total_testcases": 2003,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098300213",
            "input_formatted": "2, 5, 1",
            "input": "2\n5\n1",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
        "release_time": 1676664650,
        "oracle_code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        left=0\n        right=len(nums)-1\n        total=0\n        while left<=right:\n            if left<right:\n                total+=int(str(nums[left])+str(nums[right]))\n            else:\n                total+=nums[left]\n            left+=1\n            right-=1\n        return total",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        left=0\\n        right=len(nums)-1\\n        total=0\\n        while left<=right:\\n            if left<right:\\n                total+=int(str(nums[left])+str(nums[right]))\\n            else:\\n                total+=nums[left]\\n            left+=1\\n            right-=1\\n        return total\\n```",
        "level": "easy",
        "completed_code": "\nclass Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        conc_value = 0\n        while len(nums) > 0:\n            if len(nums) > 1:\n                conc_value += int(str(nums[0]) + str(nums[-1]))\n                nums = nums[1:-1]\n            else:\n                conc_value += nums[0]\n                nums = nums[1:]\n        return conc_value\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "75 ms",
            "memory": 16580000,
            "question_id": "2698",
            "elapsed_time": 85,
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925934155,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 53,
            "total_testcases": 53,
            "runtime_percentile": 5.128000000000003,
            "status_memory": "16.6 MB",
            "memory_percentile": 8.440199999999994,
            "pretty_lang": "Python3",
            "submission_id": "1098300331",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reverse-nodes-in-k-group",
        "description": "Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.\nk is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.\nYou may not alter the values in the list's nodes, only nodes themselves may be changed.",
        "examples": [
            "Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]",
            "Input: head = [1,2,3,4,5], k = 3\nOutput: [3,2,1,4,5]"
        ],
        "constrains": "The number of nodes in the list is n.\n1 <= k <= n <= 5000\n0 <= Node.val <= 1000\n\n\u00a0\nFollow-up: Can you solve the problem in O(1) extra memory space?",
        "release_time": 1690002884,
        "oracle_code": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        def getKth(self, node, k):\n            count = 0\n            while count < k and node:\n                node = node.next\n                count += 1\n            return node if count == k else None\n        \n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while head:\n            tail = prev\n            for _ in range(k):\n                tail = tail.next\n                if not tail:\n                    return dummy.next\n            \n            next_head = tail.next\n            tail.next = None\n            \n            new_head = self.reverseList(head)\n            prev.next = new_head\n            head.next = next_head\n            \n            prev = head\n            head = next_head\n        \n        return dummy.next\n    \n    def reverseList(self, curr):\n        prev = None\n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n        return prev\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "62 ms",
            "memory": 17440000,
            "question_id": "25",
            "elapsed_time": 71,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925949375,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 62,
            "total_testcases": 62,
            "runtime_percentile": 7.048399999999963,
            "status_memory": "17.4 MB",
            "memory_percentile": 54.49119999999999,
            "pretty_lang": "Python3",
            "submission_id": "1098300439",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "description": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.",
        "examples": [
            "Input: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".",
            "Input: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".",
            "Input: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\"."
        ],
        "constrains": "n == recipes.length == ingredients.length\n1 <= n <= 100\n1 <= ingredients[i].length, supplies.length <= 100\n1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\nrecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\nAll the values of recipes and supplies\u00a0combined are unique.\nEach ingredients[i] does not contain any duplicate values.",
        "release_time": 1672905271,
        "oracle_code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        # Create a set to store the available supplies\n        available_supplies = set(supplies)\n        \n        # Create a dictionary to store the ingredients of each recipe\n        recipe_ingredients_map = {}\n        for i in range(len(recipes)):\n            recipe_ingredients_map[recipes[i]] = ingredients[i]\n        \n        # Create a list to store the recipes that can be created\n        created_recipes = []\n        \n        # Helper function to check if all ingredients are available\n        def are_all_ingredients_available(ingredients):\n            for ingredient in ingredients:\n                if ingredient not in available_supplies:\n                    return False\n            return True\n        \n        # Helper function to create a recipe and update available supplies\n        def create_recipe(recipe):\n            if recipe in created_recipes:\n                return\n            ingredients = recipe_ingredients_map[recipe]\n            if are_all_ingredients_available(ingredients):\n                # Add the recipe to the list of created recipes\n                created_recipes.append(recipe)\n                # Remove the ingredients used from the available supplies\n                for ingredient in ingredients:\n                    available_supplies.remove(ingredient)\n                # Create any additional ingredients required by this recipe\n                for ingredient in ingredients:\n                    if ingredient in recipe_ingredients_map:\n                        create_recipe(ingredient)\n        \n        # Iterate over all the recipes\n        for recipe in recipes:\n            create_recipe(recipe)\n        \n        return created_recipes\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 23476000,
            "question_id": "2220",
            "elapsed_time": 937,
            "compare_result": "10010100000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000",
            "code_output": "[\"bread\"]",
            "std_output": "",
            "last_testcase": "[\"bread\",\"sandwich\"]\n[[\"yeast\",\"flour\"],[\"bread\",\"meat\"]]\n[\"yeast\",\"flour\",\"meat\"]",
            "expected_output": "[\"bread\",\"sandwich\"]",
            "task_finish_time": 1699925966260,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 113,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098300561",
            "input_formatted": "[\"bread\",\"sandwich\"], [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], [\"yeast\",\"flour\",\"meat\"]",
            "input": "[\"bread\",\"sandwich\"]\n[[\"yeast\",\"flour\"],[\"bread\",\"meat\"]]\n[\"yeast\",\"flour\",\"meat\"]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1669526242,
        "oracle_code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [defaultdict(int) for _ in range(n)]\n        count = 0\n        \n        for i in range(n):\n            for j in range(i):\n                diff = nums[i] - nums[j]\n                dp[i][diff] += 1\n                \n                if diff in dp[j]:\n                    dp[i][diff] += dp[j][diff]\n                    count += dp[j][diff]\n                    \n        return count\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "481 ms",
            "memory": 54664000,
            "question_id": "446",
            "elapsed_time": 503,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925980748,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 101,
            "total_testcases": 101,
            "runtime_percentile": 74.0435,
            "status_memory": "54.7 MB",
            "memory_percentile": 71.06399999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098300663",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "smallest-string-with-swaps",
        "description": "You are given a string s, and an array of pairs of indices in the string\u00a0pairs\u00a0where\u00a0pairs[i] =\u00a0[a, b]\u00a0indicates 2 indices(0-indexed) of the string.\nYou can\u00a0swap the characters at any pair of indices in the given\u00a0pairs\u00a0any number of times.\nReturn the\u00a0lexicographically smallest string that s\u00a0can be changed to after using the swaps.",
        "examples": [
            "Input: s = \"dcab\", pairs = [[0,3],[1,2]]\nOutput: \"bacd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[1] and s[2], s = \"bacd\"",
            "Input: s = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\nOutput: \"abcd\"\nExplaination: \nSwap s[0] and s[3], s = \"bcad\"\nSwap s[0] and s[2], s = \"acbd\"\nSwap s[1] and s[2], s = \"abcd\"",
            "Input: s = \"cba\", pairs = [[0,1],[1,2]]\nOutput: \"abc\"\nExplaination: \nSwap s[0] and s[1], s = \"bca\"\nSwap s[1] and s[2], s = \"bac\"\nSwap s[0] and s[1], s = \"abc\""
        ],
        "constrains": "1 <= s.length <= 10^5\n0 <= pairs.length <= 10^5\n0 <= pairs[i][0], pairs[i][1] <\u00a0s.length\ns\u00a0only contains lower case English letters.",
        "release_time": 1651023323,
        "oracle_code": "class Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def union(self, a, b):\n        root_a = self.find(a)\n        root_b = self.find(b)\n        if root_a != root_b:\n            self.parent[root_b] = root_a\n\n    def find(self, a):\n        if self.parent[a] == a:\n            return a\n        self.parent[a] = self.find(self.parent[a])\n        return self.parent[a]\n\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n        self.parent = [i for i in range(len(s))]\n        for pair in pairs:\n            first_index = pair[0]\n            second_index = pair[1]\n            self.union(first_index, second_index)\n\n        group = collections.defaultdict(list)\n        for i in range(len(s)):\n            root = self.find(i)\n            group[root].append(i)\n\n        result_list = list(s)\n        for indices in group.values():\n            group_chars = [s[index] for index in indices]\n            group_chars.sort()\n            for i, index in enumerate(indices):\n                result_list[index] = group_chars[i]\n\n        return ''.join(result_list)\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "587 ms",
            "memory": 52764000,
            "question_id": "1308",
            "elapsed_time": 622,
            "compare_result": "111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699925995878,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 36,
            "total_testcases": 36,
            "runtime_percentile": 49.29769999999995,
            "status_memory": "52.8 MB",
            "memory_percentile": 72.28609999999998,
            "pretty_lang": "Python3",
            "submission_id": "1098300790",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "description": "Given two integers n and k, return the kth lexicographically smallest integer in the range [1, n].",
        "examples": [
            "Input: n = 13, k = 2\nOutput: 10\nExplanation: The lexicographical order is [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9], so the second smallest number is 10.",
            "Input: n = 1, k = 1\nOutput: 1"
        ],
        "constrains": "1 <= k <= n <= 109",
        "release_time": 1638474846,
        "oracle_code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        def fn(x):\n            \"\"\"\n            Recursive function to count the number of integers less than or equal to x\n            \"\"\"\n            if x > n:\n                return 0\n            count = 1\n            curr = x\n            while curr <= n:\n                count += min(n - curr + 1, x)\n                curr *= 10\n                x *= 10\n            return count\n        \n        low = 1\n        high = n\n        \n        while k > 1:\n            count = fn(low)\n            if count < k:\n                low += 1\n                k -= count\n            else:\n                low *= 10\n                k -= 1\n        \n        return low\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "description": "Given two strings s and t, transform string s into string t using the following operation any number of times:\n\nChoose a non-empty substring in s and sort it in place so the characters are in ascending order.\n\n\t\nFor example, applying the operation on the underlined substring in \"14234\" results in \"12344\".\n\n\n\nReturn true if it is possible to transform s into t. Otherwise, return false.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"84532\", t = \"34852\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"84532\" (from index 2 to 3) -> \"84352\"\n\"84352\" (from index 0 to 2) -> \"34852\"",
            "Input: s = \"34521\", t = \"23415\"\nOutput: true\nExplanation: You can transform s into t using the following sort operations:\n\"34521\" -> \"23451\"\n\"23451\" -> \"23415\"",
            "Input: s = \"12345\", t = \"12435\"\nOutput: false"
        ],
        "constrains": "s.length == t.length\n1 <= s.length <= 105\ns and t consist of only digits.",
        "release_time": 1688219312,
        "oracle_code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n    \n    n = len(s)\n    s = list(s)\n    t = list(t)\n    \n    for i in range(n):\n      if s[i] > t[i]:\n        return False\n      \n      for j in range(i+1, n):\n        if s[j] == t[i]:\n          for k in range(j, i, -1):\n            s[k], s[k-1] = s[k-1], s[k]\n            break\n    \n    return s == t\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "edit-distance",
        "description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character",
        "examples": [
            "Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')",
            "Input: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
        ],
        "constrains": "0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.",
        "release_time": 1680104140,
        "oracle_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```",
        "level": "hard",
        "completed_code": "\nclass Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        # initialize a 2D array to store the minimum number of operations at each position\n        dp = [[0] * (len(word2) + 1) for _ in range(len(word1) + 1)]\n        \n        # fill in the first row and first column\n        for i in range(len(word1) + 1):\n            dp[i][0] = i\n        for j in range(len(word2) + 1):\n            dp[0][j] = j\n        \n        # fill in the rest of the table\n        for i in range(1, len(word1) + 1):\n            for j in range(1, len(word2) + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        \n        # the minimum number of operations to convert word1 to word2 is at the bottom right corner of the table\n        return dp[-1][-1]\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "128 ms",
            "memory": 20056000,
            "question_id": "72",
            "elapsed_time": 148,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699926042791,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1146,
            "total_testcases": 1146,
            "runtime_percentile": 47.47570000000003,
            "status_memory": "20.1 MB",
            "memory_percentile": 26.905600000000007,
            "pretty_lang": "Python3",
            "submission_id": "1098301140",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "the-kth-factor-of-n",
        "description": "You are given two positive integers n and k. A factor of an integer n is defined as an integer i where n % i == 0.\nConsider a list of all factors of n sorted in ascending order, return the kth factor in this list or return -1 if n has less than k factors.",
        "examples": [
            "Input: n = 12, k = 3\nOutput: 3\nExplanation: Factors list is [1, 2, 3, 4, 6, 12], the 3rd factor is 3.",
            "Input: n = 7, k = 2\nOutput: 7\nExplanation: Factors list is [1, 7], the 2nd factor is 7.",
            "Input: n = 4, k = 4\nOutput: -1\nExplanation: Factors list is [1, 2, 4], there is only 3 factors. We should return -1."
        ],
        "constrains": "1 <= k <= n <= 1000",
        "release_time": 1692616031,
        "oracle_code": "class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k else -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to iterate through all positive integers from 1 to `n` and check if they are factors of `n`. The code aims to find the `kth` factor of `n`, where `k` is a given positive integer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a simple iterative approach to find the `kth` factor of `n`. It initializes a variable `j` to keep track of the number of factors found. For each integer `i` from 1 to `n`, it checks if `i` is a factor of n by verifying if `n % i == 0`. If `i` is indeed a factor, it increments `j` and updates the variable `num` with the value of `i`.\\n\\n- The loop continues until `j` becomes equal to k or until all integers from 1 to n have been considered. If `j` becomes equal to `k`, it breaks out of the loop. At the end of the loop, if `j` is equal to `k`, it returns the value of `num`; otherwise, it returns `-1` to indicate that there is no `kth` factor.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthFactor(self, n: int, k: int) -> int:\\n        j = 0\\n        for i in range(1, n + 1):\\n            if n % i == 0:\\n                num = i\\n                j += 1\\n            if j == k:\\n                break\\n        return num if j == k else -1\\n```",
        "level": "medium",
        "completed_code": "thon\nclass Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        factors = []\n        for i in range(1, n+1):\n            if n % i == 0:\n                factors.append(i)\n                \n        if len(factors) >= k:\n            return factors[k-1]\n        else:\n            return -1\n``",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "python3",
            "run_success": false,
            "runtime_error": "Line 13: SyntaxError: invalid syntax",
            "full_runtime_error": "SyntaxError: invalid syntax\n    ^\n    ``\nLine 13  (Solution.py)",
            "status_runtime": "N/A",
            "memory": 9016000,
            "question_id": "1585",
            "elapsed_time": 18,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "12\n3",
            "expected_output": "3",
            "task_finish_time": 1699926057758,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 208,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098301241",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constrains": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters",
        "release_time": 1687376944,
        "oracle_code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n",
        "level": "medium",
        "completed_code": "\nclass Solution:\n    def smallestString(self, s: str) -> str:\n        # Find the smallest character in the original string\n        smallest_char = min(s)\n        \n        # Find the index of the smallest character in the original string\n        smallest_index = s.index(smallest_char)\n        \n        # Generate the new string by replacing all characters from smallest_index onwards with the previous character\n        new_string = s[:smallest_index] + chr(ord(smallest_char)-1)*(len(s)-smallest_index)\n        \n        return new_string\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "python3",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 20760000,
            "question_id": "2828",
            "elapsed_time": 155,
            "compare_result": "000011111111111111111111111110000001000001000001000001000000000000000000000000000000010000000000000000000000000000001000000000000000000000000000000100000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100",
            "code_output": "\"cb```\"",
            "std_output": "",
            "last_testcase": "\"cbabc\"",
            "expected_output": "\"baabc\"",
            "task_finish_time": 1699926072875,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 38,
            "total_testcases": 2241,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Python3",
            "submission_id": "1098301368",
            "input_formatted": "\"cbabc\"",
            "input": "\"cbabc\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    }
]