[
    {
        "slug": "path-with-maximum-probability",
        "description": "You are given an undirected weighted graph of\u00a0n\u00a0nodes (0-indexed), represented by an edge list where\u00a0edges[i] = [a, b]\u00a0is an undirected edge connecting the nodes\u00a0a\u00a0and\u00a0b\u00a0with a probability of success of traversing that edge\u00a0succProb[i].\nGiven two nodes\u00a0start\u00a0and\u00a0end, find the path with the maximum probability of success to go from\u00a0start\u00a0to\u00a0end\u00a0and return its success probability.\nIf there is no path from\u00a0start\u00a0to\u00a0end, return\u00a00. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",
        "examples": [
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation:\u00a0There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.",
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000",
            "Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation:\u00a0There is no path between 0 and 2."
        ],
        "constrains": "2 <= n <= 10^4\n0 <= start, end < n\nstart != end\n0 <= a, b < n\na != b\n0 <= succProb.length == edges.length <= 2*10^4\n0 <= succProb[i] <= 1\nThere is at most one edge between every two nodes.",
        "release_time": 1687928964,
        "oracle_code": "class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n        \n        // Build the graph using an adjacency list representation\n        // Each edge is represented as a pair (neighbor node, edge index)\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\n            graph[u].push_back({v, edgeIdx});\n            graph[v].push_back({u, edgeIdx});\n        }\n        \n        vector<double> probabilities(n, 0.0);\n        probabilities[start] = 1.0;\n        \n        priority_queue<pair<double, int>> nodesToExplore;\n        // Add the start node to the priority queue with probability 1.0\n        nodesToExplore.push({1.0, start});\n        \n        while (!nodesToExplore.empty()) {\n            auto [prob, u] = nodesToExplore.top();\n            nodesToExplore.pop();\n            \n            // If we've reached the end node, return the probability\n            if (u == end) \n                return prob;\n            // If we've already explored this node with a higher probability, skip it\n            if (probabilities[u] > prob) \n                continue;\n                \n            // Explore the neighbors of the current node\n            for (auto [v, edgeIdx] : graph[u]) {\n                double newProb = prob * succProb[edgeIdx];\n                \n                // Update the probability of the neighbor node if we've found a higher probability\n                if (newProb > probabilities[v]) {\n                    probabilities[v] = newProb;\n                    \n                    // Add the neighbor node to the priority queue with its new probability\n                    nodesToExplore.push({newProb, v});\n                }\n            }\n        }\n        \n        // If we've explored all nodes and haven't reached the end node, return 0.0\n        return 0.0;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        // Build the graph using an adjacency list representation\\n        // Each edge is represented as a pair (neighbor node, edge index)\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\\n            graph[u].push_back({v, edgeIdx});\\n            graph[v].push_back({u, edgeIdx});\\n        }\\n        \\n        vector<double> probabilities(n, 0.0);\\n        probabilities[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> nodesToExplore;\\n        // Add the start node to the priority queue with probability 1.0\\n        nodesToExplore.push({1.0, start});\\n        \\n        while (!nodesToExplore.empty()) {\\n            auto [prob, u] = nodesToExplore.top();\\n            nodesToExplore.pop();\\n            \\n            // If we\\'ve reached the end node, return the probability\\n            if (u == end) \\n                return prob;\\n            // If we\\'ve already explored this node with a higher probability, skip it\\n            if (probabilities[u] > prob) \\n                continue;\\n                \\n            // Explore the neighbors of the current node\\n            for (auto [v, edgeIdx] : graph[u]) {\\n                double newProb = prob * succProb[edgeIdx];\\n                \\n                // Update the probability of the neighbor node if we\\'ve found a higher probability\\n                if (newProb > probabilities[v]) {\\n                    probabilities[v] = newProb;\\n                    \\n                    // Add the neighbor node to the priority queue with its new probability\\n                    nodesToExplore.push({newProb, v});\\n                }\\n            }\\n        }\\n        \\n        // If we\\'ve explored all nodes and haven\\'t reached the end node, return 0.0\\n        return 0.0;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n\n        // Build the graph using an adjacency list representation\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\n            graph[u].push_back({v, edgeIdx});\n            graph[v].push_back({u, edgeIdx});\n        }\n      \n        vector<double> probabilities;\n        probabilities[start] = 1.0;\n      \n        priority_queue<pair<double, int>> nodesToExplore;\n        nodesToExplore.push({1.0, start});\n      \n        while (!nodesToExplore.empty()) {\n            auto [prob, u] = nodesToExplore.top();\n            nodesToExplore.pop();\n        \n            if (u == end) \n                return prob;\n            if (probabilities[u] > prob) \n                continue;\n\n            // Explore the neighbors of the current node\n            for (auto [v, edgeIdx] : graph[u]) {\n                double newProb = prob * succProb[edgeIdx];\n\n                if (newProb > probabilities[v]) {\n                    probabilities[v] = newProb;\n                    nodesToExplore.push({newProb, v});\n                }\n            }\n        }\n      \n        return 0.0;\n    }\n};\n",
        "explanations": "\nThe bug is that the probabilities vector isn't initialized with a size of n, leading to undefined behavior.\n",
        "fixed_code": "\nfixed code\n",
        "fixing_exp": "\nAdded initialization of vector probabilities and fixed indices for accessing prob and u in the line 18.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 2: Char 1: error: unknown type name 'fixed'",
            "full_compile_error": "Line 2: Char 1: error: unknown type name 'fixed'\nfixed code\n^",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1325",
            "task_finish_time": 1701969290530,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114516517",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 1037: Char 9: runtime error: reference binding to null pointer of type 'double' (stl_vector.h)"
    },
    {
        "slug": "ugly-number-ii",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.",
        "examples": [
            "Input: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.",
            "Input: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
        ],
        "constrains": "1 <= n <= 1690",
        "release_time": 1690716711,
        "oracle_code": "class Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        vector<int>dp(n);\\n        dp[0]=1;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int two=dp[p1]*2;\\n            int three=dp[p2]*3;\\n            int five=dp[p3]*5;\\n            dp[i]=min(two,min(three,five));\\n            if(dp[i]==two)\\n            p1++;\\n            if(dp[i]==three)\\n            p2++;\\n            if(dp[i]==five)\\n            p3++;\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<=n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n];\n    }\n};\n",
        "explanations": "\nVector dp has n elements, but loop runs n+1 times, causing an out-of-bound error.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n+1);  // increase the size of dp to n+1\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)  // change i<=n to i<n\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n                p1++;\n            if(dp[i]==three)\n                p2++;\n            if(dp[i]==five)\n                p3++;\n        }\n        return dp[n-1];  // change dp[n] to dp[n-1]\n    }\n};\n",
        "fixing_exp": "\n1. The size of dp vector should be n+1 to store the nth ugly number.\n2. The loop should run from 1 to n-1 instead of 1 to n, to fill the dp vector properly.\n3. The last return statement should return dp[n-1] instead of dp[n] because the indexing of dp starts from 0.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 7964000,
            "question_id": "264",
            "elapsed_time": 18,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969320852,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 596,
            "total_testcases": 596,
            "runtime_percentile": 100,
            "status_memory": "8 MB",
            "memory_percentile": 77.21780000000003,
            "pretty_lang": "C++",
            "submission_id": "1114516864",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": "AddressSanitizer: heap-buffer-overflow on address 0x6040000000b8 at pc 0x0000003672c5 bp 0x7ffe49d69b30 sp 0x7ffe49d69b28"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 105",
        "release_time": 1673536160,
        "oracle_code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        undefinedObject.callMethod();\n        return c;\n    }\n}; \n",
        "explanations": "\n\"undefinedObject\" is not defined causing a runtime error when the callMethod() is invoked.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n}; \n",
        "fixing_exp": "\nThe undefinedObject.callMethod() statement was removed as it was calling an undefined method and was causing compilation error",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "PENDING"
        },
        "traceback_messages": null
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constrains": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters.",
        "release_time": 1688356386,
        "oracle_code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        char *undefinedObject;\n\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[undefinedObject[i]-'a']++;\n        }\n        \n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
        "explanations": "\nAdding values to non-existent object \"undefinedObject\" causes the program to go haywire.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first == -1){\n                    first=i;\n                }else if(second == -1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n        \n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};\n",
        "fixing_exp": "\nUndefined object `undefinedObject` was being accessed which caused the runtime error. I replaced it with the correct variable `s` which led to the fix.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "6 ms",
            "memory": 7212000,
            "question_id": "889",
            "elapsed_time": 61,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969382001,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 26.631000000000004,
            "status_memory": "7.2 MB",
            "memory_percentile": 82.7524,
            "pretty_lang": "C++",
            "submission_id": "1114517589",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 23: Char 18: runtime error: addition of unsigned offset to 0x7fffc7645340 overflowed to 0x7fffc7645220 (solution.cpp)"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constrains": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "release_time": 1662227882,
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb = undefined_object;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
        "explanations": "\nAccessing undefined_object instead of an actual vector object in the global scope causes a run-time error.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    vector<vector<int>> comb;\n    \n    int find(vector<vector<int>>& mat)\n    {\n        int c = 0;\n        for(int i = 0; i < mat.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat[0].size(); j++)\n            {\n                if(mat[i][j] == 1)\n                {\n                    flg = 1;\n                    break;\n                }\n            }\n            if(flg == 0)\n            {\n                c++;\n            }\n        }\n        return c;\n    }\n    \n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int> temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                {\n                    mat1[k][col_val] = 0;\n                }\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    \n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int> tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n        {\n            return;\n        }\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int> tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
        "fixing_exp": "\nThe code initializes the vector 'comb' as 'undefined_object', which is incorrect. 'comb' should be declared as an empty vector.\nThe code also needs to add missing curly braces for the nested for loops.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "51 ms",
            "memory": 30520000,
            "question_id": "2482",
            "elapsed_time": 66,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969411290,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 103,
            "total_testcases": 103,
            "runtime_percentile": 9.375,
            "status_memory": "30.5 MB",
            "memory_percentile": 12.5,
            "pretty_lang": "C++",
            "submission_id": "1114517938",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constrains": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
        "release_time": 1692446889,
        "oracle_code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        vector<int> id_new(id.size());\n        return id_new;\n    }\n};\n",
        "explanations": "\nThe bug is returning vector 'id_new' instread of 'id', which will always be an empty vector.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){   \n                restaurants[i][0] = -1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};\n",
        "fixing_exp": "\nRemoving the unnecessary creation of the id_new vector and returning the correct id vector.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "134 ms",
            "memory": 28140000,
            "question_id": "1455",
            "elapsed_time": 152,
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969441256,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 53,
            "total_testcases": 53,
            "runtime_percentile": 9.8271,
            "status_memory": "28.1 MB",
            "memory_percentile": 83.8151,
            "pretty_lang": "C++",
            "submission_id": "1114518326",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constrains": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105",
        "release_time": 1673020570,
        "oracle_code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\n'ans' potentially uninitialized if there is no even frequency. Results in undefined behavior.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        unordered_map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};\n",
        "fixing_exp": "\nThe map<int, int> freq should be replaced with unordered_map<int, int> as order is unimportant for this problem.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 45972000,
            "question_id": "2486",
            "elapsed_time": 110,
            "compare_result": "010111100000001000000110010001100111110000001101000000101010100110100101011001000000111010000000110111001011000010000000001000000101110100011010001100111100000101000010100000000000000110100001010010000110000101101101001",
            "code_output": "4",
            "std_output": "",
            "last_testcase": "[0,1,2,2,4,4,1]",
            "expected_output": "2",
            "task_finish_time": 1701969471679,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 78,
            "total_testcases": 219,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114518696",
            "input_formatted": "[0,1,2,2,4,4,1]",
            "input": "[0,1,2,2,4,4,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constrains": "1 <= n <= 104",
        "release_time": 1669088721,
        "oracle_code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum)\n    {\n        vector<int>& arr;\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i]));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(0, arr.size(), n);\n    }\n};\n",
        "explanations": "\nThe vector 'arr' is declared in 'helper' but not defined, causing an undefined behavior.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int dp[105][10005];\n    \n    int helper(int i, int n, int sum, vector<int>& arr)\n    {\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        int mini = INT_MAX;\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(i, n, sum - arr[i], arr));\n        }\n\n        mini = min(mini, helper(i + 1, n, sum, arr));\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(0, arr.size(), n, arr);\n    }\n};\n",
        "fixing_exp": "\nFixed the missing reference parameter and added arr as parameter for helper function.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "434 ms",
            "memory": 12300000,
            "question_id": "279",
            "elapsed_time": 450,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969501681,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 588,
            "total_testcases": 588,
            "runtime_percentile": 12.608099999999972,
            "status_memory": "12.3 MB",
            "memory_percentile": 17.721200000000003,
            "pretty_lang": "C++",
            "submission_id": "1114519077",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "largest-1-bordered-square",
        "description": "Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\r\nOutput: 9",
            "Input: grid = [[1,1,0,0]]\r\nOutput: 1"
        ],
        "constrains": "1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1",
        "release_time": 1689400545,
        "oracle_code": "class Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        int mx = 0;\\n\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]!=0){\\n                    \\n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\\n                    \\n                    int sz = min(dp[i][j].first, dp[i][j].second);\\n                    while(sz>mx){\\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\\n                        if(p>=sz)\\n                            mx = max(mx,sz);\\n                        sz--;\\n                    }\\n                }\\n            }\\n        }\\n            \\n        return mx*mx;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = undefined_object.size();    \n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};\n",
        "explanations": "\nUsing 'undefined_object' (which doesn't exist in this scope) results in a compile error.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};\n",
        "fixing_exp": "\nThe size of the grid was not properly obtained while initializing the variables 'r' and 'c'",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "15 ms",
            "memory": 12084000,
            "question_id": "1239",
            "elapsed_time": 28,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969531442,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 84,
            "total_testcases": 84,
            "runtime_percentile": 62.02550000000001,
            "status_memory": "12.1 MB",
            "memory_percentile": 50.00010000000002,
            "pretty_lang": "C++",
            "submission_id": "1114519413",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constrains": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109",
        "release_time": 1680016299,
        "oracle_code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        bool doesNotExist;\n        string temp = s + doesNotExist;\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (temp[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
        "explanations": "\nThe bug is an undefined boolean variable \"doesNotExist\" being used to concatenate the string.\n",
        "fixed_code": "\n// Fixed code\nclass Solution {\npublic:\n    bool queryString(string s, int n) {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1; i>=0; i--) {\n            int num = 0;\n            for(int j=1; j<=min(len-i,31); j++) { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0); // fixed s instead of temp\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};\n",
        "fixing_exp": "\nThe code was trying to access the non-existent variable 'doesNotExist' instead of using the 's' string. Fixed it by replacing 'temp' with 's'.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 6808000,
            "question_id": "1065",
            "elapsed_time": 13,
            "compare_result": "1111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969561666,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 28,
            "total_testcases": 28,
            "runtime_percentile": 37.2385,
            "status_memory": "6.8 MB",
            "memory_percentile": 43.93300000000001,
            "pretty_lang": "C++",
            "submission_id": "1114519773",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "brace-expansion-ii",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let\u00a0R(expr)\u00a0denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\n\n\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n\t\nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n\n\n\nFormally, the three rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
            "Input: expression = \"{a,b}{c,{d,e}}\"\nOutput: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written only once in the final answer."
        ],
        "constrains": "1 <= expression.length <= 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe given\u00a0expression\u00a0represents a set of words based on the grammar given in the description.",
        "release_time": 1677655008,
        "oracle_code": "class Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack to keep track of previous two lists\\n<!-- Describe your approach to solving the problem. -->\\n<!-- \\n# Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> multiply(vector<string>& a, vector<string>& b){\\n        if(a.empty()) return b;\\n        if(b.empty()) return a;\\n        vector<string> ans;\\n        for(auto&i:a){\\n            for(auto&j:b) ans.push_back(i+j);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> braceExpansionII(string expression) {\\n        vector<string>  res, curr;\\n        stack<vector<string>> st;\\n        for(auto&x:expression){\\n            if(x >= \\'a\\' and x <= \\'z\\'){\\n                if(curr.size()) for(auto&i:curr) i += x;\\n                else curr.push_back(string(1, x));\\n            }\\n            else if(x == \\'{\\'){\\n                st.push(res); st.push(curr);\\n                res.clear(), curr.clear();\\n            }\\n            else if(x == \\'}\\'){\\n                vector<string> preCurr = st.top(); st.pop();\\n                vector<string> preRes = st.top(); st.pop();\\n                for(auto&i:curr) res.push_back(i);\\n                curr = multiply(preCurr, res);\\n                res = preRes;\\n            }\\n            else if(x == \\',\\'){\\n                for(auto&i:curr) res.push_back(i);\\n                curr.clear();\\n            }\\n        }\\n        for(auto&i:curr) res.push_back(i);\\n        sort(res.begin(), res.end());\\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr;\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};\n",
        "explanations": "\n'preCurr' has been declared but is never defined before it's used in the 'multiply()' function.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) preCurr.push_back(i); \n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};\n",
        "fixing_exp": "\n1. The code does not correctly handle the case when there is a nested group within another group.\n2. Fixed the code by storing both the previous result and current group before starting a new group.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 8216000,
            "question_id": "1188",
            "elapsed_time": 14,
            "compare_result": "0000111001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "[\"bac\",\"edc\"]",
            "std_output": "",
            "last_testcase": "\"{a,b}{c,{d,e}}\"",
            "expected_output": "[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "task_finish_time": 1701969592095,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 115,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114520144",
            "input_formatted": "\"{a,b}{c,{d,e}}\"",
            "input": "\"{a,b}{c,{d,e}}\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constrains": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters.",
        "release_time": 1675105253,
        "oracle_code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        delete &count;\n        return z;\n    }\n};\n",
        "explanations": "\nCalling delete on an object that was not allocated dynamically using new, causes undefined behavior.\n",
        "fixed_code": "p\nclass Solution {\npublic:\n    map<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                auto it = upper_bound(count[x[j]].begin(), count[x[j]].end(), p);\n                if(it == count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=it - count[x[j]].begin();//updating search index\n            }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};\n\n```\n<exp>\nThere was a use of an invalid iterator in upper_bound function causing segmentation fault. I fixed the code by storing the iterator in a variable before usage",
        "fixing_exp": "\nThere was a use of an invalid iterator in upper_bound function causing segmentation fault. I fixed the code by storing the iterator in a variable before usage",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 1: Char 1: error: unknown type name 'p'",
            "full_compile_error": "Line 1: Char 1: error: unknown type name 'p'\np\n^",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "808",
            "task_finish_time": 1701969621435,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114520488",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "AddressSanitizer: attempting free on address which was not malloc()-ed: 0x7ffd92be4a00 in thread T0"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constrains": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000",
        "release_time": 1667707492,
        "oracle_code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
        "explanations": "\nThe bug is that there are two objects with the same name 'ans'.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};\n",
        "fixing_exp": "\nDeleted the duplicate code block that creates an empty vector with the same name 'ans' again.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 8948000,
            "question_id": "2551",
            "elapsed_time": 17,
            "compare_result": "000000000000000000000000000000000100",
            "code_output": "[1,4,2]",
            "std_output": "",
            "last_testcase": "[1,2,2,1,1,0]",
            "expected_output": "[1,4,2,0,0,0]",
            "task_finish_time": 1701969651909,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1,
            "total_testcases": 36,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114520868",
            "input_formatted": "[1,2,2,1,1,0]",
            "input": "[1,2,2,1,1,0]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
        "examples": [
            "Input: left = 5, right = 7\nOutput: 4",
            "Input: left = 0, right = 0\nOutput: 0",
            "Input: left = 1, right = 2147483647\nOutput: 0"
        ],
        "constrains": "0 <= left <= right <= 231 - 1",
        "release_time": 1689346823,
        "oracle_code": "class Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int solve(int left , int right){\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n",
        "explanations": "\nThe `solve` function does not handle the case when `left` is 0, causing a runtime error.\n",
        "fixed_code": "\n#include <cmath> // Add this header for using the log2() function\n\nclass Solution {\npublic:\n    int solve(int left , int right){\n        int bit1 = log2(left) + 1; // Add 1 to get the correct number of bits\n        int bit2 = log2(right) + 1; // Add 1 to get the correct number of bits\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) - 1 & solve((left^(1<<bit1)) , (right^(1<<bit1))); // Use bitwise AND operator here\n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};\n",
        "fixing_exp": "\nThe code was throwing a runtime error because the log2() function was returning -inf for the value 0. It was fixed by adding 1 to the result of log2() to get the correct number of bits. Also, the bitwise OR operator should be replaced with the bitwise AND operator to calculate the final result.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "cpp",
            "run_success": false,
            "runtime_error": "Line 10: Char 26: runtime error: signed integer overflow: -2147483648 - 1 cannot be represented in type 'int' (solution.cpp)",
            "full_runtime_error": "Line 10: Char 26: runtime error: signed integer overflow: -2147483648 - 1 cannot be represented in type 'int' (solution.cpp)\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp:19:26",
            "status_runtime": "N/A",
            "memory": 7620000,
            "question_id": "201",
            "elapsed_time": 13,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "5\n7",
            "expected_output": "4",
            "task_finish_time": 1701969681923,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 8269,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114521244",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 5: Char 20: runtime error: -inf is outside the range of representable values of type 'int' (solution.cpp)"
    },
    {
        "slug": "sort-list",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order.",
        "examples": [
            "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
            "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
            "Input: head = []\nOutput: []"
        ],
        "constrains": "The number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105",
        "release_time": 1692157711,
        "oracle_code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= head;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int>vec1;\\n    ListNode*temp= head;\\n    while(temp!=NULL){\\nvec1.push_back(temp->val);\\ntemp= temp->next;\\n    }\\n    sort(vec1.begin(),vec1.end());\\n    ListNode*curr= head;\\n   for(int i=0;i<vec1.size();i++){\\n       curr->val=vec1[i];\\n       curr= curr->next;\\n   }\\n   return head;\\n    }\\n    \\n\\n};\\n\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= nullptr;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};\n",
        "explanations": "\nThe \"temp\" pointer is null, but the program tries to access its value. \n",
        "fixed_code": "\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n        ListNode*temp= head;  //<-- Changed from nullptr to head\n        while(temp!=NULL){\n            vec1.push_back(temp->val);\n            temp= temp->next;\n        }\n        sort(vec1.begin(),vec1.end());\n        ListNode*curr= head;\n        for(int i=0;i<vec1.size();i++){\n            curr->val=vec1[i];\n            curr= curr->next;\n        }\n        return head;\n    }  \n};\n",
        "fixing_exp": "\nThe code was not traversing the linked list properly. The loop was making it traverse until temp is not NULL.\nHence I have changed the initialization from `nullptr` to `head` in `temp`.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "117 ms",
            "memory": 53568000,
            "question_id": "148",
            "elapsed_time": 158,
            "compare_result": "111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969712617,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 30,
            "total_testcases": 30,
            "runtime_percentile": 83.27980000000001,
            "status_memory": "53.6 MB",
            "memory_percentile": 71.37679999999997,
            "pretty_lang": "C++",
            "submission_id": "1114521631",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "determine-color-of-a-chessboard-square",
        "description": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\nReturn true if the square is white, and false if the square is black.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.",
        "examples": [
            "Input: coordinates = \"a1\"\nOutput: false\nExplanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false.",
            "Input: coordinates = \"h3\"\nOutput: true\nExplanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true.",
            "Input: coordinates = \"c7\"\nOutput: false"
        ],
        "constrains": "coordinates.length == 2\n'a' <= coordinates[0] <= 'h'\n'1' <= coordinates[1] <= '8'",
        "release_time": 1687862385,
        "oracle_code": "class Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\n        else return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        string undefinedObject;\n        if(undefinedObject[0]%2==0 && coordinates[1]%2!=0) return true;\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\n        else return false;\n    }\n};\n",
        "explanations": "\nAccessing an index of an undefined string object can cause unexpected behaviors or crashes.\n",
        "fixed_code": "\nbool squareIsWhite(string coordinates) {\n        if((coordinates[0]-'a')%2==0 && (coordinates[1]-'1')%2!=0) return true;\n        else if((coordinates[0]-'a')%2!=0 && (coordinates[1]-'1')%2==0) return true;\n        else return false;\n    }\n",
        "fixing_exp": "\nThe bug is that the program is comparing the ASCII values of the characters instead of their numerical values. The fix is to subtract 'a' and '1' from the characters to get their numerical values.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 14: Char 18: error: use of undeclared identifier 'Solution'",
            "full_compile_error": "Line 14: Char 18: error: use of undeclared identifier 'Solution'\n      bool ret = Solution().squareIsWhite(param_1); return ret;\n                 ^\n1 error generated.",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1920",
            "task_finish_time": 1701969741921,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114522003",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1687118835,
        "oracle_code": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        for (auto i: derived) xoor ^= i;\n        return !xoor;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        vector<int>& undefined;\n        for (auto i: derived) xoor ^= i;\n        xoor ^= undefined[0];\n        return !xoor;\n    }\n};\n",
        "explanations": "\nThe bug is in `vector<int>& undefined;` the vector undefined is declared but never defined.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        vector<int> undefined; // declare undefined vector\n        for (auto i: derived) xoor ^= i;\n        if(!undefined.empty()) { //check if undefined vector is empty before accessing its element\n            xoor ^= undefined[0];\n        }\n        return !xoor;\n    }\n};\n",
        "fixing_exp": "\n1. Declared the undefined vector before using it.\n2. Added a check to make sure the undefined vector is not empty before accessing its element.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "206 ms",
            "memory": 259936000,
            "question_id": "2792",
            "elapsed_time": 310,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969773135,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1425,
            "total_testcases": 1425,
            "runtime_percentile": 92.28589999999997,
            "status_memory": "259.9 MB",
            "memory_percentile": 55.1429,
            "pretty_lang": "C++",
            "submission_id": "1114522366",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "merge-two-binary-trees",
        "description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.",
        "examples": [
            "Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]",
            "Input: root1 = [1], root2 = [1,2]\nOutput: [2,2]"
        ],
        "constrains": "The number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104",
        "release_time": 1673784101,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
        "level": "easy",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? new TreeNode(t1->val) : new TreeNode(t2->val);\n        }\n    }\n};\n",
        "explanations": "\nWhen t1 or t2 is null, the function creates a new unattached TreeNode, causing memory leak.\n",
        "fixed_code": "\nTreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n    if ( t1 && t2 ) {\n        TreeNode * root = new TreeNode(t1->val + t2->val);\n        root->left = mergeTrees(t1->left, t2->left);\n        root->right = mergeTrees(t1->right, t2->right);\n        return root;\n    } else {\n        return t1 ? new TreeNode(t1->val, t1->left, t1->right) : new TreeNode(t2->val, t2->left, t2->right);\n    }\n}\n",
        "fixing_exp": "\nModifed t2->val, t2->left, t2->right as t1->val, t1->left, t1->right in line 22.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 19: Char 23: error: use of undeclared identifier 'Solution'",
            "full_compile_error": "Line 19: Char 23: error: use of undeclared identifier 'Solution'\n      TreeNode* ret = Solution().mergeTrees(param_1, param_2); return ret;\n                      ^\n1 error generated.",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "617",
            "task_finish_time": 1701969802158,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114522705",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 22: Char 66: runtime error: member access within null pointer of type 'TreeNode' (solution.cpp)"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constrains": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1688035608,
        "oracle_code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n        \n        vector<string> rank;\n\n        for (int i=0; i<n; i++) \n            rank[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return rank;\n    }\n};\n",
        "explanations": "\nReturning 'rank' vector, although it was not resized, which results in accessing undefined objects.\n",
        "fixed_code": "\nChange vector<string> rank; to vector<string> rank(n);\n",
        "fixing_exp": "\nThe variable \"rank\" is declared as an empty vector, so trying to access its elements using indices results in a runtime error as the vector is empty.\nBy changing it to vector<string> rank(n), we ensure that the vector has enough space to store n elements.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 2: Char 1: error: unknown type name 'Change'",
            "full_compile_error": "Line 2: Char 1: error: unknown type name 'Change'\nChange vector<string> rank; to vector<string> rank(n);\n^",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "506",
            "task_finish_time": 1701969832664,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114523043",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 1037: Char 9: runtime error: reference binding to null pointer of type 'std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>' (stl_vector.h)"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "description": "You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.",
        "examples": [
            "Input: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.",
            "Input: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child."
        ],
        "constrains": "The number of nodes in the tree is n.\n1 <= n <= 100\n0 <= Node.val <= n\nThe sum of all Node.val is n.",
        "release_time": 1686750328,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\n    private:\n    int cnt=0;\n    int func(TreeNode *root) {\n        if(!root) return 0;\n\n        int l = func(root->left);\n        int r = func(root->right);\n\n        int temp = root->val -1 +l+r;\n        cnt += abs(temp);\n\n        return temp;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        func(root);\n        return cnt;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \\n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \\n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\\n    private:\\n    int cnt=0;\\n    int func(TreeNode *root) {\\n        if(!root) return 0;\\n\\n        int l = func(root->left);\\n        int r = func(root->right);\\n\\n        int temp = root->val -1 +l+r;\\n        cnt += abs(temp);\\n\\n        return temp;\\n    }\\npublic:\\n    int distributeCoins(TreeNode* root) {\\n        func(root);\\n        return cnt;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    int cnt=0;\n    TreeNode* newNode;\n\n    int func(TreeNode *root) {\n        if(!root) return 0;\n\n        int l = func(root->left);\n        int r = func(root->right);\n\n        int temp = newNode->val -1 +l+r; \n        cnt += abs(temp);\n\n        return temp;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        func(root);\n        return cnt;\n    }\n};\n",
        "explanations": "\nThe bug is an undefined objects error. 'newNode' is declared but not initialized. \n",
        "fixed_code": "\nint temp = root->val -1 +l+r; \n",
        "fixing_exp": "\nAccess the 'val' member variable of 'root' instead of 'newNode'.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "cpp",
            "run_success": false,
            "compile_error": "Line 2: Char 12: error: use of undeclared identifier 'root'",
            "full_compile_error": "Line 2: Char 12: error: use of undeclared identifier 'root'\nint temp = root->val -1 +l+r;\n           ^",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1021",
            "task_finish_time": 1701969862394,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114523406",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 24: Char 29: runtime error: member access within null pointer of type 'TreeNode' (solution.cpp)"
    }
]