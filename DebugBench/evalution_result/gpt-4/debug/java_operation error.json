[
    {
        "slug": "relative-sort-array",
        "description": "Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1.\nSort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that do not appear in arr2 should be placed at the end of arr1 in ascending order.",
        "examples": [
            "Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]\nOutput: [2,2,2,1,4,3,3,9,6,7,19]",
            "Input: arr1 = [28,6,22,8,44,17], arr2 = [22,28,8,6]\nOutput: [22,28,8,6,17,44]"
        ],
        "constrains": "1 <= arr1.length, arr2.length <= 1000\n0 <= arr1[i], arr2[i] <= 1000\nAll the elements of arr2 are distinct.\nEach\u00a0arr2[i] is in arr1.",
        "release_time": 1691725804,
        "oracle_code": "import java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr1);\\n        int[] ans = new int[arr1.length];\\n        int start = 0;\\n        int end = arr1.length - 1;\\n        int index = 0;\\n\\n        for (int i = 0; i < arr2.length; i++) {\\n            int target = arr2[i];\\n            start = 0;\\n            end = arr1.length - 1;\\n\\n            while (end >= start) {\\n                int mid = start + (end - start) / 2;\\n                if (arr1[mid] == target) {\\n                    for (int j = start; j <= end; j++) {\\n                        if (arr1[j] == target) {\\n                            ans[index++] = arr1[j];\\n                        }\\n                    }\\n                    break;\\n                }\\n                if (arr1[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (index == arr1.length) {\\n                break;\\n            }\\n            boolean found = false;\\n            for (int num : arr2) {\\n                if (arr1[i] == num) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                ans[index++] = arr1[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nimport java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                            arr1[j] = -1;\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        Arrays.sort(arr1);\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found && arr1[i] != -1) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug I added was modifying the array in the sorting step without considering its impact on forthcoming operations, causing incorrect output.\n",
        "fixed_code": "\nimport java.util.*;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int[] ans = new int[arr1.length];\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            for (int j = 0; j < arr1.length; j++) {\n                if (arr1[j] == arr2[i]) {\n                    ans[index++] = arr1[j];\n                }\n            }\n        }\n\n        List < Integer > list = new ArrayList < > ();\n        for (int i = 0; i < arr1.length; i++) {\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                list.add(arr1[i]);\n            }\n        }\n\n        Collections.sort(list);\n\n        for (Integer i: list) {\n            ans[index++] = i;\n        }\n\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nSimplified logic to fill the resultant array by iterating through the second array and filling for each occurrence in the first array.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 40848000,
            "display_runtime": "4",
            "question_id": "1217",
            "elapsed_time": 136,
            "compare_result": "11111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647448415,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 17,
            "total_testcases": 17,
            "runtime_percentile": 23.3517,
            "status_memory": "40.8 MB",
            "memory_percentile": 84.4321,
            "pretty_lang": "Java",
            "submission_id": "1096151655",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-product-of-splitted-binary-tree",
        "description": "Given the root of a binary tree, split the binary tree into two subtrees by removing one edge such that the product of the sums of the subtrees is maximized.\nReturn the maximum product of the sums of the two subtrees. Since the answer may be too large, return it modulo 109 + 7.\nNote that you need to maximize the answer before taking the mod and not after taking it.",
        "examples": [
            "Input: root = [1,2,3,4,5,6]\nOutput: 110\nExplanation: Remove the red edge and get 2 binary trees with sum 11 and 10. Their product is 110 (11*10)",
            "Input: root = [1,null,2,3,4,null,null,5,6]\nOutput: 90\nExplanation: Remove the red edge and get 2 binary trees with sum 15 and 6.Their product is 90 (15*6)"
        ],
        "constrains": "The number of nodes in the tree is in the range [2, 5 * 104].\n1 <= Node.val <= 104",
        "release_time": 1690454881,
        "oracle_code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if node:\n                dfs(node.left)\n                dfs(node.right)\n                if node.left and node.right:\n                    node.val+=node.left.val+node.right.val\n                elif node.left and not node.right:\n                    node.val+=node.left.val\n                elif node.right:\n                    node.val+=node.right.val\n        dfs(root)\n\n        ans,val=0,root.val\n        def f(node):\n            nonlocal ans\n            if node:\n                ans=max(ans,(val-node.val)*node.val)\n                f(node.left)\n                f(node.right)\n        f(root)\n        return ans%1000000007",
        "content": "> Python3 Code\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            if node:\\n                dfs(node.left)\\n                dfs(node.right)\\n                if node.left and node.right:\\n                    node.val+=node.left.val+node.right.val\\n                elif node.left and not node.right:\\n                    node.val+=node.left.val\\n                elif node.right:\\n                    node.val+=node.right.val\\n        dfs(root)\\n\\n        ans,val=0,root.val\\n        def f(node):\\n            nonlocal ans\\n            if node:\\n                ans=max(ans,(val-node.val)*node.val)\\n                f(node.left)\\n                f(node.right)\\n        f(root)\\n        return ans%1000000007\\n```",
        "level": "medium",
        "buggy_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if node:\n                dfs(node.left)\n                dfs(node.right)\n                if node.left and node.right:\n                    node.val += node.left.val + node.right.val\n                elif node.left and not node.right:\n                    node.val += node.left.val\n                elif node.right:\n                    node.val += node.right.val\n                elif node.val:\n                    node.val += node.val\n        dfs(root)\n\n        ans, val = 0, root.val\n        def f(node):\n            nonlocal ans\n            if node:\n                ans = max(ans, (val - node.val) * node.val)\n                f(node.left)\n                f(node.right)\n        f(root)\n        return ans % 1000000007\n",
        "explanations": "\nThe logic error is with the last elif where a node's value is added to itself. \n",
        "fixed_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if node:\n                left = dfs(node.left) if node.left else 0\n                right = dfs(node.right) if node.right else 0\n                subtree_sum.append(left + right + node.val)\n                return left + right + node.val\n            return 0\n\n        subtree_sum = []\n        total = dfs(root)\n        return max(i * (total - i) for i in subtree_sum) % (10**9 + 7)\n",
        "fixing_exp": "\nThe error is due to dfs function and logic for computing node values. Revised logic by storing subtree sum in the list.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "java",
            "run_success": false,
            "compile_error": "Line 2: error: illegal character: '#' [in TreeNode.java]",
            "full_compile_error": "Line 2: error: illegal character: '#' [in TreeNode.java]\n# Definition for a binary tree node.\n^\nLine 2: error: class, interface, enum, or record expected [in TreeNode.java]\n# Definition for a binary tree node.\n             ^\nLine 3: error: illegal character: '#' [in TreeNode.java]\n# class TreeNode:\n^\nLine 3: error: '{' expected [in TreeNode.java]\n# class TreeNode:\n                ^\nLine 4: error: illegal character: '#' [in TreeNode.java]\n#     def __init__(self, val=0, left=None, right=None):\n^\nLine 5: error: illegal character: '#' [in TreeNode.java]\n#         self.val = val\n^\nLine 6: error: illegal character: '#' [in TreeNode.java]\n#         self.left = left\n^\nLine 7: error: illegal character: '#' [in TreeNode.java]\n#         self.right = right\n^\nLine 8: error: '{' expected [in TreeNode.java]\nclass Solution:\n              ^\nLine 9: error: class, interface, enum, or record expected [in TreeNode.java]\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n                                                      ^\n10 errors",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1465",
            "task_finish_time": 1699647463347,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096151769",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100",
        "release_time": 1686193447,
        "oracle_code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/.",
        "level": "easy",
        "buggy_code": "\nclass Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS\n        return negatives\n",
        "explanations": "\nThe bug is in the line \"negatives += COLS\", should be \"negatives += COLS - col\".\n",
        "fixed_code": "\nclass Solution {\n    public int countNegatives(int[][] grid) {\n        int ROWS, COLS;\n        ROWS = grid.length;\n        COLS = grid[0].length;\n        int negatives = 0;\n        int col = 0;\n        \n        for (int row = ROWS - 1; row >= 0; row--) {\n            while (col < COLS && grid[row][col] >= 0) {\n                col += 1;\n            }\n            negatives += COLS - col;\n        }\n        return negatives;\n    }\n}\n",
        "fixing_exp": "\nPython code was converted to Java and corrected calculation of negative numbers count.  \n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 43876000,
            "display_runtime": "0",
            "question_id": "1476",
            "elapsed_time": 121,
            "compare_result": "11111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647483133,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 44,
            "total_testcases": 44,
            "runtime_percentile": 100,
            "status_memory": "43.9 MB",
            "memory_percentile": 45.1879,
            "pretty_lang": "Java",
            "submission_id": "1096151909",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "rearrange-characters-to-make-target-string",
        "description": "You are given two 0-indexed strings s and target. You can take some letters from s and rearrange them to form new strings.\nReturn the maximum number of copies of target that can be formed by taking letters from s and rearranging them.",
        "examples": [
            "Input: s = \"ilovecodingonleetcode\", target = \"code\"\nOutput: 2\nExplanation:\nFor the first copy of \"code\", take the letters at indices 4, 5, 6, and 7.\nFor the second copy of \"code\", take the letters at indices 17, 18, 19, and 20.\nThe strings that are formed are \"ecod\" and \"code\" which can both be rearranged into \"code\".\nWe can make at most two copies of \"code\", so we return 2.",
            "Input: s = \"abcba\", target = \"abc\"\nOutput: 1\nExplanation:\nWe can make one copy of \"abc\" by taking the letters at indices 0, 1, and 2.\nWe can make at most one copy of \"abc\", so we return 1.\nNote that while there is an extra 'a' and 'b' at indices 3 and 4, we cannot reuse the letter 'c' at index 2, so we cannot make a second copy of \"abc\".",
            "Input: s = \"abbaccaddaeea\", target = \"aaaaa\"\nOutput: 1\nExplanation:\nWe can make one copy of \"aaaaa\" by taking the letters at indices 0, 3, 6, 9, and 12.\nWe can make at most one copy of \"aaaaa\", so we return 1."
        ],
        "constrains": "1 <= s.length <= 100\n1 <= target.length <= 10\ns and target consist of lowercase English letters.",
        "release_time": 1673614634,
        "oracle_code": "class Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = 100;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt1[s.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0; i < target.length(); ++i) {\\n            ++cnt2[target.charAt(i) - \\'a\\'];\\n        }\\n        int ans = 100;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt2[i] > 0) {\\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = 100;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i]);\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nThe logic error occurs on the line where \"Math.min(ans, cnt1[i])\" doesn't divide by cnt2[i].\n",
        "fixed_code": "\nclass Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\n            }\n        }\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}\n",
        "fixing_exp": "\nThe initial value of \"ans\" was not set to maximum integer value, and there needs to be an error result. Also, the characters in \"cnt1\" array should be divided by \"cnt2\".\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 40376000,
            "display_runtime": "0",
            "question_id": "2372",
            "elapsed_time": 127,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647498213,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 115,
            "total_testcases": 115,
            "runtime_percentile": 100,
            "status_memory": "40.4 MB",
            "memory_percentile": 68.8104,
            "pretty_lang": "Java",
            "submission_id": "1096152026",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "pass-the-pillow",
        "description": "There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.\n\nGiven the two positive integers n and time, return the index of the person holding the pillow after time seconds.",
        "examples": [
            "Input: n = 4, time = 5\nOutput: 2\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.",
            "Input: n = 3, time = 2\nOutput: 3\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person."
        ],
        "constrains": "2 <= n <= 1000\n1 <= time <= 1000",
        "release_time": 1680694428,
        "oracle_code": "class Solution {\n    public int passThePillow(int n, int time) {\n        int num=(time/(n-1));\n        if(n>time){\n            return time+1;\n        }\n        if(num%2==1){\n            return n-((time%(n-1)));\n        }\n            \n        return (time%(n-1))+1;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int num=(time/(n-1));\\n        if(n>time){\\n            return time+1;\\n        }\\n        if(num%2==1){\\n            return n-((time%(n-1)));\\n        }\\n            \\n        return (time%(n-1))+1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int passThePillow(int n, int time) {\n        int num=(time/(n-1));\n        if(n>time){\n            return time;\n        }\n        if(num%2==1){\n            return n-((time%(n-1)));\n        }\n            \n        return (time%(n-1))+1;\n    }\n}\n",
        "explanations": "\nChanged return time+1 to return time, mistakenly not increasing count by 1 in base case.\n",
        "fixed_code": "\nclass Solution {\n    public int passThePillow(int n, int time) {\n        int num=(time%(n-1));\n        if(n>time){\n            return time;\n        }\n        if(num%2==1){\n            return n-((time%(n-1))+1);\n        }\n            \n        return (time%(n-1))+1;\n    }\n}\n",
        "fixing_exp": "\nThe calculation of 'num' is modified to use modulo operation and an addition in condition of num%2==1. \n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 39056000,
            "display_runtime": "0",
            "question_id": "2645",
            "elapsed_time": 98,
            "compare_result": "00000000100000000010011000001100000000000010110100001010000100010001",
            "code_output": "3",
            "std_output": "",
            "last_testcase": "4\n5",
            "expected_output": "2",
            "task_finish_time": 1699647513461,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 15,
            "total_testcases": 68,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096152132",
            "input_formatted": "4, 5",
            "input": "4\n5",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constrains": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.",
        "release_time": 1692196406,
        "oracle_code": "import java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger A=new BigInteger(a,2);\n        BigInteger B=new BigInteger(b,2);\n        BigInteger c=A.add(B);\n        return c.toString(2);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a4479753-912f-41ab-abdb-8c757f98bd03_1692196384.1712396.png)\\n\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger A=new BigInteger(a,2);\\n        BigInteger B=new BigInteger(b,2);\\n        BigInteger c=A.add(B);\\n        return c.toString(2);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nimport java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger A=new BigInteger(a,2);\n        BigInteger B=new BigInteger(b,2);\n        BigInteger c=A.add(B);\n        return c.toString(10);\n    }\n}\n",
        "explanations": "\nThe resulting sum is returned as a decimal number instead of a binary one.\n",
        "fixed_code": "\nimport java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger A=new BigInteger(a,2);\n        BigInteger B=new BigInteger(b,2);\n        BigInteger c=A.add(B);\n        return c.toString(2);\n    }\n}\n",
        "fixing_exp": "\nThe problem relies on the base of the number: it should be binary (base 2) instead of decimal (base 10).\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "6 ms",
            "memory": 41696000,
            "display_runtime": "6",
            "question_id": "67",
            "elapsed_time": 146,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647528339,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 296,
            "total_testcases": 296,
            "runtime_percentile": 17.670499999999997,
            "status_memory": "41.7 MB",
            "memory_percentile": 27.266399999999965,
            "pretty_lang": "Java",
            "submission_id": "1096152242",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "split-array-into-consecutive-subsequences",
        "description": "You are given an integer array nums that is sorted in non-decreasing order.\nDetermine if it is possible to split nums into one or more subsequences such that both of the following conditions are true:\n\nEach subsequence is a consecutive increasing sequence (i.e. each integer is exactly one more than the previous integer).\nAll subsequences have a length of 3 or more.\n\nReturn true if you can split nums according to the above conditions, or false otherwise.\nA subsequence of an array is a new array that is formed from the original array by deleting some (can be none) of the elements without disturbing the relative positions of the remaining elements. (i.e., [1,3,5] is a subsequence of [1,2,3,4,5] while [1,3,2] is not).",
        "examples": [
            "Input: nums = [1,2,3,3,4,5]\nOutput: true\nExplanation: nums can be split into the following subsequences:\n[1,2,3,3,4,5] --> 1, 2, 3\n[1,2,3,3,4,5] --> 3, 4, 5",
            "Input: nums = [1,2,3,3,4,4,5,5]\nOutput: true\nExplanation: nums can be split into the following subsequences:\n[1,2,3,3,4,4,5,5] --> 1, 2, 3, 4, 5\n[1,2,3,3,4,4,5,5] --> 3, 4, 5",
            "Input: nums = [1,2,3,4,4,5]\nOutput: false\nExplanation: It is impossible to split nums into consecutive increasing subsequences of length 3 or more."
        ],
        "constrains": "1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\nnums is sorted in non-decreasing order.",
        "release_time": 1599999408,
        "oracle_code": "// This is a greedy approach. The whole idea is to first look for an existing group\n// to join for the current num. If no, then create a new group. \n// Here a group means group of 3 or more numbers as mentioned in question description. \n\n//Well, If u didn't understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\n\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        // This hashmap tells us about whether a number in num is available for a job or not\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\n        \n        // This hashmap tells a number (say x), if there is a job vacancy for them\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\n        \n        // We store the count of every num in nums into avaibilityMap. Basically, a number's count is the avaibility of it.\n        for(int i : nums){\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\n        }\n        \n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\n        for(int i=0;i<nums.length;i++){\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\n            if(avaibilityMap.get(nums[i])<=0){\n                continue;\n            }\n            \n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\n            else if(wantMap.getOrDefault(nums[i],0)>0){\n                // Yes, someone is looking, so we decrease the avaibility count of that number\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                \n                // we also decrease its count from the job vacancy space / wantMap\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\n                \n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\n            }\n            \n            // Ooh, we are here means nums[i] was not able to find a job.\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\n                \n                // Yay! both 2 friends are available. Let's start a company.\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \n                // avaibilityMap\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\n                \n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\n            }\n            \n            // Bad luck case, nums[i] not able to start his/her company, so just return false\n            else{\n                return false;\n            }\n        }\n        \n        // All good till here so we return true\n        return true;\n    }\n}",
        "content": "**Consider this hypothetical story to better understand this question : [After reading this you will understand the code like a breeze. I hope you enjoy the story!]**\\n\\n1. Consider the numbers in the nums array are actual persons that are looking for a job. If they are available, they try to find a job. If no one wants them they go on to start their own company. But, here is the twist, a new company can be started only if it can have atleast 3 persons available. ( Are you thinking why 3? => Read the question description again.)\\n\\n2. The most important thing to note here is that each person in num, first tries to look for a job and if he/she does not gets success, he/she starts a company with 3 consecutive members. [as we want to find subsequences with consecutive numbers of length atleast 3. Think a subsequence as a company for now]\\n\\n3. So, let\\'s come to our first scenario - A person `(let\\'s say x)` looks for a job and finds it. YAY!! So, this person joins an already existing company and then he/she creates a vacancy for another person `x+1` in the job search section, so that another one like him/her do not have to face any struggle like he/she faced. He/She is a good guy/girl. No?\\n\\n4. Now, let\\'s come to our second possibility of our story. The guy/girl was not able to find a job :( \\nBUT, he/she `(let\\'s say x)` was very ambitious. So he/she decides- \\'Let\\'s build a company with me (that is x), x+1 and x+2\\'. So he/she checks with (x+1) and (x+2), if they are available to build a company as it requires 3 persons to start a company. \\n\\nHere comes two scenario:\\n\\na. x finds both the potential teammates/partners, `(x+1)` & `(x+2)` to be available so, they go on to start a new company and then after finding their own company, as a goodwill they create a new job vacancy looking for `(x+3)` so that `(x+3)` do not face any struggle they faced. People are good, believe me :) \\n\\nb. x was just out of luck, he/she was able to find their teammates i.e. (x+1) & (x+2). In this case have hope and just return false to quickly complete the program execution (BACK TO REALITY :p )\\n\\n\\n**Here is the code [If you haven\\'t read the story above, please read it to understand the solution] :**\\n\\n```\\n// This is a greedy approach. The whole idea is to first look for an existing group\\n// to join for the current num. If no, then create a new group. \\n// Here a group means group of 3 or more numbers as mentioned in question description. \\n\\n//Well, If u didn\\'t understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // This hashmap tells us about whether a number in num is available for a job or not\\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\\n        \\n        // This hashmap tells a number (say x), if there is a job vacancy for them\\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\\n        \\n        // We store the count of every num in nums into avaibilityMap. Basically, a number\\'s count is the avaibility of it.\\n        for(int i : nums){\\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\\n        for(int i=0;i<nums.length;i++){\\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\\n            if(avaibilityMap.get(nums[i])<=0){\\n                continue;\\n            }\\n            \\n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\\n            else if(wantMap.getOrDefault(nums[i],0)>0){\\n                // Yes, someone is looking, so we decrease the avaibility count of that number\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                \\n                // we also decrease its count from the job vacancy space / wantMap\\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\\n                \\n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\\n            }\\n            \\n            // Ooh, we are here means nums[i] was not able to find a job.\\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\\n                \\n                // Yay! both 2 friends are available. Let\\'s start a company.\\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \\n                // avaibilityMap\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\\n                \\n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\\n            }\\n            \\n            // Bad luck case, nums[i] not able to start his/her company, so just return false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        // All good till here so we return true\\n        return true;\\n    }\\n}\\n```\\n\\n\\n***Again to reiterate the logic :\\nThe logic is to just apply a greedy approach and try to find a group of 3 consecutive numbers first and then for other numbers try to check if existing groups can be used or it is neccessary to create a new group.***\\n\\n**Hope you enjoyed the story and if you liked it please upvote.Thanks!**",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\n        for(int i : nums){\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\n        }\n        for(int i=0;i<nums.length;i++){\n            if(avaibilityMap.get(nums[i])<=0){\n                continue;\n            }\n            else if(wantMap.getOrDefault(nums[i],0)>0){\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\n                wantMap.put(nums[i]+2, wantMap.getOrDefault(nums[i]+2,0)+1);\n            }\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
        "explanations": "\nThe bug is that I added 2 to num[i] inside the wantMap instead of 1.\n",
        "fixed_code": "\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        HashMap<Integer,Integer> availabilityMap = new HashMap<>();\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\n        for(int i : nums){\n            availabilityMap.put(i, availabilityMap.getOrDefault(i,0)+1);\n        }\n        for(int i=0;i<nums.length;i++){\n            if(availabilityMap.getOrDefault(nums[i],0)<=0){\n                continue;\n            }\n            else if(wantMap.getOrDefault(nums[i],0)>0){\n                availabilityMap.put(nums[i], availabilityMap.getOrDefault(nums[i],0)-1);\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\n            }\n            else if(availabilityMap.getOrDefault(nums[i],0)>0 && availabilityMap.getOrDefault(nums[i]+1,0)>0 && availabilityMap.getOrDefault(nums[i]+2,0)>0){\n                availabilityMap.put(nums[i], availabilityMap.getOrDefault(nums[i],0)-1);\n                availabilityMap.put(nums[i]+1, availabilityMap.getOrDefault(nums[i]+1,0)-1);\n                availabilityMap.put(nums[i]+2, availabilityMap.getOrDefault(nums[i]+2,0)-1);\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\n            }\n            else{\n                return false;\n            }\n        }\n        return true;\n    }\n}\n",
        "fixing_exp": "\nIn the else if statement, the wantMap should be incremented at key nums[i]+1 not nums[i]+2.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "27 ms",
            "memory": 45792000,
            "display_runtime": "27",
            "question_id": "659",
            "elapsed_time": 222,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647548984,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 187,
            "total_testcases": 187,
            "runtime_percentile": 38.00879999999998,
            "status_memory": "45.8 MB",
            "memory_percentile": 6.334899999999985,
            "pretty_lang": "Java",
            "submission_id": "1096152424",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "design-authentication-manager",
        "description": "There is an authentication system that works with authentication tokens. For each session, the user will receive a new authentication token that will expire timeToLive seconds after the currentTime. If the token is renewed, the expiry time will be extended to expire timeToLive seconds after the (potentially different) currentTime.\nImplement the AuthenticationManager class:\n\nAuthenticationManager(int timeToLive) constructs the AuthenticationManager and sets the timeToLive.\ngenerate(string tokenId, int currentTime) generates a new token with the given tokenId at the given currentTime in seconds.\nrenew(string tokenId, int currentTime) renews the unexpired token with the given tokenId at the given currentTime in seconds. If there are no unexpired tokens with the given tokenId, the request is ignored, and nothing happens.\ncountUnexpiredTokens(int currentTime) returns the number of unexpired tokens at the given currentTime.\n\nNote that if a token expires at time t, and another action happens on time t (renew or countUnexpiredTokens), the expiration takes place before the other actions.",
        "examples": [
            "Input\n[\"AuthenticationManager\", \"renew\", \"generate\", \"countUnexpiredTokens\", \"generate\", \"renew\", \"renew\", \"countUnexpiredTokens\"]\n[[5], [\"aaa\", 1], [\"aaa\", 2], [6], [\"bbb\", 7], [\"aaa\", 8], [\"bbb\", 10], [15]]\nOutput\n[null, null, null, 1, null, null, null, 0]\n\nExplanation\nAuthenticationManager authenticationManager = new AuthenticationManager(5); // Constructs the AuthenticationManager with timeToLive = 5 seconds.\nauthenticationManager.renew(\"aaa\", 1); // No token exists with tokenId \"aaa\" at time 1, so nothing happens.\nauthenticationManager.generate(\"aaa\", 2); // Generates a new token with tokenId \"aaa\" at time 2.\nauthenticationManager.countUnexpiredTokens(6); // The token with tokenId \"aaa\" is the only unexpired one at time 6, so return 1.\nauthenticationManager.generate(\"bbb\", 7); // Generates a new token with tokenId \"bbb\" at time 7.\nauthenticationManager.renew(\"aaa\", 8); // The token with tokenId \"aaa\" expired at time 7, and 8 >= 7, so at time 8 the renew request is ignored, and nothing happens.\nauthenticationManager.renew(\"bbb\", 10); // The token with tokenId \"bbb\" is unexpired at time 10, so the renew request is fulfilled and now the token will expire at time 15.\nauthenticationManager.countUnexpiredTokens(15); // The token with tokenId \"bbb\" expires at time 15, and the token with tokenId \"aaa\" expired at time 7, so currently no token is unexpired, so return 0."
        ],
        "constrains": "1 <= timeToLive <= 108\n1 <= currentTime <= 108\n1 <= tokenId.length <= 5\ntokenId consists only of lowercase letters.\nAll calls to generate will contain unique values of tokenId.\nThe values of currentTime across all the function calls will be strictly increasing.\nAt most 2000 calls will be made to all functions combined.",
        "release_time": 1673449685,
        "oracle_code": "class AuthenticationManager {\n\n    int time=0;\n\n    HashMap<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        \n    time=timeToLive;\n\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        \n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\n    {\n    return;\n    }\n\n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n    \n    List<String>lr=new ArrayList<>(mp.keySet());\n    \n    for(int i=0;i<lr.size();i++){\n    \n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\n\n    }\n\n    return mp.size();\n    \n    }\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    int time=0;\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        \\n    time=timeToLive;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\\n    {\\n    return;\\n    }\\n\\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n    \\n    List<String>lr=new ArrayList<>(mp.keySet());\\n    \\n    for(int i=0;i<lr.size();i++){\\n    \\n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\\n\\n    }\\n\\n    return mp.size();\\n    \\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass AuthenticationManager {\n\n    int time=0;\n\n    HashMap<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        \n    time=timeToLive;\n\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        \n    mp.put(tokenId,currentTime);\n\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\n    {\n    return;\n    }\n\n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n    \n    List<String>lr=new ArrayList<>(mp.keySet());\n    \n    for(int i=0;i<lr.size();i++){\n    \n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\n\n    }\n\n    return mp.size();\n    \n    }\n}\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */\n\n",
        "explanations": "\nIn generate function, timeToLive isn't added to the currentTime. Tokens will expire instantly.\n",
        "fixed_code": "\nimport java.util.*;\n\nclass AuthenticationManager {\n    int time=0;\n    Map<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        time=timeToLive;\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        mp.put(tokenId,currentTime + time);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        if(mp.containsKey(tokenId) && mp.get(tokenId) > currentTime){\n            mp.put(tokenId,currentTime + time);\n        }\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n        int count = 0;\n        for(Map.Entry<String,Integer> entry: mp.entrySet()){\n            if(entry.getValue() > currentTime)count++;\n        }\n        return count;\n    }\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */\n",
        "fixing_exp": "\nIn generate method, expiration time was not considering timeToLive. In renew method, incorrect condition led to early renewals. In countUnexpiredTokens, removing elements while iterating can lead to ConcurrentModificationException, so only count was returned.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "52 ms",
            "memory": 44948000,
            "display_runtime": "52",
            "question_id": "1905",
            "elapsed_time": 242,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647573954,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 91,
            "total_testcases": 91,
            "runtime_percentile": 52.8206,
            "status_memory": "44.9 MB",
            "memory_percentile": 61.025699999999986,
            "pretty_lang": "Java",
            "submission_id": "1096152637",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "design-a-stack-with-increment-operation",
        "description": "Design a stack that supports increment operations on its elements.\nImplement the CustomStack class:\n\nCustomStack(int maxSize) Initializes the object with maxSize which is the maximum number of elements in the stack.\nvoid push(int x) Adds x to the top of the stack if the stack has not reached the maxSize.\nint pop() Pops and returns the top of the stack or -1 if the stack is empty.\nvoid inc(int k, int val) Increments the bottom k elements of the stack by val. If there are less than k elements in the stack, increment all the elements in the stack.",
        "examples": [
            "Input\n[\"CustomStack\",\"push\",\"push\",\"pop\",\"push\",\"push\",\"push\",\"increment\",\"increment\",\"pop\",\"pop\",\"pop\",\"pop\"]\n[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]\nOutput\n[null,null,null,2,null,null,null,null,null,103,202,201,-1]\nExplanation\nCustomStack stk = new CustomStack(3); // Stack is Empty []\nstk.push(1);                          // stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.pop();                            // return 2 --> Return top of the stack 2, stack becomes [1]\nstk.push(2);                          // stack becomes [1, 2]\nstk.push(3);                          // stack becomes [1, 2, 3]\nstk.push(4);                          // stack still [1, 2, 3], Do not add another elements as size is 4\nstk.increment(5, 100);                // stack becomes [101, 102, 103]\nstk.increment(2, 100);                // stack becomes [201, 202, 103]\nstk.pop();                            // return 103 --> Return top of the stack 103, stack becomes [201, 202]\nstk.pop();                            // return 202 --> Return top of the stack 202, stack becomes [201]\nstk.pop();                            // return 201 --> Return top of the stack 201, stack becomes []\nstk.pop();                            // return -1 --> Stack is empty return -1."
        ],
        "constrains": "1 <= maxSize, x, k <= 1000\n0 <= val <= 100\nAt most 1000 calls will be made to each method of increment, push and pop each separately.",
        "release_time": 1674461680,
        "oracle_code": "class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(-1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val",
        "content": "# Upvote it :)\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```",
        "level": "medium",
        "buggy_code": "\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(self.top))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\n",
        "explanations": "\nThe pop() method pops item at 'top' index not the last item causing unexpected results.\n",
        "fixed_code": "\nclass CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(self.top + 1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\n",
        "fixing_exp": "\nModified the pop method to decrement top index after the pop operation.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "java",
            "run_success": false,
            "compile_error": "Line 2: error: '{' expected [in CustomStack.java]",
            "full_compile_error": "Line 2: error: '{' expected [in CustomStack.java]\nclass CustomStack:\n                 ^\nLine 4: error: class, interface, enum, or record expected [in CustomStack.java]\n    def __init__(self, maxSize: int):\n                                ^\n2 errors",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1497",
            "task_finish_time": 1699647589674,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096152749",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "n-th-tribonacci-number",
        "description": "The Tribonacci sequence Tn is defined as follows:\u00a0\nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n >= 0.\nGiven n, return the value of Tn.",
        "examples": [
            "Input: n = 4\r\nOutput: 4\r\nExplanation:\r\nT_3 = 0 + 1 + 1 = 2\r\nT_4 = 1 + 1 + 2 = 4",
            "Input: n = 25\r\nOutput: 1389537"
        ],
        "constrains": "0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.",
        "release_time": 1675068570,
        "oracle_code": "class Solution {\n    public int tribonacci(int n) {\n        if(n==0)return 0;\n        if(n==1||n==2) return 1;\n        int dp[]=new int[n+1];\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=1;\n        for(int i=3;i<=n;i++){\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\n        }\n        return dp[n];\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2) return 1;\\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=1;\\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int tribonacci(int n) {\n        if(n==0)return 0;\n        if(n==1||n==2) return 1;\n        int dp[]=new int[n+1];\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=1;\n        for(int i=3;i<=n;i++){\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-4];\n        }\n        return dp[n];\n    }\n}\n",
        "explanations": "\nThe bug is in the loop, where dp[i-4] doesn't exist for i less than 4.\n",
        "fixed_code": "\nclass Solution {\n    public int tribonacci(int n) {\n        if(n==0)return 0;\n        if(n==1||n==2) return 1;\n        int dp[]=new int[n+1];\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=1;\n        for(int i=3;i<=n;i++){\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\n        }\n        return dp[n];\n    }\n}\n",
        "fixing_exp": "\nThe ternary sequence involves adding up the last three numbers, but it was erroneously adding the fourth last number.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39356000,
            "display_runtime": "0",
            "question_id": "1236",
            "elapsed_time": 96,
            "compare_result": "111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647604936,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 39,
            "total_testcases": 39,
            "runtime_percentile": 100,
            "status_memory": "39.4 MB",
            "memory_percentile": 24.002300000000016,
            "pretty_lang": "Java",
            "submission_id": "1096152870",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-uncommon-subsequence-i",
        "description": "Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\nAn uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n\nFor example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).",
        "examples": [
            "Input: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.",
            "Input: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation:\u00a0The longest uncommon subsequences are \"aaa\" and \"bbb\".",
            "Input: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation:\u00a0Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a."
        ],
        "constrains": "1 <= a.length, b.length <= 100\na and b consist of lower-case English letters.",
        "release_time": 1688445720,
        "oracle_code": "class Solution {\n    public int findLUSlength(String a, String b) {\n        if(a.equals(b)){\n            return -1;\n        }else{\n            return Math.max(a.length(),b.length());\n        }\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLUSlength(String a, String b) {\\n        if(a.equals(b)){\\n            return -1;\\n        }else{\\n            return Math.max(a.length(),b.length());\\n        }\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        if(a.equals(b)){\n            return -1;\n        }else{\n            return Math.min(a.length(),b.length());\n        }\n    }\n}\n",
        "explanations": "\nThe method is supposed to return the maximum length between two strings, but it mistakenly returns the minimum.\n",
        "fixed_code": "\nclass Solution {\n    public int findLUSlength(String a, String b) {\n        if(a.equals(b)){\n            return -1;\n        }else{\n            return Math.max(a.length(),b.length());\n        }\n    }\n}\n",
        "fixing_exp": "\nThe function should return the maximum length between two strings, not the minimum.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 40124000,
            "display_runtime": "0",
            "question_id": "521",
            "elapsed_time": 131,
            "compare_result": "11111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647620223,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 41,
            "total_testcases": 41,
            "runtime_percentile": 100,
            "status_memory": "40.1 MB",
            "memory_percentile": 61.55340000000001,
            "pretty_lang": "Java",
            "submission_id": "1096152999",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constrains": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2.",
        "release_time": 1686334819,
        "oracle_code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 10.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}\n",
        "explanations": "\nThe bug is in the line \"double a = pairs / 10.0;\". This calculation will give a wrong number of swaps needed as dividing by 10 isn't correct.\n",
        "fixed_code": "\nclass Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (!s.isEmpty() && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2.0;\n        int ans = (int) Math.ceil(pairs);\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nChanged the divisor in the computation of \"pairs\" to be 2.0 instead of 2 for accurate double division result.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 54576000,
            "display_runtime": "117",
            "question_id": "2095",
            "elapsed_time": 473,
            "compare_result": "10111011111110000100000000000000000000000000000000000111100",
            "code_output": "3",
            "std_output": "",
            "last_testcase": "\"]]][[[\"",
            "expected_output": "2",
            "task_finish_time": 1699647638926,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 59,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096153164",
            "input_formatted": "\"]]][[[\"",
            "input": "\"]]][[[\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constrains": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters.",
        "release_time": 1683601117,
        "oracle_code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            if(x.equals(SB.reverse().toString())) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for(String x : words) {\\n            StringBuilder SB = new StringBuilder(x);\\n            if(x.equals(SB.reverse().toString())) {\\n                return x;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            x = SB.reverse().toString();\n            if(x.equals(SB.toString())) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}\n",
        "explanations": "\nThe variable 'x' is changed before comparison, which constantly makes the condition true.\n",
        "fixed_code": "\nclass Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            String reverse = SB.reverse().toString();\n            if(x.equals(reverse)) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}\n",
        "fixing_exp": "\nAfter reversing, stored it in a new String variable instead of overriding the variable \"x\".\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 43852000,
            "display_runtime": "4",
            "question_id": "2231",
            "elapsed_time": 170,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647653150,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 266,
            "total_testcases": 266,
            "runtime_percentile": 40.1093,
            "status_memory": "43.9 MB",
            "memory_percentile": 41.1532,
            "pretty_lang": "Java",
            "submission_id": "1096153294",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constrains": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's",
        "release_time": 1684037017,
        "oracle_code": "class Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%2==0);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%3==0);\n    }\n}\n",
        "explanations": "\nThe logic error is in the return line. It is checking for divisibility by 3 instead of 2.\n",
        "fixed_code": "\nclass Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%3==0);\n    }\n}\n",
        "fixing_exp": "\nThere isn't any bug in the code. It performs as it is supposed to.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 59604000,
            "display_runtime": "10",
            "question_id": "2792",
            "elapsed_time": 583,
            "compare_result": "001111110111010001110100100000001101000000000000000011100010000100000000000000001111100000000000100000000010000001100000000100000110111000011001100010111001100010110011110000000100010111110011111101101100000000011111111100011110001010101001101111111110110100101001101001011011101111111011100101110100111100001111011010011111111011010110010101111001111100101110001110010110101110010001100011001101011110001111110000000001110000011000100000001100111011001011110100010101010010101010100001001000000001111010110110011010000011011001010111001111010110001010010100100101101010010001001001111111101111111100111001100101110101011110100001000100000101110000110100110111000000010110100111011011111001111000111001100111101110100001000000010111100100100001100111101101000011011000100000011110011000110111111011001111001100001000011100001000100001110101000011100111100001001010100100011100100101101111000100001001101111001010010111101010001010000010110111100000010110101010100101001110110101000111010101110000101001001000101010100011101100011111001011010101000011011110000011111100010011000100000100001000010000010111100111101001110100111011100010011110100111101010000001000111101000101010101100010011011111110101101011100001011000101001101101011111011000010111100111001100010000110000010010111001011001111110010101000101010010101100000000010011001001100110110010010010010011101000111001100110100111101000110010100110101001010011110010000",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "[1,1,0]",
            "expected_output": "true",
            "task_finish_time": 1699647672775,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 676,
            "total_testcases": 1425,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096153444",
            "input_formatted": "[1,1,0]",
            "input": "[1,1,0]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sign-of-the-product-of-an-array",
        "description": "There is a function signFunc(x) that returns:\n\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).",
        "examples": [
            "Input: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1",
            "Input: nums = [1,5,0,2,-3]\nOutput: 0\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0",
            "Input: nums = [-1,1,-1,1,-1]\nOutput: -1\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1"
        ],
        "constrains": "1 <= nums.length <= 1000\n-100 <= nums[i] <= 100",
        "release_time": 1682989041,
        "oracle_code": "class Solution { // Vezzz\n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z >> 31 | 1;\n  }\n}",
        "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z;\n  }\n}\n",
        "explanations": "\nThe code now returns the final XOR combination of all elements, not recognizing sign correctly.\n",
        "fixed_code": "\nclass Solution { \n  public int arraySign(int[] nums) {\n    int z = 1;\n    for (int v : nums) {\n      if (v == 0)\n        return 0;\n      else\n        z *= Math.signum(v);\n    }\n    return z;\n  }\n}\n",
        "fixing_exp": "\nThe original code was incorrectly using XOR for multiplying signs. Revised to use multiplication with proper sign extraction.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 42684000,
            "display_runtime": "1",
            "question_id": "1950",
            "elapsed_time": 175,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647684494,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 76,
            "total_testcases": 76,
            "runtime_percentile": 27.286,
            "status_memory": "42.7 MB",
            "memory_percentile": 84.29879999999994,
            "pretty_lang": "Java",
            "submission_id": "1096153548",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximal-rectangle",
        "description": "Given a rows x cols\u00a0binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.",
        "examples": [
            "Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]\nOutput: 6\nExplanation: The maximal rectangle is shown in the above picture.",
            "Input: matrix = [[\"0\"]]\nOutput: 0",
            "Input: matrix = [[\"1\"]]\nOutput: 1"
        ],
        "constrains": "rows == matrix.length\ncols == matrix[i].length\n1 <= row, cols <= 200\nmatrix[i][j] is '0' or '1'.",
        "release_time": 1691836401,
        "oracle_code": "class Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '1';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}\n",
        "explanations": "\nThe code 'nums[j] = matrix[0][j] - '1';' subtracts '1' instead of '0', incurring wrong behaviors.\n",
        "fixed_code": "\nclass Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;\n\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        //remaining code is same\n    }\n}\n",
        "fixing_exp": "\nAdded check for null and empty matrix, and adjusted '-' to '0' in 'nums[j] = matrix[0][j] - '0';' for correct computation.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "java",
            "run_success": false,
            "compile_error": "Line 36: error: missing return statement [in Pair.java]",
            "full_compile_error": "Line 36: error: missing return statement [in Pair.java]\n    }\n    ^",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "85",
            "task_finish_time": 1699647703048,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096153699",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "print-in-order",
        "description": "Suppose we have a class:\n\npublic class Foo {\n  public void first() { print(\"first\"); }\n  public void second() { print(\"second\"); }\n  public void third() { print(\"third\"); }\n}\n\nThe same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().\nNote:\nWe do not know how the threads will be scheduled in the operating system, even though the numbers in the input seem to imply the ordering. The input format you see is mainly to ensure our tests' comprehensiveness.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: \"firstsecondthird\"\nExplanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). \"firstsecondthird\" is the correct output.",
            "Input: nums = [1,3,2]\nOutput: \"firstsecondthird\"\nExplanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). \"firstsecondthird\" is the correct output."
        ],
        "constrains": "nums is a permutation of [1, 2, 3].",
        "release_time": 1662361771,
        "oracle_code": "class Foo {\n    private volatile int num = 1;\n    public Foo() {\n\n    }\n\n    public void first(Runnable printFirst) throws InterruptedException {\n        while(num != 1){\n        }\n\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\n        printFirst.run();\n        num++;\n    }\n\n    public void second(Runnable printSecond) throws InterruptedException {\n        while(num != 2){\n        }\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\n        printSecond.run();\n        num++;\n    }\n\n    public void third(Runnable printThird) throws InterruptedException {\n        while(num != 3){\n        }\n        // printThird.run() outputs \"third\". Do not change or remove this line.\n        printThird.run();\n        num++;\n    }\n}",
        "content": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Foo {\n    private volatile int num = 1;\n    public Foo() {\n\n    }\n\n    public void first(Runnable printFirst) throws InterruptedException {\n        while(num != 1){\n        }\n\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\n        printFirst.run();\n    }\n\n    public void second(Runnable printSecond) throws InterruptedException {\n        while(num != 2){\n        }\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\n        printSecond.run();\n        num++;\n    }\n\n    public void third(Runnable printThird) throws InterruptedException {\n        while(num != 3){\n        }\n        // printThird.run() outputs \"third\". Do not change or remove this line.\n        printThird.run();\n        num++;\n    }\n}\n",
        "explanations": "\nThe increment operation in the first method is removed so the program will hang indefinitely.\n",
        "fixed_code": "\nclass Foo {\n    private volatile int num = 1;\n    public Foo() {\n\n    }\n\n    public synchronized void first(Runnable printFirst) throws InterruptedException {\n        while(num != 1){\n        }\n\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\n        printFirst.run();\n        num++;\n    }\n\n    public synchronized void second(Runnable printSecond) throws InterruptedException {\n        while(num != 2){\n            wait();\n        }\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\n        printSecond.run();\n        num++;\n        notifyAll();\n    }\n\n    public synchronized void third(Runnable printThird) throws InterruptedException {\n        while(num != 3){\n            wait();\n        }\n        // printThird.run() outputs \"third\". Do not change or remove this line.\n        printThird.run();\n        num++;\n        notifyAll();\n    }\n}\n",
        "fixing_exp": "\nThe methods need to be synchronized. Added num++ after first(). Used wait() and notifyAll() to control the execution of methods.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "state": "STARTED"
        }
    },
    {
        "slug": "count-number-of-rectangles-containing-each-point",
        "description": "You are given a 2D integer array rectangles where rectangles[i] = [li, hi] indicates that ith rectangle has a length of li and a height of hi. You are also given a 2D integer array points where points[j] = [xj, yj] is a point with coordinates (xj, yj).\nThe ith rectangle has its bottom-left corner point at the coordinates (0, 0) and its top-right corner point at (li, hi).\nReturn an integer array count of length points.length where count[j] is the number of rectangles that contain the jth point.\nThe ith rectangle contains the jth point if 0 <= xj <= li and 0 <= yj <= hi. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.",
        "examples": [
            "Input: rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]\nOutput: [2,1]\nExplanation: \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return [2, 1].",
            "Input: rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]\nOutput: [1,3]\nExplanation:\nThe first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return [1, 3]."
        ],
        "constrains": "1 <= rectangles.length, points.length <= 5 * 104\nrectangles[i].length == points[j].length == 2\n1 <= li, xj <= 109\n1 <= hi, yj <= 100\nAll the rectangles are unique.\nAll the points are unique.",
        "release_time": 1650772874,
        "oracle_code": "class Solution {\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\n    // group by y, as 1 <= y <= 100\n    int limit = 101;\n    List<List<Integer>> group = new ArrayList<>(limit);\n    for (int i = 0; i < limit; i++) {\n      group.add(new ArrayList<>());\n    }\n\n    for (int[] rectangle : rectangles) {\n      group.get(rectangle[1]).add(rectangle[0]);\n    }\n\n    // sort each group\n    for (int i = 0; i < limit; i++) {\n      group.get(i).sort(Comparator.naturalOrder());\n    }\n\n    int m = points.length;\n    int[] result = new int[m];\n\n    for (int i = 0; i < m; i++) {\n      int count = 0;\n      for (int j = points[i][1]; j < limit; j++) {\n        List<Integer> part = group.get(j);\n        int index = Collections.binarySearch(part, points[i][0]);\n        if (index < 0) {\n          index = -index - 1;\n        }\n\n        count += part.size() - index;\n      }\n      result[i] = count;\n    }\n    return result;\n  }\n}",
        "content": "Pay attention to condition: `1 <= y <= 100`, so we should group by `y` and then binary search `x`.\\n\\nWe can save lots of time, if we group by `y` instead of `x`.\\n\\nTime: O(NlogN)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\\n    // group by y, as 1 <= y <= 100\\n    int limit = 101;\\n    List<List<Integer>> group = new ArrayList<>(limit);\\n    for (int i = 0; i < limit; i++) {\\n      group.add(new ArrayList<>());\\n    }\\n\\n    for (int[] rectangle : rectangles) {\\n      group.get(rectangle[1]).add(rectangle[0]);\\n    }\\n\\n    // sort each group\\n    for (int i = 0; i < limit; i++) {\\n      group.get(i).sort(Comparator.naturalOrder());\\n    }\\n\\n    int m = points.length;\\n    int[] result = new int[m];\\n\\n    for (int i = 0; i < m; i++) {\\n      int count = 0;\\n      for (int j = points[i][1]; j < limit; j++) {\\n        List<Integer> part = group.get(j);\\n        int index = Collections.binarySearch(part, points[i][0]);\\n        if (index < 0) {\\n          index = -index - 1;\\n        }\\n\\n        count += part.size() - index;\\n      }\\n      result[i] = count;\\n    }\\n    return result;\\n  }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\n    // group by y, as 1 <= y <= 100\n    int limit = 101;\n    List<List<Integer>> group = new ArrayList<>(limit);\n    for (int i = 0; i < limit; i++) {\n      group.add(new ArrayList<>());\n    }\n\n    for (int[] rectangle : rectangles) {\n      group.get(rectangle[1]).add(rectangle[0]);\n    }\n\n    // sort each group\n    for (int i = 0; i < limit; i++) {\n      group.get(i).sort(Comparator.reverseOrder());\n    }\n\n    int m = points.length;\n    int[] result = new int[m];\n\n    for (int i = 0; i < m; i++) {\n      int count = 0;\n      for (int j = points[i][1]; j < limit; j++) {\n        List<Integer> part = group.get(j);\n        int index = Collections.binarySearch(part, points[i][0]);\n        if (index < 0) {\n          index = -index - 1;\n        }\n\n        count += part.size() - index;\n      }\n      result[i] = count;\n    }\n    return result;\n  }\n}\n",
        "explanations": "\nSorted each group in reverse order, making binary search and subsequent index calculation incorrect.\n",
        "fixed_code": "\nclass Solution {\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\n    // group by y, as 1 <= y <= 100\n    int limit = 101;\n    List<List<Integer>> group = new ArrayList<>(limit);\n    for (int i = 0; i < limit; i++) {\n      group.add(new ArrayList<>());\n    }\n\n    for (int[] rectangle : rectangles) {\n      group.get(rectangle[1]).add(rectangle[0]);\n    }\n\n    // sort each group\n    for (int i = 0; i < limit; i++) {\n      group.get(i).sort(Comparator.naturalOrder());\n    }\n\n    int m = points.length;\n    int[] result = new int[m];\n\n    for (int i = 0; i < m; i++) {\n      int count = 0;\n      for (int j = points[i][1]; j < limit; j++) {\n        List<Integer> part = group.get(j);\n        int index = Collections.binarySearch(part, points[i][0]);\n        if (index < 0) {\n          index = -index - 1;\n        } else {\n          index += 1;\n        }\n        count += part.size() - index;\n      }\n      result[i] = count;\n    }\n    return result;\n  }\n}\n",
        "fixing_exp": "\nThe binary search in Collections returns index of the search key if it is contained in the list; otherwise, it returns (-(insertion point) - 1). \nThe insertion point is defined as the point at which the key would be inserted into the list.\nSo, if the index returned is not negative (indicating the key was found in the list), the index should be increased by one because the current point itself should not be counted.\nAnd the comparator must sort in ascending order.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 73380000,
            "display_runtime": "635",
            "question_id": "2333",
            "elapsed_time": 1038,
            "compare_result": "00000000000000000000000000000000000000000011011",
            "code_output": "[0,1]",
            "std_output": "",
            "last_testcase": "[[1,2],[2,3],[2,5]]\n[[2,1],[1,4]]",
            "expected_output": "[2,1]",
            "task_finish_time": 1699647739920,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 47,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096153981",
            "input_formatted": "[[1,2],[2,3],[2,5]], [[2,1],[1,4]]",
            "input": "[[1,2],[2,3],[2,5]]\n[[2,1],[1,4]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "description": "Given an integer array nums and an integer k, return the number of pairs (i, j) where i < j such that |nums[i] - nums[j]| == k.\nThe value of |x| is defined as:\n\nx if x >= 0.\n-x if x < 0.",
        "examples": [
            "Input: nums = [1,2,2,1], k = 1\nOutput: 4\nExplanation: The pairs with an absolute difference of 1 are:\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]\n- [1,2,2,1]",
            "Input: nums = [1,3], k = 3\nOutput: 0\nExplanation: There are no pairs with an absolute difference of 3.",
            "Input: nums = [3,2,1,5,4], k = 2\nOutput: 3\nExplanation: The pairs with an absolute difference of 2 are:\n- [3,2,1,5,4]\n- [3,2,1,5,4]\n- [3,2,1,5,4]"
        ],
        "constrains": "1 <= nums.length <= 200\n1 <= nums[i] <= 100\n1 <= k <= 99",
        "release_time": 1677159545,
        "oracle_code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countKDifference(int[] nums, int k) {\\n       int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (Math.abs(nums[i] - nums[j]) == k) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nplease upvote, if u like this solution!",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans--;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nDecremented 'ans' instead of incrementing, which causes incorrect count of pairs with difference 'k'.\n",
        "fixed_code": "\nclass Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nThe counter 'ans' should be incremented instead of decremented when the condition is met.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "8 ms",
            "memory": 42600000,
            "display_runtime": "8",
            "question_id": "2116",
            "elapsed_time": 226,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647753960,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 237,
            "total_testcases": 237,
            "runtime_percentile": 44.998000000000005,
            "status_memory": "42.6 MB",
            "memory_percentile": 89.80339999999998,
            "pretty_lang": "Java",
            "submission_id": "1096154115",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "increasing-decreasing-string",
        "description": "You are given a string s. Reorder the string using the following algorithm:\n\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\n\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
        "examples": [
            "Input: s = \"aaaabbbbcccc\"\nOutput: \"abccbaabccba\"\nExplanation: After steps 1, 2 and 3 of the first iteration, result = \"abc\"\nAfter steps 4, 5 and 6 of the first iteration, result = \"abccba\"\nFirst iteration is done. Now s = \"aabbcc\" and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = \"abccbaabc\"\nAfter steps 4, 5 and 6 of the second iteration, result = \"abccbaabccba\"",
            "Input: s = \"rat\"\nOutput: \"art\"\nExplanation: The word \"rat\" becomes \"art\" after re-ordering it with the mentioned algorithm."
        ],
        "constrains": "1 <= s.length <= 500\ns consists of only lowercase English letters.",
        "release_time": 1676313293,
        "oracle_code": "class Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n        \n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}",
        "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[num]=arr[num]+1; \n            ++num; \n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}\n",
        "explanations": "\nThe num variable is incremented after being used to index the arr array, leading to incorrect count of characters.\n",
        "fixed_code": "\nclass Solution {\n    public String sortString(String s) {\n        int[] arr = new int[26];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf(s.charAt(i));\n            arr[num]++;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n\n        while(count<len){\n            for(int i=0;i<26;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i));\n                    arr[i]--;\n                    count++;\n                }\n            }\n            for(int j=25;j>=0;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j));\n                    arr[j]--;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}\n",
        "fixing_exp": "\nA well-known alphabets 'a-z' are represented with indexes '0-25', instead of '1-26', so changed array size & indexes accordingly.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 41852000,
            "display_runtime": "4",
            "question_id": "1472",
            "elapsed_time": 152,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647769241,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 323,
            "total_testcases": 323,
            "runtime_percentile": 39.108900000000006,
            "status_memory": "41.9 MB",
            "memory_percentile": 89.10889999999999,
            "pretty_lang": "Java",
            "submission_id": "1096154233",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-odd-numbers-in-an-interval-range",
        "description": "Given two non-negative integers low and high. Return the count of odd numbers between low and high\u00a0(inclusive).",
        "examples": [
            "Input: low = 3, high = 7\r\nOutput: 3\r\nExplanation: The odd numbers between 3 and 7 are [3,5,7].",
            "Input: low = 8, high = 10\r\nOutput: 1\r\nExplanation: The odd numbers between 8 and 10 are [9]."
        ],
        "constrains": "0 <= low <= high\u00a0<= 10^9",
        "release_time": 1683277667,
        "oracle_code": "class Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0)\n            return (high-low)/2;\n        else\n            return (high-low)/2+1;\n    }\n}",
        "content": "# Intuition\\nAt first i thought to execute it with using loops.\\n\\n# Approach\\nThere are four possible ways to get no.of odd numbers from low and high limits.\\nWhen both numbers are even print half of its difference else by adding one to it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countOdds(int low, int high) {\\n        if(low%2==0 && high%2==0)\\n            return (high-low)/2;\\n        else\\n            return (high-low)/2+1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0)\n            return (high-low)/2+1;\n        else\n            return (high-low)/2+1;\n    }\n}\n",
        "explanations": "\nSame return value in both cases, ignoring condition, will incorrectly count odd numbers in range.\n",
        "fixed_code": "\nclass Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0)\n            return (high-low)/2;\n        else\n            return (high-low)/2+1;\n    }\n}\n",
        "fixing_exp": "\nThe code was counting one extra even number when both limits were even.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39036000,
            "display_runtime": "0",
            "question_id": "1630",
            "elapsed_time": 136,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647784031,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 84,
            "total_testcases": 84,
            "runtime_percentile": 100,
            "status_memory": "39 MB",
            "memory_percentile": 56.47239999999999,
            "pretty_lang": "Java",
            "submission_id": "1096154357",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "mirror-reflection",
        "description": "There is a special square room with mirrors on each of the four walls. Except for the southwest corner, there are receptors on each of the remaining corners, numbered 0, 1, and 2.\nThe square room has walls of length p\u00a0and a laser ray from the southwest corner first meets the east wall at a distance q from the 0th receptor.\nGiven the two integers p and q, return the number of the receptor that the ray meets first.\nThe test cases are guaranteed so that the ray will meet a receptor eventually.",
        "examples": [
            "Input: p = 2, q = 1\nOutput: 2\nExplanation: The ray meets receptor 2 the first time it gets reflected back to the left wall.",
            "Input: p = 3, q = 1\nOutput: 1"
        ],
        "constrains": "1 <= q <= p <= 1000",
        "release_time": 1659577168,
        "oracle_code": "class Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q >>= 1;\n        }\n        return (q&1) + ((p&1)^1);\n    }\n}",
        "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int mirrorReflection(int p, int q) {\\n        while(((p|q)&1) == 0){\\n            p >>= 1;\\n            q >>= 1;\\n        }\\n        return (q&1) + ((p&1)^1);\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q <<= 1;\n        }\n        return (q&1) + ((p&1)^1);\n    }\n}\n",
        "explanations": "\nInstead of right shifting q (dividing by 2), it is being left shifted (multiplied by 2) which can lead to wrong results.\n",
        "fixed_code": "\nclass Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q >>= 1;\n        }\n        return (q&1) + ((p&1)^1);\n    }\n}\n",
        "fixing_exp": "\nModified 'q <<= 1;' to 'q >>= 1;' to ensure q is properly right-shifted during while loop.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39144000,
            "display_runtime": "0",
            "question_id": "888",
            "elapsed_time": 129,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647799054,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 70,
            "total_testcases": 70,
            "runtime_percentile": 100,
            "status_memory": "39.1 MB",
            "memory_percentile": 45.8822,
            "pretty_lang": "Java",
            "submission_id": "1096154469",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "diagonal-traverse-ii",
        "description": "Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.",
        "examples": [
            "Input: nums = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,4,2,7,5,3,8,6,9]",
            "Input: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\nOutput: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]"
        ],
        "constrains": "1 <= nums.length <= 105\n1 <= nums[i].length <= 105\n1 <= sum(nums[i].length) <= 105\n1 <= nums[i][j] <= 105",
        "release_time": 1687196653,
        "oracle_code": "class Solution {\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\n        List<Integer>[] map = new ArrayList[100001];\n        for (int i = 0; i < m; i++) {\n            size += nums.get(i).size();\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                int sum = i + j;\n                if (map[sum] == null) map[sum] = new ArrayList<>();\n                map[sum].add(nums.get(i).get(j));\n                maxSum = Math.max(maxSum, sum);\n            }\n        }\n        int[] res = new int[size];\n        for (int i = 0; i <= maxSum; i++) {\n            List<Integer> cur = map[i];\n            for (int j = cur.size() - 1; j >= 0; j--) {\n                res[index++] = cur.get(j);\n            }\n        }\n        return res;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\\n        List<Integer>[] map = new ArrayList[100001];\\n        for (int i = 0; i < m; i++) {\\n            size += nums.get(i).size();\\n            for (int j = 0; j < nums.get(i).size(); j++) {\\n                int sum = i + j;\\n                if (map[sum] == null) map[sum] = new ArrayList<>();\\n                map[sum].add(nums.get(i).get(j));\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n        int[] res = new int[size];\\n        for (int i = 0; i <= maxSum; i++) {\\n            List<Integer> cur = map[i];\\n            for (int j = cur.size() - 1; j >= 0; j--) {\\n                res[index++] = cur.get(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\n        List<Integer>[] map = new ArrayList[100001];\n        for (int i = 0; i < m; i++) {\n            size += nums.get(i).size();\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                int sum = i + j;\n                if (map[sum] == null) map[sum] = new ArrayList<>();\n                map[sum].add(nums.get(i).get(j));\n                maxSum = Math.max(maxSum, j);\n            }\n        }\n        int[] res = new int[size];\n        for (int i = 0; i <= maxSum; i++) {\n            List<Integer> cur = map[i];\n            for (int j = cur.size() - 1; j >= 0; j--) {\n                res[index++] = cur.get(j);\n            }\n        }\n        return res;\n    }\n}\n",
        "explanations": "\nModified 'maxSum = Math.max(maxSum, sum);' to 'maxSum = Math.max(maxSum, j);' which, after computing incorrect maxSum, results in incorrect result array.\n",
        "fixed_code": "\nclass Solution {\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\n        List<Integer>[] map = new ArrayList[m];\n        for (int i = 0; i < m; i++) {\n            size += nums.get(i).size();\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                int sum = i + j;\n                if (map[sum] == null) map[sum] = new ArrayList<>();\n                map[sum].add(nums.get(i).get(j));\n                maxSum = Math.max(maxSum, sum);\n            }\n        }\n        int[] res = new int[size];\n        for (int i = 0; i <= maxSum; i++) {\n            List<Integer> cur = map[i];\n            for (int j = cur.size() - 1; j >= 0; j--) {\n                res[index++] = cur.get(j);\n            }\n        }\n        return res;\n    }\n}\n",
        "fixing_exp": "\nFixed the maxSum computation from using j to i+j to consider the entire diagonal length.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "java",
            "run_success": false,
            "runtime_error": "Line 10: java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3",
            "full_runtime_error": "java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\n  at line 10, Solution.findDiagonalOrder\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main",
            "status_runtime": "N/A",
            "memory": 39400000,
            "question_id": "1539",
            "elapsed_time": 108,
            "compare_result": "00000000000000000000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[[1,2,3],[4,5,6],[7,8,9]]",
            "expected_output": "[1,4,2,7,5,3,8,6,9]",
            "task_finish_time": 1699647816258,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 56,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096154580",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximal-score-after-applying-k-operations",
        "description": "You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\n\nchoose an index i such that 0 <= i < nums.length,\nincrease your score by nums[i], and\nreplace nums[i] with ceil(nums[i] / 3).\n\nReturn the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.",
        "examples": [
            "Input: nums = [10,10,10,10,10], k = 5\nOutput: 50\nExplanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.",
            "Input: nums = [1,10,3,3,3], k = 3\nOutput: 17\nExplanation: You can do the following operations:\nOperation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17."
        ],
        "constrains": "1 <= nums.length, k <= 105\n1 <= nums[i] <= 109",
        "release_time": 1673150548,
        "oracle_code": "class Solution {\n    public long maxKelements(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n        public int compare(Integer a, Integer b) {\n            return b - a;\n        }\n    });\n    \n    for (int num : nums) {\n        pq.add(num);\n    }\n        \n    long score = 0;\n    \n    for (int i = 0; i < k; i++) {\n        // Get the maximum value from the priority queue\n        int max = pq.poll();\n        \n        // Increase the score by the maximum value\n        score += max;\n        \n        // Replace the value with ceil(max / 3)\n        pq.add((int) Math.ceil(max / 3.0));\n    }\n    \n    return score;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\\n        public int compare(Integer a, Integer b) {\\n            return b - a;\\n        }\\n    });\\n    \\n    for (int num : nums) {\\n        pq.add(num);\\n    }\\n        \\n    long score = 0;\\n    \\n    for (int i = 0; i < k; i++) {\\n        // Get the maximum value from the priority queue\\n        int max = pq.poll();\\n        \\n        // Increase the score by the maximum value\\n        score += max;\\n        \\n        // Replace the value with ceil(max / 3)\\n        pq.add((int) Math.ceil(max / 3.0));\\n    }\\n    \\n    return score;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public long maxKelements(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n        public int compare(Integer a, Integer b) {\n            return b - a;\n        }\n    });\n    \n    for (int num : nums) {\n        pq.add(num);\n    }\n        \n    long score = 0;\n    \n    for (int i = 0; i < k; i++) {\n        // Get the maximum value from the priority queue\n        int max = pq.poll();\n        \n        // Increase the score by the maximum value\n        score += max;\n        \n        // Replace the value with ceil(max / 3)\n        pq.add((int) Math.ceil(max / 4.0));\n    }\n    \n    return score;\n    }\n}\n",
        "explanations": "\nThe logic error is introduced by dividing max by 4 instead of by intended 3.\n",
        "fixed_code": "\nclass Solution {\n    public long maxKelements(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n        public int compare(Integer a, Integer b) {\n            return b - a;\n        }\n    });\n    \n    for (int num : nums) {\n        pq.add(num);\n    }\n        \n    long score = 0;\n    \n    for (int i = 0; i < k; i++) {\n        if (!pq.isEmpty()) {\n            // Get the maximum value from the priority queue\n            int max = pq.poll();\n\n            // Increase the score by the maximum value\n            score += max;\n\n            // Replace the value with ceil(max / 3)\n            pq.add((int) Math.ceil((double) max / 4));\n        }\n    }\n    \n    return score;\n    }\n}\n",
        "fixing_exp": "\nAdded check to avoid null values from PriorityQueue and properly cast values to double in the division for correct calculation.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 60612000,
            "display_runtime": "122",
            "question_id": "2616",
            "elapsed_time": 465,
            "compare_result": "101111000110000100010000000000000011111",
            "code_output": "16",
            "std_output": "",
            "last_testcase": "[1,10,3,3,3]\n3",
            "expected_output": "17",
            "task_finish_time": 1699647831972,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 14,
            "total_testcases": 39,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096154688",
            "input_formatted": "[1,10,3,3,3], 3",
            "input": "[1,10,3,3,3]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constrains": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "release_time": 1691938245,
        "oracle_code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7c0897c-8dc0-4fa5-aeca-e836b2887d45_1691938187.8801217.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        ArrayList<Integer>atr=new ArrayList<>();\\n        for(int a:nums){\\n            atr.add(a);\\n        }\\n        atr.add(target);\\n        Collections.sort(atr);\\n        int k=atr.indexOf(target);\\n        return k;\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        atr.remove(target);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}\n",
        "explanations": "\nThe bug is in atr.remove(target), it removes the target before getting its index.\n",
        "fixed_code": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n    }\n}\n",
        "fixing_exp": "\nRemoved the unnecessary line atr.remove(target). It was causing the indexOf function to return the wrong position.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "3 ms",
            "memory": 42708000,
            "display_runtime": "3",
            "question_id": "35",
            "elapsed_time": 129,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647847620,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 65,
            "total_testcases": 65,
            "runtime_percentile": 100,
            "status_memory": "42.7 MB",
            "memory_percentile": 93.57409999999996,
            "pretty_lang": "Java",
            "submission_id": "1096154813",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "the-number-of-weak-characters-in-the-game",
        "description": "You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\nA character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei.\nReturn the number of weak characters.",
        "examples": [
            "Input: properties = [[5,5],[6,3],[3,6]]\nOutput: 0\nExplanation: No character has strictly greater attack and defense than the other.",
            "Input: properties = [[2,2],[3,3]]\nOutput: 1\nExplanation: The first character is weak because the second character has a strictly greater attack and defense.",
            "Input: properties = [[1,5],[10,4],[4,3]]\nOutput: 1\nExplanation: The third character is weak because the second character has a strictly greater attack and defense."
        ],
        "constrains": "2 <= properties.length <= 105\nproperties[i].length == 2\n1 <= attacki, defensei <= 105",
        "release_time": 1662691692,
        "oracle_code": "class Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}",
        "content": "**Time Complexity : O(n*logn)**\\n**Java**\\n```\\nclass Solution {\\n    public int numberOfWeakCharacters(int[][] properties) {\\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\\n        int count = 0, max = 0;\\n        for(int[] arr: properties){\\n            if(arr[1] < max)    count++;\\n            max = Math.max(max, arr[1]);\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar numberOfWeakCharacters = function(properties) {\\n    properties.sort((a,b) => (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\\n    let count = 0, max = 0\\n    for(let arr of properties){\\n        if(arr[1] < max)    count++\\n        max = Math.max(max, arr[1])\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def numberOfWeakCharacters(self, properties):\\n        properties.sort(key = lambda x: (-x[0], x[1]))\\n        count, mx = 0, 0\\n        for arr in properties:\\n            if arr[1] < mx:\\n                count += 1\\n            mx = max(mx, arr[1])\\n        return count\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (b[0]-a[0]));\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nThe bug is in the sorting comparator causing the sorting order to be incorrect.\n",
        "fixed_code": "\nclass Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (b[1]-a[1]) : (a[0]-b[0]));\n        int count = 0, max = 0;\n        for(int i = properties.length - 1; i >= 0; i--){\n            if(properties[i][1] < max) count++;\n            max = Math.max(max, properties[i][1]);\n        }\n        return count;\n    }\n}\n",
        "fixing_exp": "\nThis code is sorting in incorrect order and not properly iterating through the array properties.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "83 ms",
            "memory": 100728000,
            "display_runtime": "83",
            "question_id": "2123",
            "elapsed_time": 532,
            "compare_result": "11111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647868845,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 44,
            "total_testcases": 44,
            "runtime_percentile": 76.47049999999996,
            "status_memory": "100.7 MB",
            "memory_percentile": 66.66639999999981,
            "pretty_lang": "Java",
            "submission_id": "1096154976",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "sum-of-mutated-array-closest-to-target",
        "description": "Given an integer array arr and a target value target, return the integer value such that when we change all the integers larger than value in the given array to be equal to value, the sum of the array gets as close as possible (in absolute difference) to target.\nIn case of a tie, return the minimum such integer.\nNotice that the answer is not neccesarilly a number from arr.",
        "examples": [
            "Input: arr = [4,9,3], target = 10\nOutput: 3\nExplanation: When using 3 arr converts to [3, 3, 3] which sums 9 and that's the optimal answer.",
            "Input: arr = [2,3,5], target = 10\nOutput: 5",
            "Input: arr = [60864,25176,27249,21296,20204], target = 56803\nOutput: 11361"
        ],
        "constrains": "1 <= arr.length <= 104\n1 <= arr[i], target <= 105",
        "release_time": 1680185953,
        "oracle_code": "class Solution {\n    public int findBestValue(int[] arr, int target) {\n      int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        }\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.min(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int findBestValue(int[] arr, int target) {\n      int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        }\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.max(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}\n",
        "explanations": "\nChanged Math.min to Math.max in summation inside the while loop, altering total sum.\n",
        "fixed_code": "\nclass Solution {\n    public int findBestValue(int[] arr, int target) {\n        int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        }\n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.min(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}\n",
        "fixing_exp": "\nSwitched Math.max to Math.min in the sum calculation within the while loop.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "3 ms",
            "memory": 42848000,
            "display_runtime": "3",
            "question_id": "1232",
            "elapsed_time": 157,
            "compare_result": "111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647886161,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 21,
            "total_testcases": 21,
            "runtime_percentile": 81.2786,
            "status_memory": "42.8 MB",
            "memory_percentile": 87.2146,
            "pretty_lang": "Java",
            "submission_id": "1096155130",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "max-sum-of-rectangle-no-larger-than-k",
        "description": "Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\nIt is guaranteed that there will be a rectangle with a sum no larger than k.",
        "examples": [
            "Input: matrix = [[1,0,1],[0,-2,3]], k = 2\nOutput: 2\nExplanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).",
            "Input: matrix = [[2,2,-1]], k = 3\nOutput: 3"
        ],
        "constrains": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-100 <= matrix[i][j] <= 100\n-105 <= k <= 105",
        "release_time": 1661575112,
        "oracle_code": "//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n\t\t\t\t\t\n\t\t\t\t\t//explanation of these 3 loops starts from 02:00 in Video\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n\t\t\t\t\t\n                    //if you don't understand what exactly is going on here\n\t\t\t\t\t// then watch the video from 12:27\n\t\t\t\t\t\n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] -= matrix[row][right];\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n                    \n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
        "explanations": "\nInstead of adding the matrix elements in rSum array, it now subtracts, leading to incorrect results. \n",
        "fixed_code": "\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n                    \n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}\n",
        "fixing_exp": "\nThe row sum needs to be added instead of subtracted.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "303 ms",
            "memory": 43340000,
            "display_runtime": "303",
            "question_id": "363",
            "elapsed_time": 466,
            "compare_result": "111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647902329,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 36,
            "total_testcases": 36,
            "runtime_percentile": 21.95200000000016,
            "status_memory": "43.3 MB",
            "memory_percentile": 92.1952,
            "pretty_lang": "Java",
            "submission_id": "1096155241",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-sum-with-exactly-k-elements",
        "description": "You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:\n\nSelect an element m from nums.\nRemove the selected element m from the array.\nAdd a new element with a value of m + 1 to the array.\nIncrease your score by m.\n\nReturn the maximum score you can achieve after performing the operation exactly k times.",
        "examples": [
            "Input: nums = [1,2,3,4,5], k = 3\nOutput: 18\nExplanation: We need to choose exactly 3 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]\nFor the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]\nSo, we will return 18.\nIt can be proven, that 18 is the maximum answer that we can achieve.",
            "Input: nums = [5,5,5], k = 2\nOutput: 11\nExplanation: We need to choose exactly 2 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]\nSo, we will return 11.\nIt can be proven, that 11 is the maximum answer that we can achieve."
        ],
        "constrains": "1 <= nums.length <= 100\n1 <= nums[i] <= 100\n1 <= k <= 100",
        "release_time": 1682812985,
        "oracle_code": "class Solution {\n    public int maximizeSum(int[] nums, int k) {\n        int max = 0;\n        for(int i = 0; i<nums.length; i++){ \n            max = Math.max(max, nums[i]);\n        }\n        \n        int ans = 0;\n        while(k>0){\n            ans+=max;\n            max = max+1;\n            k--;\n        }\n        return ans;\n    }   \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i<nums.length; i++){ \\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int ans = 0;\\n        while(k>0){\\n            ans+=max;\\n            max = max+1;\\n            k--;\\n        }\\n        return ans;\\n    }   \\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int maximizeSum(int[] nums, int k) {\n        int max = 0;\n        for(int i = 0; i<nums.length; i++){ \n            max = Math.max(max, nums[i]);\n        }\n        \n        int ans = 0;\n        while(k>0){\n            ans+=max;\n            max = max-1;\n            k--;\n        }\n        return ans;\n    }   \n}\n",
        "explanations": "\nDecrementing max in loop leads to unwanted results as it should be enhancing max value.\n",
        "fixed_code": "\nclass Solution {\n    public int maximizeSum(int[] nums, int k) {\n        int max = Integer.MIN_VALUE;\n        for(int i = 0; i<nums.length; i++){ \n            max = Math.max(max, nums[i]);\n        }\n        \n        int ans = 0;\n        while(k>0 && max > 0){\n            ans += max;\n            max = max-1;\n            k--;\n        }\n        return ans;\n    }   \n}\n",
        "fixing_exp": "\nFixed initial max value and added condition max > 0 to avoid adding negative values when k remains.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 43588000,
            "display_runtime": "2",
            "question_id": "2767",
            "elapsed_time": 208,
            "compare_result": "0000000001100000000000000000000000000000000000000000000000000000000000000000000100000001000000000000000000000000010000000000000010000000000000000100000000000110000000100000000000000000000010000010000100100010010000000001101000000000010000000000100001000000000000010010100000000000001100000000000000000000000100000000000100100000001000000000000000000000000000100000000000000100000000001000000000000000100001000000000000000000001100000000000000000000000000000100001000000000000000000100000000000000000100000001000000000000000000000000000001010100100000110000000000000010010000000000010000000000011000000000000000000100000000000000010000000000000000000000000100001100000000100000010000000000000000000000000000000000000000010001000000000000000000001000000010110001101000000000000100000000010000000000000000000010000000000001000000000100100000010100000000000000000000000000000000000000000000110000000000111000000010010000000000001000000000010100000010000000000000000000000010000000101100000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010001010000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000001000000000000000010000001000000000000000100000100001010100000000000001101010100000010000000000000001000000100000000000000000000000001000011000000100011011000000000000000000000100000000000010000000000000000000100000000000100000000000010000010000000010100000001000100010000010000000000100100000010001000001010000000000000100000000100000000000011000000000000000000000000100001000000000100000000000100000000000000010000010000000000000000000000000000110000000001001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000001000000000000000000000000000000011000100000000001010100010100000000000010000000000100001000000000000000011010000000000000000000000100001000000001000000000000000000000000000000000000000000000000000000000000001000000000000000100000000000001000100001001101000000000001010100100000001010000000000000000010100100001000000000000100000000000000011000000000000000000000000000001000110000000000011001000010000000000000000000101000100000000000000000000000000000000000000010001100000000000000000000000000000",
            "code_output": "12",
            "std_output": "",
            "last_testcase": "[1,2,3,4,5]\n3",
            "expected_output": "18",
            "task_finish_time": 1699647916734,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 213,
            "total_testcases": 3004,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096155344",
            "input_formatted": "[1,2,3,4,5], 3",
            "input": "[1,2,3,4,5]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "first-completely-painted-row-or-column",
        "description": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.",
        "examples": [
            "Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]\nOutput: 2\nExplanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].",
            "Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\nOutput: 3\nExplanation: The second column becomes fully painted at arr[3]."
        ],
        "constrains": "m == mat.length\nn = mat[i].length\narr.length == m * n\n1 <= m, n <= 105\n1 <= m * n <= 105\n1 <= arr[i], mat[r][c] <= m * n\nAll the integers of arr are unique.\nAll the integers of mat are unique.",
        "release_time": 1682933570,
        "oracle_code": "class Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int ind=0;\n        int m=mat.length,n=mat[0].length;\n        int row[]=new int[m];\n        int col[]=new int[n];\n        boolean flag=true;;\n        while(flag){\n            int i=0;\n            for(i=0;i<m;i++){\n                int j=0;\n                for(j=0;j<n;j++){\n                    if(mat[i][j]==arr[ind]){\n                        ind++;\n                        row[i]++;\n                        col[j]++;\n                    }\n                    if(row[i]==n || col[j]==m){\n                        flag=false;\n                        break;\n                    }\n                }\n                if(!flag)   break;\n            }\n        }\n       return ind-1;\n    }\n}",
        "content": "\\nUnoptimized but still works\\n# Complexity\\n- Time complexity:O(k*m*n)\\n- Where k is the number of operation required to make one wall to be colored\\n- m is number of rows\\n- n is number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\\nOptimized Version of the same:\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- m is number of rows\\n- n is number of columns\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int ind=0;\n        int m=mat.length,n=mat[0].length;\n        int row[]=new int[m];\n        int col[]=new int[n];\n        boolean flag=true;;\n        while(flag){\n            int i=0;\n            for(i=0;i<m;i++){\n                int j=0;\n                for(j=0;j<n;j++){\n                    if(mat[i][j]==arr[ind]){\n                        ind++;\n                        row[i]++;\n                        col[j]++;\n                        if(row[i]==n || col[j]==m){\n                            flag=false;\n                            break;\n                        }\n                    }\n                }\n                if(!flag)   break;\n            }\n        }\n       return ind+1;\n    }\n}\n",
        "explanations": "\nReturning \"ind+1\" instead of \"ind-1\" would give the index of the next expected number.\n",
        "fixed_code": "\nclass Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int ind=0;\n        int m=mat.length;\n        if (m == 0) {\n            return -1;\n        }\n        int n=mat[0].length;\n        int row[]=new int[m];\n        int col[]=new int[n];\n        boolean flag=true;\n        while(flag && ind < arr.length){\n            int i=0;\n            for(i=0;i<m;i++){\n                int j=0;\n                for(j=0;j<n;j++){\n                    if(mat[i][j]==arr[ind]){\n                        ind++;\n                        row[i]++;\n                        col[j]++;\n                        if(row[i]==n || col[j]==m){\n                            flag=false;\n                            break;\n                        }\n                    }\n                    if(ind >= arr.length) break;\n                }\n                if(!flag || ind >= arr.length)   break;\n            }\n        }\n        return (ind < arr.length) ? ind+1 : -1;\n    }\n}\n",
        "fixing_exp": "\nAdded boundary checks for mat[][] and arr[] to avoid IndexOutOfBoundsException.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 56200000,
            "display_runtime": "283",
            "question_id": "2685",
            "elapsed_time": 647,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "4",
            "std_output": "",
            "last_testcase": "[1,3,4,2]\n[[1,4],[2,3]]",
            "expected_output": "2",
            "task_finish_time": 1699647937506,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 1058,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096155499",
            "input_formatted": "[1,3,4,2], [[1,4],[2,3]]",
            "input": "[1,3,4,2]\n[[1,4],[2,3]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "description": "You are given two strings of the same length s1 and s2 and a string baseStr.\nWe say s1[i] and s2[i] are equivalent characters.\n\nFor example, if s1 = \"abc\" and s2 = \"cde\", then we have 'a' == 'c', 'b' == 'd', and 'c' == 'e'.\n\nEquivalent characters follow the usual rules of any equivalence relation:\n\nReflexivity: 'a' == 'a'.\nSymmetry: 'a' == 'b' implies 'b' == 'a'.\nTransitivity: 'a' == 'b' and 'b' == 'c' implies 'a' == 'c'.\n\nFor example, given the equivalency information from s1 = \"abc\" and s2 = \"cde\", \"acd\" and \"aab\" are equivalent strings of baseStr = \"eed\", and \"aab\" is the lexicographically smallest equivalent string of baseStr.\nReturn the lexicographically smallest equivalent string of baseStr by using the equivalency information from s1 and s2.",
        "examples": [
            "Input: s1 = \"parker\", s2 = \"morris\", baseStr = \"parser\"\nOutput: \"makkek\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [m,p], [a,o], [k,r,s], [e,i].\nThe characters in each group are equivalent and sorted in lexicographical order.\nSo the answer is \"makkek\".",
            "Input: s1 = \"hello\", s2 = \"world\", baseStr = \"hold\"\nOutput: \"hdld\"\nExplanation: Based on the equivalency information in s1 and s2, we can group their characters as [h,w], [d,e,o], [l,r].\nSo only the second letter 'o' in baseStr is changed to 'd', the answer is \"hdld\".",
            "Input: s1 = \"leetcode\", s2 = \"programs\", baseStr = \"sourcecode\"\nOutput: \"aauaaaaada\"\nExplanation: We group the equivalent characters in s1 and s2 as [a,o,e,r,s,c], [l,p], [g,t] and [d,m], thus all letters in baseStr except 'u' and 'd' are transformed to 'a', the answer is \"aauaaaaada\"."
        ],
        "constrains": "1 <= s1.length, s2.length, baseStr <= 1000\ns1.length == s2.length\ns1, s2, and baseStr consist of lowercase English letters.",
        "release_time": 1673736567,
        "oracle_code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n        }\n        return sb.reverse().toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
        "explanations": "\nAdding `sb.reverse().toString();` at the end reverses the expected output string.\n",
        "fixed_code": "\nclass Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-'a',s2.charAt(i)-'a');\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 'a');\n            sb.append((char)(dsu.min[root] + 'a'));\n        }\n        return sb.toString();\n    }\n    \n    class UFDS {\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j) return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}\n",
        "fixing_exp": "\nChanged the hardcoded ASCII value 97 to 'a' for readability, and removed the unnecessary reverse() call on StringBuilder.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "2 ms",
            "memory": 40476000,
            "display_runtime": "2",
            "question_id": "1058",
            "elapsed_time": 141,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647964835,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 116,
            "total_testcases": 116,
            "runtime_percentile": 97.2,
            "status_memory": "40.5 MB",
            "memory_percentile": 95.99999999999999,
            "pretty_lang": "Java",
            "submission_id": "1096155725",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "guess-number-higher-or-lower",
        "description": "We are playing the Guess Game. The game is as follows:\nI pick a number from 1 to n. You have to guess which number I picked.\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n-1: Your guess is higher than the number I picked (i.e. num > pick).\n1: Your guess is lower than the number I picked (i.e. num < pick).\n0: your guess is equal to the number I picked (i.e. num == pick).\n\nReturn the number that I picked.",
        "examples": [
            "Input: n = 10, pick = 6\nOutput: 6",
            "Input: n = 1, pick = 1\nOutput: 1",
            "Input: n = 2, pick = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 231 - 1\n1 <= pick <= n",
        "release_time": 1689963688,
        "oracle_code": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is higher than the picked number\n *\t\t\t      1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=0,high=n;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            int x= guess(mid);\n            if(x==0) \n            {\n                return mid;\n            }\n            else if(x==-1)\n            {\n                high=mid-1;\n            }\n            else\n            {\n                low = mid+1;\n            }\n        }\n        return -1;\n    }\n}",
        "content": "# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0,high=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int x= guess(mid);\\n            if(x==0) \\n            {\\n                return mid;\\n            }\\n            else if(x==-1)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return      -1 if num is higher than the picked number\n *              1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=0, high=n;\n        while(low<=high)\n        {\n            int mid=low+high;\n            int x= guess(mid);\n            if(x==0) \n            {\n                return mid;\n            }\n            else if(x==-1)\n            {\n                high=mid-1;\n            }\n            else\n            {\n                low = mid+1;\n            }\n        }\n        return -1;\n    }\n}\n",
        "explanations": "\nMid is not being calculated correctly, this might cause integer overflow for large numbers.\n",
        "fixed_code": "\n/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return      -1 if num is higher than the picked number\n *              1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=1, high=n;\n        while(low<=high)\n        {\n           int mid=low+(high-low)/2;\n           int x= guess(mid);\n           if(x==0) \n           {\n              return mid;\n           }\n           else if(x<0)\n           {\n              high=mid-1;\n           }\n           else\n           {\n              low = mid+1;\n           }\n        }\n        return -1;\n    }\n}\n",
        "fixing_exp": "\nCorrected low start from 1 instead of 0 and mid calculation to avoid overflow.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39204000,
            "display_runtime": "0",
            "question_id": "374",
            "elapsed_time": 87,
            "compare_result": "1111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699647980769,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 25,
            "total_testcases": 25,
            "runtime_percentile": 100,
            "status_memory": "39.2 MB",
            "memory_percentile": 30.44500000000002,
            "pretty_lang": "Java",
            "submission_id": "1096155843",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "implement-trie-prefix-tree",
        "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.",
        "examples": [
            "Input\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True"
        ],
        "constrains": "1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.",
        "release_time": 1682938465,
        "oracle_code": "class Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n    Node links[]= new Node[26];\\n    boolean flag=false;\\n    public Node(){\\n\\n    }\\n    boolean contains(char ch){\\n        return (links[ch-\\'a\\']!=null);\\n    }\\n    void put(char ch, Node node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n\\n}\\nclass Trie {\\nprivate static Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                node.put(word.charAt(i),new Node());\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        node.setEnd();\\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        if(node.isEnd())\\n            return true;\\n        return false;\\n    }\\n    \\n    public boolean startsWith(String prefix) {\\n        Node node=root;\\n        for(int i=0;i<prefix.length();i++){\\n            if(!node.contains(prefix.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(prefix.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Trie object will be instantiated and called as such:\\n * Trie obj = new Trie();\\n * obj.insert(word);\\n * boolean param_2 = obj.search(word);\\n * boolean param_3 = obj.startsWith(prefix);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'A'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return true;\n    }\n}\n",
        "explanations": "\nIn the get method, it is getting 'ch'-'A' instead of 'ch'-'a', this causes array out of bounds errors for lowercase input letters.\n",
        "fixed_code": "\nclass Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a']; // corrected ch-'A' to ch-'a'\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return true;\n    }\n}\n",
        "fixing_exp": "\nThe get method was incorrectly subtracting 'A' instead of 'a' from the character.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "45 ms",
            "memory": 57884000,
            "display_runtime": "45",
            "question_id": "208",
            "elapsed_time": 238,
            "compare_result": "1111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648010830,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 16,
            "total_testcases": 16,
            "runtime_percentile": 20.551199999999998,
            "status_memory": "57.9 MB",
            "memory_percentile": 5.008999999999957,
            "pretty_lang": "Java",
            "submission_id": "1096156045",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "magic-squares-in-grid",
        "description": "A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\nGiven a row x col\u00a0grid\u00a0of integers, how many 3 x 3 \"magic square\" subgrids are there?\u00a0 (Each subgrid is contiguous).",
        "examples": [
            "Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n\nwhile this one is not:\n\nIn total, there is only one magic square inside the given grid.",
            "Input: grid = [[8]]\nOutput: 0"
        ],
        "constrains": "row == grid.length\ncol == grid[i].length\n1 <= row, col <= 10\n0 <= grid[i][j] <= 15",
        "release_time": 1648659719,
        "oracle_code": "class Solution {\n    /** Algorithm\n        1. If nr of columns or rows < 3 return false \n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\n           - use a boolean[10] seen to mark the already present number in 3x3 view\n           - return false if number if <1 or > 9\n           - return false if any found sum is different that a reference sum\n        4. Count the views /3x3 matrices and return their number   \n    */\n    public int numMagicSquaresInside(int[][] grid) {\n        if(grid.length < 3 || grid[0].length < 3) {\n            return 0;\n        }\n        int magicSquares = 0;\n        for (int i = 0; i < grid.length -2; i++) {\n            for (int j = 0; j < grid[i].length -2; j++) {\n                if (isMagicSquare(grid, i, j)) {\n                    magicSquares++;\n                }\n            }\n        }\n        return magicSquares;\n    }\n    \n    private boolean isMagicSquare(int[][] grid, int row, int col) {\n        // map the present number is a boolean of 10 (1-9)\n        boolean[] seen = new boolean[10];\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\n        int tempSum = 0;\n        // row sum\n        for (int i = row; i <= row +2; i++) {\n            tempSum = 0;\n            for (int j = col; j <= col +2; j++) {\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\n                    return false;\n                }\n                seen[grid[i][j]] = true;\n                tempSum += grid[i][j];\n            }\n            if (tempSum != sum) {\n                return false;\n            }\n        }\n        //col sum\n        for (int j = col; j <= col +2; j++) {\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\n                return false;\n            }\n        }\n        //diag 1 and 2\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\n            return false;\n        }\n        return true;\n    }\n}",
        "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        if(grid.length < 3 || grid[0].length < 3) {\n            return 0;\n        }\n        int magicSquares = 0;\n        for (int i = 0; i < grid.length -2; i++) {\n            for (int j = 0; j < grid[i].length -2; j++) {\n                if (isMagicSquare(grid, i, j)) {\n                    magicSquares--;\n                }\n            }\n        }\n        return magicSquares;\n    }\n    \n    private boolean isMagicSquare(int[][] grid, int row, int col) {\n        boolean[] seen = new boolean[10];\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\n        int tempSum = 0;\n        for (int i = row; i <= row +2; i++) {\n            tempSum = 0;\n            for (int j = col; j <= col +2; j++) {\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\n                    return false;\n                }\n                seen[grid[i][j]] = true;\n                tempSum += grid[i][j];\n            }\n            if (tempSum != sum) {\n                return false;\n            }\n        }\n        for (int j = col; j <= col +2; j++) {\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\n                return false;\n            }\n        }\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "explanations": "\nI replaced magicSquares++ with magicSquares-- so the count of magic squares decreases instead of increasing.\n",
        "fixed_code": "\nclass Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        if(grid.length < 3 || grid[0].length < 3) {\n            return 0;\n        }\n        int magicSquares = 0;\n        for (int i = 0; i < grid.length -2; i++) {\n            for (int j = 0; j < grid[i].length -2; j++) {\n                if (isMagicSquare(grid, i, j)) {\n                    magicSquares++;\n                }\n            }\n        }\n        return magicSquares;\n    }\n    \n    private boolean isMagicSquare(int[][] grid, int row, int col) {\n        boolean[] seen = new boolean[10];\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\n        int tempSum = 0;\n        for (int i = row; i <= row +2; i++) {\n            tempSum = 0;\n            for (int j = col; j <= col +2; j++) {\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\n                    return false;\n                }\n                seen[grid[i][j]] = true;\n                tempSum += grid[i][j];\n            }\n            if (tempSum != sum) {\n                return false;\n            }\n        }\n        for (int j = col; j <= col +2; j++) {\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\n                return false;\n            }\n        }\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\n            return false;\n        }\n        return true;\n    }\n}\n",
        "fixing_exp": "\nThe magicSquares variable should be incremented instead of decremented when a magic square is found.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39376000,
            "display_runtime": "0",
            "question_id": "870",
            "elapsed_time": 171,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648037111,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 93,
            "total_testcases": 93,
            "runtime_percentile": 100,
            "status_memory": "39.4 MB",
            "memory_percentile": 99.1525,
            "pretty_lang": "Java",
            "submission_id": "1096156239",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "account-balance-after-rounded-purchase",
        "description": "Initially, you have a bank account balance of 100 dollars.\nYou are given an integer purchaseAmount representing the amount you will spend on a purchase in dollars.\nAt the store where you will make the purchase, the purchase amount is rounded to the nearest multiple of 10. In other words, you pay a non-negative amount, roundedAmount, such that roundedAmount is a multiple of 10 and abs(roundedAmount - purchaseAmount) is minimized.\nIf there is more than one nearest multiple of 10, the largest multiple is chosen.\nReturn an integer denoting your account balance after making a purchase worth purchaseAmount dollars from the store.\nNote: 0 is considered to be a multiple of 10 in this problem.",
        "examples": [
            "Input: purchaseAmount = 9\nOutput: 90\nExplanation: In this example, the nearest multiple of 10 to 9 is 10. Hence, your account balance becomes 100 - 10 = 90.",
            "Input: purchaseAmount = 15\nOutput: 80\nExplanation: In this example, there are two nearest multiples of 10 to 15: 10 and 20. So, the larger multiple, 20, is chosen.\nHence, your account balance becomes 100 - 20 = 80."
        ],
        "constrains": "0 <= purchaseAmount <= 100",
        "release_time": 1691437848,
        "oracle_code": "class Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 == 0)\n        {\n            return 100-amt;\n        }\n        int ans=100-amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int accountBalanceAfterPurchase(int amt) {\\n        if(amt%10 == 0)\\n        {\\n            return 100-amt;\\n        }\\n        int ans=100-amt;\\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 == 0)\n        {\n            return 100-amt;\n        }\n        int ans=100+amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}\n",
        "explanations": "\nThe addition operator in \"int ans=100+amt;\" should be a subtraction for calculating the remaining balance.\n",
        "fixed_code": "\nclass Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 == 0)\n        {\n            return 100-amt;\n        }\n        int ans = 100-amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}\n",
        "fixing_exp": "\nThe faulty code was adding 'amt' to balance instead of subtracting it.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39104000,
            "display_runtime": "0",
            "question_id": "2955",
            "elapsed_time": 102,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648052464,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 101,
            "total_testcases": 101,
            "runtime_percentile": 100,
            "status_memory": "39.1 MB",
            "memory_percentile": 44.74359999999997,
            "pretty_lang": "Java",
            "submission_id": "1096156390",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "n-repeated-element-in-size-2n-array",
        "description": "You are given an integer array nums with the following properties:\n\nnums.length == 2 * n.\nnums contains n + 1 unique elements.\nExactly one element of nums is repeated n times.\n\nReturn the element that is repeated n times.",
        "examples": [
            "Input: nums = [1,2,3,3]\nOutput: 3",
            "Input: nums = [2,1,2,5,3,2]\nOutput: 2",
            "Input: nums = [5,1,5,2,5,3,5,4]\nOutput: 5"
        ],
        "constrains": "2 <= n <= 5000\nnums.length == 2 * n\n0 <= nums[i] <= 104\nnums contains n + 1 unique elements and one of them is repeated exactly n times.",
        "release_time": 1679196910,
        "oracle_code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        HashSet<Integer>set=new HashSet<>();\n        for(int n:nums){\n            if(!set.contains(n)){\n                set.add(n);\n            }else{\n                return n;\n            }\n        }\n        return 0;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int repeatedNTimes(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int n:nums){\\n            if(!set.contains(n)){\\n                set.add(n);\\n            }else{\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        HashSet<Integer>set=new HashSet<>();\n        for(int n:nums){\n            if(!set.contains(n)){\n                set.add(n);\n            }else{\n                return n+1;\n            }\n        }\n        return 0;\n    }\n}\n",
        "explanations": "\nReturning n+1 instead of n will give incorrect output for repeated number in array.\n",
        "fixed_code": "\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        HashSet<Integer>set=new HashSet<>();\n        for(int n:nums){\n            if(!set.contains(n)){\n                set.add(n);\n            }else{\n                return n;\n            }\n        }\n        return 0;\n    }\n}\n",
        "fixing_exp": "\nn+1 should be changed to n because we need to return repeated number not the incremented number.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 43936000,
            "display_runtime": "0",
            "question_id": "1001",
            "elapsed_time": 259,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648067145,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 103,
            "total_testcases": 103,
            "runtime_percentile": 100,
            "status_memory": "43.9 MB",
            "memory_percentile": 59.08039999999999,
            "pretty_lang": "Java",
            "submission_id": "1096156493",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constrains": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique.",
        "release_time": 1683184626,
        "oracle_code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[a]-score[b]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
        "explanations": "\nThe bug is in the PriorityQueue comparator logic where score[a] - score[b] will not sort the scores as expected.\n",
        "fixed_code": "\nclass Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n = score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n        String[] ans = new String[n];\n        int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}\n",
        "fixing_exp": "\nThe comparison function in PriorityQueue should be score[b] - score[a] to make it a max heap.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "7 ms",
            "memory": 44880000,
            "display_runtime": "7",
            "question_id": "506",
            "elapsed_time": 183,
            "compare_result": "11111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648082324,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 17,
            "total_testcases": 17,
            "runtime_percentile": 87.59540000000001,
            "status_memory": "44.9 MB",
            "memory_percentile": 35.49600000000004,
            "pretty_lang": "Java",
            "submission_id": "1096156613",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "tuple-with-same-product",
        "description": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.",
        "examples": [
            "Input: nums = [2,3,4,6]\nOutput: 8\nExplanation: There are 8 valid tuples:\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)",
            "Input: nums = [1,2,4,5,10]\nOutput: 16\nExplanation: There are 16 valid tuples:\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)"
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
        "release_time": 1661554822,
        "oracle_code": "class Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount);\n            }\n        }\n        \n\t\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += count * (count - 1) / 2;\n        }\n        return factor * 8;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        int m = nums.length;\\n        int factor = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i = 0; i < m - 1; i ++) {\\n            for(int j = i + 1; j < m; j ++) {\\n                int curNumber = nums[i] * nums[j];\\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\\n                hm.put(curNumber, curNumberCount);\\n            }\\n        }\\n        \\n\\t\\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\\n\\t\\t\\n        for(Integer key: hm.keySet()) {\\n            int count = hm.get(key);\\n            if(count == 1) continue;\\n            factor += count * (count - 1) / 2;\\n        }\\n        return factor * 8;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount);\n            }\n        }\n        \n        \n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += (count - 1) / 2; \n        }\n        return factor * 8;\n    }\n}\n",
        "explanations": "\nThe factor calculation logic is wrong. It should be \"count * (count - 1) / 2\", not \"(count - 1) / 2\".\n",
        "fixed_code": "\nimport java.util.*;\n\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                hm.put(curNumber, hm.getOrDefault(curNumber, 0) + 1);\n            }\n        }\n        \n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            factor += count * (count - 1) / 2; \n        }\n        return factor * 8;\n    }\n}\n",
        "fixing_exp": "\nFixed wrong calculation of number pairs which have same product and missing java.util import.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "192 ms",
            "memory": 62636000,
            "display_runtime": "192",
            "question_id": "1364",
            "elapsed_time": 573,
            "compare_result": "1111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648097473,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 37,
            "total_testcases": 37,
            "runtime_percentile": 56.39059999999995,
            "status_memory": "62.6 MB",
            "memory_percentile": 81.20299999999997,
            "pretty_lang": "Java",
            "submission_id": "1096156723",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "description": "Given 2n balls of k distinct colors. You will be given an integer array balls of size k where balls[i] is the number of balls of color i.\nAll the balls will be shuffled uniformly at random, then we will distribute the first n balls to the first box and the remaining n balls to the other box (Please read the explanation of the second example carefully).\nPlease note that the two boxes are considered different. For example, if we have two balls of colors a and b, and two boxes [] and (), then the distribution [a] (b) is considered different than the distribution [b] (a) (Please read the explanation of the first example carefully).\nReturn the probability that the two boxes have the same number of distinct balls. Answers within 10-5 of the actual value will be accepted as correct.",
        "examples": [
            "Input: balls = [1,1]\nOutput: 1.00000\nExplanation: Only 2 ways to divide the balls equally:\n- A ball of color 1 to box 1 and a ball of color 2 to box 2\n- A ball of color 2 to box 1 and a ball of color 1 to box 2\nIn both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1",
            "Input: balls = [2,1,1]\nOutput: 0.66667\nExplanation: We have the set of balls [1, 1, 2, 3]\nThis set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):\n[1,1 / 2,3], [1,1 / 3,2], [1,2 / 1,3], [1,2 / 3,1], [1,3 / 1,2], [1,3 / 2,1], [2,1 / 1,3], [2,1 / 3,1], [2,3 / 1,1], [3,1 / 1,2], [3,1 / 2,1], [3,2 / 1,1]\nAfter that, we add the first two balls to the first box and the second two balls to the second box.\nWe can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.\nProbability is 8/12 = 0.66667",
            "Input: balls = [1,2,1,2]\nOutput: 0.60000\nExplanation: The set of balls is [1, 2, 2, 3, 4, 4]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.\nProbability = 108 / 180 = 0.6"
        ],
        "constrains": "1 <= balls.length <= 8\n1 <= balls[i] <= 6\nsum(balls) is even.",
        "release_time": 1689418968,
        "oracle_code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib + 1;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
        "explanations": "\nThe bug is in the function dfs where 1 is added to valid count, causing over-counting.\n",
        "fixed_code": "\nclass Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        if (idx == balls.length) {\n            if (num1 == num2) {\n                double distrib = permFake(first)*permFake(second);\n                possible += distrib;\n                if (unique(first) == unique(second)) {\n                    valid += distrib;    \n                }\n            }\n            return;\n        }\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + b, num2 + balls[idx] - b, idx + 1);\n        }\n    }\n    \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    private double permFake(int[] balls) {\n        double ret = 2.0;\n        int sum = 0;\n        for (int b: balls) {\n            ret *= factorial(b);\n            sum += b;\n        }\n        return ret / factorial(sum);\n    }\n    \n    private double factorial(int n){\n        double ret = 1.0;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}\n",
        "fixing_exp": "\nFixed dfs input since it must iterate over indices, also changed the permutation calculation and made return type double for factorial function.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 40284000,
            "display_runtime": "91",
            "question_id": "1577",
            "elapsed_time": 217,
            "compare_result": "100000010100000000001",
            "code_output": "0.33333",
            "std_output": "",
            "last_testcase": "[2,1,1]",
            "expected_output": "0.66667",
            "task_finish_time": 1699648119719,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 4,
            "total_testcases": 21,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096156897",
            "input_formatted": "[2,1,1]",
            "input": "[2,1,1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constrains": "1 <= n <= 1000",
        "release_time": 1671862293,
        "oracle_code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-2)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
        "explanations": "\nChanged solve(n-3) to solve(n-2) altering the intended mathematical sequence.\n",
        "fixed_code": "\nclass Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=0) return dp[n];\n\n        return dp[n] = (2*solve(n-1)%MOD+solve(n-2)%MOD) % MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n\n        return (int)solve(n)%MOD;\n    }\n}\n",
        "fixing_exp": "\nWe now initialize the dp array to 0 to properly check if the value for the position has been computed.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 38420000,
            "display_runtime": "0",
            "question_id": "806",
            "elapsed_time": 187,
            "compare_result": "111000000000000000000000000000000000000",
            "code_output": "12",
            "std_output": "",
            "last_testcase": "4",
            "expected_output": "11",
            "task_finish_time": 1699648134538,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 3,
            "total_testcases": 39,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096157026",
            "input_formatted": "4",
            "input": "4",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "make-array-strictly-increasing",
        "description": "Given two integer arrays\u00a0arr1 and arr2, return the minimum number of operations (possibly zero) needed\u00a0to make arr1 strictly increasing.\nIn one operation, you can choose two indices\u00a00 <=\u00a0i < arr1.length\u00a0and\u00a00 <= j < arr2.length\u00a0and do the assignment\u00a0arr1[i] = arr2[j].\nIf there is no way to make\u00a0arr1\u00a0strictly increasing,\u00a0return\u00a0-1.",
        "examples": [
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].",
            "Input: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing."
        ],
        "constrains": "1 <= arr1.length, arr2.length <= 2000\n0 <= arr1[i], arr2[i] <= 10^9",
        "release_time": 1686968225,
        "oracle_code": "class Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution { \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr2);\\n        \\n        int answer = helper(0, -1, arr1, arr2);\\n        \\n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\\n    }\\n    \\n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\\n        if (i == arr1.length) {\\n            return 0;\\n        }\\n        if (dp.containsKey(new Pair<>(i, prev))) {\\n            return dp.get(new Pair<>(i, prev));\\n        }\\n\\n        int operation = Integer.MAX_VALUE-100;\\n\\n        \\n        if (arr1[i] > prev) {\\n            operation = helper(i + 1, arr1[i], arr1, arr2);\\n        }\\n\\n       \\n        int idx = binarySearch(arr2, prev);\\n\\n        \\n        if (idx < arr2.length) {\\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\\n        }\\n\\n        dp.put(new Pair<>(i, prev),operation);\\n        return operation;\\n    }\\n    \\n    private static int binarySearch(int[] arr, int value) {\\n        int left = 0, right = arr.length-1;\\n        while (left <= right) {\\n            int mid = left+(right-left) / 2;\\n            if (arr[mid] <= value) {\\n                left = mid + 1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    } \\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = helper(i + 1, arr2[idx], arr1, arr2);\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}\n",
        "explanations": "\nIn the helper function, operation should take the minimum value between its previous value and the next calculated value.\n",
        "fixed_code": "\nclass Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        int[] arr3 = new int[arr2.length + 1];\n        arr3[0] = Integer.MIN_VALUE;\n        for (int i = 0; i < arr2.length; ++i) {\n            arr3[i + 1] = arr2[i];\n        }\n\n        int[][] dp = new int[arr1.length + 1][arr3.length];\n        for (int i = 0; i <= arr1.length; ++i) {\n            Arrays.fill(dp[i], Integer.MAX_VALUE / 2);\n        }\n        dp[0][0] = 0;\n\n        for (int i = 0; i < arr1.length; ++i) {\n            for (int j = 0; j < arr3.length; ++j) {\n                if (j > 0) {\n                    dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j - 1] + 1);\n                }\n                if (arr1[i] > arr3[j]) {\n                    dp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j]);\n                }\n            }\n        }\n\n        int answer = Arrays.stream(dp[arr1.length]).min().getAsInt();\n        return answer < Integer.MAX_VALUE / 2 ? answer : -1;\n    }\n}\n",
        "fixing_exp": "\nThis code is fixed by implementing dynamic programming and handling the edge case if the sequence is not increasing.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 56492000,
            "display_runtime": "27",
            "question_id": "1290",
            "elapsed_time": 168,
            "compare_result": "0000000000000000000000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[1,5,3,6,7]\n[1,3,2,4]",
            "expected_output": "1",
            "task_finish_time": 1699648156864,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 22,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096157206",
            "input_formatted": "[1,5,3,6,7], [1,3,2,4]",
            "input": "[1,5,3,6,7]\n[1,3,2,4]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-atoms",
        "description": "Given a string formula representing a chemical formula, return the count of each atom.\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\nFor example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\nFor example, \"H2O2He3Mg4\" is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\nFor example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.",
        "examples": [
            "Input: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.",
            "Input: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.",
            "Input: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}."
        ],
        "constrains": "1 <= formula.length <= 1000\nformula consists of English letters, digits, '(', and ')'.\nformula is always valid.",
        "release_time": 1601928748,
        "oracle_code": "class Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            multiplier *= val;\n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            i--;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}",
        "content": "We essentially start from the back. Each time we encounter a number we add it to the stack. We can clearly see that going backwards, a number will always be preceeded by either `)` or `element`. So in the same loop we first parse the number followed by the element/bracket. If a number is not seen, we take the default 1 as the number.\\n\\nWe maintain the stack with the multipliers encountered and keep a `multiplier` variable to store the product. Upon poping the stack, we divide by this popped number.\\n\\nEverytime we encounter a `(`, we pop the stack. We again pop the stack after each element is processed.\\n\\nWe also use StringBuilder to optimize.\\n```\\nclass Solution {\\n    Map<String, Integer> res = new TreeMap<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int multiplier = 1;\\n    \\n    public String countOfAtoms(String formula) {\\n        int end = formula.length() - 1, i = formula.length() - 1;\\n        \\n        while (i >= 0) {\\n            if (formula.charAt(i) == \\'(\\') {\\n                multiplier /= stack.pop();\\n                i--;\\n                continue;\\n            }\\n            \\n            end = i;\\n            int val = 1;\\n            \\n            if (Character.isDigit(formula.charAt(i))) {\\n                while (Character.isDigit(formula.charAt(i))) i--;\\n                val = Integer.parseInt(formula.substring(i+1, end+1));\\n            } \\n            stack.push(val);\\n            multiplier *= val;\\n            \\n            end = i;\\n            if (Character.isLetter(formula.charAt(i))) {\\n                while(Character.isLowerCase(formula.charAt(i))) i--;\\n                updateMap(formula.substring(i, end+1));\\n            }\\n            i--;\\n        }\\n        \\n        StringBuilder rs = new StringBuilder();\\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\\n            rs.append(entry.getKey());\\n            if (entry.getValue() > 1) rs.append(entry.getValue());\\n        }\\n        return rs.toString();\\n    }\\n    \\n    private void updateMap(String key) {\\n        if (res.get(key) == null) {\\n            res.put(key, multiplier);\\n        } else {\\n            res.put(key, multiplier + res.get(key));\\n        }\\n\\n        multiplier /= stack.pop();\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            \n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            i--;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}\n",
        "explanations": "\nRemoving \"multiplier *= val\" incorrectly sets atom count, as each atom isn't multiplied by its count.\n",
        "fixed_code": "\nclass Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int i;\n    \n    public String countOfAtoms(String formula) {\n        i = 0;\n        while (i < formula.length()) {\n            if (formula.charAt(i) == '(') {\n                i++;\n                countOfAtoms(formula);\n                i++;\n            }\n            else if (formula.charAt(i) == ')') {\n                int j = ++i;\n                while (i < formula.length() && Character.isDigit(formula.charAt(i))) i++;\n                int multiplier = j<i ? Integer.parseInt(formula.substring(j, i)) : 1;\n                for(String ele: new ArrayList<>(res.keySet())) {\n                    res.put(ele, res.get(ele) * multiplier);\n                }\n            }\n            else {\n                int j = i++;\n                while (i < formula.length() && Character.isLowerCase(formula.charAt(i))) i++;\n                String key = formula.substring(j, i);\n                j = i;\n                while (i < formula.length() && Character.isDigit(formula.charAt(i))) i++;\n                int multiplier = j<i ? Integer.parseInt(formula.substring(j, i)) : 1;\n                res.put(key, res.getOrDefault(key, 0) + multiplier);\n            }\n        }\n        return makeFormula();\n    }\n\n    private String makeFormula() {\n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n}\n",
        "fixing_exp": "\nThe original solution had incorrect char processing due to decrement in loop. Substituted it with recursive char processing for correct formula parsing.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "java",
            "run_success": false,
            "runtime_error": "Line 30: java.lang.StackOverflowError",
            "full_runtime_error": "java.lang.StackOverflowError\n  at line 110, java.base/java.lang.StringLatin1.compareTo\n  at line 2016, java.base/java.lang.String.compareTo\n  at line 140, java.base/java.lang.String.compareTo\n  at line 350, java.base/java.util.TreeMap.getEntry\n  at line 279, java.base/java.util.TreeMap.get\n  at line 671, java.base/java.util.Map.getOrDefault\n  at line 30, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms\n  at line 12, Solution.countOfAtoms",
            "status_runtime": "N/A",
            "memory": 287872000,
            "question_id": "726",
            "elapsed_time": 745,
            "compare_result": "10000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "\"Mg(OH)2\"",
            "expected_output": "\"H2MgO2\"",
            "task_finish_time": 1699648181567,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1,
            "total_testcases": 32,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096157389",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "queens-that-can-attack-the-king",
        "description": "On a 0-indexed 8 x 8 chessboard, there can be multiple black queens ad one white king.\nYou are given a 2D integer array queens where queens[i] = [xQueeni, yQueeni] represents the position of the ith black queen on the chessboard. You are also given an integer array king of length 2 where king = [xKing, yKing] represents the position of the white king.\nReturn the coordinates of the black queens that can directly attack the king. You may return the answer in any order.",
        "examples": [
            "Input: queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]\nOutput: [[0,1],[1,0],[3,3]]\nExplanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).",
            "Input: queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]\nOutput: [[2,2],[3,4],[4,4]]\nExplanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes)."
        ],
        "constrains": "1 <= queens.length < 64\nqueens[i].length == king.length == 2\n0 <= xQueeni, yQueeni, xKing, yKing < 8\nAll the given positions are unique.",
        "release_time": 1604566770,
        "oracle_code": "class Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8];\n\t\t//Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n\t\t//Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++){\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][0];\n                l = l + moves[i][1];\n            }\n        }\n        \n        return output;\n    }\n}",
        "content": "The basic idea here is to move to all the 8 possible directions from king and see if any of the spot is occupied by a queen. If occupied then add that position to output and don\\'t move in that direction since all other queens in that direction will be blocked by this queen.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\\n        boolean[][] q = new boolean[8][8];\\n\\t\\t//Mark all the positions of queen on a 8 X 8 board.\\n        for (int[] queen: queens) {\\n            q[queen[0]][queen[1]] = true;\\n        }\\n        List<List<Integer>> output = new ArrayList<>();\\n\\t\\t//Specify all the moves of the queen\\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\\n        for(int i = 0; i < moves.length; i++){\\n            int k = king[0] + moves[i][0];\\n            int l = king[1] + moves[i][1];\\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\\n                if(q[k][l]){\\n                    List<Integer> pair = new ArrayList<>();\\n                    pair.add(k);\\n                    pair.add(l);\\n                    output.add(pair);\\n                    break;\\n                }\\n                k = k + moves[i][0];\\n                l = l + moves[i][1];\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8];\n\t\t//Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n\t\t//Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++){\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][1]; \n                l = l + moves[i][1];\n            }\n        }\n        \n        return output;\n    }\n}\n",
        "explanations": "\nThe bug is in the update of 'k'. It should be 'k = k + moves[i][0]', not 'moves[i][1]'.\n",
        "fixed_code": "\nclass Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8];\n        //Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n        //Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++){\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][0]; \n                l = l + moves[i][1];\n            }\n        }\n        \n        return output;\n    }\n}\n",
        "fixing_exp": "\nChanged \"moves[i][1]\" to \"moves[i][0]\" to correctly update the position.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 41788000,
            "display_runtime": "0",
            "question_id": "1342",
            "elapsed_time": 115,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648200823,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 100,
            "total_testcases": 100,
            "runtime_percentile": 100,
            "status_memory": "41.8 MB",
            "memory_percentile": 59.47379999999998,
            "pretty_lang": "Java",
            "submission_id": "1096157543",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\n\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\n\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.",
        "examples": [
            "Input: primeFactors = 5\r\nOutput: 6\r\nExplanation: 200 is a valid value of n.\r\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\r\nThere is not other value of n that has at most 5 prime factors and more nice divisors.",
            "Input: primeFactors = 8\r\nOutput: 18"
        ],
        "constrains": "1 <= primeFactors <= 109",
        "release_time": 1616918029,
        "oracle_code": "class Solution {\n    int MOD = (int)(1e9+7);\n\n    public int maxNiceDivisors(int n) {\n        if(n <= 3) return n;\n        \n        /*\n            Approach\n            let say\n            m = (p1 ^ e1) * (p2 ^ e2) ....  (pn ^ en)\n            where p1, p2 ..... pn are primes\n            and e1, e2, .. ..en are exponeent (power)\n            \n            As given n is the prime factor, \n            n will be n = e1 + e2 + e3 .... en\n            \n            and number of divisor will \n              divisorCount =  e1 * e2 * e3 .... en\n            \n            \n            As in give problem statement, we want maximum divisor count\n            so if want max divisor, so must large exponent,\n            for largerst exponent, we must have smallest prime number as\n            possible as.\n            \n            \n            for this we can use only 2 numbers ,  2 and 3 as prime numbers\n            \n            we can convert any big number into 2s, 3s power\n            \n            Algorithm\n            1. Keep adding 3s as long as n \\u2265 5 and then subtarct 3 \n            2. at end it will left, either 0, 2, 4\n            3. so multiple the result by remaining n (except 0)\n            \n        */\n        \n        \n        long divisorCount = 1L;\n        int remainder = n % 3;\n        \n        if(remainder == 0){\n            divisorCount = power(3, n / 3);\n        \n        }else if(remainder == 1) {\n            divisorCount = 4 * power(3, (n - 4) / 3); \n        \n        }else if(remainder == 2){\n            divisorCount = 2 * power(3, n / 3);\n        }\n        \n        return (int) (divisorCount % MOD);\n    }\n    \n    private long power(long num, long exp){\n        if (exp == 1) return num;\n        if (exp == 0) return 1;\n        \n        long k1 = power(num, exp / 2);\n        if (exp % 2 == 0) {\n            return (k1 * k1) % MOD;\n        } else {\n            return (k1 * k1 * num) % MOD;\n        }\n    }\n}",
        "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    int MOD = (int)(1e9+7);\\n\\n    public int maxNiceDivisors(int n) {\\n        if(n <= 3) return n;\\n        \\n        /*\\n            Approach\\n            let say\\n            m = (p1 ^ e1) * (p2 ^ e2) ....  (pn ^ en)\\n            where p1, p2 ..... pn are primes\\n            and e1, e2, .. ..en are exponeent (power)\\n            \\n            As given n is the prime factor, \\n            n will be n = e1 + e2 + e3 .... en\\n            \\n            and number of divisor will \\n              divisorCount =  e1 * e2 * e3 .... en\\n            \\n            \\n            As in give problem statement, we want maximum divisor count\\n            so if want max divisor, so must large exponent,\\n            for largerst exponent, we must have smallest prime number as\\n            possible as.\\n            \\n            \\n            for this we can use only 2 numbers ,  2 and 3 as prime numbers\\n            \\n            we can convert any big number into 2s, 3s power\\n            \\n            Algorithm\\n            1. Keep adding 3s as long as n \\u2265 5 and then subtarct 3 \\n            2. at end it will left, either 0, 2, 4\\n            3. so multiple the result by remaining n (except 0)\\n            \\n        */\\n        \\n        \\n        long divisorCount = 1L;\\n        int remainder = n % 3;\\n        \\n        if(remainder == 0){\\n            divisorCount = power(3, n / 3);\\n        \\n        }else if(remainder == 1) {\\n            divisorCount = 4 * power(3, (n - 4) / 3); \\n        \\n        }else if(remainder == 2){\\n            divisorCount = 2 * power(3, n / 3);\\n        }\\n        \\n        return (int) (divisorCount % MOD);\\n    }\\n    \\n    private long power(long num, long exp){\\n        if (exp == 1) return num;\\n        if (exp == 0) return 1;\\n        \\n        long k1 = power(num, exp / 2);\\n        if (exp % 2 == 0) {\\n            return (k1 * k1) % MOD;\\n        } else {\\n            return (k1 * k1 * num) % MOD;\\n        }\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    int MOD = (int)(1e9+7);\n\n    public int maxNiceDivisors(int n) {\n        if(n <= 3) return n;\n\n        long divisorCount = 1L;\n        int remainder = n % 3;\n        \n        if(remainder == 0){\n            divisorCount = power(3, n / 3);\n        \n        }else if(remainder == 1) {\n            divisorCount = 4 * power(3, (n - 1) / 3); \n        \n        }else if(remainder == 2){\n            divisorCount = 2 * power(3, n / 3);\n        }\n        \n        return (int) (divisorCount % MOD);\n    }\n    \n    private long power(long num, long exp){\n        if (exp == 1) return num;\n        if (exp == 0) return 1;\n        \n        long k1 = power(num, exp / 2);\n        if (exp % 2 == 0) {\n            return (k1 * k1) % MOD;\n        } else {\n            return (k1 * k1 * num) % MOD;\n        }\n    }\n}\n",
        "explanations": "\nChanged the 'n-4' to 'n-1' in the remainder equals 1 condition which causes incorrect computation.\n",
        "fixed_code": "\nclass Solution {\n    long MOD = (long)(1e9+7);\n\n    public int maxNiceDivisors(int n) {\n        if(n <= 3) return n;\n\n        long divisorCount = 1L;\n        int remainder = n % 3;\n        \n        if(remainder == 0){\n            divisorCount = power(3, n / 3);\n        } else if(remainder == 1) {\n            divisorCount = 4 * power(3, (n - 4) / 3);         \n        } else {\n            divisorCount = 2 * power(3, n / 3);\n        }\n        \n        return (int) (divisorCount % MOD);\n    }\n    \n    private long power(long a, long b){\n        if (b == 0) return 1;\n        if (b == 1) return a % MOD;\n\n        if (b % 2 == 0) {\n            long temp = power(a, b / 2);\n            return (temp * temp) % MOD;\n        } else {\n            return (a * power(a, b - 1)) % MOD;\n        }\n    }\n}\n",
        "fixing_exp": "\nMade MOD a long type variable; corrected the fault in the power method, also fixed the case when remainder equals to 1.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 39096000,
            "display_runtime": "0",
            "question_id": "1936",
            "elapsed_time": 112,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648221132,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 213,
            "total_testcases": 213,
            "runtime_percentile": 100,
            "status_memory": "39.1 MB",
            "memory_percentile": 66.2338,
            "pretty_lang": "Java",
            "submission_id": "1096157705",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximize-number-of-subsequences-in-a-string",
        "description": "You are given a 0-indexed string text and another 0-indexed string pattern of length 2, both of which consist of only lowercase English letters.\nYou can add either pattern[0] or pattern[1] anywhere in text exactly once. Note that the character can be added even at the beginning or at the end of text.\nReturn the maximum number of times pattern can occur as a subsequence of the modified text.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.",
        "examples": [
            "Input: text = \"abdcdbc\", pattern = \"ac\"\nOutput: 4\nExplanation:\nIf we add pattern[0] = 'a' in between text[1] and text[2], we get \"abadcdbc\". Now, the number of times \"ac\" occurs as a subsequence is 4.\nSome other strings which have 4 subsequences \"ac\" after adding a character to text are \"aabdcdbc\" and \"abdacdbc\".\nHowever, strings such as \"abdcadbc\", \"abdccdbc\", and \"abdcdbcc\", although obtainable, have only 3 subsequences \"ac\" and are thus suboptimal.\nIt can be shown that it is not possible to get more than 4 subsequences \"ac\" by adding only one character.",
            "Input: text = \"aabb\", pattern = \"ab\"\nOutput: 6\nExplanation:\nSome of the strings which can be obtained from text and have 6 subsequences \"ab\" are \"aaabb\", \"aaabb\", and \"aabbb\"."
        ],
        "constrains": "1 <= text.length <= 105\npattern.length == 2\ntext and pattern consist only of lowercase English letters.",
        "release_time": 1647705692,
        "oracle_code": "class Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 1;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n            if (s.charAt(i) == p.charAt(0)) cnt++;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 1;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n            if (s.charAt(i) == p.charAt(1)) cnt++;\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}",
        "content": "```\\nclass Solution {\\n\\n    public long maximumSubsequenceCount(String s, String p) {\\n        long ans = 0, max = 0;\\n        int cnt = 1;\\n        //Assume adding 0th character of pattern at starting\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(0)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        ans = 0; cnt = 1;\\n        //Assume adding second character of pattern at end\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(1)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        return max;\\n    }\\n}\\n```\\n",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 1;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n            if (s.charAt(i) == p.charAt(0)) cnt--;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 1;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n            if (s.charAt(i) == p.charAt(1)) cnt++;\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}\n",
        "explanations": "\nThe counter 'cnt' is decremented instead of incremented when 0th character of pattern is found.\n",
        "fixed_code": "\nclass Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 0;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(0)) cnt++;\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 0;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(1)) cnt++;\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}\n",
        "fixing_exp": "\nFixed the sequence of increment for 'cnt' and increment of 'ans', as well as corrected 'cnt' initialization to 0.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 44488000,
            "display_runtime": "30",
            "question_id": "2309",
            "elapsed_time": 219,
            "compare_result": "0011110111111010111011110110000000000010000000000000000000001100001000000000000000010000000000000000000000000000000000100000000000000000001100000001000011110000001100000000",
            "code_output": "2",
            "std_output": "",
            "last_testcase": "\"abdcdbc\"\n\"ac\"",
            "expected_output": "4",
            "task_finish_time": 1699648237916,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 35,
            "total_testcases": 172,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096157830",
            "input_formatted": "\"abdcdbc\", \"ac\"",
            "input": "\"abdcdbc\"\n\"ac\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "destroying-asteroids",
        "description": "You are given an integer mass, which represents the original mass of a planet. You are further given an integer array asteroids, where asteroids[i] is the mass of the ith asteroid.\nYou can arrange for the planet to collide with the asteroids in any arbitrary order. If the mass of the planet is greater than or equal to the mass of the asteroid, the asteroid is destroyed and the planet gains the mass of the asteroid. Otherwise, the planet is destroyed.\nReturn true if all asteroids can be destroyed. Otherwise, return false.",
        "examples": [
            "Input: mass = 10, asteroids = [3,9,19,5,21]\nOutput: true\nExplanation: One way to order the asteroids is [9,19,5,3,21]:\n- The planet collides with the asteroid with a mass of 9. New planet mass: 10 + 9 = 19\n- The planet collides with the asteroid with a mass of 19. New planet mass: 19 + 19 = 38\n- The planet collides with the asteroid with a mass of 5. New planet mass: 38 + 5 = 43\n- The planet collides with the asteroid with a mass of 3. New planet mass: 43 + 3 = 46\n- The planet collides with the asteroid with a mass of 21. New planet mass: 46 + 21 = 67\nAll asteroids are destroyed.",
            "Input: mass = 5, asteroids = [4,9,23,4]\nOutput: false\nExplanation: \nThe planet cannot ever gain enough mass to destroy the asteroid with a mass of 23.\nAfter the planet destroys the other asteroids, it will have a mass of 5 + 4 + 9 + 4 = 22.\nThis is less than 23, so a collision would not destroy the last asteroid."
        ],
        "constrains": "1 <= mass <= 105\n1 <= asteroids.length <= 105\n1 <= asteroids[i] <= 105",
        "release_time": 1680364813,
        "oracle_code": "class Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c+=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        int c=0;\\n        long s=(long)mass;\\n        for(int i=0;i<asteroids.length;i++)\\n        {\\n            long d=(long)asteroids[i];\\n            if(s>=d)\\n            {\\n                c+=1;\\n                s+=d;\\n            }\\n        }\\n        if(c==asteroids.length)return true;\\n        else return false;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c-=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}\n",
        "explanations": "\nDecremented 'c' instead of incrementing causing the function to return incorrect results.\n",
        "fixed_code": "\nclass Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c+=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}\n",
        "fixing_exp": "\nChanged \"c-=1\" to \"c+=1\" because we want to increment the variable c, not decrement it.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "22 ms",
            "memory": 57536000,
            "display_runtime": "22",
            "question_id": "2245",
            "elapsed_time": 393,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648254282,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 68,
            "total_testcases": 68,
            "runtime_percentile": 83.6065,
            "status_memory": "57.5 MB",
            "memory_percentile": 27.86919999999995,
            "pretty_lang": "Java",
            "submission_id": "1096157933",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-number-of-achievable-transfer-requests",
        "description": "We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\nYou are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\nAll buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\nReturn the maximum number of achievable requests.",
        "examples": [
            "Input: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\nOutput: 5\nExplantion: Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.",
            "Input: n = 3, requests = [[0,0],[1,2],[2,1]]\nOutput: 3\nExplantion: Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests.",
            "Input: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\nOutput: 4"
        ],
        "constrains": "1 <= n <= 20\n1 <= requests.length <= 16\nrequests[i].length == 2\n0 <= fromi, toi < n",
        "release_time": 1688260744,
        "oracle_code": "class Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        l=len(requests)\n        for i in range(l,0,-1):\n            for j in combinations(requests,i):\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\n                    return i\n\n        return 0",
        "content": "\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        l=len(requests)\\n        for i in range(l,0,-1):\\n            for j in combinations(requests,i):\\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\\n                    return i\\n\\n        return 0            \\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        l=len(requests)\n        for i in range(l,0,-1):\n            for j in combinations(requests,i):\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\n                    return i-1\n        return 0\n",
        "explanations": "\nThe function incorrectly returns i - 1 rather than i, leading to inconsistent results.\n",
        "fixed_code": "\nclass Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        l=len(requests)\n        for i in range(l,0,-1):\n            for j in combinations(requests,i):\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\n                    return i\n        return 0\n",
        "fixing_exp": "\nThe decrementation of \"i\" before the return statement was unnecessary and has been removed.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 20,
            "lang": "java",
            "run_success": false,
            "compile_error": "Line 2: error: '{' expected",
            "full_compile_error": "Line 2: error: '{' expected\nclass Solution:\n              ^\nLine 3: error: class, interface, enum, or record expected\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n                                 ^\n2 errors",
            "status_runtime": "N/A",
            "memory": 0,
            "question_id": "1723",
            "task_finish_time": 1699648268784,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": null,
            "total_testcases": null,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096158053",
            "status_msg": "Compile Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "count-largest-group",
        "description": "You are given an integer n.\nEach number from 1 to n is grouped according to the sum of its digits.\nReturn the number of groups that have the largest size.",
        "examples": [
            "Input: n = 13\nOutput: 4\nExplanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13:\n[1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9].\nThere are 4 groups with largest size.",
            "Input: n = 2\nOutput: 2\nExplanation: There are 2 groups [1], [2] of size 1."
        ],
        "constrains": "1 <= n <= 104",
        "release_time": 1655802809,
        "oracle_code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n\n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return 1 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n            }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}\n",
        "explanations": "\nIn the countDigits method, it was supposed to return n%10 + countDigits(n/10), but it now returns 1 + countDigits(n/10). So instead of the sum of all digits of number 'n', it returns the number of digits in 'n'. \n",
        "fixed_code": "\nclass Solution {\n\n    int getSumOfDigits(int n) {\n        int sum = 0;\n        while (n != 0) {\n            sum = sum + n % 10;\n            n = n / 10;\n        }\n        return sum;\n    }\n\n    public int countLargestGroup(int n) {\n        int[] count = new int[37];\n        int max = 0, res = 0;\n        \n        for (int i = 1; i <= n; i++) {\n            int sum = getSumOfDigits(i);\n            count[sum]++;\n            max = Math.max(max, count[sum]);\n        }\n\n        for (int freq : count)\n            if (freq == max)\n                res++;\n\n        return res;\n    }\n}\n",
        "fixing_exp": "\nThe method \"countDigits\" was erroneously summing the count of digits instead of their values for each integer 'i'.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "5 ms",
            "memory": 39472000,
            "display_runtime": "5",
            "question_id": "1500",
            "elapsed_time": 122,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648285822,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 75,
            "total_testcases": 75,
            "runtime_percentile": 65.7993,
            "status_memory": "39.5 MB",
            "memory_percentile": 70.632,
            "pretty_lang": "Java",
            "submission_id": "1096158188",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "orderly-queue",
        "description": "You are given a string s and an integer k. You can choose one of the first k letters of s and append it at the end of the string..\nReturn the lexicographically smallest string you could have after applying the mentioned step any number of moves.",
        "examples": [
            "Input: s = \"cba\", k = 1\nOutput: \"acb\"\nExplanation: \nIn the first move, we move the 1st character 'c' to the end, obtaining the string \"bac\".\nIn the second move, we move the 1st character 'b' to the end, obtaining the final result \"acb\".",
            "Input: s = \"baaca\", k = 3\nOutput: \"aaabc\"\nExplanation: \nIn the first move, we move the 1st character 'b' to the end, obtaining the string \"aacab\".\nIn the second move, we move the 3rd character 'c' to the end, obtaining the final result \"aaabc\"."
        ],
        "constrains": "1 <= k <= s.length <= 1000\ns consist of lowercase English letters.",
        "release_time": 1667735681,
        "oracle_code": "class Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\n                    str2=s;                     //store smaller lexo combo\n                } \n             }\n             return str2;\n        }     \n    }\n}",
        "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(2)+s.charAt(1); \n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\n                    str2=s;                     //store smaller lexo combo\n                } \n             }\n             return str2;\n        }     \n    }\n}\n",
        "explanations": "\nNow we're moving the second character to the end, which isn't correct when k=1.\n",
        "fixed_code": "\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){\n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{\n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(1)+s.charAt(0);\n                if(str2.compareTo(s)>0){\n                    str2=s;\n                } \n             }\n             return str2;\n        }     \n    }\n}\n",
        "fixing_exp": "\nThe error was in the substrings indexes, you want to move the first to last, not the second to last.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "7 ms",
            "memory": 43996000,
            "display_runtime": "7",
            "question_id": "935",
            "elapsed_time": 141,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648300360,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 112,
            "total_testcases": 112,
            "runtime_percentile": 23.89369999999998,
            "status_memory": "44 MB",
            "memory_percentile": 8.849199999999943,
            "pretty_lang": "Java",
            "submission_id": "1096158298",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "find-palindrome-with-fixed-length",
        "description": "Given an integer array queries and a positive integer intLength, return an array answer where answer[i] is either the queries[i]th smallest positive palindrome of length intLength or -1 if no such palindrome exists.\nA palindrome is a number that reads the same backwards and forwards. Palindromes cannot have leading zeros.",
        "examples": [
            "Input: queries = [1,2,3,4,5,90], intLength = 3\nOutput: [101,111,121,131,141,999]\nExplanation:\nThe first few palindromes of length 3 are:\n101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, ...\nThe 90th palindrome of length 3 is 999.",
            "Input: queries = [2,4,6], intLength = 4\nOutput: [1111,1331,1551]\nExplanation:\nThe first six palindromes of length 4 are:\n1001, 1111, 1221, 1331, 1441, and 1551."
        ],
        "constrains": "1 <= queries.length <= 5 * 104\n1 <= queries[i] <= 109\n1 <= intLength\u00a0<= 15",
        "release_time": 1690442915,
        "oracle_code": "class Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        \n        int palindrome_present = ( intLength+1 )/2 ;\n        \n        long l=(long)Math.pow(10,palindrome_present-1); //10\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\n        for(int q:queries){\n            if(q<=(r-l+1)){\n                String left_half=Long.toString(l+q-1);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n                \n            }\n            else{\n                ans[ans_i]=-1;\n            }\n            \n            ans_i++;\n        }\n        \n        return ans;\n    }\n}",
        "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        \n        int palindrome_present = ( intLength+1 )/2 ;\n        \n        long l=(long)Math.pow(10,palindrome_present-1); //10\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\n        for(int q:queries){\n            \n            if(q<=(r-l+1)){\n                String left_half=Long.toString(l+q-1);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=-1; \n                \n            }\n            else{\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n            }\n            \n            ans_i++;\n        }\n        \n        return ans;\n    }\n}\n",
        "explanations": "\nThe 'else' and 'if' conditions logic is swapped causing incorrect assignment of result.\n",
        "fixed_code": "\nclass Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        int palindrome_present = ( intLength+1 )/2 ;\n        \n        long l=(long)Math.pow(10,palindrome_present-1); \n        long r=(long)Math.pow(10,palindrome_present)-1; \n        for(int q:queries){\n            String left_half = \"\";\n            if(q<=(r-l+1)){\n                left_half=Long.toString(l+q-1);\n                ans[ans_i]=-1; \n            }\n            else{\n                left_half=Long.toString(l+q-2);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n            }\n            \n            ans_i++;\n        }\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nMoved 'left_half' variable outside the if statement and supplied appropriate value in else block.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 40472000,
            "question_id": "1375",
            "elapsed_time": 102,
            "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "[-1,-1,-1,-1,-1,-1]",
            "std_output": "",
            "last_testcase": "[1,2,3,4,5,90]\n3",
            "expected_output": "[101,111,121,131,141,999]",
            "task_finish_time": 1699648315015,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 162,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096158393",
            "input_formatted": "[1,2,3,4,5,90], 3",
            "input": "[1,2,3,4,5,90]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-product-difference-between-two-pairs",
        "description": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\n\nFor example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\n\nGiven an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\nReturn the maximum such product difference.",
        "examples": [
            "Input: nums = [5,6,2,7,4]\r\nOutput: 34\r\nExplanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34.",
            "Input: nums = [4,2,5,9,7,4,8]\r\nOutput: 64\r\nExplanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64."
        ],
        "constrains": "4 <= nums.length <= 104\n1 <= nums[i] <= 104",
        "release_time": 1683517149,
        "oracle_code": "class Solution {\n    public int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        int n =nums.length;\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\n    }\n}",
        "content": "\\n\\n#  Superb Logic in java\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n}\\n```\\n# please upvote me it would encourages me so much",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        int n =nums.length;\n    return nums[n-1]*nums[n-3]-nums[0]*nums[1];\n    }\n}\n",
        "explanations": "\nThe second highest number is 'nums[n-2]' not 'nums[n-3]' causing a miscalculated product difference.\n",
        "fixed_code": "\nclass Solution {\n    public int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        int n =nums.length;\n        return nums[n-1]*nums[n-2]-nums[0]*nums[1];\n    }\n}\n",
        "fixing_exp": "\nTo maximize the difference, we should use two largest numbers rather than using third largest number. Therefore, replaced n-3 with n-2.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "8 ms",
            "memory": 43932000,
            "display_runtime": "8",
            "question_id": "2042",
            "elapsed_time": 232,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648330766,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 96,
            "total_testcases": 96,
            "runtime_percentile": 11.955199999999977,
            "status_memory": "43.9 MB",
            "memory_percentile": 60.585200000000036,
            "pretty_lang": "Java",
            "submission_id": "1096158502",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "tuple-with-same-product",
        "description": "Given an array nums of distinct positive integers, return the number of tuples (a, b, c, d) such that a * b = c * d where a, b, c, and d are elements of nums, and a != b != c != d.",
        "examples": [
            "Input: nums = [2,3,4,6]\nOutput: 8\nExplanation: There are 8 valid tuples:\n(2,6,3,4) , (2,6,4,3) , (6,2,3,4) , (6,2,4,3)\n(3,4,2,6) , (4,3,2,6) , (3,4,6,2) , (4,3,6,2)",
            "Input: nums = [1,2,4,5,10]\nOutput: 16\nExplanation: There are 16 valid tuples:\n(1,10,2,5) , (1,10,5,2) , (10,1,2,5) , (10,1,5,2)\n(2,5,1,10) , (2,5,10,1) , (5,2,1,10) , (5,2,10,1)\n(2,10,4,5) , (2,10,5,4) , (10,2,4,5) , (10,2,5,4)\n(4,5,2,10) , (4,5,10,2) , (5,4,2,10) , (5,4,10,2)"
        ],
        "constrains": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104\nAll elements in nums are distinct.",
        "release_time": 1611201483,
        "oracle_code": "class Solution {\n    public int tupleSameProduct(int[] nums) {\n        \n        if(nums.length < 4){\n            return 0;\n        }\n        \n        int res = 0;\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < nums.length - 1; i++){\n            \n            for(int j = i + 1; j < nums.length; j++){\n                \n                int val = nums[i] * nums[j];\n                map.put(val, map.getOrDefault(val, 0) + 1);\n            }\n        }\n        \n        for(int key : map.keySet()){\n            \n            int val = map.get(key);\n            \n            if(val > 1){\n                res += val * (val - 1) * 4;    // (val * (val - 1) / 2) * 8\n            }\n        }\n        \n        return res;\n    }\n}",
        "content": "Main idea :\\nA possible sequence can have 8 possible arrangements\\na * b = c * d\\nWe can\\'t choose all 4 numbers (a, b, c, d) from the array as it will increase time complexity ( O(n^4) )\\nBut we can choose 2 numbers as O(n^2) solution is allowed because of constraints\\nWe will store the product of a and b in a HashMap corresponding to its frequency(Why : Because then we can compare it with c * d)\\nSince all elements are distinct, there won\\'t be any duplicacy ( a != b != c != d )\\nTo get the solution we have to choose 2 equal products ( Since a * b = c * d ) (a * b = first pair and c * d = second pair)\\nnC2 = n * (n - 1) / 2\\nThen we have to multiply this by 8 because a possible sequence can have 8 arrangements\\n\\n```\\nclass Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        \\n        if(nums.length < 4){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length - 1; i++){\\n            \\n            for(int j = i + 1; j < nums.length; j++){\\n                \\n                int val = nums[i] * nums[j];\\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n            }\\n        }\\n        \\n        for(int key : map.keySet()){\\n            \\n            int val = map.get(key);\\n            \\n            if(val > 1){\\n                res += val * (val - 1) * 4;    // (val * (val - 1) / 2) * 8\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nIf you liked this post, Please Upvote",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        \n        if(nums.length < 4){\n            return 0;\n        }\n        \n        int res = 0;\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < nums.length - 1; i++){\n            \n            for(int j = i + 1; j < nums.length; j++){\n                \n                int val = nums[i] * nums[j];\n                map.put(val, map.getOrDefault(val, 0) + 1);\n            }\n        }\n        \n        for(int key : map.keySet()){\n            \n            int val = map.get(key);\n            \n            if(val > 1){\n                res += val * val * 4;    \n            }\n        }\n        \n        return res;\n    }\n}\n",
        "explanations": "\nThe bug in this code is that the calculation in the code is val * val * 4 instead of val * (val - 1) * 4 which results in wrongly calculated result.\n",
        "fixed_code": "\nclass Solution {\n    public int tupleSameProduct(int[] nums) {\n        \n        if(nums.length < 4){\n            return 0;\n        }\n        \n        int res = 0;\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < nums.length - 1; i++){\n            \n            for(int j = i + 1; j < nums.length; j++){\n                \n                int val = nums[i] * nums[j];\n                map.put(val, map.getOrDefault(val, 0) + 1);\n            }\n        }\n        \n        for(int key : map.keySet()){\n            \n            int val = map.get(key);\n            \n            if(val > 1){\n                res += val * (val - 1) * 4;    \n            }\n        }\n        \n        return res;\n    }\n}\n",
        "fixing_exp": "\nThe product calculation is wrong, it should be number of tuples times (number of tuples - 1) times 4.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "277 ms",
            "memory": 66804000,
            "display_runtime": "277",
            "question_id": "1364",
            "elapsed_time": 742,
            "compare_result": "1111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648348347,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 37,
            "total_testcases": 37,
            "runtime_percentile": 13.532499999999992,
            "status_memory": "66.8 MB",
            "memory_percentile": 52.63149999999994,
            "pretty_lang": "Java",
            "submission_id": "1096158629",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "description": "Given an integer array nums, return the number of all the arithmetic subsequences of nums.\nA sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n\nFor example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\nFor example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nThe test cases are generated so that the answer fits in 32-bit integer.",
        "examples": [
            "Input: nums = [2,4,6,8,10]\nOutput: 7\nExplanation: All arithmetic subsequence slices are:\n[2,4,6]\n[4,6,8]\n[6,8,10]\n[2,4,6,8]\n[4,6,8,10]\n[2,4,6,8,10]\n[2,6,10]",
            "Input: nums = [7,7,7,7,7]\nOutput: 16\nExplanation: Any subsequence of this array is arithmetic."
        ],
        "constrains": "1\u00a0 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1",
        "release_time": 1669530463,
        "oracle_code": "class Solution {\n\tpublic int numberOfArithmeticSlices(int[] arr) {\n\t\tint n = arr.length;\n\t\tHashMap<Integer, Integer>[] map = new HashMap[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = new HashMap<>();\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tlong cd = (long) arr[i] - (long) arr[j];\n\t\t\t\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\tint asj = map[j].getOrDefault((int) cd, 0);\n\t\t\t\tint asi = map[i].getOrDefault((int) cd, 0);\n\t\t\t\tans += asj;\n\t\t\t\tmap[i].put((int) cd, asi + asj + 1);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}",
        "content": "# Code\\n```\\nclass Solution {\\n\\tpublic int numberOfArithmeticSlices(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tHashMap<Integer, Integer>[] map = new HashMap[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tmap[i] = new HashMap<>();\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tlong cd = (long) arr[i] - (long) arr[j];\\n\\t\\t\\t\\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint asj = map[j].getOrDefault((int) cd, 0);\\n\\t\\t\\t\\tint asi = map[i].getOrDefault((int) cd, 0);\\n\\t\\t\\t\\tans += asj;\\n\\t\\t\\t\\tmap[i].put((int) cd, asi + asj + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n\tpublic int numberOfArithmeticSlices(int[] arr) {\n\t\tint n = arr.length;\n\t\tHashMap<Integer, Integer>[] map = new HashMap[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = new HashMap<>();\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tlong cd = (long) arr[i] - (long) arr[j];\n\t\t\t\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\tint asj = map[j].getOrDefault((int) cd, 0);\n\t\t\t\tint asi = map[i].getOrDefault((int) cd, 0);\n\t\t\t\tans += asj;\n\t\t\t\tmap[i].put((int) cd, asi + 1); \n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "explanations": "\nThe bug is within the updating HashMap step, it should have added 'asj + 1' instead of '1'.\n",
        "fixed_code": "\nimport java.util.*;\n\nclass Solution {\n\tpublic int numberOfArithmeticSlices(int[] arr) {\n\t\tint n = arr.length;\n\t\tMap<Integer, Integer>[] map = new Map[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = new HashMap<>();\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tlong cd = (long) arr[i] - (long) arr[j];\n\t\t\t\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\tint asj = map[j].getOrDefault((int) cd, 0);\n\t\t\t\tint asi = map[i].getOrDefault((int) cd, 0);\n\t\t\t\tans += asj;\n\t\t\t\tmap[i].put((int) cd, asi + 1); \n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "fixing_exp": "\nChanged HashMap to Map at the declaration to follow good programming practices.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 88496000,
            "display_runtime": "123",
            "question_id": "446",
            "elapsed_time": 392,
            "compare_result": "00111000000011111110000000000000000000000000000000000000000000000000011111111011111101111000000000011",
            "code_output": "4",
            "std_output": "",
            "last_testcase": "[2,4,6,8,10]",
            "expected_output": "7",
            "task_finish_time": 1699648367356,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 30,
            "total_testcases": 101,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096158772",
            "input_formatted": "[2,4,6,8,10]",
            "input": "[2,4,6,8,10]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constrains": "1 <= s.length <= 300\ns contains only lowercase English letters.",
        "release_time": 1675183693,
        "oracle_code": "class Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        int res=-1;\n        HashMap<Character,Integer> hm=new HashMap<>();\n        for(int i=0;i<s.length();i++){\n            char c=s.charAt(i);\n            if(hm.containsKey(c))\n                res=Math.max(res,i-hm.get(c)-1);\n            else\n                hm.put(c,i);\n        }\n\n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Store each char along with their position in a HashMap.\\n- If a char occurs again, calc their index diffrences.\\n- return the max difference.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(min(n, k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hm.containsKey(c))\\n                res=Math.max(res,i-hm.get(c)-1);\\n            else\\n                hm.put(c,i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        int res=-1;\n        HashMap<Character,Integer> hm=new HashMap<>();\n        for(int i=0;i<s.length();i++){\n            char c=s.charAt(i);\n            if(hm.containsKey(c))\n                res=Math.max(res,i-hm.get(c)+1); \n            else\n                hm.put(c,i);\n        }\n\n        return res;\n    }\n}\n",
        "explanations": "\nChanging -1 to +1 in the max calculation doesn't give the correct distance between identical characters.\n",
        "fixed_code": "\nclass Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        int res=-1;\n        HashMap<Character,Integer> hm=new HashMap<>();\n        for(int i=0;i<s.length();i++){\n            char c=s.charAt(i);\n            if(hm.containsKey(c))\n                res=Math.max(res,i-hm.get(c)-1); \n            else\n                hm.put(c,i);\n        }\n\n        return res;\n    }\n}\n",
        "fixing_exp": "\nSubtract 1 instead of add 1 to get the correct length between equal characters.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 40392000,
            "display_runtime": "1",
            "question_id": "1746",
            "elapsed_time": 132,
            "compare_result": "111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648381895,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 54,
            "total_testcases": 54,
            "runtime_percentile": 88.3117,
            "status_memory": "40.4 MB",
            "memory_percentile": 48.91759999999999,
            "pretty_lang": "Java",
            "submission_id": "1096158899",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "difference-between-element-sum-and-digit-sum-of-an-array",
        "description": "You are given a positive integer array nums.\n\nThe element sum is the sum of all the elements in nums.\nThe digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\n\nReturn the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.",
        "examples": [
            "Input: nums = [1,15,6,3]\nOutput: 9\nExplanation: \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.",
            "Input: nums = [1,2,3,4]\nOutput: 0\nExplanation:\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0."
        ],
        "constrains": "1 <= nums.length <= 2000\n1 <= nums[i] <= 2000",
        "release_time": 1683903237,
        "oracle_code": "class Solution {\n    public int differenceOfSum(int[] nums) {\n        \n        int sum=0;\n        int digitSum=0;\n\n        for(int num:nums){\n            sum+=num;\n\n            while(num>0){\n                int digit=num%10;\n                digitSum+=digit;\n                num/=10;\n            }\n\n        }\n\n        return sum-digitSum;\n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n*k) and for second code O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) and for second code O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int differenceOfSum(int[] nums) {\\n        \\n        int sum=0;\\n        int digitSum=0;\\n\\n        for(int num:nums){\\n            sum+=num;\\n\\n            while(num>0){\\n                int digit=num%10;\\n                digitSum+=digit;\\n                num/=10;\\n            }\\n\\n        }\\n\\n        return sum-digitSum;\\n    }\\n}\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int differenceOfSum(int[] nums) {\\n\\n        // sum the all element \\n        String digit=\"\";\\n        int sum=0;\\n        for(int num: nums) {\\n            sum+=num;\\n            digit+=num;\\n        \\n        }\\n\\n        int digitSum=0;\\n        for(int i=0;i<digit.length();i++){\\n            digitSum+=digit.charAt(i)-\\'0\\';\\n        }\\nreturn sum-digitSum;\\n    }\\n}\\n```\\n\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int differenceOfSum(int[] nums) {\n        \n        int sum=0;\n        int digitSum=0;\n\n        for(int num:nums){\n            sum+=num;\n\n            while(num>0){\n                int digit=num%10;\n                digitSum+=digit;\n                num=num/100;\n            }\n\n        }\n\n        return sum-digitSum;\n    }\n}\n",
        "explanations": "\nThe logic error is in line number 13. num should be divided by 10, not 100.\n",
        "fixed_code": "\nclass Solution {\n    public int differenceOfSum(int[] nums) {\n        \n        int sum=0;\n        int digitSum=0;\n\n        for(int num:nums){\n            sum+=num;\n            int tempNum = num;\n\n            while(tempNum>0){\n                int digit=tempNum%10;\n                digitSum+=digit;\n                tempNum=tempNum/10;\n            }\n\n        }\n\n        return sum-digitSum;\n    }\n}\n",
        "fixing_exp": "\nThe inner while loop was incorrectly dividing the number by 100 and also modifying the original number. It should divide by 10 and not modify the original number.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "2 ms",
            "memory": 43752000,
            "display_runtime": "2",
            "question_id": "2624",
            "elapsed_time": 170,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648397119,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 142,
            "total_testcases": 142,
            "runtime_percentile": 98.1797,
            "status_memory": "43.8 MB",
            "memory_percentile": 42.093500000000034,
            "pretty_lang": "Java",
            "submission_id": "1096159023",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "reverse-words-in-a-string",
        "description": "Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.",
        "examples": [
            "Input: s = \"the sky is blue\"\nOutput: \"blue is sky the\"",
            "Input: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.",
            "Input: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string."
        ],
        "constrains": "1 <= s.length <= 104\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n\n\u00a0\nFollow-up:\u00a0If the string data type is mutable in your language, can\u00a0you solve it\u00a0in-place\u00a0with\u00a0O(1)\u00a0extra space?",
        "release_time": 1692301725,
        "oracle_code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}\n",
        "explanations": "\nI'm removing crucial characters through `s.substring(start+1, i)`, which leads to incorrect reversed words.\n",
        "fixed_code": "\nclass Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        int i = s.length() - 1;\n        while(i >= 0){\n            if(s.charAt(i)==' '){\n                i--;\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}\n",
        "fixing_exp": "\nFixed \"for loop\" to \"while loop\", missing decrement i operator, and wrong substring parameters end index by adding 1.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 41896000,
            "display_runtime": "4",
            "question_id": "151",
            "elapsed_time": 165,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648412321,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 58,
            "total_testcases": 58,
            "runtime_percentile": 95.7586,
            "status_memory": "41.9 MB",
            "memory_percentile": 82.67230000000004,
            "pretty_lang": "Java",
            "submission_id": "1096159143",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-arithmetic-triplets",
        "description": "You are given a 0-indexed, strictly increasing integer array nums and a positive integer diff. A triplet (i, j, k) is an arithmetic triplet if the following conditions are met:\n\ni < j < k,\nnums[j] - nums[i] == diff, and\nnums[k] - nums[j] == diff.\n\nReturn the number of unique arithmetic triplets.",
        "examples": [
            "Input: nums = [0,1,4,6,7,10], diff = 3\nOutput: 2\nExplanation:\n(1, 2, 4) is an arithmetic triplet because both 7 - 4 == 3 and 4 - 1 == 3.\n(2, 4, 5) is an arithmetic triplet because both 10 - 7 == 3 and 7 - 4 == 3.",
            "Input: nums = [4,5,6,7,8,9], diff = 2\nOutput: 2\nExplanation:\n(0, 2, 4) is an arithmetic triplet because both 8 - 6 == 2 and 6 - 4 == 2.\n(1, 3, 5) is an arithmetic triplet because both 9 - 7 == 2 and 7 - 5 == 2."
        ],
        "constrains": "3 <= nums.length <= 200\n0 <= nums[i] <= 200\n1 <= diff <= 50\nnums is strictly increasing.",
        "release_time": 1688291896,
        "oracle_code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        }\n\n        return ans;\n        \n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find a triplet of (i, j, k) such that \\ni<j<k , \\nnums[j] - nums[i] == diff, and \\nnums[k] - nums[j] == diff\\n\\nin other word we can also say nums[k]-nums[i]== 2*diff. To reduce the time complexity I use only 2 loop remove the loop for k and include it in j iterartion such that nums[j]-nums[i] == 2*diff. So in every iterartion of j we will get 2 condition nums[j]-nums[i] == diff and nums[j]-nums[i] == 2*diff when these 2 condition get satisfied in j iterartion, We get 1 count as answer. So for every iteration when count>=2 we add 1 to ans and at last return it.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int ans =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            int count =0;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count >= 2){\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff || nums[j]+nums[i]==2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        }\n\n        return ans;\n        \n    }\n}\n",
        "explanations": "\nThe bug is in the if statement. It should be \"nums[j]-nums[i]==2*diff\", not \"nums[j]+nums[i]==2*diff\".\n",
        "fixed_code": "\nclass Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff){\n                    count++;\n                    if(count >= 2){\n                        ans++;\n                        break;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nThe third numbers in the triplet were incorrectly calculated, and the count must be checked inside the loop.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 40256000,
            "display_runtime": "2",
            "question_id": "2442",
            "elapsed_time": 130,
            "compare_result": "00011111101111011110111111111111111111111101101111111111110101111100000000000000000000000000000000000001",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[0,1,4,6,7,10]\n3",
            "expected_output": "2",
            "task_finish_time": 1699648427938,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 57,
            "total_testcases": 104,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096159248",
            "input_formatted": "[0,1,4,6,7,10], 3",
            "input": "[0,1,4,6,7,10]\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums\u00a0should hold the final result. It does not matter what you leave beyond the first\u00a0k\u00a0elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\n\nIf all assertions pass, then your solution will be accepted.",
        "examples": [
            "Input: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).",
            "Input: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores)."
        ],
        "constrains": "1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.",
        "release_time": 1680527006,
        "oracle_code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n     int   index = 1;\n      int  count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i] == nums[i-1]){\n                count++;\n            }\n            else{\n                count = 0;\n            }\n\n            if(count <= 1){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others**Bold**\\n![download.jfif](https://assets.leetcode.com/users/images/e1f75de3-02bf-44d0-bb86-208e5309d274_1680526945.9427269.jpeg)",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n     int   index = 1;\n      int  count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i] == nums[i-1]){\n                count++;\n            }\n            else{\n                count++;\n            }\n\n            if(count <= 1){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}\n",
        "explanations": "\nIncrements count even if current number is not the same as previous, causing inaccurate counting.\n",
        "fixed_code": "\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if(nums.length == 0) return 0;\n        int index = 1;\n        for(int i = 1; i<nums.length; i++){\n            if(nums[i] != nums[i-1]){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}\n",
        "fixing_exp": "\nThe counting duplicates and checking count was unnecessary. It's required to place unique elements to front.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 43616000,
            "display_runtime": "0",
            "question_id": "80",
            "elapsed_time": 162,
            "compare_result": "001010001000000000000000000100000000000000000000000001001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001",
            "code_output": "[1,2,3]",
            "std_output": "",
            "last_testcase": "[1,1,1,2,2,3]",
            "expected_output": "[1,1,2,2,3]",
            "task_finish_time": 1699648442583,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 7,
            "total_testcases": 165,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096159364",
            "input_formatted": "[1,1,1,2,2,3]",
            "input": "[1,1,1,2,2,3]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "description": "Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\nOutput: [3,9,20,null,null,15,7]",
            "Input: inorder = [-1], postorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= inorder.length <= 3000\npostorder.length == inorder.length\n-3000 <= inorder[i], postorder[i] <= 3000\ninorder and postorder consist of unique values.\nEach value of postorder also appears in inorder.\ninorder is guaranteed to be the inorder traversal of the tree.\npostorder is guaranteed to be the postorder traversal of the tree.",
        "release_time": 1689531937,
        "oracle_code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return buildTree(0, postorder.length - 2, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}\n",
        "explanations": "\nIn the call to buildTree() method, postorder.length - 2 will skip the last element.\n",
        "fixed_code": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        \n        return helper(0, inorder.length - 1, postorder, m);\n    }\n\n    private TreeNode helper(int l, int r, int[] postorder, Map<Integer, Integer> m) {\n        if (l > r) return null;\n\n        TreeNode root = new TreeNode(postorder[index]);\n        int mid = m.get(root.val);\n        index--;\n\n        root.right = helper(mid + 1, r, postorder, m);\n        root.left = helper(l, mid - 1, postorder, m);\n\n        return root;\n    }\n}\n",
        "fixing_exp": "\nThe method needs to be correctly referenced as helper instead of buildTree in recursion.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 43748000,
            "display_runtime": "1",
            "question_id": "106",
            "elapsed_time": 116,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648462532,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 202,
            "total_testcases": 202,
            "runtime_percentile": 97.7079,
            "status_memory": "43.7 MB",
            "memory_percentile": 13.338300000000011,
            "pretty_lang": "Java",
            "submission_id": "1096159484",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "convert-the-temperature",
        "description": "You are given a non-negative floating point number rounded to two decimal places celsius, that denotes the temperature in Celsius.\nYou should convert Celsius into Kelvin and Fahrenheit and return it as an array ans = [kelvin, fahrenheit].\nReturn the array ans. Answers within 10-5 of the actual answer will be accepted.\nNote that:\n\nKelvin = Celsius + 273.15\nFahrenheit = Celsius * 1.80 + 32.00",
        "examples": [
            "Input: celsius = 36.50\nOutput: [309.65000,97.70000]\nExplanation: Temperature at 36.50 Celsius converted in Kelvin is 309.65 and converted in Fahrenheit is 97.70.",
            "Input: celsius = 122.11\nOutput: [395.26000,251.79800]\nExplanation: Temperature at 122.11 Celsius converted in Kelvin is 395.26 and converted in Fahrenheit is 251.798."
        ],
        "constrains": "0 <= celsius <= 1000",
        "release_time": 1668314039,
        "oracle_code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 237.15;\n        return arr;\n    }\n}\n",
        "explanations": "\nThe conversion from Celsius to Kelvin is incorrect, it should be 273.15, not 237.15.\n",
        "fixed_code": "\nclass Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[0] = (celsius * 9.0/5.0) + 32.0;\n        arr[1] = celsius + 273.15;\n        return arr;\n    }\n}\n",
        "fixing_exp": "\nSwapped Fahrenheit and Kelvin conversions and corrected Kelvin conversion formula.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 40512000,
            "display_runtime": "0",
            "question_id": "2556",
            "elapsed_time": 153,
            "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "[97.70000,309.65000]",
            "std_output": "",
            "last_testcase": "36.50",
            "expected_output": "[309.65000,97.70000]",
            "task_finish_time": 1699648476942,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 74,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096159593",
            "input_formatted": "36.50",
            "input": "36.50",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "longest-valid-parentheses",
        "description": "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
        "examples": [
            "Input: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".",
            "Input: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".",
            "Input: s = \"\"\nOutput: 0"
        ],
        "constrains": "0 <= s.length <= 3 * 104\ns[i] is '(', or ')'.",
        "release_time": 1688495250,
        "oracle_code": "class Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(-1);\\n        int n = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    n = Math.max(n, i - st.peek());\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.pop());\n            }\n        }\n        return n;\n    }\n}\n",
        "explanations": "\nThe stack.peek() method had been changed to stack.pop(), causing the expected top-value of stack to get removed unexpectedly.\n",
        "fixed_code": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}\n",
        "fixing_exp": "\nModified the stack's pop operation to peek, as we are not supposed to remove the element.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "3 ms",
            "memory": 41940000,
            "display_runtime": "3",
            "question_id": "32",
            "elapsed_time": 148,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648492941,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 231,
            "total_testcases": 231,
            "runtime_percentile": 75.01809999999999,
            "status_memory": "41.9 MB",
            "memory_percentile": 49.866699999999994,
            "pretty_lang": "Java",
            "submission_id": "1096159694",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "description": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.",
        "examples": [
            "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
            "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
            "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
        ],
        "constrains": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105",
        "release_time": 1685246871,
        "oracle_code": "class Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n        \n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return a[0] - b[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = queue.remove();\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 1, cur);\n            }\n            \n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n            \n            res = Math.max(res, cur);\n        }\n        \n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rows = new int[m], cols = new int[n];\\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\\n        \\n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\\n        for(int i=0;i<m;i++) {\\n            rows[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i=0;i<n;i++) {\\n            cols[i] = Integer.MIN_VALUE;\\n        }\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\\n            return a[0] - b[0];\\n        });\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                queue.add(new int[]{mat[i][j], i, j});\\n            }\\n        }\\n        int res = 0;\\n        while(!queue.isEmpty()) {\\n            int[] arr = queue.remove();\\n            int val = arr[0], row = arr[1], col = arr[2];\\n            int cur = 1;\\n            if(val == rows[row]) {\\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\\n            } else {\\n                cur = Math.max(rowMaxVals[row] + 1, cur);\\n            }\\n            if(val == cols[col]) {\\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\\n            } else {\\n                cur = Math.max(colMaxVals[col] + 1, cur);\\n            }\\n            \\n\\n            if(val > rows[row]) {\\n                rowSubMaxVals[row] = rowMaxVals[row];\\n                rows[row] = val;\\n            }\\n            if(val > cols[col]) {\\n                colSubMaxVals[col] = colMaxVals[col];\\n                cols[col] = val;\\n            }\\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\\n            \\n            res = Math.max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n        \n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return a[0] - b[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = queue.remove();\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 2, cur); \n            }\n\n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n            \n            res = Math.max(res, cur);\n        }\n        \n        return res;\n    }\n}\n",
        "explanations": "\nThe bug is that I've incrementing by 2 instead of 1 in \"Math.max(colMaxVals[col] + 2, cur);\". This would cause a greater value than expected.\n",
        "fixed_code": "\nclass Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n        \n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n            rowSubMaxVals[i] = Integer.MIN_VALUE;\n            rowMaxVals[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n            colSubMaxVals[i] = Integer.MIN_VALUE;\n            colMaxVals[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return b[0] - a[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = queue.poll();\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 1, cur); \n            }\n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n            \n            res = Math.max(res, cur);\n        }\n        \n        return res;\n    }\n}\n",
        "fixing_exp": "\nFixed the initialization of the priority queue comparator so it compares in reverse order to get maximum first. Also fixed null pointer exception by initializing all arrays to Integer.MIN_VALUE.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 70440000,
            "display_runtime": "212",
            "question_id": "2818",
            "elapsed_time": 644,
            "compare_result": "1111111111111111111111111111111001010101111111110010011001001111010000001110001010010110001111111010100011001000100100011000101000001001100000000000000000000000000000011110010010010000000000000000010100000000000000100000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111",
            "code_output": "5",
            "std_output": "",
            "last_testcase": "[[2,-4,2,-2,6]]",
            "expected_output": "4",
            "task_finish_time": 1699648523695,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 105,
            "total_testcases": 565,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096159932",
            "input_formatted": "[[2,-4,2,-2,6]]",
            "input": "[[2,-4,2,-2,6]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "subrectangle-queries",
        "description": "Implement the class SubrectangleQueries\u00a0which receives a rows x cols rectangle as a matrix of integers in the constructor and supports two methods:\n1.\u00a0updateSubrectangle(int row1, int col1, int row2, int col2, int newValue)\n\nUpdates all values with newValue in the subrectangle whose upper left coordinate is (row1,col1) and bottom right coordinate is (row2,col2).\n\n2.\u00a0getValue(int row, int col)\n\nReturns the current value of the coordinate (row,col) from\u00a0the rectangle.",
        "examples": [
            "Input\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\"]\n[[[[1,2,1],[4,3,4],[3,2,1],[1,1,1]]],[0,2],[0,0,3,2,5],[0,2],[3,1],[3,0,3,2,10],[3,1],[0,2]]\nOutput\n[null,1,null,5,5,null,10,5]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,2,1],[4,3,4],[3,2,1],[1,1,1]]);  \n// The initial rectangle (4x3) looks like:\n// 1 2 1\n// 4 3 4\n// 3 2 1\n// 1 1 1\nsubrectangleQueries.getValue(0, 2); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 3, 2, 5);\n// After this update the rectangle looks like:\n// 5 5 5\n// 5 5 5\n// 5 5 5\n// 5 5 5 \nsubrectangleQueries.getValue(0, 2); // return 5\nsubrectangleQueries.getValue(3, 1); // return 5\nsubrectangleQueries.updateSubrectangle(3, 0, 3, 2, 10);\n// After this update the rectangle looks like:\n// 5   5   5\n// 5   5   5\n// 5   5   5\n// 10  10  10 \nsubrectangleQueries.getValue(3, 1); // return 10\nsubrectangleQueries.getValue(0, 2); // return 5",
            "Input\n[\"SubrectangleQueries\",\"getValue\",\"updateSubrectangle\",\"getValue\",\"getValue\",\"updateSubrectangle\",\"getValue\"]\n[[[[1,1,1],[2,2,2],[3,3,3]]],[0,0],[0,0,2,2,100],[0,0],[2,2],[1,1,2,2,20],[2,2]]\nOutput\n[null,1,null,100,100,null,20]\nExplanation\nSubrectangleQueries subrectangleQueries = new SubrectangleQueries([[1,1,1],[2,2,2],[3,3,3]]);\nsubrectangleQueries.getValue(0, 0); // return 1\nsubrectangleQueries.updateSubrectangle(0, 0, 2, 2, 100);\nsubrectangleQueries.getValue(0, 0); // return 100\nsubrectangleQueries.getValue(2, 2); // return 100\nsubrectangleQueries.updateSubrectangle(1, 1, 2, 2, 20);\nsubrectangleQueries.getValue(2, 2); // return 20"
        ],
        "constrains": "There will be at most 500\u00a0operations considering both methods:\u00a0updateSubrectangle and getValue.\n1 <= rows, cols <= 100\nrows ==\u00a0rectangle.length\ncols == rectangle[i].length\n0 <= row1 <= row2 < rows\n0 <= col1 <= col2 < cols\n1 <= newValue, rectangle[i][j] <= 10^9\n0 <= row < rows\n0 <= col < cols",
        "release_time": 1691178896,
        "oracle_code": "class SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++){\n            for(int j=col1; j<=col2; j++){\n                ans[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The constructor initializes a 2D array \\'ans\\' to store the rectangle.\\n2. The \\'updateSubrectangle\\' function updates the subrectangle with the given \\'newValue\\' by iterating over the specified range and updating each element.\\n3. The \\'getValue\\' function retrieves the value at the specified row and column in \\'ans\\'.\\n\\n# Complexity\\n- Time complexity: O((row2 - row1 + 1) * (col2 - col1 + 1))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass SubrectangleQueries {\\n    int[][] ans;\\n    public SubrectangleQueries(int[][] rectangle) {\\n        ans = rectangle;\\n    }\\n    \\n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\\n        for(int i=row1; i<=row2; i++){\\n            for(int j=col1; j<=col2; j++){\\n                ans[i][j] = newValue;\\n            }\\n        }\\n    }\\n    \\n    public int getValue(int row, int col) {\\n        int val = ans[row][col];\\n        return val;\\n    }\\n}\\n\\n/**\\n * Your SubrectangleQueries object will be instantiated and called as such:\\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\\n * int param_2 = obj.getValue(row,col);\\n */\\n```",
        "level": "medium",
        "buggy_code": "\nclass SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++){\n            for(int j=col1; j<=col2; j++){\n                ans[i][j] = newValue;\n                newValue++;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */\n",
        "explanations": "\nThe newValue is incremented in each loop iteration which changes the value unexpectedly.\n",
        "fixed_code": "\nclass SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = new int[rectangle.length][];\n        for (int i = 0; i < rectangle.length; i++) {\n            ans[i] = rectangle[i].clone();\n        }\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++){\n            for(int j=col1; j<=col2; j++){\n                ans[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */\n",
        "fixing_exp": "\nDuplicated the array at initialization to prevent reference issues and removed the incrementation of newValue in the loop.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "22 ms",
            "memory": 46716000,
            "display_runtime": "22",
            "question_id": "1572",
            "elapsed_time": 219,
            "compare_result": "1111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648539685,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 52,
            "total_testcases": 52,
            "runtime_percentile": 30.490000000000002,
            "status_memory": "46.7 MB",
            "memory_percentile": 71.14330000000001,
            "pretty_lang": "Java",
            "submission_id": "1096160036",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "jewels-and-stones",
        "description": "You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so \"a\" is considered a different type of stone from \"A\".",
        "examples": [
            "Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3",
            "Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0"
        ],
        "constrains": "1 <=\u00a0jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of\u00a0jewels are unique.",
        "release_time": 1689949381,
        "oracle_code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count--;\n            }\n        }\n        return count;\n    }\n}\n",
        "explanations": "\nThe bug is that count decreases when a jewel is found, instead of increasing.\n",
        "fixed_code": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n",
        "fixing_exp": "\nThe count should be incremented when a jewel is found, not decremented.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 40660000,
            "display_runtime": "1",
            "question_id": "782",
            "elapsed_time": 153,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648554445,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 255,
            "total_testcases": 255,
            "runtime_percentile": 79.0848,
            "status_memory": "40.7 MB",
            "memory_percentile": 57.244100000000024,
            "pretty_lang": "Java",
            "submission_id": "1096160131",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "perfect-number",
        "description": "A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\nGiven an integer n, return true if n is a perfect number, otherwise return false.",
        "examples": [
            "Input: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.",
            "Input: num = 7\nOutput: false"
        ],
        "constrains": "1 <= num <= 108",
        "release_time": 1683370625,
        "oracle_code": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if(num==1){\n            return false;\n        }\n        int sum=1;\n        for(int i =2 ;i*i<=num;i++){\n            if(num%i==0){\n                sum+=i+ num/i;  \n            }\n        }\n        if(num==sum){\n            return true;\n        }\n        return false;\n    }\n}",
        "content": "![image.png](https://assets.leetcode.com/users/images/9efca421-50e2-4af1-94b6-5c5dcba4cc28_1683370607.0372207.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkPerfectNumber(int num) {\\n        if(num==1){\\n            return false;\\n        }\\n        int sum=1;\\n        for(int i =2 ;i*i<=num;i++){\\n            if(num%i==0){\\n                sum+=i+ num/i;  \\n            }\\n        }\\n        if(num==sum){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public boolean checkPerfectNumber(int num) {\n        if(num==1){\n            return false;\n        }\n        int sum=1;\n        for(int i =2 ;i*i<=num;i++){\n            if(num%i==0){\n                sum+=i;\n                if(i*i != num) {\n                    sum += num/i;\n                }\n            }\n        }\n        if(num==sum*2){\n            return true;\n        }\n        return false;\n    }\n}\n",
        "explanations": "\nThe bug here is in the sum comparison with num. It should be compared with sum not sum*2.\n",
        "fixed_code": "\nclass Solution {\n    public boolean checkPerfectNumber(int num) {\n        if(num==1){\n            return false;\n        }\n        int sum=1;\n        for(int i =2 ;i*i<=num;i++){\n            if(num%i==0){\n                sum+=i;\n                if(i*i != num) {\n                    sum += num/i;\n                }\n            }\n        }\n        if(num==sum){\n            return true;\n        }\n        return false;\n    }\n}\n",
        "fixing_exp": "\nThe condition checking the sum was faulty, it should not be sum*2, but sum to consider a perfect number.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 38748000,
            "display_runtime": "1",
            "question_id": "507",
            "elapsed_time": 164,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648569794,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 98,
            "total_testcases": 98,
            "runtime_percentile": 98.5215,
            "status_memory": "38.7 MB",
            "memory_percentile": 88.87769999999995,
            "pretty_lang": "Java",
            "submission_id": "1096160249",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "earliest-possible-day-of-full-bloom",
        "description": "You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each:\n\nplantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total.\ngrowTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.\n\nFrom the beginning of day 0, you can plant the seeds in any order.\nReturn the earliest possible day where all seeds are blooming.",
        "examples": [
            "Input: plantTime = [1,4,3], growTime = [2,3,1]\nOutput: 9\nExplanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.\nOn days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.\nOn days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.",
            "Input: plantTime = [1,2,3,2], growTime = [2,1,2,1]\nOutput: 9\nExplanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.\nOne optimal way is:\nOn day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.\nOn days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.\nOn days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.\nOn days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.\nThus, on day 9, all the seeds are blooming.",
            "Input: plantTime = [1], growTime = [1]\nOutput: 2\nExplanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.\nThus, on day 2, all the seeds are blooming."
        ],
        "constrains": "n == plantTime.length == growTime.length\n1 <= n <= 105\n1 <= plantTime[i], growTime[i] <= 104",
        "release_time": 1677868965,
        "oracle_code": "class Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}",
        "content": "![image.png](https://assets.leetcode.com/users/images/98855a88-cdb5-4c6f-ba41-3ba577588b51_1678010575.6496518.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n       int max = 0;\\n       for (int i : growTime){\\n           if(max < i){\\n               max = i;\\n           }\\n       }\\n\\n       int len = max;\\n       int[] arr = new int[len + 1];\\n       int tmp = 0;\\n       int minTime = 0;\\n       \\n       for (int i = 0; i < plantTime.length; i++) {\\n           arr[growTime[i]] += plantTime[i];\\n       }\\n\\n       for (int i = len; i > 0; i--) {\\n            if (arr[i] != 0) {\\n                tmp = tmp + arr[i];\\n                minTime = Math.max(minTime, tmp + i);\\n            }\\n       }\\n\\n       return minTime;\\n    }\\n}\\n\\n\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.min(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}\n",
        "explanations": "\nThe logic error is in the min function, it should be a max function because it calculates maximum time.\n",
        "fixed_code": "\nclass Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       int tmp = arr[len];\n       for (int i = len - 1; i >= 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}\n",
        "fixing_exp": "\nThe initial values of tmp and minTime were wrong, and minTime should be the maximum between minTime and tmp+i.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 59260000,
            "display_runtime": "4",
            "question_id": "2257",
            "elapsed_time": 412,
            "compare_result": "11000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100111111111111111000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[1]\n[1]",
            "expected_output": "2",
            "task_finish_time": 1699648594428,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 177,
            "total_testcases": 185,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096160463",
            "input_formatted": "[1], [1]",
            "input": "[1]\n[1]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "jump-game-iv",
        "description": "Given an array of\u00a0integers arr, you are initially positioned at the first index of the array.\nIn one step you can jump from index i to index:\n\ni + 1 where:\u00a0i + 1 < arr.length.\ni - 1 where:\u00a0i - 1 >= 0.\nj where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\nNotice that you can not jump outside of the array at any time.",
        "examples": [
            "Input: arr = [100,-23,-23,404,100,23,23,23,3,404]\nOutput: 3\nExplanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.",
            "Input: arr = [7]\nOutput: 0\nExplanation: Start index is the last index. You do not need to jump.",
            "Input: arr = [7,6,9,6,9,6,9,7]\nOutput: 1\nExplanation: You can jump directly from index 0 to index 7 which is last index of the array."
        ],
        "constrains": "1 <= arr.length <= 5 * 104\n-108 <= arr[i] <= 108",
        "release_time": 1677998298,
        "oracle_code": "class Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                al.clear();\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}\n",
        "explanations": "\nClearing the array list 'al' before we iterate through it results in skipping values.\n",
        "fixed_code": "\nclass Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>> hm = new HashMap<>();\n        for(int i = 0; i < arr.length; i++){\n            hm.putIfAbsent(arr[i], new ArrayList<>());\n            hm.get(arr[i]).add(i);\n        }\n        boolean[] vis = new boolean[arr.length];\n        Queue<Integer> q = new LinkedList<>();\n        q.add(0);\n        vis[0] = true;\n        int cnt = 0;\n        while(!q.isEmpty()){\n            for(int k = q.size(); k > 0; k--){\n                int n = q.poll();\n                if(n == arr.length - 1) return cnt;\n                ArrayList<Integer> al = hm.get(arr[n]);\n                for(int i : al){\n                    if(i >= 0 && i < arr.length && !vis[i]){\n                        vis[i] = true;\n                        q.add(i);\n                    }\n                }\n                if(n-1>=0 && !vis[n-1]){\n                    vis[n-1] = true;\n                    q.add(n-1);\n                }\n                if(n+1<arr.length && !vis[n+1]){\n                    vis[n+1] = true;\n                    q.add(n+1);\n                }\n            }\n            cnt++;\n        }\n        return -1;\n    }\n}\n",
        "fixing_exp": "\nChanged the logic in managing queue and used poll instead of remove. Avoided unnecessary \"al\" list modification and clearing.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 14,
            "lang": "java",
            "run_success": false,
            "status_runtime": "N/A",
            "memory": 53744000,
            "question_id": "1447",
            "elapsed_time": 3992,
            "compare_result": "111111111111111111111111110000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,11]",
            "expected_output": "2",
            "task_finish_time": 1699648619620,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 26,
            "total_testcases": 33,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096160609",
            "status_msg": "Time Limit Exceeded",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "new-21-game",
        "description": "Alice plays the following game, loosely based on the card game \"21\".\nAlice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\nAlice stops drawing numbers when she gets k or more points.\nReturn the probability that Alice has n or fewer points.\nAnswers within 10-5 of the actual answer are considered accepted.",
        "examples": [
            "Input: n = 10, k = 1, maxPts = 10\nOutput: 1.00000\nExplanation: Alice gets a single card, then stops.",
            "Input: n = 6, k = 1, maxPts = 10\nOutput: 0.60000\nExplanation: Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.",
            "Input: n = 21, k = 17, maxPts = 10\nOutput: 0.73278"
        ],
        "constrains": "0 <= k <= n <= 104\n1 <= maxPts <= 104",
        "release_time": 1684986822,
        "oracle_code": "class Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts)\n        return 1.0;\n    \n    double[] dp = new double[n + 1];\n    double windowSum = 1.0;\n    double probability = 0.0;\n    \n    dp[0] = 1.0;\n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = windowSum / maxPts;\n        \n        if (i < k)\n            windowSum += dp[i];\n        else\n            probability += dp[i];\n        \n        if (i - maxPts >= 0)\n            windowSum -= dp[i - maxPts];\n    }\n    \n    return probability;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to calculate the probability that Alice has n or fewer points. To achieve this, we can consider the probability at each point and use dynamic programming to build up the probabilities iteratively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we handle the base cases. If k is 0 or if n is greater than or equal to k + maxPts, Alice will always stop drawing after the first round and have a probability of 1.0 to have n or fewer points.\\n1. We create an array dp to store the probabilities for each possible number of points.\\n1. Initialize dp[0] to 1.0, indicating that Alice starts with 0 points.\\n1. We use a sliding window approach to calculate the probabilities iteratively. We maintain a windowSum variable that represents the sum of probabilities within the window of size maxPts.\\n1. Iterate from 1 to n and calculate dp[i] as windowSum / maxPts since each draw has equal probabilities.\\n1. If i is less than k, we update windowSum by adding dp[i] since we can continue drawing.\\n1. Otherwise, if i is greater than or equal to k, we update probability by adding dp[i] since Alice has stopped drawing at this point.\\n1. We adjust the windowSum by subtracting the probability that falls outside the window, i.e., dp[i - maxPts], if it exists.\\n1. Finally, we return the calculated probability.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n) because we iterate from 1 to n to calculate the probabilities.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) because we use an array dp of size n+1 to store the probabilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public double new21Game(int n, int k, int maxPts) {\\n        if (k == 0 || n >= k + maxPts)\\n        return 1.0;\\n    \\n    double[] dp = new double[n + 1];\\n    double windowSum = 1.0;\\n    double probability = 0.0;\\n    \\n    dp[0] = 1.0;\\n    \\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = windowSum / maxPts;\\n        \\n        if (i < k)\\n            windowSum += dp[i];\\n        else\\n            probability += dp[i];\\n        \\n        if (i - maxPts >= 0)\\n            windowSum -= dp[i - maxPts];\\n    }\\n    \\n    return probability;\\n    }\\n}\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts)\n            return 1.0;\n    \n        double[] dp = new double[n + 1];\n        double windowSum = 1.0;\n        double probability = 0.0;\n    \n        dp[0] = 1.0;\n    \n        for (int i = 1; i <= n; i++) {\n            dp[i] = windowSum / maxPts;\n        \n            if (i < k)\n                windowSum += dp[i];\n            else\n                probability += dp[i-1];\n        \n            if (i - maxPts >= 0)\n                windowSum -= dp[i - maxPts];\n        }\n    \n        return probability;\n    }\n}\n",
        "explanations": "\nAdding dp[i-1] to probability instead of dp[i] will give incorrect probability calculations.\n",
        "fixed_code": "\nclass Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts)\n            return 1.0;\n    \n        double[] dp = new double[n + 1];\n        double windowSum = 1.0;\n        double probability = 0.0;\n    \n        dp[0] = 1.0;\n    \n        for (int i = 1; i <= n; i++) {\n            dp[i] = windowSum / maxPts;\n        \n            if (i < k)\n                windowSum += dp[i];\n            else\n                probability += dp[i];\n        \n            if (i - maxPts >= 0)\n                windowSum -= dp[i - maxPts];\n        }\n    \n        return probability;\n    }\n}\n",
        "fixing_exp": "\nThe probability was incorrectly calculated from dp[i-1] instead of dp[i] when i is not less than k.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "4 ms",
            "memory": 43084000,
            "display_runtime": "4",
            "question_id": "867",
            "elapsed_time": 137,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648638821,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 151,
            "total_testcases": 151,
            "runtime_percentile": 74.3363,
            "status_memory": "43.1 MB",
            "memory_percentile": 23.008699999999997,
            "pretty_lang": "Java",
            "submission_id": "1096160807",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "number-of-different-subsequences-gcds",
        "description": "You are given an array nums that consists of positive integers.\nThe GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly.\n\nFor example, the GCD of the sequence [4,6,16] is 2.\n\nA subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n\nFor example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n\nReturn the number of different GCDs among all non-empty subsequences of nums.",
        "examples": [
            "Input: nums = [6,10,3]\nOutput: 5\nExplanation: The figure shows all the non-empty subsequences and their GCDs.\nThe different GCDs are 6, 10, 3, 2, and 1.",
            "Input: nums = [5,15,40,5,6]\nOutput: 7"
        ],
        "constrains": "1 <= nums.length <= 105\n1 <= nums[i] <= 2 * 105",
        "release_time": 1617547962,
        "oracle_code": "class Solution {\n    int max = 0;\n    Set<Integer> exist = new HashSet();\n    public int countDifferentSubsequenceGCDs(int[] nums) {\n        getMax(nums);\n        for(int num : nums) exist.add(num);\n        int count = 0;\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      //  <---- findGCD\n        return count;\n    }\n    public void getMax(int[] nums){\n        for(int i : nums) max = Math.max(max, i);\n    }\n    public int gcd(int a, int b){\n        return (a == 0) ? b : gcd(b % a, a);\n    }\n\tpublic boolean findGCD(int num){\n        int val = 0;\n        for(int i = num; i <= max; i+= num)\n            if(exist.contains(i)) val = gcd(i, val);          //  <---- gcd between two number\n        return (val == num);\n    }\n}",
        "content": "**PLEASE UPVOTE IF YOU FIND THIS USEFUL**\\n\\n* Generating all subsets and finding the gcd will lead you to `TLE`\\n* We can try to build optimization around based on the constraint `1 <= nums[i] <= 2 * 10^5`\\n* The limit is `200000` and we find GCD for all the numbers available between them. we can limit to the `max` number in the input array, `nums`. \\n* We pick a number `num` and check if the GCD subsequence exists equals to the same number. If it exists then the elements of the gcd susequence will be the multiple of the same number passed. This is the reason why we increment the value by num in `findGCD`\\n* Maintaining a set `exist` for easy existence check for the number in the `nums`\\n* Increment the counter `count` if the gcd between the numbers matches\\n\\n**Time:**  N Log N (GCD worst case is logN)\\n**Space:** O(N) (usage of Set for N numbers)\\n```\\nclass Solution {\\n    int max = 0;\\n    Set<Integer> exist = new HashSet();\\n    public int countDifferentSubsequenceGCDs(int[] nums) {\\n        getMax(nums);\\n        for(int num : nums) exist.add(num);\\n        int count = 0;\\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      //  <---- findGCD\\n        return count;\\n    }\\n    public void getMax(int[] nums){\\n        for(int i : nums) max = Math.max(max, i);\\n    }\\n    public int gcd(int a, int b){\\n        return (a == 0) ? b : gcd(b % a, a);\\n    }\\n\\tpublic boolean findGCD(int num){\\n        int val = 0;\\n        for(int i = num; i <= max; i+= num)\\n            if(exist.contains(i)) val = gcd(i, val);          //  <---- gcd between two number\\n        return (val == num);\\n    }\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    int max = 0;\n    Set<Integer> exist = new HashSet();\n    public int countDifferentSubsequenceGCDs(int[] nums) {\n        getMax(nums);\n        for(int num : nums) exist.add(num);\n        int count = 0;\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      \n        return count;\n    }\n    public void getMax(int[] nums){\n        for(int i : nums) max = Math.min(max, i);\n    }\n    public int gcd(int a, int b){\n        return (a == 0) ? b : gcd(b % a, a);\n    }\n\tpublic boolean findGCD(int num){\n        int val = 0;\n        for(int i = num; i <= max; i+= num)\n            if(exist.contains(i)) val = gcd(i, val);          \n        return (val == num);\n    }\n}\n",
        "explanations": "\nThe getMax function should find the maximum number in array, but it's incorrectly finding the minimum.\n",
        "fixed_code": "\nclass Solution {\n    int max = 0;\n    Set<Integer> exist = new HashSet<>();\n    public int countDifferentSubsequenceGCDs(int[] nums) {\n        getMax(nums);\n        for(int num : nums) exist.add(num);\n        int count = 0;\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      \n        return count;\n    }\n    public void getMax(int[] nums){\n        for(int num : nums) max = Math.max(max, num);\n    }\n    public int gcd(int a, int b){\n        return (b == 0) ? a : gcd(b % a, a);\n    }\n\tpublic boolean findGCD(int num){\n        int val = 0;\n        for(int i = num; i <= max; i+= num)\n            if(exist.contains(i)) val = gcd(val, i);          \n        return (val == num);\n    }\n}\n",
        "fixing_exp": "\nUpdated getMax() to take max instead of min value and fixed parameters order for gcd() method.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 15,
            "lang": "java",
            "run_success": false,
            "runtime_error": "Line 16: java.lang.ArithmeticException: / by zero",
            "full_runtime_error": "java.lang.ArithmeticException: / by zero\n  at line 16, Solution.gcd\n  at line 21, Solution.findGCD\n  at line 9, Solution.countDifferentSubsequenceGCDs\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main",
            "status_runtime": "N/A",
            "memory": 39540000,
            "question_id": "1947",
            "elapsed_time": 122,
            "compare_result": "000000000000000000000000000000000000000",
            "code_output": "",
            "std_output": "",
            "last_testcase": "[6,10,3]",
            "expected_output": "5",
            "task_finish_time": 1699648659507,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 39,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096160971",
            "status_msg": "Runtime Error",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "hamming-distance",
        "description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.",
        "examples": [
            "Input: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u2191   \u2191\nThe above arrows point to positions where the corresponding bits are different.",
            "Input: x = 3, y = 1\nOutput: 1"
        ],
        "constrains": "0 <=\u00a0x, y <= 231 - 1",
        "release_time": 1676104831,
        "oracle_code": "import java.math.BigInteger;\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        String x_bin = Integer.toBinaryString(x);\n        String y_bin = Integer.toBinaryString(y);\n\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\n\n        int result = 0;\n        BigInteger min_bi;\n        min_bi  = new BigInteger(min_str);\n        System.out.println(\"min_bi = \"+ min_bi);\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\n        for(int i=0; i<max_len; i++){\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\n            {\n                result+=1;\n            }\n        }\n        System.out.println(max_str);\n        System.out.println(min_format_str);\n\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe crux of the problem:\\n1. Convert both numbers to Binary strings\\n2. Find the strings with maximum len and the one with min length.\\n3. Add leading zeros to the min length string so the lengths of either strings match.\\n4. Compare the chars of either string, if they don\\'t match increment result by 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOrdinary solution using loop and appropriate data types.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(length of maximum string)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Two strings with as many characters in the longest string)\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        String x_bin = Integer.toBinaryString(x);\\n        String y_bin = Integer.toBinaryString(y);\\n\\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\\n\\n        int result = 0;\\n        BigInteger min_bi;\\n        min_bi  = new BigInteger(min_str);\\n        System.out.println(\"min_bi = \"+ min_bi);\\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\\n        for(int i=0; i<max_len; i++){\\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\\n            {\\n                result+=1;\\n            }\\n        }\\n        System.out.println(max_str);\\n        System.out.println(min_format_str);\\n\\n        return result;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nimport java.math.BigInteger;\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        String x_bin = Integer.toBinaryString(x);\n        String y_bin = Integer.toBinaryString(y);\n\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\n\n        int result = 0;\n        BigInteger min_bi;\n        min_bi  = new BigInteger(min_str, 2); \n        System.out.println(\"min_bi = \"+ min_bi);\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\n        for(int i=0; i<max_len; i++){\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\n            {\n                result+=1;\n            }\n        }\n        System.out.println(max_str);\n        System.out.println(min_format_str);\n\n        return result;\n    }\n}\n",
        "explanations": "\nInteger-to-binary string was not correctly converted to BigInteger, causing incorrect min_format_str.\n",
        "fixed_code": "\nimport java.math.BigInteger;\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        String x_bin = String.format(\"%32s\", Integer.toBinaryString(x)).replace(' ', '0');\n        String y_bin = String.format(\"%32s\", Integer.toBinaryString(y)).replace(' ', '0');\n\n        int result = 0;\n        for(int i=0; i<32; i++){\n            if(x_bin.charAt(i)!=y_bin.charAt(i))\n            {\n                result+=1;\n            }\n        }\n        return result;\n    }\n}\n",
        "fixing_exp": "\nThe original code was overly complicated. Now it preprocesses the binary strings to be equal length by padding zeros. \n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "7 ms",
            "memory": 39732000,
            "display_runtime": "7",
            "question_id": "461",
            "elapsed_time": 109,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648674016,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 149,
            "total_testcases": 149,
            "runtime_percentile": 5.939500000000004,
            "status_memory": "39.7 MB",
            "memory_percentile": 12.792699999999984,
            "pretty_lang": "Java",
            "submission_id": "1096161082",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "minimum-adjacent-swaps-for-k-consecutive-ones",
        "description": "You are given an integer array, nums, and an integer k. nums comprises of only 0's and 1's. In one move, you can choose two adjacent indices and swap their values.\nReturn the minimum number of moves required so that nums has k consecutive 1's.",
        "examples": [
            "Input: nums = [1,0,0,1,0,1], k = 2\nOutput: 1\nExplanation: In 1 move, nums could be [1,0,0,0,1,1] and have 2 consecutive 1's.",
            "Input: nums = [1,0,0,0,0,0,1,1], k = 3\nOutput: 5\nExplanation: In 5 moves, the leftmost 1 can be shifted right until nums = [0,0,0,0,0,1,1,1].",
            "Input: nums = [1,1,0,1], k = 2\nOutput: 0\nExplanation: nums already has 2 consecutive 1's."
        ],
        "constrains": "1 <= nums.length <= 105\nnums[i] is 0 or 1.\n1 <= k <= sum(nums)",
        "release_time": 1609051531,
        "oracle_code": "class Solution {\n    public int minMoves(int[] a, int k) {\n\t\tint n = a.length;\n\t\tArrayList<Integer> oneInd = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] == 1)\n\t\t\t\toneInd.add(i);\n\t\tint prfsm[] = new int[oneInd.size()];\n\t\tfor (int i = 0; i < oneInd.size(); i++)\n\t\t\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint left = 0, right = k - 1;\n\t\twhile (right < oneInd.size()) {\n\t\t\tif (k % 2 == 1) {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * (rad + 1);\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t} else {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1]))\n\t\t\t\t\t\t- oneInd.get(medianInd) - rad * (rad + 1) - (rad + 1);\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t}\n\t\t\tleft++;\n\t\t\tright++;\n\t\t}\n\t\treturn ans;\n\t}\n}",
        "content": "Explaination with pictures: https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/discuss/987607/O(n)-explanation-with-picture\\n\\n```\\nclass Solution {\\n    public int minMoves(int[] a, int k) {\\n\\t\\tint n = a.length;\\n\\t\\tArrayList<Integer> oneInd = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tif (a[i] == 1)\\n\\t\\t\\t\\toneInd.add(i);\\n\\t\\tint prfsm[] = new int[oneInd.size()];\\n\\t\\tfor (int i = 0; i < oneInd.size(); i++)\\n\\t\\t\\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\\n\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\tint left = 0, right = k - 1;\\n\\t\\twhile (right < oneInd.size()) {\\n\\t\\t\\tif (k % 2 == 1) {\\n\\t\\t\\t\\tint medianInd = left + (k + 1) / 2 - 1;\\n\\t\\t\\t\\tint rad = medianInd - left;\\n\\t\\t\\t\\tint res = (prfsm[right] - prfsm[medianInd])\\n\\t\\t\\t\\t\\t\\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * (rad + 1);\\n\\t\\t\\t\\tans = Math.min(ans, res);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint medianInd = left + (k + 1) / 2 - 1;\\n\\t\\t\\t\\tint rad = medianInd - left;\\n\\t\\t\\t\\tint res = (prfsm[right] - prfsm[medianInd])\\n\\t\\t\\t\\t\\t\\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1]))\\n\\t\\t\\t\\t\\t\\t- oneInd.get(medianInd) - rad * (rad + 1) - (rad + 1);\\n\\t\\t\\t\\tans = Math.min(ans, res);\\n\\t\\t\\t}\\n\\t\\t\\tleft++;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\n    public int minMoves(int[] a, int k) {\n\t\tint n = a.length;\n\t\tArrayList<Integer> oneInd = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] == 1)\n\t\t\t\toneInd.add(i);\n\t\tint prfsm[] = new int[oneInd.size()];\n\t\tfor (int i = 0; i < oneInd.size(); i++)\n\t\t\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint left = 0, right = k - 1;\n\t\twhile (right < oneInd.size()) {\n\t\t\tif (k % 2 == 1) {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * rad;\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t} else {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1]))\n\t\t\t\t\t\t- oneInd.get(medianInd) - rad * rad;\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t}\n\t\t\tleft++;\n\t\t\tright++;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "explanations": "\nThe bug was changing 'rad * (rad + 1)' to 'rad * rad'. This throws off calculation.\n",
        "fixed_code": "\nclass Solution {\n    public int minMoves(int[] a, int k) {\n\t\tint n = a.length;\n\t\tArrayList<Integer> oneInd = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] == 1)\n\t\t\t\toneInd.add(i);\n\t\tint prfsm[] = new int[oneInd.size() + 1];\n\t\tfor (int i = 1; i <= oneInd.size(); i++)\n\t\t\tprfsm[i] = prfsm[i - 1] + oneInd.get(i - 1);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint left = 0, right = k - 1;\n\t\twhile (right < oneInd.size()) {\n\t\t\tint medianInd = left + k / 2;\n\t\t\tint rad = oneInd.get(medianInd);\n\t\t\tint res = prfsm[right + 1] - prfsm[medianInd + 1] - rad * (k - k/2)\n\t\t\t\t\t+ rad * (k/2) - (prfsm[medianInd] - prfsm[left]);\n\t\t\tans = Math.min(ans, res);\n\t\t\tleft++;\n\t\t\tright++;\n\t\t}\n\t\treturn ans;\n\t}\n}\n",
        "fixing_exp": "\nFixed an error in calculation of median and prefix sum array. Modified the radius calculation logic to be more accurate.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "java",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 55212000,
            "display_runtime": "10",
            "question_id": "1805",
            "elapsed_time": 329,
            "compare_result": "00001001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "-3",
            "std_output": "",
            "last_testcase": "[1,0,0,1,0,1]\n2",
            "expected_output": "1",
            "task_finish_time": 1699648691336,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 2,
            "total_testcases": 116,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "Java",
            "submission_id": "1096161202",
            "input_formatted": "[1,0,0,1,0,1], 2",
            "input": "[1,0,0,1,0,1]\n2",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.",
        "examples": [
            "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.",
            "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.",
            "Input: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0."
        ],
        "constrains": "n == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
        "release_time": 1690174250,
        "oracle_code": "class Solution {\n    public int isWinner(int[] player1, int[] player2) {\n        int i=1,j=i-1,k=i-2;\n        int p1=player1[0],p2=player2[0];\n        while(i<player1.length){\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\n                p1+=2*player1[i];\n            }\n            else{\n                p1+=player1[i];\n            }\n            i++;\n            j++;\n            k++;\n        }\n        int l=1,m=l-1,n=l-2;\n        while(l<player2.length){\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\n                p2+=2*player2[l];\n            }\n            else{\n                p2+=player2[l];\n            }\n            l++;\n            m++;\n            n++;\n        }\n        if(p1>p2) return 1;\n        else if(p1==p2) return 0;\n        else return 2;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int isWinner(int[] player1, int[] player2) {\n        int i=1,j=i-1,k=i-2;\n        int p1=player1[0],p2=player2[0];\n        while(i<player1.length){\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\n                p1+=2*player1[i];\n            }\n            else{\n                p1+=player1[i];\n            }\n            i++;\n            j--;\n            k--;\n        }\n        int l=1,m=l-1,n=l-2;\n        while(l<player2.length){\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\n                p2+=2*player2[l];\n            }\n            else{\n                p2+=player2[l];\n            }\n            l++;\n            m--;\n            n--;\n        }\n        if(p1>p2) return 1;\n        else if(p1==p2) return 0;\n        else return 2;\n    }\n}\n",
        "explanations": "\nVariable j and variable k are being decremented instead of being incremented.\n",
        "fixed_code": "\nclass Solution {\n    public int isWinner(int[] player1, int[] player2) {\n        int i=1,j=i-1,k=i-2;\n        int p1=player1[0],p2=player2[0];\n        while(i<player1.length){\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\n                p1+=2*player1[i];\n            }\n            else{\n                p1+=player1[i];\n            }\n            i++;\n            j=i-1;\n            k=i-2;\n        }\n        int l=1,m=l-1,n=l-2;\n        while(l<player2.length){\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\n                p2+=2*player2[l];\n            }\n            else{\n                p2+=player2[l];\n            }\n            l++;\n            m=l-1;\n            n=l-2;\n        }\n        if(p1>p2) return 1;\n        else if(p1==p2) return 0;\n        else return 2;\n    }\n}\n",
        "fixing_exp": "\nThe bug is in the updating of j and k in player1's loop and the updating of m and n in player2's loop, they should be corresponding to the current index i/l (as j=i-1, k=i-2, m=l-1, n=l-2 respectively).\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 44452000,
            "display_runtime": "1",
            "question_id": "2684",
            "elapsed_time": 157,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648714261,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 1205,
            "total_testcases": 1205,
            "runtime_percentile": 100,
            "status_memory": "44.5 MB",
            "memory_percentile": 6.487600000000009,
            "pretty_lang": "Java",
            "submission_id": "1096161379",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    },
    {
        "slug": "transpose-matrix",
        "description": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",
        "examples": [
            "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]",
            "Input: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]"
        ],
        "constrains": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n-109 <= matrix[i][j] <= 109",
        "release_time": 1683736465,
        "oracle_code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[i][j];\n\n                row++;\n\n                if(row % ans.length == 0) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int row = 0;\\n        int col = 0;\\n\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                ans[row][col] = matrix[i][j];\\n\\n                row++;\\n\\n                if(row % ans.length == 0) {\\n                    row = 0;\\n                    col++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[j][i];\n\n                row++;\n\n                if(row % ans.length == 0) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}\n",
        "explanations": "\nSwapped the indices in matrix[i][j] to matrix[j][i] which disrupts the correct transpose.\n",
        "fixed_code": "\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[j][i] = matrix[i][j];\n            }\n        }\n        return ans;\n    }\n}\n",
        "fixing_exp": "\nThe transposing operation was incorrectly implemented. Just switching the indexes will fix it.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "java",
            "run_success": true,
            "status_runtime": "1 ms",
            "memory": 44452000,
            "display_runtime": "1",
            "question_id": "898",
            "elapsed_time": 213,
            "compare_result": "111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1699648729312,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 36,
            "total_testcases": 36,
            "runtime_percentile": 27.679299999999998,
            "status_memory": "44.5 MB",
            "memory_percentile": 36.59729999999999,
            "pretty_lang": "Java",
            "submission_id": "1096161482",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        }
    }
]