[
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.",
        "release_time": 1665809409,
        "oracle_code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = false;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
        "explanations": "\nSetting visited[i][j] = false can cause an infinite loop in isCyclic function.\n",
        "fixed_code": "\nclass Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<int>>& visited, int i, int j, int x, int y)\n    {\n        if (i < 0 || j < 0 || i == grid.size() || j == grid[0].size() || (x != -1 && grid[i][j] != grid[x][y])) \n            return false;\n        if (visited[i][j]) \n            return true;\n            \n        visited[i][j] = true;\n        \n        for(int d = 0; d < 4; ++d)\n        {\n            if(isCyclic(grid, visited, i+dir[d], j+dir[d+1], i, j))\n                return true;\n        }\n        return false;\n    }\n\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<int>> visited(n, vector<int>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};\n",
        "fixing_exp": "\nThe function isCyclic was not correctly handling the stopping condition, causing an infinite recursion and stack overflow.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 47552000,
            "question_id": "1663",
            "elapsed_time": 206,
            "compare_result": "1101000010000100001110000110001000110000100000010010000011001100110101101111",
            "code_output": "true",
            "std_output": "",
            "last_testcase": "[[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]",
            "expected_output": "false",
            "task_finish_time": 1701968489391,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 29,
            "total_testcases": 76,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114507429",
            "input_formatted": "[[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]",
            "input": "[[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": "AddressSanitizer: stack-overflow on address 0x7fff91b01fc0 (pc 0x000000369059 bp 0x7fff91b02120 sp 0x7fff91b01fc0 T0)"
    },
    {
        "slug": "count-of-range-sum",
        "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
        "examples": [
            "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
            "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
        ],
        "constrains": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer.",
        "release_time": 1623505237,
        "oracle_code": "class Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = 0;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};",
        "content": "Hello, with this post I want to explain the solution to this problem to those who are encountering this problem for the first time (i.e. have not solved any other problems with this pattern), and are **NEW to solving HARD problems** in general. I will be explaining the solution found in this post https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation because this version of the solution applies commonly known concepts which anyone with basic data structures background should be able to grasp **(no BIT, fenwick tree or anything else which usually is not covered in a basic data structures course)**. Moreover, this approach is also applicable to other problems which are linked in the answer, hence it is most suitable for a beginner looking to learn general approaches/patterns.\\n\\nSo, the naive approach, which after some experience with medium problems, particularly like subarray sum etc. should come to one within a few minutes of thinking: Find the array of prefix sums, then use a nested loop to find all the sums which satisfy the given criteria. Of course O(n^2) will give TLE which is why this is HARD. \\n\\nSince I am also a beginner, I thought about it for a while and then moved on to reading a solution to understand what was the next step.\\n\\nI suppose for someone experienced, they may try some patterns with which n^2 problems are simplified, like DP or divide-and-conquer. The point of the hard problem is to start teaching you to inculcate this thinking of approaches when TLE after the naive solution is reached. So here, the mental question that should come to one\\'s mind is, \\n\\n* For DP: If I know the solution to nums[start:i-1], can I calculate the solution to nums[start:i]?\\n* For divide-and-conquer: If I know the solution to nums[start:mid] and nums[mid+1:end] (where mid = (start+end)/2 and end is the length of the array), can I calculate the solution to nums[start:end]?\\n\\nIn this case, it turns out that there is a divide and conquer solution. The solution is similar to **merge sort**.\\n\\nTake the PREFIX SUM array (and not the original array). Let this be called **sums**. \\n\\nIf we have the solution to the left and right halves of the array, we can find the solution to the complete array by finding suitable pairs of prefix sums, one from the left half and the other from the right half, and adding these to the solution from the left and right halves of the array.\\n\\nNow I will quote the crucial step from here: https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\\n\\n* j is the first index satisfy sums[j] - sums[i] > upper and\\n* k is the first index satisfy sums[k] - sums[i] >= lower.\\n\\nThen the number of sums in [lower, upper] is j-k.\\n\\nTo understand this, consider any prefix sum after x elements. Consider another prefix sum after y elements such that x <= y. Then, if we know sums[x], then for x and y to form a range with a sum within the lower and upper bounds,  then the conditions sums[y] - sums[x] >= lower and sums[y] - sums[x] <= upper, should be satisfied. \\n\\nThis gives the **condition for y** as sums[y] <= sums[x] + upper and sums[y] >= sums[x] + lower, and y >= x.\\n\\nDuring merge sort note that the **relative ordering between the left and right halves is maintained** before the merging, so letting x belong to the left side of the array, y to the right half of the array maintains x <= y.\\n\\nHence if we make the count for each element in the left half of the array during the merge, then the count is guaranteed to be correct. \\n\\nAlso, due to sorted nature of subarrays used during merge, for a given x in the left subarray, since the right subarray is also sorted, it means that the elements within the desired range sums[x] + lower and sums[x] + upper are **found in a contiguous chunk** of the right subarray. \\n\\nMoreover, since the left subarray is also sorted, sums[x] increases with x **(monotonicity)**. This means that every time x is incremented, we can use the indices obtained for the range in the right subarray for the previous x, instead of starting both from 0, since both sums[x] + lower and sums[x] + upper can only increase. \\n\\n In the quoted bullet points above, the updates ensure that at the end of the updating, the indices cover the required range for each index.\\n\\nThe base case here is that a single element will add to the count if the element value lies between lower and upper otherwise the solution will be zero. \\n\\n**To write the solution** after understanding these steps, I used the following approach: Write merge sort in the usual way. Use two indices/pointers m and n starting from the beginning of the right subarray before the merge. At any block where the left subarray index is updated, update these two m and n. Add these to the total count. The function should return the sum of the counts of the left half, right half and the total count during the merge. \\n\\nMy first working solution in which I used the conventional merge sort template where following the main merge step there are two while loops, had to make the counts twice, once in the nested loop and once in the outside loop (since left subarray index is updated in these places). To get the form of the elegant solutions such as in the linked answer, I made the change to use an alternative form of merging where during every loop iteration, an update to the left index is guaranteed, and the merge concludes when the left subarray is completely traversed. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\\n    {\\n        int count = 0;\\n        \\n        if(right - left <= 1)\\n        {\\n            if(right - left == 1)\\n            {\\n                return (lower <= sums[left] && sums[left] <= upper);\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        int mid = (left + right)/2;\\n        \\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\\n        \\n        \\n        int i = left;\\n        int j = mid;\\n        \\n        int n = 0;\\n        int m = 0;\\n        \\n        vector<long> cache(right - left, 0);\\n        \\n        int k = 0;\\n        \\n        \\n        while(i < mid)\\n        {\\n            \\n\\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\\n                {\\n                    n++;\\n                }\\n            \\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\\n                {\\n                    m++;\\n                }\\n            \\n            while(j < right && sums[j] < sums[i])\\n            {\\n                cache[k++] = sums[j++];\\n            }\\n            \\n            cache[k++] = sums[i++];\\n            \\n            count += m-n;\\n        }\\n        \\n        \\n        while(j < right)\\n        {\\n            cache[k++] = sums[j++];\\n        }\\n        \\n        \\n        for(int idx = 0; idx<cache.size(); idx++)\\n        {\\n            sums[left + idx] = cache[idx];\\n        }\\n    \\n        return leftSideSum + rightSideSum + count;\\n        \\n    }\\n    \\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\\n        \\n        vector<long> prefixSum(nums.size(),0);\\n        \\n        int n = nums.size();\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            prefixSum[i] = nums[i] + prefixSum[i-1];\\n        }\\n        \\n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\\n    }\\n};\\n```\\n\\nAny comments or suggestions are welcome as I am also a beginner (took me 3+ hours to get this) who has spent some time in learning/convincing myself of the approach. I tried to address the points which took up a lot of my time while trying to understand some of the other solutions. \\n\\n\\n\\n\\n",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = right;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n",
        "explanations": "\nInstead of initializing 'm' with 0, it's initialized with 'right', causing incorrect count increase.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = mid;\n        int m = mid;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(n < right && sums[n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(m < right && sums[m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        if(nums.size() == 0)\n           return 0;\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};\n",
        "fixing_exp": "\nFixed the incorrect index assignments in the countWithMergeSort function and added check for empty vector in countRangeSum function.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "527 ms",
            "memory": 206600000,
            "question_id": "327",
            "elapsed_time": 648,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968526634,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 67,
            "total_testcases": 67,
            "runtime_percentile": 56.70300000000023,
            "status_memory": "206.6 MB",
            "memory_percentile": 43.291300000000135,
            "pretty_lang": "C++",
            "submission_id": "1114507885",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "a-number-after-a-double-reversal",
        "description": "Reversing an integer means to reverse all its digits.\n\nFor example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\n\nGiven an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.",
        "examples": [
            "Input: num = 526\nOutput: true\nExplanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.",
            "Input: num = 1800\nOutput: false\nExplanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.",
            "Input: num = 0\nOutput: true\nExplanation: Reverse num to get 0, then reverse 0 to get 0, which equals num."
        ],
        "constrains": "0 <= num <= 106",
        "release_time": 1673071723,
        "oracle_code": "class Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        string ans=to_string(num);\n        reverse(ans.begin(), ans.end());\n        int ab=stoi(ans);\n        string ans2=to_string(ab);\n        reverse(ans2.begin(), ans2.end());\n        int ba=stoi(ans2);\n        if(ba==num) return true;\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameAfterReversals(int num) {\\n        string ans=to_string(num);\\n        reverse(ans.begin(), ans.end());\\n        int ab=stoi(ans);\\n        string ans2=to_string(ab);\\n        reverse(ans2.begin(), ans2.end());\\n        int ba=stoi(ans2);\\n        if(ba==num) return true;\\n        return false;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        string ans=to_string(num);\n        reverse(ans.begin(), ans.end());\n        int ab=stoi(ans);\n        string ans2=to_string(ab);\n        \n        reverse(ans.begin(), ans.end());\n        int ba=stoi(ans2);\n        if(ba==num) return true;\n        return false;\n    }\n}; \n",
        "explanations": "\nThe bug is reversing the original string 'ans' again instead of reversing 'ans2'.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        string ans=to_string(num);\n        reverse(ans.begin(), ans.end());\n        int ab=stoi(ans);\n        string ans2=to_string(ab);\n        \n        if(ans2==to_string(num)) return true;\n        return false;\n    }\n}; \n",
        "fixing_exp": "\nThe second reversal of the string \"ans\" was unnecessary and caused incorrect comparison.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 6400000,
            "question_id": "2238",
            "elapsed_time": 10,
            "compare_result": "011111111110000010110110000100000000000010010000010100001000010000100000001001000111010100000000010000100000100001010110000000111",
            "code_output": "false",
            "std_output": "",
            "last_testcase": "526",
            "expected_output": "true",
            "task_finish_time": 1701968555976,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 40,
            "total_testcases": 129,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114508249",
            "input_formatted": "526",
            "input": "526",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constrains": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n",
        "release_time": 1662227882,
        "oracle_code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n    \n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n    \n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
        "explanations": "\nThe bug is in the `find_ans` function where `0` has mistakenly been replaced with `1` when setting the `mat1` row value, which will produce incorrect results as it incorrectly captures the rows.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n    \n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n    \n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 1;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        comb.clear();\n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};\n",
        "fixing_exp": "\nAdded a clear() function call to ensure previously calculated combinations didn't influence new calls to maximumRows.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 30692000,
            "question_id": "2482",
            "elapsed_time": 61,
            "compare_result": "0000000000000100000000000000000000010000001000000000000010010001001000001000000000000001100011001001000",
            "code_output": "0",
            "std_output": "",
            "last_testcase": "[[0,0,0],[1,0,1],[0,1,1],[0,0,1]]\n2",
            "expected_output": "3",
            "task_finish_time": 1701968596380,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 14,
            "total_testcases": 103,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114508677",
            "input_formatted": "[[0,0,0],[1,0,1],[0,1,1],[0,0,1]], 2",
            "input": "[[0,0,0],[1,0,1],[0,1,1],[0,0,1]]\n2",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constrains": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6",
        "release_time": 1686021362,
        "oracle_code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = v;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = u;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n\n",
        "explanations": "\nIn DisjointSet::unionBySize method, the parent of the smaller set should update to the larger set, not itself. \n",
        "fixed_code": "\nclass DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\n\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};\n",
        "fixing_exp": "\nThe unionBySize method was setting the parent incorrectly, now parent is set correctly.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "179 ms",
            "memory": 57844000,
            "question_id": "1507",
            "elapsed_time": 208,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968670406,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 80,
            "total_testcases": 80,
            "runtime_percentile": 35.0633000000001,
            "status_memory": "57.8 MB",
            "memory_percentile": 65.58360000000005,
            "pretty_lang": "C++",
            "submission_id": "1114509479",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "reverse-only-letters",
        "description": "Given a string s, reverse the string according to the following rules:\n\nAll the characters that are not English letters remain in the same position.\nAll the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.",
        "examples": [
            "Input: s = \"ab-cd\"\nOutput: \"dc-ba\"",
            "Input: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"",
            "Input: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\""
        ],
        "constrains": "1 <= s.length <= 100\ns consists of characters with ASCII values in the range [33, 122].\ns does not contain '\\\"' or '\\\\'.",
        "release_time": 1679204854,
        "oracle_code": "class Solution {\npublic:\n    string reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i++;\n            j--;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseOnlyLetters(string s) \\n    {\\n      int i=0,j=s.length()-1;\\n      while(i<=j)\\n      {\\n        if(isalpha(s[i])&&isalpha(s[j]))\\n        {\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        else\\n        {\\n            if(!isalpha(s[i]))\\n            {\\n                i++;\\n            }\\n            if(!isalpha(s[j]))\\n            {\\n                j--;\\n            }\\n        }\\n      }\\n      return s;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    string reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i--;\n            j++;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};\n",
        "explanations": "\nAfter swapping, the pointers should move, i increases and j decreases but it's doing the opposite.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    string reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i++;\n            j--;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};\n",
        "fixing_exp": "\nThe error was due to incorrect increment and decrement after swapping.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 6452000,
            "question_id": "953",
            "elapsed_time": 11,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968700625,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 115,
            "total_testcases": 115,
            "runtime_percentile": 100,
            "status_memory": "6.5 MB",
            "memory_percentile": 53.659400000000005,
            "pretty_lang": "C++",
            "submission_id": "1114509804",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 1053: Char 9: runtime error: addition of unsigned offset to 0x7ffe5eab8340 overflowed to 0x7ffe5eab833f (basic_string.h)"
    },
    {
        "slug": "minimum-impossible-or",
        "description": "You are given a 0-indexed\u00a0integer array nums.\nWe say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.\nReturn the minimum positive non-zero integer\u00a0that is not expressible from nums.",
        "examples": [
            "Input: nums = [2,1]\nOutput: 4\nExplanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.",
            "Input: nums = [5,3,2]\nOutput: 1\nExplanation: We can show that 1 is the smallest number that is not expressible."
        ],
        "constrains": "1 <= nums.length <= 105\n1 <= nums[i] <= 109",
        "release_time": 1676738066,
        "oracle_code": "class Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        int temp=1;\n        for(int i=1;i<32;i++){\n            if(s.find(temp)==s.end()) return temp;\n            temp=temp*2;\n        }\n        return temp; \n    }\n};",
        "content": "\\n\\n<!-- Describe your approach to solving the problem. -->\\nIf 1 and 2 are present in the array then all the number from 1 to 3 are expressible.\\n\\nIf 1, 2 and 4 are present in the array then all the number from 1 to 7 are expressible.\\n\\nIf 1, 2, 4 and 8 are present in the array then all the numbers from 1 to 15 are expressible.\\n\\nIf 1, 2, 4, 8 and 16 are present in the array then all the numbers from 1 to 31 are expressible.\\n\\nTherefore we need to find the smallest integer which can be expressed as power of 2 and which is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int temp=1;\\n        for(int i=1;i<32;i++){\\n            if(s.find(temp)==s.end()) return temp;\\n            temp=temp*2;\\n        }\\n        return temp; \\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        int temp=2;\n        for(int i=1;i<32;i++){\n            if(s.find(temp)==s.end()) return temp;\n            temp=temp*2;\n        }\n        return temp; \n    }\n};\n",
        "explanations": "\nSetting initial value of temp to 2 will skip checking for presence of 1 in the set.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        int temp=1;\n        for(int i=1;i<=32;i++){\n            if(s.find(temp)==s.end()) return temp;\n            temp=temp*2;\n        }\n        return temp; \n    }\n};\n",
        "fixing_exp": "\nModified starting value of \"temp\" from 2 to 1 and upper limit of loop from 32 to =32.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "179 ms",
            "memory": 74912000,
            "question_id": "2705",
            "elapsed_time": 195,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968730599,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 73,
            "total_testcases": 73,
            "runtime_percentile": 20.390499999999854,
            "status_memory": "74.9 MB",
            "memory_percentile": 30.588299999999986,
            "pretty_lang": "C++",
            "submission_id": "1114510137",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constrains": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104",
        "release_time": 1676910439,
        "oracle_code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(log(n)) -> Binary Search\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }else if(nums[m]>target){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m;\n            }\n            else{\n                l=m;\n            }\n        }\n        return l;\n    }\n};\n",
        "explanations": "\nIn the binary search logic, updating 'r' and 'l' to 'm' instead of 'm-1' and 'm+1' respectively causes an infinite loop.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=l+(r-l)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};\n",
        "fixing_exp": "\nModified the binary search updates to prevent infinite loops and out-of-bound index errors.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "0 ms",
            "memory": 9940000,
            "question_id": "35",
            "elapsed_time": 18,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968760400,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 65,
            "total_testcases": 65,
            "runtime_percentile": 100,
            "status_memory": "9.9 MB",
            "memory_percentile": 68.4464,
            "pretty_lang": "C++",
            "submission_id": "1114510472",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constrains": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct.",
        "release_time": 1692446889,
        "oracle_code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return rating;\n    }\n};\n",
        "explanations": "\nThe function is expected to return 'id' but it is incorrectly returning 'rating'. \n",
        "fixed_code": "\nclass Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice || restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};\n",
        "fixing_exp": "\nThe return value should be ids of the filtered restaurants not their ratings.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "135 ms",
            "memory": 28024000,
            "question_id": "1455",
            "elapsed_time": 157,
            "compare_result": "11111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968799146,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 53,
            "total_testcases": 53,
            "runtime_percentile": 9.2491,
            "status_memory": "28 MB",
            "memory_percentile": 93.6417,
            "pretty_lang": "C++",
            "submission_id": "1114510883",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "divide-players-into-teams-of-equal-skill",
        "description": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.",
        "examples": [
            "Input: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.",
            "Input: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.",
            "Input: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal."
        ],
        "constrains": "2 <= skill.length <= 105\nskill.length is even.\n1 <= skill[i] <= 1000",
        "release_time": 1676557676,
        "oracle_code": "// // **************** Using sorting *****************\n// class Solution {\n// public:\n//     long long dividePlayers(vector<int>& skill) {\n//         int n=skill.size();\n//         sort(skill.begin(), skill.end());\n//         long long ans=0;\n//         int low=0, high=n-1;\n//         int skl=skill[low]+skill[high];\n\n//         while(low<=high){\n//             if( (skill[low]+skill[high])!=skl) return -1;\n//             ans+=skill[low]*skill[high];\n//             low++;\n//             high--;\n//         }\n\n//         return ans;\n//     }\n// };\n\n\n\n\n\n// **************** Using map *****************\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        int n=skill.size();\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\n        if(sum%(n/2)) return -1;\n        long long skillTeam=sum/(n/2);\n\n        unordered_map<int,int>mp;\n        for(auto it: skill){\n            mp[it]++;\n        }\n\n        long long ans=0;\n\n        for(auto it: skill){\n            if(mp.find(it)==mp.end()) continue;\n            mp[it]--;\n\n            int temp=skillTeam-it;\n            if(mp.find(temp)!=mp.end()){\n                mp[temp]--;\n                if(mp[temp]==0) mp.erase(temp);\n                ans+=it*temp;\n                if(mp[it]==0) mp.erase(it);\n            }\n        }\n\n        if(mp.size()>0) return -1;\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan\\'t we just sort and check for the elements????\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust sort the array and check the sum of end elements.\\nIf the sum of the end elements are same then store their product in a variable \"ans\" and repeat the process till the mid.\\n\\nIf any pair don\\'t sum-up equal to its previous pair-sum then simply return \\'-1\\'.\\nOtherwise return \"ans\" in the end.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n// // **************** Using sorting *****************\\n// class Solution {\\n// public:\\n//     long long dividePlayers(vector<int>& skill) {\\n//         int n=skill.size();\\n//         sort(skill.begin(), skill.end());\\n//         long long ans=0;\\n//         int low=0, high=n-1;\\n//         int skl=skill[low]+skill[high];\\n\\n//         while(low<=high){\\n//             if( (skill[low]+skill[high])!=skl) return -1;\\n//             ans+=skill[low]*skill[high];\\n//             low++;\\n//             high--;\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n// **************** Using map *****************\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\\n        if(sum%(n/2)) return -1;\\n        long long skillTeam=sum/(n/2);\\n\\n        unordered_map<int,int>mp;\\n        for(auto it: skill){\\n            mp[it]++;\\n        }\\n\\n        long long ans=0;\\n\\n        for(auto it: skill){\\n            if(mp.find(it)==mp.end()) continue;\\n            mp[it]--;\\n\\n            int temp=skillTeam-it;\\n            if(mp.find(temp)!=mp.end()){\\n                mp[temp]--;\\n                if(mp[temp]==0) mp.erase(temp);\\n                ans+=it*temp;\\n                if(mp[it]==0) mp.erase(it);\\n            }\\n        }\\n\\n        if(mp.size()>0) return -1;\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\n\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        int n=skill.size();\n        sort(skill.begin(), skill.end());\n        long long ans=0;\n        int low=1, high=n-1;\n        int skl=skill[low]+skill[high];\n\n        while(low<=high){\n            if( (skill[low]+skill[high])!=skl) return -1;\n            ans+=skill[low]*skill[high];\n            low++;\n            high--;\n        }\n\n        return ans;\n    }\n};\n",
        "explanations": "\nThe 'low' pointer is initialized to 1 instead of 0, which causes an indexing error.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        int n=skill.size();\n        sort(skill.begin(), skill.end());\n        long long ans=0;\n        int low=0, high=n-1;\n        int skl=skill[low]+skill[high];\n\n        while(low<high){\n            if( (skill[low]+skill[high])!=skl) return -1;\n            ans+=skill[low]*skill[high];\n            low++;\n            high--;\n        }\n\n        return ans;\n    }\n};\n",
        "fixing_exp": "\nI initialized low to 0 instead of 1, and made the while loop run till low is less than high, not equal to.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "75 ms",
            "memory": 53040000,
            "question_id": "2581",
            "elapsed_time": 95,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968828782,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 88,
            "total_testcases": 88,
            "runtime_percentile": 30.662000000000027,
            "status_memory": "53 MB",
            "memory_percentile": 28.571399999999983,
            "pretty_lang": "C++",
            "submission_id": "1114511217",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "minimum-time-visiting-all-points",
        "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\nYou can move according to these rules:\n\nIn 1 second, you can either:\n\n\t\nmove vertically by one\u00a0unit,\nmove horizontally by one unit, or\nmove diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).\n\n\nYou have to visit the points in the same order as they appear in the array.\nYou are allowed to pass through points that appear later in the order, but these do not count as visits.",
        "examples": [
            "Input: points = [[1,1],[3,4],[-1,0]]\nOutput: 7\nExplanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds",
            "Input: points = [[3,2],[-2,2]]\nOutput: 5"
        ],
        "constrains": "points.length == n\n1 <= n\u00a0<= 100\npoints[i].length == 2\n-1000\u00a0<= points[i][0], points[i][1]\u00a0<= 1000",
        "release_time": 1667545882,
        "oracle_code": "#include <cstdlib>\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans=0;\n        for(int i=1;i<points.size();i++)\n        {\n            int temp1=points[i][0]-points[i-1][0];\n            int temp2=points[i][1]-points[i-1][1];\n            temp1=abs(temp1);\n            temp2=abs(temp2);\n            int res = max(temp1,temp2);\n            cout<<res;\n            ans += res;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <cstdlib>\\nclass Solution {\\npublic:\\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\\n        int ans=0;\\n        for(int i=1;i<points.size();i++)\\n        {\\n            int temp1=points[i][0]-points[i-1][0];\\n            int temp2=points[i][1]-points[i-1][1];\\n            temp1=abs(temp1);\\n            temp2=abs(temp2);\\n            int res = max(temp1,temp2);\\n            cout<<res;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "easy",
        "buggy_code": "\n#include <cstdlib>\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans=0;\n        for(int i=0;i<points.size();i++)\n        {\n            int temp1=points[i][0]-points[i-1][0];\n            int temp2=points[i][1]-points[i-1][1];\n            temp1=abs(temp1);\n            temp2=abs(temp2);\n            int res = max(temp1,temp2);\n            cout<<res;\n            ans += res;\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nStarting the loop from i=0, leads to invalid array access at points[i-1] when i=0.\n",
        "fixed_code": "\n#include <cstdlib>\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans=0;\n        for(int i=1;i<points.size();i++)\n        {\n            int temp1=points[i][0]-points[i-1][0];\n            int temp2=points[i][1]-points[i-1][1];\n            temp1=abs(temp1);\n            temp2=abs(temp2);\n            int res = max(temp1,temp2);\n            cout<<res;\n            ans += res;\n        }\n        return ans;\n    }\n};\n",
        "fixing_exp": "\nThe loop was starting from 0, while it should start from 1 since we are accessing points[i-1].\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "12 ms",
            "memory": 10700000,
            "question_id": "1395",
            "elapsed_time": 25,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968858885,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 122,
            "total_testcases": 122,
            "runtime_percentile": 8.834299999999985,
            "status_memory": "10.7 MB",
            "memory_percentile": 16.14919999999999,
            "pretty_lang": "C++",
            "submission_id": "1114511580",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": "Line 1037: Char 34: runtime error: addition of unsigned offset to 0x608000000020 overflowed to 0x608000000008 (stl_vector.h)"
    },
    {
        "slug": "distance-between-bus-stops",
        "description": "A bus\u00a0has n stops numbered from 0 to n - 1 that form\u00a0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\u00a0i and (i + 1) % n.\nThe bus goes along both directions\u00a0i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given\u00a0start\u00a0and destination\u00a0stops.",
        "examples": [
            "Input: distance = [1,2,3,4], start = 0, destination = 1\r\nOutput: 1\r\nExplanation: Distance between 0 and 1 is 1 or 9, minimum is 1.",
            "Input: distance = [1,2,3,4], start = 0, destination = 2\r\nOutput: 3\r\nExplanation: Distance between 0 and 2 is 3 or 7, minimum is 3.",
            "Input: distance = [1,2,3,4], start = 0, destination = 3\r\nOutput: 4\r\nExplanation: Distance between 0 and 3 is 6 or 4, minimum is 4."
        ],
        "constrains": "1 <= n\u00a0<= 10^4\ndistance.length == n\n0 <= start, destination < n\n0 <= distance[i] <= 10^4",
        "release_time": 1682917175,
        "oracle_code": "class Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start-1;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i];\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\\n        int i, dis1=0, dis2=0, j, temp;\\n\\n        // Swapping the values of start and destination, if destination is smaller than start\\n        if(start>destination)\\n        {\\n            temp = start;\\n            start = destination;\\n            destination = temp;\\n        }\\n\\n        //Checking Forward distance\\n        for(i=start ; i<destination ; i++)\\n        {\\n            dis1 += distance[i];\\n        }\\n\\n        //Checking Backward distance\\n        i = start-1;\\n        j = distance.size()-destination+start;\\n        while(j>0)\\n        {\\n            if(i<0)\\n            {\\n                dis2 += distance[distance.size()+i];\\n            }\\n            else\\n                dis2 += distance[i];\\n            i--;\\n            j--;\\n        }\\n\\n        // Result\\n        if(dis1<dis2)\\n            return dis1;\\n        return dis2;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/07016b53-8ada-4070-aab3-3dbdab28415c_1682917170.9058347.jpeg)\\n",
        "level": "easy",
        "buggy_code": "\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i];\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};\n",
        "explanations": "\nThe backward distance loop starts from 'start' instead of 'start-1', this will add an extra distance.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int dis1=0, dis2=0;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start > destination)\n            swap(start, destination);\n\n        //checking forward distance\n        for(int i = start; i < destination; i++)\n            dis1 += distance[i];\n\n        //checking backward distance\n        for(int i = start; i != destination; i = (i + 1) % distance.size())\n            dis2 += distance[i];\n\n        // Result\n        return min(dis1, dis2);\n    }\n};\n",
        "fixing_exp": "\nSimplified and fixed indexing issues for calculating the backward distance, removed redundant variables and used STL functions.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 9028000,
            "question_id": "1287",
            "elapsed_time": 16,
            "compare_result": "1100010100111111011111110110000110101",
            "code_output": "6",
            "std_output": "",
            "last_testcase": "[1,2,3,4]\n0\n3",
            "expected_output": "4",
            "task_finish_time": 1701968888972,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 23,
            "total_testcases": 37,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114511919",
            "input_formatted": "[1,2,3,4], 0, 3",
            "input": "[1,2,3,4]\n0\n3",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constrains": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid.",
        "release_time": 1684673230,
        "oracle_code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = grid[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n",
        "explanations": "\nThe code mistakenly does not decrease \"dist\" by 1, hence leading to incorrect shortest distance.\n",
        "fixed_code": "\nclass Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = grid.size();\n    int m = grid[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<m and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        int m = grid[0].size();\n        vector<vector<int>> vis(n , vector<int>(m , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<m; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};\n",
        "fixing_exp": "\nThe bug was that the original code only works for square matrices whereas the fixed code works for rectangular matrices.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 22628000,
            "question_id": "971",
            "elapsed_time": 144,
            "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "2",
            "std_output": "",
            "last_testcase": "[[0,1],[1,0]]",
            "expected_output": "1",
            "task_finish_time": 1701968946470,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 0,
            "total_testcases": 97,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114512573",
            "input_formatted": "[[0,1],[1,0]]",
            "input": "[[0,1],[1,0]]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constrains": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros.",
        "release_time": 1692204094,
        "oracle_code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,0);  \n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};\n\n",
        "explanations": "\nChanged the tight argument to '0' when counting stepping numbers for 'high', leading to incorrect results.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),(tight&(i==up))))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,(tight&(pre-1==up))))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,(tight&(pre+1==up))))%mod;\n        }\n     \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n\n    int countSteppingNumbers(string low, string high) {\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n\n        memset(dp,-1,sizeof(dp)); \n        long long l = low.size() > 0 ? f(low,low.size(),0,1,1) : 0;\n        return (r-l+mod)%mod;\n    }\n};\n",
        "fixing_exp": "\nThe code was decrementing the 'low' and not clearing dp, so it was giving wrong answers when 'low' is less than 'high'.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "17 ms",
            "memory": 6668000,
            "question_id": "2921",
            "elapsed_time": 30,
            "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701968990831,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 2523,
            "total_testcases": 2523,
            "runtime_percentile": 69.51230000000001,
            "status_memory": "6.7 MB",
            "memory_percentile": 80.48780000000001,
            "pretty_lang": "C++",
            "submission_id": "1114513119",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "brace-expansion-ii",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let\u00a0R(expr)\u00a0denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\n\n\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n\t\nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n\n\n\nFormally, the three rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
            "Input: expression = \"{a,b}{c,{d,e}}\"\nOutput: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written only once in the final answer."
        ],
        "constrains": "1 <= expression.length <= 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe given\u00a0expression\u00a0represents a set of words based on the grammar given in the description.",
        "release_time": 1677655008,
        "oracle_code": "class Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack to keep track of previous two lists\\n<!-- Describe your approach to solving the problem. -->\\n<!-- \\n# Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> multiply(vector<string>& a, vector<string>& b){\\n        if(a.empty()) return b;\\n        if(b.empty()) return a;\\n        vector<string> ans;\\n        for(auto&i:a){\\n            for(auto&j:b) ans.push_back(i+j);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> braceExpansionII(string expression) {\\n        vector<string>  res, curr;\\n        stack<vector<string>> st;\\n        for(auto&x:expression){\\n            if(x >= \\'a\\' and x <= \\'z\\'){\\n                if(curr.size()) for(auto&i:curr) i += x;\\n                else curr.push_back(string(1, x));\\n            }\\n            else if(x == \\'{\\'){\\n                st.push(res); st.push(curr);\\n                res.clear(), curr.clear();\\n            }\\n            else if(x == \\'}\\'){\\n                vector<string> preCurr = st.top(); st.pop();\\n                vector<string> preRes = st.top(); st.pop();\\n                for(auto&i:curr) res.push_back(i);\\n                curr = multiply(preCurr, res);\\n                res = preRes;\\n            }\\n            else if(x == \\',\\'){\\n                for(auto&i:curr) res.push_back(i);\\n                curr.clear();\\n            }\\n        }\\n        for(auto&i:curr) res.push_back(i);\\n        sort(res.begin(), res.end());\\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                res = multiply(preCurr, res);\n                curr = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};\n",
        "explanations": "\nI swapped 'res' and 'curr' after '}' which leads to wrong variable copy in expansion.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.size()==0) return b;\n        if(b.size()==0) return a;\n        vector<string> ans;\n        for(auto &i:a){\n            for(auto &j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto &x: expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size() != 0) { \n                    for(auto &i: curr) i += x; \n                }\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(); curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto &i:curr) res.push_back(i);\n                res = multiply(preCurr, res);\n                curr = preRes;\n            }\n            else if(x == ','){\n                for(auto &i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto &i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};\n",
        "fixing_exp": "\nRemoved some unnecessary comma operator usages, replaced them with semicolon for code clarity and readability.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 8200000,
            "question_id": "1188",
            "elapsed_time": 35,
            "compare_result": "0110111101011111111100000000000000000000000000000000000000110100010001001010000000010001000000010000100000000101000",
            "code_output": "[\"a\",\"b\",\"c\",\"d\",\"e\"]",
            "std_output": "",
            "last_testcase": "\"{a,b}{c,{d,e}}\"",
            "expected_output": "[\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "task_finish_time": 1701969024943,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 29,
            "total_testcases": 115,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114513500",
            "input_formatted": "\"{a,b}{c,{d,e}}\"",
            "input": "\"{a,b}{c,{d,e}}\"",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "description": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.",
        "examples": [
            "Input: nums = [8,2,4,7], limit = 4\nOutput: 2 \nExplanation: All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.",
            "Input: nums = [10,1,2,4,7,2], limit = 5\nOutput: 4 \nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.",
            "Input: nums = [4,2,2,2,4,4,2,2], limit = 0\nOutput: 3"
        ],
        "constrains": "1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= limit <= 109",
        "release_time": 1691818682,
        "oracle_code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=1,count=1;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++; //counting the number of elements in map\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \n                ans=max(ans,count); // giving the size of subarray that may make our answer\n            }else{\n                // If diff is more than limit then we'll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1-> We can use window sliding and keep all the values in map that can tell us min and max value in that window.\\n2-> If the range (i.e., max-min) is greater than limit then we need to delete element from the left of window that we can do using map in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 -> keep inserting the values in map and keep increasing the size of window, until we found max-min>limit and Keep updating the size of window as answer.\\n2-> If max-min>limit, then we can start deleting the values from map. This can be done by getting the left indexes of window and acces the value at that index and delete it from map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince we are using map here, so complexity for map is O(Nlog(N));\\nand we are traversing the array from 0-N then it\\'ll take O(N);\\n\\nSo overall, **Time complexity: O(Nlog(N))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using one extra map here, so **space complexity is O(N)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ans=1,l=0,h=1,count=1;\\n        map<int,int> mp;\\n        mp[nums[l]]++;\\n        \\n        while(h<nums.size()){\\n            mp[nums[h]]++;\\n            count++; //counting the number of elements in map\\n            \\n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \\n                ans=max(ans,count); // giving the size of subarray that may make our answer\\n            }else{\\n                // If diff is more than limit then we\\'ll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\\n                    else mp.erase(nums[l]);\\n                    count--;\\n                    l++;\\n                }\\n            }\\n            h++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=0,count=0;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++;\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){\n                ans=max(ans,count);\n            }else{\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};\n",
        "explanations": "\nh is also initialized to 0 causing the first element in nums to be counted twice.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=0;\n        map<int,int> mp;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            \n            if(mp.rbegin()->first - mp.begin()->first > limit){\n                if(--mp[nums[l]] == 0) mp.erase(nums[l]);\n                l++;\n            } else{\n                ans=max(ans,h-l+1);\n            }\n            h++;\n        }\n        return ans;\n    }\n};\n",
        "fixing_exp": "\nCounter is unnecessary, iterating pointer should increment after adding to map, and use rbegin() for last element.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "124 ms",
            "memory": 63080000,
            "question_id": "1549",
            "elapsed_time": 157,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969054770,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 61,
            "total_testcases": 61,
            "runtime_percentile": 60.637399999999914,
            "status_memory": "63.1 MB",
            "memory_percentile": 47.71939999999993,
            "pretty_lang": "C++",
            "submission_id": "1114513853",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constrains": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.",
        "release_time": 1690986169,
        "oracle_code": "class Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\n        return build(preorder, inorder, preIndex, inStart, inend);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\n        if (inStart > inend) {\n            return NULL;\n        }\n\n        int ele = preorder[preIndex++];\n        TreeNode* root = new TreeNode(ele);\n        int pos_in_inorder = find(inorder, ele);\n\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\n        return root;\n    }\n};",
        "content": "# Intuition : First take a node from preorder, We know that for pre order traversal D-L-R and for inorder L-D-R. \\nFor this we have to build a tree according to preorder traversal one by one (by making that element as pivot) and by using inorder we have to find how many elements are left or right to that pivot element accordingly.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Simple Recursion \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n- 1) For making a tree in recursive function we\\'ll required O(n).\\n- 2) For finding element in inorder traversal we\\'ll required again O(n).\\n- Overall Complexity will be O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>& inorder, int k) {\\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\\n        return -1;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\\n        return build(preorder, inorder, preIndex, inStart, inend);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\\n        if (inStart > inend) {\\n            return NULL;\\n        }\\n\\n        int ele = preorder[preIndex++];\\n        TreeNode* root = new TreeNode(ele);\\n        int pos_in_inorder = find(inorder, ele);\\n\\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\\n        return root;\\n    }\\n};\\n\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0, inend = inorder.size();\n        return build(preorder, inorder, preIndex, inStart, inend);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\n        if (inStart > inend) {\n            return NULL;\n        }\n\n        int ele = preorder[preIndex++];\n        TreeNode* root = new TreeNode(ele);\n        int pos_in_inorder = find(inorder, ele);\n\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\n        return root;\n    }\n};\n",
        "explanations": "\nThe 'inend' is set to the size of the array rather than size minus one.\n",
        "fixed_code": "\nclass Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (unsigned int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0;\n        int inEnd = inorder.size() - 1;\n        return build(preorder, inorder, preIndex, inStart, inEnd);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inEnd) {\n        if (inStart > inEnd) return NULL;\n\n        int ele = preorder[preIndex++];\n        TreeNode* root = new TreeNode(ele);\n        int posInInorder = find(inorder, ele);\n        \n        if (posInInorder == -1) return NULL; \n\n        root->left = build(preorder, inorder, preIndex, inStart, posInInorder - 1);\n        root->right = build(preorder, inorder, preIndex, posInInorder + 1, inEnd);\n\n        return root;\n    }\n};\n",
        "fixing_exp": "\n'InEnd' was too large causing a buffer overflow. Ensured position in 'Inorder' array is valid.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "26 ms",
            "memory": 26036000,
            "question_id": "105",
            "elapsed_time": 53,
            "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969091528,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 203,
            "total_testcases": 203,
            "runtime_percentile": 30.23389999999999,
            "status_memory": "26 MB",
            "memory_percentile": 91.70460000000001,
            "pretty_lang": "C++",
            "submission_id": "1114514233",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": "AddressSanitizer: heap-buffer-overflow on address 0x603000000060 at pc 0x00000036734b bp 0x7fff6332feb0 sp 0x7fff6332fea8"
    },
    {
        "slug": "tallest-billboard",
        "description": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.",
        "examples": [
            "Input: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.",
            "Input: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.",
            "Input: rods = [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0."
        ],
        "constrains": "1 <= rods.length <= 20\n1 <= rods[i] <= 1000\nsum(rods[i]) <= 5000",
        "release_time": 1687588495,
        "oracle_code": "class Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust as any dp problem where we have to select the item or leave it, same idea is being used here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor any given rod we have 3 optins to add it to the right leg or left leg or leave the rod. Now for the states of the dp one has to be the i that will iterate through the rods array. And if we maintain two additional states for left and the right leg then a total of 3 states was giving a memory limit exceed(in my case).\\n\\nTo reduce the a state, I used a balance state that will denote the difference between the legs\\' height. If we add the ith rod in the right leg then we increase the balance by rod[i] and if we add it to the left leg then we decerase the balance by rod[i], remains unchanged if we choose to skip the rod. \\n\\n**Balance ==0 will denote both legs are of same height, balance>0 means right leg is longer ans balance<0 means left is longer.**\\n\\n**Now, sum(rods[i])<=5000 (as given). Then our balance could range from -5000 to 5000. So in the memo table I am shifting the balance by 5000 to handle the negative indixes.**\\n\\n  \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\\n    {\\n        if(i>=rods.size() && balance==0)\\n            return 0;\\n        if(i>=rods.size() && balance!=0)\\n            return INT_MIN;\\n\\n        if(memo[i][balance+5000]!=-1)\\n            return memo[i][balance+5000];\\n        int left= build_board(rods,balance+rods[i],i+1,memo);\\n        int right= build_board(rods,balance-rods[i],i+1,memo);\\n\\n        int ans= rods[i]+max(left,right);\\n\\n        int skip= build_board(rods,balance,i+1,memo);\\n\\n        ans= max(ans,skip);\\n\\n        memo[i][balance+5000]=ans;\\n        return ans;\\n\\n    }\\n\\n    int tallestBillboard(vector<int>& rods) {\\n        \\n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\\n        int ans= build_board(rods,0,0,memo);\\n\\n        if(ans<=0)\\n            return 0;\\n        else\\n            return ans/2;\\n    }\\n};\\n```",
        "level": "hard",
        "buggy_code": "\nclass Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i+1]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};\n",
        "explanations": "\nThe index for rods in \"ans = rods[i+1] + max(left,right);\" line exceeds the array size.\n",
        "fixed_code": "\nclass Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance, int i, vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans;\n        if(i+1<rods.size()) \n            ans= rods[i+1]+max(left,right);\n        else \n            ans = max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};\n",
        "fixing_exp": "\nAdjusted the condition for assigning 'ans' to avoid accessing array out of bounds.\n",
        "test_result_bool": false,
        "test_result_dict": {
            "status_code": 11,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "N/A",
            "memory": 73136000,
            "question_id": "993",
            "elapsed_time": 118,
            "compare_result": "00111100000010000000000000000000000000000000000000000000000000000000000000000000",
            "code_output": "5",
            "std_output": "",
            "last_testcase": "[1,2,3,6]",
            "expected_output": "6",
            "task_finish_time": 1701969135670,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 5,
            "total_testcases": 80,
            "runtime_percentile": null,
            "status_memory": "N/A",
            "memory_percentile": null,
            "pretty_lang": "C++",
            "submission_id": "1114514764",
            "input_formatted": "[1,2,3,6]",
            "input": "[1,2,3,6]",
            "status_msg": "Wrong Answer",
            "state": "SUCCESS"
        },
        "traceback_messages": "AddressSanitizer: heap-buffer-overflow on address 0x6020000000a0 at pc 0x000000367c10 bp 0x7fff069cd3b0 sp 0x7fff069cd3a8"
    },
    {
        "slug": "maximum-number-of-removable-characters",
        "description": "You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\nYou want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\nReturn the maximum k you can choose such that p is still a subsequence of s after the removals.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "examples": [
            "Input: s = \"abcacb\", p = \"ab\", removable = [3,1,0]\nOutput: 2\nExplanation: After removing the characters at indices 3 and 1, \"abcacb\" becomes \"accb\".\n\"ab\" is a subsequence of \"accb\".\nIf we remove the characters at indices 3, 1, and 0, \"abcacb\" becomes \"ccb\", and \"ab\" is no longer a subsequence.\nHence, the maximum k is 2.",
            "Input: s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\nOutput: 1\nExplanation: After removing the character at index 3, \"abcbddddd\" becomes \"abcddddd\".\n\"abcd\" is a subsequence of \"abcddddd\".",
            "Input: s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\nOutput: 0\nExplanation: If you remove the first index in the array removable, \"abc\" is no longer a subsequence."
        ],
        "constrains": "1 <= p.length <= s.length <= 105\n0 <= removable.length < s.length\n0 <= removable[i] < s.length\np is a subsequence of s.\ns and p both consist of lowercase English letters.\nThe elements in removable are distinct.",
        "release_time": 1667447295,
        "oracle_code": "class Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == M; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n int rm[100001] = {};\\n    bool valid(string &s, string &p, vector<int> &A, int k) {\\n        memset(rm, 0, sizeof(rm));\\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \\n        int N = s.size(), M = p.size(), j = 0; \\n        for (int i = 0; i < N && j < M; ++i) {\\n            if (rm[i] == 1) continue; \\n            if (s[i] == p[j]) ++j; \\n        }\\n        return j == M; \\n    }\\npublic:\\n    int maximumRemovals(string s, string p, vector<int>& A) {\\n        int L = 0, R = A.size();\\n        while (L <= R) {\\n            int M = (L + R) / 2;\\n            if (valid(s, p, A, M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```",
        "level": "medium",
        "buggy_code": "\nclass Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == N; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};\n",
        "explanations": "\nIn \"valid\" function, \"j\" must be equal to \"M\", not \"N\", for correct results.\n",
        "fixed_code": "\nclass Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == M; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};\n",
        "fixing_exp": "\nCompared all elements in string 'p' rather than in 's', so changed from return j == N to return j == M.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "195 ms",
            "memory": 76228000,
            "question_id": "2027",
            "elapsed_time": 276,
            "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969174594,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 67,
            "total_testcases": 67,
            "runtime_percentile": 70.60989999999991,
            "status_memory": "76.2 MB",
            "memory_percentile": 95.6989,
            "pretty_lang": "C++",
            "submission_id": "1114515240",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constrains": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries.",
        "release_time": 1667792667,
        "oracle_code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```",
        "level": "hard",
        "buggy_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = i; \n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n",
        "explanations": "\nThe parent of i-th node is set to be i instead of parent[i] in constructor.\n",
        "fixed_code": "\nclass TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20, -1));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i]; \n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] != -1) par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n",
        "fixing_exp": "\nFixed assignment of immediate parent and added default value for undefined parents for every node.\n",
        "test_result_bool": true,
        "test_result_dict": {
            "status_code": 10,
            "lang": "cpp",
            "run_success": true,
            "status_runtime": "261 ms",
            "memory": 118112000,
            "question_id": "1296",
            "elapsed_time": 339,
            "compare_result": "11111111111111111",
            "code_output": "",
            "std_output": "",
            "last_testcase": "",
            "expected_output": "",
            "task_finish_time": 1701969208322,
            "task_name": "judger.judgetask.Judge",
            "finished": true,
            "total_correct": 17,
            "total_testcases": 17,
            "runtime_percentile": 69.55120000000002,
            "status_memory": "118.1 MB",
            "memory_percentile": 47.760000000000005,
            "pretty_lang": "C++",
            "submission_id": "1114515601",
            "status_msg": "Accepted",
            "state": "SUCCESS"
        },
        "traceback_messages": null
    }
]