[
    {
        "slug": "power-of-heroes",
        "description": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.",
        "examples": [
            "Input: nums = [2,1,4]\nOutput: 141\nExplanation: \n1st\u00a0group: [2] has power = 22\u00a0* 2 = 8.\n2nd\u00a0group: [1] has power = 12 * 1 = 1. \n3rd\u00a0group: [4] has power = 42 * 4 = 64. \n4th\u00a0group: [2,1] has power = 22 * 1 = 4. \n5th\u00a0group: [2,4] has power = 42 * 2 = 32. \n6th\u00a0group: [1,4] has power = 42 * 1 = 16. \n\u200b\u200b\u200b\u200b\u200b\u200b\u200b7th\u00a0group: [2,1,4] has power = 42\u200b\u200b\u200b\u200b\u200b\u200b\u200b * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.",
            "Input: nums = [1,1,1]\nOutput: 7\nExplanation: A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109"
    },
    {
        "slug": "my-calendar-i",
        "description": "You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.\nA double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\nThe event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\nImplement the MyCalendar class:\n\nMyCalendar() Initializes the calendar object.\nboolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.",
        "examples": [
            "Input\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\nOutput\n[null, true, false, true]\n\nExplanation\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.\nmyCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20."
        ],
        "constraints": "0 <= start < end <= 109\nAt most 1000 calls will be made to book."
    },
    {
        "slug": "cat-and-mouse-ii",
        "description": "A game is played by a cat and a mouse named Cat and Mouse.\nThe environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food.\n\nPlayers are represented by the characters 'C'(Cat),'M'(Mouse).\nFloors are represented by the character '.' and can be walked on.\nWalls are represented by the character '#' and cannot be walked on.\nFood is represented by the character 'F' and can be walked on.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n\nMouse and Cat play according to the following rules:\n\nMouse moves first, then they take turns to move.\nDuring each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid.\ncatJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\nStaying in the same position is allowed.\nMouse can jump over Cat.\n\nThe game can end in 4 ways:\n\nIf Cat occupies the same position as Mouse, Cat wins.\nIf Cat reaches the food first, Cat wins.\nIf Mouse reaches the food first, Mouse wins.\nIf Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false.",
        "examples": [
            "Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2\nOutput: true\nExplanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse.",
            "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4\nOutput: true",
            "Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3\nOutput: false"
        ],
        "constraints": "rows == grid.length\ncols = grid[i].length\n1 <= rows, cols <= 8\ngrid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'.\nThere is only one of each character 'C', 'M', and 'F' in grid.\n1 <= catJump, mouseJump <= 8"
    },
    {
        "slug": "number-of-black-blocks",
        "description": "You are given two integers m and n representing the dimensions of a\u00a00-indexed\u00a0m x n grid.\nYou are also given a 0-indexed 2D integer matrix coordinates, where coordinates[i] = [x, y] indicates that the cell with coordinates [x, y] is colored black. All cells in the grid that do not appear in coordinates are white.\nA block is defined as a 2 x 2 submatrix of the grid. More formally, a block with cell [x, y] as its top-left corner where 0 <= x < m - 1 and 0 <= y < n - 1 contains the coordinates [x, y], [x + 1, y], [x, y + 1], and [x + 1, y + 1].\nReturn a 0-indexed integer array arr of size 5 such that arr[i] is the number of blocks that contains exactly i black cells.",
        "examples": [
            "Input: m = 3, n = 3, coordinates = [[0,0]]\nOutput: [3,1,0,0,0]\nExplanation: The grid looks like this:\n\nThere is only 1 block with one black cell, and it is the block starting with cell [0,0].\nThe other 3 blocks start with cells [0,1], [1,0] and [1,1]. They all have zero black cells. \nThus, we return [3,1,0,0,0].",
            "Input: m = 3, n = 3, coordinates = [[0,0],[1,1],[0,2]]\nOutput: [0,2,2,0,0]\nExplanation: The grid looks like this:\n\nThere are 2 blocks with two black cells (the ones starting with cell coordinates [0,0] and [0,1]).\nThe other 2 blocks have starting cell coordinates of [1,0] and [1,1]. They both have 1 black cell.\nTherefore, we return [0,2,2,0,0]."
        ],
        "constraints": "2 <= m <= 105\n2 <= n <= 105\n0 <= coordinates.length <= 104\ncoordinates[i].length == 2\n0 <= coordinates[i][0] < m\n0 <= coordinates[i][1] < n\nIt is guaranteed that coordinates contains pairwise distinct coordinates."
    },
    {
        "slug": "find-the-string-with-lcp",
        "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an\u00a0n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.",
        "examples": [
            "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\".",
            "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
        ],
        "constraints": "1 <= n ==\u00a0lcp.length == lcp[i].length\u00a0<= 1000\n0 <= lcp[i][j] <= n"
    },
    {
        "slug": "valid-anagram",
        "description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: s = \"anagram\", t = \"nagaram\"\nOutput: true",
            "Input: s = \"rat\", t = \"car\"\nOutput: false"
        ],
        "constraints": "1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters."
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "description": "Given the array restaurants where \u00a0restaurants[i] = [idi, ratingi, veganFriendlyi, pricei, distancei]. You have to filter the restaurants using three filters.\nThe veganFriendly filter will be either true (meaning you should only include restaurants with veganFriendlyi set to true)\u00a0or false\u00a0(meaning you can include any restaurant). In addition, you have the filters\u00a0maxPrice and maxDistance\u00a0which\u00a0are the maximum value for price and distance of restaurants you should consider respectively.\nReturn the array of restaurant IDs after filtering, ordered by rating from highest to lowest. For restaurants with the same rating, order them by id from highest to lowest. For simplicity veganFriendlyi and veganFriendly take value 1 when it is true, and 0 when it is false.",
        "examples": [
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 1, maxPrice = 50, maxDistance = 10\nOutput: [3,1,5] \nExplanation: \nThe restaurants are:\nRestaurant 1 [id=1, rating=4, veganFriendly=1, price=40, distance=10]\nRestaurant 2 [id=2, rating=8, veganFriendly=0, price=50, distance=5]\nRestaurant 3 [id=3, rating=8, veganFriendly=1, price=30, distance=4]\nRestaurant 4 [id=4, rating=10, veganFriendly=0, price=10, distance=3]\nRestaurant 5 [id=5, rating=1, veganFriendly=1, price=15, distance=1] \nAfter filter restaurants with veganFriendly = 1, maxPrice = 50 and maxDistance = 10 we have restaurant 3, restaurant 1 and restaurant 5 (ordered by rating from highest to lowest).",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 50, maxDistance = 10\nOutput: [4,3,2,1,5]\nExplanation: The restaurants are the same as in example 1, but in this case the filter veganFriendly = 0, therefore all restaurants are considered.",
            "Input: restaurants = [[1,4,1,40,10],[2,8,0,50,5],[3,8,1,30,4],[4,10,0,10,3],[5,1,1,15,1]], veganFriendly = 0, maxPrice = 30, maxDistance = 3\nOutput: [4,5]"
        ],
        "constraints": "1 <=\u00a0restaurants.length <= 10^4\nrestaurants[i].length == 5\n1 <=\u00a0idi, ratingi, pricei, distancei <= 10^5\n1 <=\u00a0maxPrice,\u00a0maxDistance <= 10^5\nveganFriendlyi and\u00a0veganFriendly\u00a0are\u00a00 or 1.\nAll idi are distinct."
    },
    {
        "slug": "sum-multiples",
        "description": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying\u00a0the constraint.",
        "examples": [
            "Input: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.",
            "Input: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.",
            "Input: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30."
        ],
        "constraints": "1 <= n <= 103"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "description": "You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\nReturn the minimum number of operations needed to make s alternating.",
        "examples": [
            "Input: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.",
            "Input: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.",
            "Input: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\"."
        ],
        "constraints": "1 <= s.length <= 104\ns[i] is either '0' or '1'."
    },
    {
        "slug": "shortest-bridge",
        "description": "You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\nYou may change 0's to 1's to connect the two islands to form one island.\nReturn the smallest number of 0's you must flip to connect the two islands.",
        "examples": [
            "Input: grid = [[0,1],[1,0]]\nOutput: 1",
            "Input: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2",
            "Input: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1"
        ],
        "constraints": "n == grid.length == grid[i].length\n2 <= n <= 100\ngrid[i][j] is either 0 or 1.\nThere are exactly two islands in grid."
    },
    {
        "slug": "reverse-only-letters",
        "description": "Given a string s, reverse the string according to the following rules:\n\nAll the characters that are not English letters remain in the same position.\nAll the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.",
        "examples": [
            "Input: s = \"ab-cd\"\nOutput: \"dc-ba\"",
            "Input: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"",
            "Input: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\""
        ],
        "constraints": "1 <= s.length <= 100\ns consists of characters with ASCII values in the range [33, 122].\ns does not contain '\\\"' or '\\\\'."
    },
    {
        "slug": "battleships-in-a-board",
        "description": "Given an m x n matrix board where each cell is a battleship 'X' or empty '.', return the number of the battleships on board.\nBattleships can only be placed horizontally or vertically on board. In other words, they can only be made of the shape 1 x k (1 row, k columns) or k x 1 (k rows, 1 column), where k can be of any size. At least one horizontal or vertical cell separates between two battleships (i.e., there are no adjacent battleships).",
        "examples": [
            "Input: board = [[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]]\nOutput: 2",
            "Input: board = [[\".\"]]\nOutput: 0"
        ],
        "constraints": "m == board.length\nn == board[i].length\n1 <= m, n <= 200\nboard[i][j] is either '.' or 'X'."
    },
    {
        "slug": "balanced-binary-tree",
        "description": "Given a binary tree, determine if it is height-balanced.",
        "examples": [
            "Input: root = [3,9,20,null,null,15,7]\nOutput: true",
            "Input: root = [1,2,2,3,3,null,null,4,4]\nOutput: false",
            "Input: root = []\nOutput: true"
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 5000].\n-104 <= Node.val <= 104"
    },
    {
        "slug": "maximum-number-of-occurrences-of-a-substring",
        "description": "Given a string s, return the maximum number of occurrences of any substring under the following rules:\n\nThe number of unique characters in the substring must be less than or equal to maxLetters.\nThe substring size must be between minSize and maxSize inclusive.",
        "examples": [
            "Input: s = \"aababcaab\", maxLetters = 2, minSize = 3, maxSize = 4\nOutput: 2\nExplanation: Substring \"aab\" has 2 occurrences in the original string.\nIt satisfies the conditions, 2 unique letters and size 3 (between minSize and maxSize).",
            "Input: s = \"aaaa\", maxLetters = 1, minSize = 3, maxSize = 3\nOutput: 2\nExplanation: Substring \"aaa\" occur 2 times in the string. It can overlap."
        ],
        "constraints": "1 <= s.length <= 105\n1 <= maxLetters <= 26\n1 <= minSize <= maxSize <= min(26, s.length)\ns consists of only lowercase English letters."
    },
    {
        "slug": "maximum-star-sum-of-a-graph",
        "description": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.",
        "examples": [
            "Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\nOutput: 16\nExplanation: The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.",
            "Input: vals = [-5], edges = [], k = 0\nOutput: -5\nExplanation: There is only one possible star graph, which is node 0 itself.\nHence, we return -5."
        ],
        "constraints": "n == vals.length\n1 <= n <= 105\n-104 <= vals[i] <= 104\n0 <= edges.length <= min(n * (n - 1) / 2, 105)\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= k <= n - 1"
    },
    {
        "slug": "flood-fill",
        "description": "An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.",
        "examples": [
            "Input: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.",
            "Input: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image."
        ],
        "constraints": "m == image.length\nn == image[i].length\n1 <= m, n <= 50\n0 <= image[i][j], color < 216\n0 <= sr < m\n0 <= sc < n"
    },
    {
        "slug": "remove-outermost-parentheses",
        "description": "A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\nFor example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n\nA valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\nGiven a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\nReturn s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.",
        "examples": [
            "Input: s = \"(()())(())\"\nOutput: \"()()()\"\nExplanation: \nThe input string is \"(()())(())\", with primitive decomposition \"(()())\" + \"(())\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" = \"()()()\".",
            "Input: s = \"(()())(())(()(()))\"\nOutput: \"()()()()(())\"\nExplanation: \nThe input string is \"(()())(())(()(()))\", with primitive decomposition \"(()())\" + \"(())\" + \"(()(()))\".\nAfter removing outer parentheses of each part, this is \"()()\" + \"()\" + \"()(())\" = \"()()()()(())\".",
            "Input: s = \"()()\"\nOutput: \"\"\nExplanation: \nThe input string is \"()()\", with primitive decomposition \"()\" + \"()\".\nAfter removing outer parentheses of each part, this is \"\" + \"\" = \"\"."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '(' or ')'.\ns is a valid parentheses string."
    },
    {
        "slug": "find-if-path-exists-in-graph",
        "description": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.",
        "examples": [
            "Input: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2\nOutput: true\nExplanation: There are two paths from vertex 0 to vertex 2:\n- 0 \u2192 1 \u2192 2\n- 0 \u2192 2",
            "Input: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5\nOutput: false\nExplanation: There is no path from vertex 0 to vertex 5."
        ],
        "constraints": "1 <= n <= 2 * 105\n0 <= edges.length <= 2 * 105\nedges[i].length == 2\n0 <= ui, vi <= n - 1\nui != vi\n0 <= source, destination <= n - 1\nThere are no duplicate edges.\nThere are no self edges."
    },
    {
        "slug": "array-partition",
        "description": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.",
        "examples": [
            "Input: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.",
            "Input: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9."
        ],
        "constraints": "1 <= n <= 104\nnums.length == 2 * n\n-104 <= nums[i] <= 104"
    },
    {
        "slug": "longest-increasing-subsequence",
        "description": "Given an integer array nums, return the length of the longest strictly increasing subsequence.",
        "examples": [
            "Input: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.",
            "Input: nums = [0,1,0,3,2,3]\nOutput: 4",
            "Input: nums = [7,7,7,7,7,7,7]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 2500\n-104 <= nums[i] <= 104"
    },
    {
        "slug": "most-profit-assigning-work",
        "description": "You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\ndifficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\nworker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\nFor example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.",
        "examples": [
            "Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.",
            "Input: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0"
        ],
        "constraints": "n == difficulty.length\nn == profit.length\nm == worker.length\n1 <= n, m <= 104\n1 <= difficulty[i], profit[i], worker[i] <= 105"
    },
    {
        "slug": "longest-common-prefix",
        "description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".",
        "examples": [
            "Input: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"",
            "Input: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings."
        ],
        "constraints": "1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters."
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
        "description": "Given a binary string s, return the minimum number of character swaps to make it alternating, or -1 if it is impossible.\nThe string is called alternating if no two adjacent characters are equal. For example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not.\nAny two characters may be swapped, even if they are\u00a0not adjacent.",
        "examples": [
            "Input: s = \"111000\"\nOutput: 1\nExplanation: Swap positions 1 and 4: \"111000\" -> \"101010\"\nThe string is now alternating.",
            "Input: s = \"010\"\nOutput: 0\nExplanation: The string is already alternating, no swaps are needed.",
            "Input: s = \"1110\"\nOutput: -1"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'."
    },
    {
        "slug": "leaf-similar-trees",
        "description": "Consider all the leaves of a binary tree, from\u00a0left to right order, the values of those\u00a0leaves form a leaf value sequence.\n\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar\u00a0if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.",
        "examples": [
            "Input: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\nOutput: true",
            "Input: root1 = [1,2,3], root2 = [1,3,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in each tree will be in the range [1, 200].\nBoth of the given trees will have values in the range [0, 200]."
    },
    {
        "slug": "number-of-provinces",
        "description": "There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\nReturn the total number of provinces.",
        "examples": [
            "Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2",
            "Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 200\nn == isConnected.length\nn == isConnected[i].length\nisConnected[i][j] is 1 or 0.\nisConnected[i][i] == 1\nisConnected[i][j] == isConnected[j][i]"
    },
    {
        "slug": "min-cost-climbing-stairs",
        "description": "You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.\nYou can either start from the step with index 0, or the step with index 1.\nReturn the minimum cost to reach the top of the floor.",
        "examples": [
            "Input: cost = [10,15,20]\nOutput: 15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.",
            "Input: cost = [1,100,1,1,1,100,1,1,100,1]\nOutput: 6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
        ],
        "constraints": "2 <= cost.length <= 1000\n0 <= cost[i] <= 999"
    },
    {
        "slug": "design-twitter",
        "description": "Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\nImplement the Twitter class:\n\nTwitter() Initializes your twitter object.\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.",
        "examples": [
            "Input\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2."
        ],
        "constraints": "1 <= userId, followerId, followeeId <= 500\n0 <= tweetId <= 104\nAll the tweets have unique IDs.\nAt most 3 * 104 calls will be made to postTweet, getNewsFeed, follow, and unfollow."
    },
    {
        "slug": "number-of-matching-subsequences",
        "description": "Given a string s and an array of strings words, return the number of words[i] that is a subsequence of s.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".",
        "examples": [
            "Input: s = \"abcde\", words = [\"a\",\"bb\",\"acd\",\"ace\"]\nOutput: 3\nExplanation: There are three strings in words that are a subsequence of s: \"a\", \"acd\", \"ace\".",
            "Input: s = \"dsahjpjauf\", words = [\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"]\nOutput: 2"
        ],
        "constraints": "1 <= s.length <= 5 * 104\n1 <= words.length <= 5000\n1 <= words[i].length <= 50\ns and words[i] consist of only lowercase English letters."
    },
    {
        "slug": "largest-combination-with-bitwise-and-greater-than-zero",
        "description": "The bitwise AND of an array nums is the bitwise AND of all integers in nums.\n\nFor example, for nums = [1, 5, 3], the bitwise AND is equal to 1 & 5 & 3 = 1.\nAlso, for nums = [7], the bitwise AND is 7.\n\nYou are given an array of positive integers candidates. Evaluate the bitwise AND of every combination of numbers of candidates. Each number in candidates may only be used once in each combination.\nReturn the size of the largest combination of candidates with a bitwise AND greater than 0.",
        "examples": [
            "Input: candidates = [16,17,71,62,12,24,14]\nOutput: 4\nExplanation: The combination [16,17,62,24] has a bitwise AND of 16 & 17 & 62 & 24 = 16 > 0.\nThe size of the combination is 4.\nIt can be shown that no combination with a size greater than 4 has a bitwise AND greater than 0.\nNote that more than one combination may have the largest size.\nFor example, the combination [62,12,24,14] has a bitwise AND of 62 & 12 & 24 & 14 = 8 > 0.",
            "Input: candidates = [8,8]\nOutput: 2\nExplanation: The largest combination [8,8] has a bitwise AND of 8 & 8 = 8 > 0.\nThe size of the combination is 2, so we return 2."
        ],
        "constraints": "1 <= candidates.length <= 105\n1 <= candidates[i] <= 107"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "description": "You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors.\nMore formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i].\nReturn any rearrangement of nums that meets the requirements.",
        "examples": [
            "Input: nums = [1,2,3,4,5]\nOutput: [1,2,4,5,3]\nExplanation:\nWhen i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5.\nWhen i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5.\nWhen i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5.",
            "Input: nums = [6,2,0,9,7]\nOutput: [9,7,6,2,0]\nExplanation:\nWhen i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5.\nWhen i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5.\nWhen i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3."
        ],
        "constraints": "3 <= nums.length <= 105\n0 <= nums[i] <= 105"
    },
    {
        "slug": "number-of-subarrays-with-gcd-equal-to-k",
        "description": "Given an integer array nums and an integer k, return the number of subarrays of nums where the greatest common divisor of the subarray's elements is k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe greatest common divisor of an array is the largest integer that evenly divides all the array elements.",
        "examples": [
            "Input: nums = [9,3,1,2,6,3], k = 3\nOutput: 4\nExplanation: The subarrays of nums where 3 is the greatest common divisor of all the subarray's elements are:\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]\n- [9,3,1,2,6,3]",
            "Input: nums = [4], k = 7\nOutput: 0\nExplanation: There are no subarrays of nums where 7 is the greatest common divisor of all the subarray's elements."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i], k <= 109"
    },
    {
        "slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "description": "Given an integer array arr, remove a subarray (can be empty) from arr such that the remaining elements in arr are non-decreasing.\nReturn the length of the shortest subarray to remove.\nA subarray is a contiguous subsequence of the array.",
        "examples": [
            "Input: arr = [1,2,3,10,4,2,3,5]\nOutput: 3\nExplanation: The shortest subarray we can remove is [10,4,2] of length 3. The remaining elements after that will be [1,2,3,3,5] which are sorted.\nAnother correct solution is to remove the subarray [3,10,4].",
            "Input: arr = [5,4,3,2,1]\nOutput: 4\nExplanation: Since the array is strictly decreasing, we can only keep a single element. Therefore we need to remove a subarray of length 4, either [5,4,3,2] or [4,3,2,1].",
            "Input: arr = [1,2,3]\nOutput: 0\nExplanation: The array is already non-decreasing. We do not need to remove any elements."
        ],
        "constraints": "1 <= arr.length <= 105\n0 <= arr[i] <= 109"
    },
    {
        "slug": "minimum-time-visiting-all-points",
        "description": "On a 2D plane, there are n points with integer coordinates points[i] = [xi, yi]. Return the minimum time in seconds to visit all the points in the order given by points.\nYou can move according to these rules:\n\nIn 1 second, you can either:\n\n\t\nmove vertically by one\u00a0unit,\nmove horizontally by one unit, or\nmove diagonally sqrt(2) units (in other words, move one unit vertically then one unit horizontally in 1 second).\n\n\nYou have to visit the points in the same order as they appear in the array.\nYou are allowed to pass through points that appear later in the order, but these do not count as visits.",
        "examples": [
            "Input: points = [[1,1],[3,4],[-1,0]]\nOutput: 7\nExplanation: One optimal path is [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]   \nTime from [1,1] to [3,4] = 3 seconds \nTime from [3,4] to [-1,0] = 4 seconds\nTotal time = 7 seconds",
            "Input: points = [[3,2],[-2,2]]\nOutput: 5"
        ],
        "constraints": "points.length == n\n1 <= n\u00a0<= 100\npoints[i].length == 2\n-1000\u00a0<= points[i][0], points[i][1]\u00a0<= 1000"
    },
    {
        "slug": "determine-color-of-a-chessboard-square",
        "description": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\n\nReturn true if the square is white, and false if the square is black.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.",
        "examples": [
            "Input: coordinates = \"a1\"\nOutput: false\nExplanation: From the chessboard above, the square with coordinates \"a1\" is black, so return false.",
            "Input: coordinates = \"h3\"\nOutput: true\nExplanation: From the chessboard above, the square with coordinates \"h3\" is white, so return true.",
            "Input: coordinates = \"c7\"\nOutput: false"
        ],
        "constraints": "coordinates.length == 2\n'a' <= coordinates[0] <= 'h'\n'1' <= coordinates[1] <= '8'"
    },
    {
        "slug": "merge-similar-items",
        "description": "You are given two 2D integer arrays, items1 and items2, representing two sets of items. Each array items has the following properties:\n\nitems[i] = [valuei, weighti] where valuei represents the value and weighti represents the weight of the ith item.\nThe value of each item in items is unique.\n\nReturn a 2D integer array ret where ret[i] = [valuei, weighti], with weighti being the sum of weights of all items with value valuei.\nNote: ret should be returned in ascending order by value.",
        "examples": [
            "Input: items1 = [[1,1],[4,5],[3,8]], items2 = [[3,1],[1,5]]\nOutput: [[1,6],[3,9],[4,5]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 5, total weight = 1 + 5 = 6.\nThe item with value = 3 occurs in items1 with weight = 8 and in items2 with weight = 1, total weight = 8 + 1 = 9.\nThe item with value = 4 occurs in items1 with weight = 5, total weight = 5.  \nTherefore, we return [[1,6],[3,9],[4,5]].",
            "Input: items1 = [[1,1],[3,2],[2,3]], items2 = [[2,1],[3,2],[1,3]]\nOutput: [[1,4],[2,4],[3,4]]\nExplanation: \nThe item with value = 1 occurs in items1 with weight = 1 and in items2 with weight = 3, total weight = 1 + 3 = 4.\nThe item with value = 2 occurs in items1 with weight = 3 and in items2 with weight = 1, total weight = 3 + 1 = 4.\nThe item with value = 3 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4.\nTherefore, we return [[1,4],[2,4],[3,4]].",
            "Input: items1 = [[1,3],[2,2]], items2 = [[7,1],[2,2],[1,4]]\nOutput: [[1,7],[2,4],[7,1]]\nExplanation:\nThe item with value = 1 occurs in items1 with weight = 3 and in items2 with weight = 4, total weight = 3 + 4 = 7. \nThe item with value = 2 occurs in items1 with weight = 2 and in items2 with weight = 2, total weight = 2 + 2 = 4. \nThe item with value = 7 occurs in items2 with weight = 1, total weight = 1.\nTherefore, we return [[1,7],[2,4],[7,1]]."
        ],
        "constraints": "1 <= items1.length, items2.length <= 1000\nitems1[i].length == items2[i].length == 2\n1 <= valuei, weighti <= 1000\nEach valuei in items1 is unique.\nEach valuei in items2 is unique."
    },
    {
        "slug": "brace-expansion-ii",
        "description": "Under the grammar given below, strings can represent a set of lowercase words. Let\u00a0R(expr)\u00a0denote the set of words the expression represents.\nThe grammar can best be understood through simple examples:\n\nSingle letters represent a singleton set containing that word.\n\t\nR(\"a\") = {\"a\"}\nR(\"w\") = {\"w\"}\n\n\nWhen we take a comma-delimited list of two or more expressions, we take the union of possibilities.\n\t\nR(\"{a,b,c}\") = {\"a\",\"b\",\"c\"}\nR(\"{{a,b},{b,c}}\") = {\"a\",\"b\",\"c\"} (notice the final set only contains each word at most once)\n\n\nWhen we concatenate two expressions, we take the set of possible concatenations between two words where the first word comes from the first expression and the second word comes from the second expression.\n\t\nR(\"{a,b}{c,d}\") = {\"ac\",\"ad\",\"bc\",\"bd\"}\nR(\"a{b,c}{d,e}f{g,h}\") = {\"abdfg\", \"abdfh\", \"abefg\", \"abefh\", \"acdfg\", \"acdfh\", \"acefg\", \"acefh\"}\n\n\n\nFormally, the three rules for our grammar:\n\nFor every lowercase letter x, we have R(x) = {x}.\nFor expressions e1, e2, ... , ek with k >= 2, we have R({e1, e2, ...}) = R(e1) \u222a R(e2) \u222a ...\nFor expressions e1 and e2, we have R(e1 + e2) = {a + b for (a, b) in R(e1) \u00d7 R(e2)}, where + denotes concatenation, and \u00d7 denotes the cartesian product.\n\nGiven an expression representing a set of words under the given grammar, return the sorted list of words that the expression represents.",
        "examples": [
            "Input: expression = \"{a,b}{c,{d,e}}\"\nOutput: [\"ac\",\"ad\",\"ae\",\"bc\",\"bd\",\"be\"]",
            "Input: expression = \"{{a,z},a{b,c},{ab,z}}\"\nOutput: [\"a\",\"ab\",\"ac\",\"z\"]\nExplanation: Each distinct word is written only once in the final answer."
        ],
        "constraints": "1 <= expression.length <= 60\nexpression[i] consists of '{', '}', ','or lowercase English letters.\nThe given\u00a0expression\u00a0represents a set of words based on the grammar given in the description."
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "description": "You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\nFor example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.",
        "examples": [
            "Input: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"",
            "Input: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"",
            "Input: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\""
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 8500].\n0 <= Node.val <= 25"
    },
    {
        "slug": "asteroid-collision",
        "description": "We are given an array asteroids of integers representing asteroids in a row.\nFor each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.\nFind out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.",
        "examples": [
            "Input: asteroids = [5,10,-5]\nOutput: [5,10]\nExplanation: The 10 and -5 collide resulting in 10. The 5 and 10 never collide.",
            "Input: asteroids = [8,-8]\nOutput: []\nExplanation: The 8 and -8 collide exploding each other.",
            "Input: asteroids = [10,2,-5]\nOutput: [10]\nExplanation: The 2 and -5 collide resulting in -5. The 10 and -5 collide resulting in 10."
        ],
        "constraints": "2 <= asteroids.length <= 104\n-1000 <= asteroids[i] <= 1000\nasteroids[i] != 0"
    },
    {
        "slug": "distance-between-bus-stops",
        "description": "A bus\u00a0has n stops numbered from 0 to n - 1 that form\u00a0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\u00a0i and (i + 1) % n.\nThe bus goes along both directions\u00a0i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given\u00a0start\u00a0and destination\u00a0stops.",
        "examples": [
            "Input: distance = [1,2,3,4], start = 0, destination = 1\r\nOutput: 1\r\nExplanation: Distance between 0 and 1 is 1 or 9, minimum is 1.",
            "Input: distance = [1,2,3,4], start = 0, destination = 2\r\nOutput: 3\r\nExplanation: Distance between 0 and 2 is 3 or 7, minimum is 3.",
            "Input: distance = [1,2,3,4], start = 0, destination = 3\r\nOutput: 4\r\nExplanation: Distance between 0 and 3 is 6 or 4, minimum is 4."
        ],
        "constraints": "1 <= n\u00a0<= 10^4\ndistance.length == n\n0 <= start, destination < n\n0 <= distance[i] <= 10^4"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.",
        "examples": [
            "Input: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.",
            "Input: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 104"
    },
    {
        "slug": "a-number-after-a-double-reversal",
        "description": "Reversing an integer means to reverse all its digits.\n\nFor example, reversing 2021 gives 1202. Reversing 12300 gives 321 as the leading zeros are not retained.\n\nGiven an integer num, reverse num to get reversed1, then reverse reversed1 to get reversed2. Return true if reversed2 equals num. Otherwise return false.",
        "examples": [
            "Input: num = 526\nOutput: true\nExplanation: Reverse num to get 625, then reverse 625 to get 526, which equals num.",
            "Input: num = 1800\nOutput: false\nExplanation: Reverse num to get 81, then reverse 81 to get 18, which does not equal num.",
            "Input: num = 0\nOutput: true\nExplanation: Reverse num to get 0, then reverse 0 to get 0, which equals num."
        ],
        "constraints": "0 <= num <= 106"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "description": "You are given a string s consisting of only lowercase English letters. In one operation, you can do the following:\n\nSelect any non-empty substring of s, possibly the entire string, then replace each one of its characters with the previous character of the English alphabet. For example, 'b' is converted to 'a', and 'a' is converted to 'z'.\n\nReturn the lexicographically smallest string you can obtain after performing the above operation exactly once.\nA substring is a contiguous sequence of characters in a string.\nA string x is lexicographically smaller than a string y of the same length if x[i] comes before y[i] in alphabetic order for the first position i such that x[i] != y[i].",
        "examples": [
            "Input: s = \"cbabc\"\nOutput: \"baabc\"\nExplanation: We apply the operation on the substring starting at index 0, and ending at index 1 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"acbbc\"\nOutput: \"abaab\"\nExplanation: We apply the operation on the substring starting at index 1, and ending at index 4 inclusive. \nIt can be proven that the resulting string is the lexicographically smallest.",
            "Input: s = \"leetcode\"\nOutput: \"kddsbncd\"\nExplanation: We apply the operation on the entire string. \nIt can be proven that the resulting string is the lexicographically smallest."
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consists of lowercase English letters"
    },
    {
        "slug": "buddy-strings",
        "description": "Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\nSwapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n\nFor example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".",
        "examples": [
            "Input: s = \"ab\", goal = \"ba\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'b' to get \"ba\", which is equal to goal.",
            "Input: s = \"ab\", goal = \"ab\"\nOutput: false\nExplanation: The only letters you can swap are s[0] = 'a' and s[1] = 'b', which results in \"ba\" != goal.",
            "Input: s = \"aa\", goal = \"aa\"\nOutput: true\nExplanation: You can swap s[0] = 'a' and s[1] = 'a' to get \"aa\", which is equal to goal."
        ],
        "constraints": "1 <= s.length, goal.length <= 2 * 104\ns and goal consist of lowercase letters."
    },
    {
        "slug": "combinations",
        "description": "Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.",
        "examples": [
            "Input: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.",
            "Input: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination."
        ],
        "constraints": "1 <= n <= 20\n1 <= k <= n"
    },
    {
        "slug": "check-knight-tour-configuration",
        "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.",
        "examples": [
            "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.",
            "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
        ],
        "constraints": "n == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique."
    },
    {
        "slug": "maximum-gap",
        "description": "Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\nYou must write an algorithm that runs in linear time and uses linear extra space.",
        "examples": [
            "Input: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.",
            "Input: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "description": "You are given an m x n grid grid where:\n\n'.' is an empty cell.\n'#' is a wall.\n'@' is the starting point.\nLowercase letters represent keys.\nUppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.",
        "examples": [
            "Input: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.",
            "Input: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6",
            "Input: grid = [\"@Aa\"]\nOutput: -1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 30\ngrid[i][j] is either an English letter, '.', '#', or '@'.\u00a0\nThere is exactly one\u00a0'@'\u00a0in the grid.\nThe number of keys in the grid is in the range [1, 6].\nEach key in the grid is unique.\nEach key in the grid has a matching lock."
    },
    {
        "slug": "perfect-squares",
        "description": "Given an integer n, return the least number of perfect square numbers that sum to n.\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.",
        "examples": [
            "Input: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.",
            "Input: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9."
        ],
        "constraints": "1 <= n <= 104"
    },
    {
        "slug": "delete-nodes-and-return-forest",
        "description": "Given the root of a binary tree, each node in the tree has a distinct value.\nAfter deleting all nodes with a value in to_delete, we are left with a forest (a disjoint union of trees).\nReturn the roots of the trees in the remaining forest. You may return the result in any order.",
        "examples": [
            "Input: root = [1,2,3,4,5,6,7], to_delete = [3,5]\nOutput: [[1,2,null,4],[6],[7]]",
            "Input: root = [1,2,4,null,3], to_delete = [3]\nOutput: [[1,2,4]]"
        ],
        "constraints": "The number of nodes in the given tree is at most 1000.\nEach node has a distinct value between 1 and 1000.\nto_delete.length <= 1000\nto_delete contains distinct values between 1 and 1000."
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
        "description": "You are given an array prices where prices[i] is the price of a given stock on the ith day, and an integer fee representing a transaction fee.\nFind the maximum profit you can achieve. You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction.\nNote:\n\nYou may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\nThe transaction fee is only charged once for each stock purchase and sale.",
        "examples": [
            "Input: prices = [1,3,2,8,4,9], fee = 2\nOutput: 8\nExplanation: The maximum profit can be achieved by:\n- Buying at prices[0] = 1\n- Selling at prices[3] = 8\n- Buying at prices[4] = 4\n- Selling at prices[5] = 9\nThe total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.",
            "Input: prices = [1,3,7,5,10,3], fee = 3\nOutput: 6"
        ],
        "constraints": "1 <= prices.length <= 5 * 104\n1 <= prices[i] < 5 * 104\n0 <= fee < 5 * 104"
    },
    {
        "slug": "longest-subarray-of-1s-after-deleting-one-element",
        "description": "Given a binary array nums, you should delete one element from it.\nReturn the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.",
        "examples": [
            "Input: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.",
            "Input: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].",
            "Input: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element."
        ],
        "constraints": "1 <= nums.length <= 105\nnums[i] is either 0 or 1."
    },
    {
        "slug": "decode-xored-array",
        "description": "There is a hidden integer array arr that consists of n non-negative integers.\nIt was encoded into another integer array encoded of length n - 1, such that encoded[i] = arr[i] XOR arr[i + 1]. For example, if arr = [1,0,2,1], then encoded = [1,2,3].\nYou are given the encoded array. You are also given an integer first, that is the first element of arr, i.e. arr[0].\nReturn the original array arr. It can be proved that the answer exists and is unique.",
        "examples": [
            "Input: encoded = [1,2,3], first = 1\nOutput: [1,0,2,1]\nExplanation: If arr = [1,0,2,1], then first = 1 and encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]",
            "Input: encoded = [6,2,7,3], first = 4\nOutput: [4,2,0,7,4]"
        ],
        "constraints": "2 <= n <= 104\nencoded.length == n - 1\n0 <= encoded[i] <= 105\n0 <= first <= 105"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.",
        "examples": [
            "Input: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.",
            "Input: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3."
        ],
        "constraints": "The number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n"
    },
    {
        "slug": "find-the-smallest-divisor-given-a-threshold",
        "description": "Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division's result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\nThe test cases are generated so\u00a0that there will be an answer.",
        "examples": [
            "Input: nums = [1,2,5,9], threshold = 6\nOutput: 5\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. \nIf the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).",
            "Input: nums = [44,22,33,11,1], threshold = 5\nOutput: 44"
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 106\nnums.length <= threshold <= 106"
    },
    {
        "slug": "find-peak-element",
        "description": "A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -\u221e. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.",
        "examples": [
            "Input: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.",
            "Input: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6."
        ],
        "constraints": "1 <= nums.length <= 1000\n-231 <= nums[i] <= 231 - 1\nnums[i] != nums[i + 1] for all valid i."
    },
    {
        "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
        "description": "You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\nReturn the average salary of employees excluding the minimum and maximum salary. Answers within 10-5 of the actual answer will be accepted.",
        "examples": [
            "Input: salary = [4000,3000,1000,2000]\nOutput: 2500.00000\nExplanation: Minimum salary and maximum salary are 1000 and 4000 respectively.\nAverage salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500",
            "Input: salary = [1000,2000,3000]\nOutput: 2000.00000\nExplanation: Minimum salary and maximum salary are 1000 and 3000 respectively.\nAverage salary excluding minimum and maximum salary is (2000) / 1 = 2000"
        ],
        "constraints": "3 <= salary.length <= 100\n1000 <= salary[i] <= 106\nAll the integers of salary are unique."
    },
    {
        "slug": "arranging-coins",
        "description": "You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\nGiven the integer n, return the number of complete rows of the staircase you will build.",
        "examples": [
            "Input: n = 5\nOutput: 2\nExplanation: Because the 3rd row is incomplete, we return 2.",
            "Input: n = 8\nOutput: 3\nExplanation: Because the 4th row is incomplete, we return 3."
        ],
        "constraints": "1 <= n <= 231 - 1"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "description": "Given a 1-indexed\u00a0m x n integer matrix mat, you can select any cell in the matrix as your starting cell.\nFrom the starting cell, you can move to any other cell in the same row or column, but only if the value of the destination cell is strictly greater than the value of the current cell. You can repeat this process as many times as possible, moving from cell to cell until you can no longer make any moves.\nYour task is to find the maximum number of cells that you can visit in the matrix by starting from some cell.\nReturn an integer denoting the maximum number of cells that can be visited.",
        "examples": [
            "Input: mat = [[3,1],[3,4]]\nOutput: 2\nExplanation: The image shows how we can visit 2 cells starting from row 1, column 2. It can be shown that we cannot visit more than 2 cells no matter where we start from, so the answer is 2.",
            "Input: mat = [[1,1],[1,1]]\nOutput: 1\nExplanation: Since the cells must be strictly increasing, we can only visit one cell in this example.",
            "Input: mat = [[3,1,6],[-9,5,7]]\nOutput: 4\nExplanation: The image above shows how we can visit 4 cells starting from row 2, column 1. It can be shown that we cannot visit more than 4 cells no matter where we start from, so the answer is 4."
        ],
        "constraints": "m == mat.length\u00a0\nn == mat[i].length\u00a0\n1 <= m, n <= 105\n1 <= m * n <= 105\n-105\u00a0<= mat[i][j] <= 105"
    },
    {
        "slug": "find-eventual-safe-states",
        "description": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.",
        "examples": [
            "Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.",
            "Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4."
        ],
        "constraints": "n == graph.length\n1 <= n <= 104\n0 <= graph[i].length <= n\n0 <= graph[i][j] <= n - 1\ngraph[i] is sorted in a strictly increasing order.\nThe graph may contain self-loops.\nThe number of edges in the graph will be in the range [1, 4 * 104]."
    },
    {
        "slug": "shuffle-string",
        "description": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\nReturn the shuffled string.",
        "examples": [
            "Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3]\nOutput: \"leetcode\"\nExplanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling.",
            "Input: s = \"abc\", indices = [0,1,2]\nOutput: \"abc\"\nExplanation: After shuffling, each character remains in its position."
        ],
        "constraints": "s.length == indices.length == n\n1 <= n <= 100\ns consists of only lowercase English letters.\n0 <= indices[i] < n\nAll values of indices are unique."
    },
    {
        "slug": "k-closest-points-to-origin",
        "description": "Given an array of points where points[i] = [xi, yi] represents a point on the X-Y plane and an integer k, return the k closest points to the origin (0, 0).\nThe distance between two points on the X-Y plane is the Euclidean distance (i.e., \u221a(x1 - x2)2 + (y1 - y2)2).\nYou may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in).",
        "examples": [
            "Input: points = [[1,3],[-2,2]], k = 1\nOutput: [[-2,2]]\nExplanation:\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just [[-2,2]].",
            "Input: points = [[3,3],[5,-1],[-2,4]], k = 2\nOutput: [[3,3],[-2,4]]\nExplanation: The answer [[-2,4],[3,3]] would also be accepted."
        ],
        "constraints": "1 <= k <= points.length <= 104\n-104 <= xi, yi <= 104"
    },
    {
        "slug": "palindrome-linked-list",
        "description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.",
        "examples": [
            "Input: head = [1,2,2,1]\nOutput: true",
            "Input: head = [1,2]\nOutput: false"
        ],
        "constraints": "The number of nodes in the list is in the range [1, 105].\n0 <= Node.val <= 9"
    },
    {
        "slug": "most-frequent-even-element",
        "description": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.",
        "examples": [
            "Input: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.",
            "Input: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.",
            "Input: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element."
        ],
        "constraints": "1 <= nums.length <= 2000\n0 <= nums[i] <= 105"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.",
        "examples": [
            "Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]",
            "Input: preorder = [-1], inorder = [-1]\nOutput: [-1]"
        ],
        "constraints": "1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree."
    },
    {
        "slug": "3sum-closest",
        "description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.",
        "examples": [
            "Input: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).",
            "Input: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0)."
        ],
        "constraints": "3 <= nums.length <= 500\n-1000 <= nums[i] <= 1000\n-104 <= target <= 104"
    },
    {
        "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
        "description": "You are given an integer array nums.\nIn one move, you can choose one element of nums and change it to any value.\nReturn the minimum difference between the largest and smallest value of nums after performing at most three moves.",
        "examples": [
            "Input: nums = [5,3,2,4]\nOutput: 0\nExplanation: We can make at most 3 moves.\nIn the first move, change 2 to 3. nums becomes [5,3,3,4].\nIn the second move, change 4 to 3. nums becomes [5,3,3,3].\nIn the third move, change 5 to 3. nums becomes [3,3,3,3].\nAfter performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.",
            "Input: nums = [1,5,0,10,14]\nOutput: 1\nExplanation: We can make at most 3 moves.\nIn the first move, change 5 to 0. nums becomes [1,0,0,10,14].\nIn the second move, change 10 to 0. nums becomes [1,0,0,0,14].\nIn the third move, change 14 to 1. nums becomes [1,0,0,0,1].\nAfter performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 1.\nIt can be shown that there is no way to make the difference 0 in 3 moves.",
            "Input: nums = [3,100,20]\nOutput: 0\nExplanation: We can make at most 3 moves.\nIn the first move, change 100 to 7. nums becomes [3,7,20].\nIn the second move, change 20 to 7. nums becomes [3,7,7].\nIn the third move, change 3 to 7. nums becomes [7,7,7].\nAfter performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0."
        ],
        "constraints": "1 <= nums.length <= 105\n-109 <= nums[i] <= 109"
    },
    {
        "slug": "01-matrix",
        "description": "Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.",
        "examples": [
            "Input: mat = [[0,0,0],[0,1,0],[0,0,0]]\nOutput: [[0,0,0],[0,1,0],[0,0,0]]",
            "Input: mat = [[0,0,0],[0,1,0],[1,1,1]]\nOutput: [[0,0,0],[0,1,0],[1,2,1]]"
        ],
        "constraints": "m == mat.length\nn == mat[i].length\n1 <= m, n <= 104\n1 <= m * n <= 104\nmat[i][j] is either 0 or 1.\nThere is at least one 0 in mat."
    },
    {
        "slug": "final-value-of-variable-after-performing-operations",
        "description": "There is a programming language with only four operations and one variable X:\n\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\n\nInitially, the value of X is 0.\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.",
        "examples": [
            "Input: operations = [\"--X\",\"X++\",\"X++\"]\nOutput: 1\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.",
            "Input: operations = [\"++X\",\"++X\",\"X++\"]\nOutput: 3\nExplanation: The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.",
            "Input: operations = [\"X++\",\"++X\",\"--X\",\"X--\"]\nOutput: 0\nExplanation:\u00a0The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0."
        ],
        "constraints": "1 <= operations.length <= 100\noperations[i] will be either \"++X\", \"X++\", \"--X\", or \"X--\"."
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "description": "In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.",
        "examples": [
            "Input: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\nOutput: true\nExplanation: As 'h' comes before 'l' in this language, then the sequence is sorted.",
            "Input: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\nOutput: false\nExplanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.",
            "Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: false\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '\u2205', where '\u2205' is defined as the blank character which is less than any other character (More info)."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 20\norder.length == 26\nAll characters in words[i] and order are English lowercase letters."
    },
    {
        "slug": "maximize-win-from-two-segments",
        "description": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\nFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\n\nReturn the maximum number of prizes you can win if you choose the two segments optimally.",
        "examples": [
            "Input: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\nExplanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].",
            "Input: prizePositions = [1,2,3,4], k = 0\nOutput: 2\nExplanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes."
        ],
        "constraints": "1 <= prizePositions.length <= 105\n1 <= prizePositions[i] <= 109\n0 <= k <= 109 \nprizePositions is sorted in non-decreasing order."
    },
    {
        "slug": "keep-multiplying-found-values-by-two",
        "description": "You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\nYou then do the following steps:\n\nIf original is found in nums, multiply it by two (i.e., set original = 2 * original).\nOtherwise, stop the process.\nRepeat this process with the new number as long as you keep finding the number.\n\nReturn the final value of original.",
        "examples": [
            "Input: nums = [5,3,6,1,12], original = 3\nOutput: 24\nExplanation: \n- 3 is found in nums. 3 is multiplied by 2 to obtain 6.\n- 6 is found in nums. 6 is multiplied by 2 to obtain 12.\n- 12 is found in nums. 12 is multiplied by 2 to obtain 24.\n- 24 is not found in nums. Thus, 24 is returned.",
            "Input: nums = [2,7,9], original = 4\nOutput: 4\nExplanation:\n- 4 is not found in nums. Thus, 4 is returned."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i], original <= 1000"
    },
    {
        "slug": "intervals-between-identical-elements",
        "description": "You are given a 0-indexed array of n integers arr.\nThe interval between two elements in arr is defined as the absolute difference between their indices. More formally, the interval between arr[i] and arr[j] is |i - j|.\nReturn an array intervals of length n where intervals[i] is the sum of intervals between arr[i] and each element in arr with the same value as arr[i].\nNote: |x| is the absolute value of x.",
        "examples": [
            "Input: arr = [2,1,3,1,2,3,3]\nOutput: [4,2,7,2,4,4,5]\nExplanation:\n- Index 0: Another 2 is found at index 4. |0 - 4| = 4\n- Index 1: Another 1 is found at index 3. |1 - 3| = 2\n- Index 2: Two more 3s are found at indices 5 and 6. |2 - 5| + |2 - 6| = 7\n- Index 3: Another 1 is found at index 1. |3 - 1| = 2\n- Index 4: Another 2 is found at index 0. |4 - 0| = 4\n- Index 5: Two more 3s are found at indices 2 and 6. |5 - 2| + |5 - 6| = 4\n- Index 6: Two more 3s are found at indices 2 and 5. |6 - 2| + |6 - 5| = 5",
            "Input: arr = [10,5,10,10]\nOutput: [5,0,3,4]\nExplanation:\n- Index 0: Two more 10s are found at indices 2 and 3. |0 - 2| + |0 - 3| = 5\n- Index 1: There is only one 5 in the array, so its sum of intervals to identical elements is 0.\n- Index 2: Two more 10s are found at indices 0 and 3. |2 - 0| + |2 - 3| = 3\n- Index 3: Two more 10s are found at indices 0 and 2. |3 - 0| + |3 - 2| = 4"
        ],
        "constraints": "n == arr.length\n1 <= n <= 105\n1 <= arr[i] <= 105"
    },
    {
        "slug": "convert-binary-number-in-a-linked-list-to-integer",
        "description": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\nReturn the decimal value of the number in the linked list.\nThe most significant bit is at the head of the linked list.",
        "examples": [
            "Input: head = [1,0,1]\nOutput: 5\nExplanation: (101) in base 2 = (5) in base 10",
            "Input: head = [0]\nOutput: 0"
        ],
        "constraints": "The Linked List is not empty.\nNumber of nodes will not exceed 30.\nEach node's value is either 0 or 1."
    },
    {
        "slug": "count-nice-pairs-in-an-array",
        "description": "You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n\n0 <= i < j < nums.length\nnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\n\nReturn the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.",
        "examples": [
            "Input: nums = [42,11,1,97]\nOutput: 2\nExplanation: The two pairs are:\n - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.",
            "Input: nums = [13,10,35,24,76]\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 109"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.",
        "examples": [
            "Input: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.",
            "Input: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100"
    },
    {
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "description": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.",
        "examples": [
            "Input: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\nOutput: 1\nExplanation: We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.",
            "Input: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\nOutput: 1\nExplanation: We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.",
            "Input: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\nOutput: -1\nExplanation: Since \"ate\" does not exist in words, we return -1."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "description": "You are given a positive integer n representing the number of nodes of a Directed Acyclic Graph (DAG). The nodes are numbered from 0 to n - 1 (inclusive).\nYou are also given a 2D integer array edges, where edges[i] = [fromi, toi] denotes that there is a unidirectional edge from fromi to toi in the graph.\nReturn a list answer, where answer[i] is the list of ancestors of the ith node, sorted in ascending order.\nA node u is an ancestor of another node v if u can reach v via a set of edges.",
        "examples": [
            "Input: n = 8, edgeList = [[0,3],[0,4],[1,3],[2,4],[2,7],[3,5],[3,6],[3,7],[4,6]]\nOutput: [[],[],[],[0,1],[0,2],[0,1,3],[0,1,2,3,4],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Nodes 0, 1, and 2 do not have any ancestors.\n- Node 3 has two ancestors 0 and 1.\n- Node 4 has two ancestors 0 and 2.\n- Node 5 has three ancestors 0, 1, and 3.\n- Node 6 has five ancestors 0, 1, 2, 3, and 4.\n- Node 7 has four ancestors 0, 1, 2, and 3.",
            "Input: n = 5, edgeList = [[0,1],[0,2],[0,3],[0,4],[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nOutput: [[],[0],[0,1],[0,1,2],[0,1,2,3]]\nExplanation:\nThe above diagram represents the input graph.\n- Node 0 does not have any ancestor.\n- Node 1 has one ancestor 0.\n- Node 2 has two ancestors 0 and 1.\n- Node 3 has three ancestors 0, 1, and 2.\n- Node 4 has four ancestors 0, 1, 2, and 3."
        ],
        "constraints": "1 <= n <= 1000\n0 <= edges.length <= min(2000, n * (n - 1) / 2)\nedges[i].length == 2\n0 <= fromi, toi <= n - 1\nfromi != toi\nThere are no duplicate edges.\nThe graph is directed and acyclic."
    },
    {
        "slug": "longest-alternating-subarray",
        "description": "You are given a 0-indexed integer array nums. A subarray s of length m is called alternating if:\n\nm is greater than 1.\ns1 = s0 + 1.\nThe 0-indexed subarray s looks like [s0, s1, s0, s1,...,s(m-1) % 2]. In other words, s1 - s0 = 1, s2 - s1 = -1, s3 - s2 = 1, s4 - s3 = -1, and so on up to s[m - 1] - s[m - 2] = (-1)m.\n\nReturn the maximum length of all alternating subarrays present in nums or -1 if no such subarray exists.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [2,3,4,3,4]\nOutput: 4\nExplanation: The alternating subarrays are [3,4], [3,4,3], and [3,4,3,4]. The longest of these is [3,4,3,4], which is of length 4.",
            "Input: nums = [4,5,6]\nOutput: 2\nExplanation: [4,5] and [5,6] are the only two alternating subarrays. They are both of length 2."
        ],
        "constraints": "2 <= nums.length <= 100\n1 <= nums[i] <= 104"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-iv",
        "description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day, and an integer k.\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).",
        "examples": [
            "Input: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.",
            "Input: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3."
        ],
        "constraints": "1 <= k <= 100\n1 <= prices.length <= 1000\n0 <= prices[i] <= 1000"
    },
    {
        "slug": "finding-3-digit-even-numbers",
        "description": "You are given an integer array digits, where each element is a digit. The array may contain duplicates.\nYou need to find all the unique integers that follow the given requirements:\n\nThe integer consists of the concatenation of three elements from digits in any arbitrary order.\nThe integer does not have leading zeros.\nThe integer is even.\n\nFor example, if the given digits were [1, 2, 3], integers 132 and 312 follow the requirements.\nReturn a sorted array of the unique integers.",
        "examples": [
            "Input: digits = [2,1,3,0]\nOutput: [102,120,130,132,210,230,302,310,312,320]\nExplanation: All the possible integers that follow the requirements are in the output array. \nNotice that there are no odd integers or integers with leading zeros.",
            "Input: digits = [2,2,8,8,2]\nOutput: [222,228,282,288,822,828,882]\nExplanation: The same digit can be used as many times as it appears in digits. \nIn this example, the digit 8 is used twice each time in 288, 828, and 882.",
            "Input: digits = [3,7,5]\nOutput: []\nExplanation: No even integers can be formed using the given digits."
        ],
        "constraints": "3 <= digits.length <= 100\n0 <= digits[i] <= 9"
    },
    {
        "slug": "evaluate-reverse-polish-notation",
        "description": "You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\n\nThe valid operators are '+', '-', '*', and '/'.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.",
        "examples": [
            "Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9",
            "Input: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6",
            "Input: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22"
        ],
        "constraints": "1 <= tokens.length <= 104\ntokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200]."
    },
    {
        "slug": "middle-of-the-linked-list",
        "description": "Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.",
        "examples": [
            "Input: head = [1,2,3,4,5]\nOutput: [3,4,5]\nExplanation: The middle node of the list is node 3.",
            "Input: head = [1,2,3,4,5,6]\nOutput: [4,5,6]\nExplanation: Since the list has two middle nodes with values 3 and 4, we return the second one."
        ],
        "constraints": "The number of nodes in the list is in the range [1, 100].\n1 <= Node.val <= 100"
    },
    {
        "slug": "shortest-cycle-in-a-graph",
        "description": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.",
        "examples": [
            "Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\nOutput: 3\nExplanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0",
            "Input: n = 4, edges = [[0,1],[0,2]]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constraints": "2 <= n <= 1000\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi < n\nui != vi\nThere are no repeated edges."
    },
    {
        "slug": "gray-code",
        "description": "An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\n\nGiven an integer n, return any valid n-bit gray code sequence.",
        "examples": [
            "Input: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit",
            "Input: n = 1\nOutput: [0,1]"
        ],
        "constraints": "1 <= n <= 16"
    },
    {
        "slug": "minimum-operations-to-make-array-equal",
        "description": "You have an array arr of length n where arr[i] = (2 * i) + 1 for all valid values of i (i.e.,\u00a00 <= i < n).\nIn one operation, you can select two indices x and y where 0 <= x, y < n and subtract 1 from arr[x] and add 1 to arr[y] (i.e., perform arr[x] -=1 and arr[y] += 1). The goal is to make all the elements of the array equal. It is guaranteed that all the elements of the array can be made equal using some operations.\nGiven an integer n, the length of the array, return the minimum number of operations needed to make all the elements of arr equal.",
        "examples": [
            "Input: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation choose x = 2 and y = 0, this leads arr to be [2, 3, 4]\nIn the second operation choose x = 2 and y = 0 again, thus arr = [3, 3, 3].",
            "Input: n = 6\nOutput: 9"
        ],
        "constraints": "1 <= n <= 104"
    },
    {
        "slug": "sort-colors",
        "description": "Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library's sort function.",
        "examples": [
            "Input: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]",
            "Input: nums = [2,0,1]\nOutput: [0,1,2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2."
    },
    {
        "slug": "trapping-rain-water",
        "description": "Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
        "examples": [
            "Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.",
            "Input: height = [4,2,0,3,2,5]\nOutput: 9"
        ],
        "constraints": "n == height.length\n1 <= n <= 2 * 104\n0 <= height[i] <= 105"
    },
    {
        "slug": "largest-rectangle-in-histogram",
        "description": "Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
        "examples": [
            "Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.",
            "Input: heights = [2,4]\nOutput: 4"
        ],
        "constraints": "1 <= heights.length <= 105\n0 <= heights[i] <= 104"
    },
    {
        "slug": "maximum-number-of-events-that-can-be-attended-ii",
        "description": "You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.\nYou can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\nReturn the maximum sum of values that you can receive by attending events.",
        "examples": [
            "Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\nOutput: 7\nExplanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.",
            "Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\nOutput: 10\nExplanation: Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do not have to attend k events.",
            "Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\nOutput: 9\nExplanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three."
        ],
        "constraints": "1 <= k <= events.length\n1 <= k * events.length <= 106\n1 <= startDayi <= endDayi <= 109\n1 <= valuei <= 106"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "description": "Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different.\nThe bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed).",
        "examples": [
            "Input: nums = [3,1]\nOutput: 2\nExplanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3:\n- [3]\n- [3,1]",
            "Input: nums = [2,2,2]\nOutput: 7\nExplanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets.",
            "Input: nums = [3,2,1,5]\nOutput: 6\nExplanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7:\n- [3,5]\n- [3,1,5]\n- [3,2,5]\n- [3,2,1,5]\n- [2,5]\n- [2,1,5]"
        ],
        "constraints": "1 <= nums.length <= 16\n1 <= nums[i] <= 105"
    },
    {
        "slug": "single-number",
        "description": "Given a non-empty\u00a0array of integers nums, every element appears twice except for one. Find that single one.\nYou must\u00a0implement a solution with a linear runtime complexity and use\u00a0only constant\u00a0extra space.",
        "examples": [
            "Input: nums = [2,2,1]\nOutput: 1",
            "Input: nums = [4,1,2,1,2]\nOutput: 4",
            "Input: nums = [1]\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once."
    },
    {
        "slug": "domino-and-tromino-tiling",
        "description": "You have two types of tiles: a 2 x 1 domino shape and a tromino shape. You may rotate these shapes.\n\nGiven an integer n, return the number of ways to tile an 2 x n board. Since the answer may be very large, return it modulo 109 + 7.\nIn a tiling, every square must be covered by a tile. Two tilings are different if and only if there are two 4-directionally adjacent cells on the board such that exactly one of the tilings has both squares occupied by a tile.",
        "examples": [
            "Input: n = 3\nOutput: 5\nExplanation: The five different ways are show above.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 1000"
    },
    {
        "slug": "check-if-point-is-reachable",
        "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.",
        "examples": [
            "Input: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.",
            "Input: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
        ],
        "constraints": "1 <= targetX, targetY\u00a0<= 109"
    },
    {
        "slug": "check-if-all-the-integers-in-a-range-are-covered",
        "description": "You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.\nReturn true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.\nAn integer x is covered by an interval ranges[i] = [starti, endi] if starti <= x <= endi.",
        "examples": [
            "Input: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\nOutput: true\nExplanation: Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.",
            "Input: ranges = [[1,10],[10,20]], left = 21, right = 21\nOutput: false\nExplanation: 21 is not covered by any range."
        ],
        "constraints": "1 <= ranges.length <= 50\n1 <= starti <= endi <= 50\n1 <= left <= right <= 50"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -> (1, 2) -> (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.",
        "examples": [
            "Input: grid = [[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"b\",\"b\",\"a\"],[\"a\",\"a\",\"a\",\"a\"]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:",
            "Input: grid = [[\"c\",\"c\",\"c\",\"a\"],[\"c\",\"d\",\"c\",\"c\"],[\"c\",\"c\",\"e\",\"c\"],[\"f\",\"c\",\"c\",\"c\"]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:",
            "Input: grid = [[\"a\",\"b\",\"b\"],[\"b\",\"z\",\"b\"],[\"b\",\"b\",\"a\"]]\nOutput: false"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters."
    },
    {
        "slug": "number-of-different-integers-in-a-string",
        "description": "You are given a string word that consists of digits and lowercase English letters.\nYou will replace every non-digit character with a space. For example, \"a123bc34d8ef34\" will become \" 123\u00a0 34 8\u00a0 34\". Notice that you are left with some integers that are separated by at least one space: \"123\", \"34\", \"8\", and \"34\".\nReturn the number of different integers after performing the replacement operations on word.\nTwo integers are considered different if their decimal representations without any leading zeros are different.",
        "examples": [
            "Input: word = \"a123bc34d8ef34\"\nOutput: 3\nExplanation: The three different integers are \"123\", \"34\", and \"8\". Notice that \"34\" is only counted once.",
            "Input: word = \"leet1234code234\"\nOutput: 2",
            "Input: word = \"a1b01c001\"\nOutput: 1\nExplanation: The three integers \"1\", \"01\", and \"001\" all represent the same integer because\nthe leading zeros are ignored when comparing their decimal values."
        ],
        "constraints": "1 <= word.length <= 1000\nword consists of digits and lowercase English letters."
    },
    {
        "slug": "car-pooling",
        "description": "There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\nYou are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car's initial location.\nReturn true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.",
        "examples": [
            "Input: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false",
            "Input: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true"
        ],
        "constraints": "1 <= trips.length <= 1000\ntrips[i].length == 3\n1 <= numPassengersi <= 100\n0 <= fromi < toi <= 1000\n1 <= capacity <= 105"
    },
    {
        "slug": "find-the-duplicate-number",
        "description": "Given an array of integers nums containing\u00a0n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this\u00a0repeated\u00a0number.\nYou must solve the problem without modifying the array nums\u00a0and uses only constant extra space.",
        "examples": [
            "Input: nums = [1,3,4,2,2]\nOutput: 2",
            "Input: nums = [3,1,3,4,2]\nOutput: 3"
        ],
        "constraints": "1 <= n <= 105\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times."
    },
    {
        "slug": "count-pairs-with-xor-in-a-range",
        "description": "Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs.\nA nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high.",
        "examples": [
            "Input: nums = [1,4,2,7], low = 2, high = 6\r\nOutput: 6\r\nExplanation: All nice pairs (i, j) are as follows:\r\n    - (0, 1): nums[0] XOR nums[1] = 5 \r\n    - (0, 2): nums[0] XOR nums[2] = 3\r\n    - (0, 3): nums[0] XOR nums[3] = 6\r\n    - (1, 2): nums[1] XOR nums[2] = 6\r\n    - (1, 3): nums[1] XOR nums[3] = 3\r\n    - (2, 3): nums[2] XOR nums[3] = 5",
            "Input: nums = [9,8,4,2,1], low = 5, high = 14\r\nOutput: 8\r\nExplanation: All nice pairs (i, j) are as follows:\r\n\u200b\u200b\u200b\u200b\u200b    - (0, 2): nums[0] XOR nums[2] = 13\r\n\u00a0   - (0, 3): nums[0] XOR nums[3] = 11\r\n\u00a0   - (0, 4): nums[0] XOR nums[4] = 8\r\n\u00a0   - (1, 2): nums[1] XOR nums[2] = 12\r\n\u00a0   - (1, 3): nums[1] XOR nums[3] = 10\r\n\u00a0   - (1, 4): nums[1] XOR nums[4] = 9\r\n\u00a0   - (2, 3): nums[2] XOR nums[3] = 6\r\n\u00a0   - (2, 4): nums[2] XOR nums[4] = 5"
        ],
        "constraints": "1 <= nums.length <= 2 * 104\n1 <= nums[i] <= 2 * 104\n1 <= low <= high <= 2 * 104"
    },
    {
        "slug": "count-of-range-sum",
        "description": "Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.",
        "examples": [
            "Input: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.",
            "Input: nums = [0], lower = 0, upper = 0\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n-105 <= lower <= upper <= 105\nThe answer is guaranteed to fit in a 32-bit integer."
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node's value equals val and return the subtree rooted with that node. If such a node does not exist, return null.",
        "examples": [
            "Input: root = [4,2,7,1,3], val = 2\nOutput: [2,1,3]",
            "Input: root = [4,2,7,1,3], val = 5\nOutput: []"
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 5000].\n1 <= Node.val <= 107\nroot is a binary search tree.\n1 <= val <= 107"
    },
    {
        "slug": "largest-1-bordered-square",
        "description": "Given a 2D grid of 0s and 1s, return the number of elements in\u00a0the largest square\u00a0subgrid that has all 1s on its border, or 0 if such a subgrid\u00a0doesn't exist in the grid.",
        "examples": [
            "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]\r\nOutput: 9",
            "Input: grid = [[1,1,0,0]]\r\nOutput: 1"
        ],
        "constraints": "1 <= grid.length <= 100\n1 <= grid[0].length <= 100\ngrid[i][j] is 0 or 1"
    },
    {
        "slug": "kids-with-the-greatest-number-of-candies",
        "description": "There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.\nReturn a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.\nNote that multiple kids can have the greatest number of candies.",
        "examples": [
            "Input: candies = [2,3,5,1,3], extraCandies = 3\nOutput: [true,true,true,false,true] \nExplanation: If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.",
            "Input: candies = [4,2,1,1,2], extraCandies = 1\nOutput: [true,false,false,false,false] \nExplanation: There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.",
            "Input: candies = [12,1,12], extraCandies = 10\nOutput: [true,false,true]"
        ],
        "constraints": "n == candies.length\n2 <= n <= 100\n1 <= candies[i] <= 100\n1 <= extraCandies <= 50"
    },
    {
        "slug": "longest-common-subsequence",
        "description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, \"ace\" is a subsequence of \"abcde\".\n\nA common subsequence of two strings is a subsequence that is common to both strings.",
        "examples": [
            "Input: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.",
            "Input: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.",
            "Input: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0."
        ],
        "constraints": "1 <= text1.length, text2.length <= 1000\ntext1 and text2 consist of only lowercase English characters."
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "description": "You are given an array time where time[i] denotes the time taken by the ith bus to complete one trip.\nEach bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.\nYou are also given an integer totalTrips, which denotes the number of trips all buses should make in total. Return the minimum time required for all buses to complete at least totalTrips trips.",
        "examples": [
            "Input: time = [1,2,3], totalTrips = 5\nOutput: 3\nExplanation:\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.",
            "Input: time = [2], totalTrips = 1\nOutput: 2\nExplanation:\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2."
        ],
        "constraints": "1 <= time.length <= 105\n1 <= time[i], totalTrips <= 107"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "description": "You are given an integer array nums (0-indexed). In one operation, you can choose an element of the array and increment it by 1.\n\nFor example, if nums = [1,2,3], you can choose to increment nums[1] to make nums = [1,3,3].\n\nReturn the minimum number of operations needed to make nums strictly increasing.\nAn array nums is strictly increasing if nums[i] < nums[i+1] for all 0 <= i < nums.length - 1. An array of length 1 is trivially strictly increasing.",
        "examples": [
            "Input: nums = [1,1,1]\r\nOutput: 3\r\nExplanation: You can do the following operations:\r\n1) Increment nums[2], so nums becomes [1,1,2].\r\n2) Increment nums[1], so nums becomes [1,2,2].\r\n3) Increment nums[2], so nums becomes [1,2,3].",
            "Input: nums = [1,5,2,4,1]\r\nOutput: 14",
            "Input: nums = [8]\r\nOutput: 0"
        ],
        "constraints": "1 <= nums.length <= 5000\n1 <= nums[i] <= 104"
    },
    {
        "slug": "reduction-operations-to-make-the-array-elements-equal",
        "description": "Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\nFind the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\nFind the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\nReduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.",
        "examples": [
            "Input: nums = [5,1,3]\nOutput: 3\nExplanation:\u00a0It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].",
            "Input: nums = [1,1,1]\nOutput: 0\nExplanation:\u00a0All elements in nums are already equal.",
            "Input: nums = [1,1,2,2,3]\nOutput: 4\nExplanation:\u00a0It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 5 * 104"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "description": "Given an integer n, return the number of trailing zeroes in n!.\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.",
        "examples": [
            "Input: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.",
            "Input: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.",
            "Input: n = 0\nOutput: 0"
        ],
        "constraints": "0 <= n <= 104"
    },
    {
        "slug": "add-strings",
        "description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.",
        "examples": [
            "Input: num1 = \"11\", num2 = \"123\"\nOutput: \"134\"",
            "Input: num1 = \"456\", num2 = \"77\"\nOutput: \"533\"",
            "Input: num1 = \"0\", num2 = \"0\"\nOutput: \"0\""
        ],
        "constraints": "1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don't have any leading zeros except for the zero itself."
    },
    {
        "slug": "frequency-tracker",
        "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\nFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\nvoid add(int number): Adds number to the data structure.\nvoid deleteOne(int number): Deletes one occurrence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\nbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.",
        "examples": [
            "Input\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice",
            "Input\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty",
            "Input\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once"
        ],
        "constraints": "1 <= number <= 105\n1 <= frequency <= 105\nAt most, 2 *\u00a0105\u00a0calls will be made to add, deleteOne, and hasFrequency\u00a0in total."
    },
    {
        "slug": "find-elements-in-a-contaminated-binary-tree",
        "description": "Given a binary tree with the following rules:\n\nroot.val == 0\nIf treeNode.val == x and treeNode.left != null, then treeNode.left.val == 2 * x + 1\nIf treeNode.val == x and treeNode.right != null, then treeNode.right.val == 2 * x + 2\n\nNow the binary tree is contaminated, which means all treeNode.val have been changed to -1.\nImplement the FindElements class:\n\nFindElements(TreeNode* root) Initializes the object with a contaminated binary tree and recovers it.\nbool find(int target) Returns true if the target value exists in the recovered binary tree.",
        "examples": [
            "Input\n[\"FindElements\",\"find\",\"find\"]\n[[[-1,null,-1]],[1],[2]]\nOutput\n[null,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1]); \nfindElements.find(1); // return False \nfindElements.find(2); // return True",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\"]\n[[[-1,-1,-1,-1,-1]],[1],[3],[5]]\nOutput\n[null,true,true,false]\nExplanation\nFindElements findElements = new FindElements([-1,-1,-1,-1,-1]);\nfindElements.find(1); // return True\nfindElements.find(3); // return True\nfindElements.find(5); // return False",
            "Input\n[\"FindElements\",\"find\",\"find\",\"find\",\"find\"]\n[[[-1,null,-1,-1,null,-1]],[2],[3],[4],[5]]\nOutput\n[null,true,false,false,true]\nExplanation\nFindElements findElements = new FindElements([-1,null,-1,-1,null,-1]);\nfindElements.find(2); // return True\nfindElements.find(3); // return False\nfindElements.find(4); // return False\nfindElements.find(5); // return True"
        ],
        "constraints": "TreeNode.val == -1\nThe height of the binary tree is less than or equal to 20\nThe total number of nodes is between [1, 104]\nTotal calls of find() is between [1, 104]\n0 <= target <= 106"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "description": "You are given a 0-indexed string s of even length n. The string consists of exactly n / 2 opening brackets '[' and n / 2 closing brackets ']'.\nA string is called balanced if and only if:\n\nIt is the empty string, or\nIt can be written as AB, where both A and B are balanced strings, or\nIt can be written as [C], where C is a balanced string.\n\nYou may swap the brackets at any two indices any number of times.\nReturn the minimum number of swaps to make s balanced.",
        "examples": [
            "Input: s = \"][][\"\nOutput: 1\nExplanation: You can make the string balanced by swapping index 0 with index 3.\nThe resulting string is \"[[]]\".",
            "Input: s = \"]]][[[\"\nOutput: 2\nExplanation: You can do the following to make the string balanced:\n- Swap index 0 with index 4. s = \"[]][][\".\n- Swap index 1 with index 5. s = \"[[][]]\".\nThe resulting string is \"[[][]]\".",
            "Input: s = \"[]\"\nOutput: 0\nExplanation: The string is already balanced."
        ],
        "constraints": "n == s.length\n2 <= n <= 106\nn is even.\ns[i] is either '[' or ']'.\nThe number of opening brackets '[' equals n / 2, and the number of closing brackets ']' equals n / 2."
    },
    {
        "slug": "hamming-distance",
        "description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.",
        "examples": [
            "Input: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       \u2191   \u2191\nThe above arrows point to positions where the corresponding bits are different.",
            "Input: x = 3, y = 1\nOutput: 1"
        ],
        "constraints": "0 <=\u00a0x, y <= 231 - 1"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "description": "You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\nReturn the minimum number of moves required to make every node have exactly one coin.",
        "examples": [
            "Input: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.",
            "Input: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child."
        ],
        "constraints": "The number of nodes in the tree is n.\n1 <= n <= 100\n0 <= Node.val <= n\nThe sum of all Node.val is n."
    },
    {
        "slug": "determine-whether-matrix-can-be-obtained-by-rotation",
        "description": "Given two n x n binary matrices mat and target, return true if it is possible to make mat equal to target by rotating mat in 90-degree increments, or false otherwise.",
        "examples": [
            "Input: mat = [[0,1],[1,0]], target = [[1,0],[0,1]]\nOutput: true\nExplanation: We can rotate mat 90 degrees clockwise to make mat equal target.",
            "Input: mat = [[0,1],[1,1]], target = [[1,0],[0,1]]\nOutput: false\nExplanation: It is impossible to make mat equal to target by rotating mat.",
            "Input: mat = [[0,0,0],[0,1,0],[1,1,1]], target = [[1,1,1],[0,1,0],[0,0,0]]\nOutput: true\nExplanation: We can rotate mat 90 degrees clockwise two times to make mat equal target."
        ],
        "constraints": "n == mat.length == target.length\nn == mat[i].length == target[i].length\n1 <= n <= 10\nmat[i][j] and target[i][j] are either 0 or 1."
    },
    {
        "slug": "greatest-sum-divisible-by-three",
        "description": "Given an integer array nums, return the maximum possible sum of elements of the array such that it is divisible by three.",
        "examples": [
            "Input: nums = [3,6,5,1,8]\nOutput: 18\nExplanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).",
            "Input: nums = [4]\nOutput: 0\nExplanation: Since 4 is not divisible by 3, do not pick any number.",
            "Input: nums = [1,2,3,4,4]\nOutput: 12\nExplanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3)."
        ],
        "constraints": "1 <= nums.length <= 4 * 104\n1 <= nums[i] <= 104"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "description": "Given an array of integers nums and a positive integer k, check whether it is possible to divide this array into sets of k consecutive numbers.\nReturn true if it is possible. Otherwise, return false.",
        "examples": [
            "Input: nums = [1,2,3,3,4,4,5,6], k = 4\nOutput: true\nExplanation: Array can be divided into [1,2,3,4] and [3,4,5,6].",
            "Input: nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3\nOutput: true\nExplanation: Array can be divided into [1,2,3] , [2,3,4] , [3,4,5] and [9,10,11].",
            "Input: nums = [1,2,3,4], k = 3\nOutput: false\nExplanation: Each array should be divided in subarrays of size 3."
        ],
        "constraints": "1 <= k <= nums.length <= 105\n1 <= nums[i] <= 109\n\n\u00a0\nNote: This question is the same as\u00a0846:\u00a0https://leetcode.com/problems/hand-of-straights/"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "description": "Given a binary string s and a positive integer n, return true if the binary representation of all the integers in the range [1, n] are substrings of s, or false otherwise.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"0110\", n = 3\nOutput: true",
            "Input: s = \"0110\", n = 4\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 1000\ns[i] is either '0' or '1'.\n1 <= n <= 109"
    },
    {
        "slug": "maximum-score-from-removing-stones",
        "description": "You are playing a solitaire game with three piles of stones of sizes a\u200b\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b\u200b respectively. Each turn you choose two different non-empty piles, take one stone from each, and add 1 point to your score. The game stops when there are fewer than two non-empty piles (meaning there are no more available moves).\nGiven three integers a\u200b\u200b\u200b\u200b\u200b, b,\u200b\u200b\u200b\u200b\u200b and c\u200b\u200b\u200b\u200b\u200b, return the maximum score you can get.",
        "examples": [
            "Input: a = 2, b = 4, c = 6\nOutput: 6\nExplanation: The starting state is (2, 4, 6). One optimal set of moves is:\n- Take from 1st and 3rd piles, state is now (1, 4, 5)\n- Take from 1st and 3rd piles, state is now (0, 4, 4)\n- Take from 2nd and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 6 points.",
            "Input: a = 4, b = 4, c = 6\nOutput: 7\nExplanation: The starting state is (4, 4, 6). One optimal set of moves is:\n- Take from 1st and 2nd piles, state is now (3, 3, 6)\n- Take from 1st and 3rd piles, state is now (2, 3, 5)\n- Take from 1st and 3rd piles, state is now (1, 3, 4)\n- Take from 1st and 3rd piles, state is now (0, 3, 3)\n- Take from 2nd and 3rd piles, state is now (0, 2, 2)\n- Take from 2nd and 3rd piles, state is now (0, 1, 1)\n- Take from 2nd and 3rd piles, state is now (0, 0, 0)\nThere are fewer than two non-empty piles, so the game ends. Total: 7 points.",
            "Input: a = 1, b = 8, c = 8\nOutput: 8\nExplanation: One optimal set of moves is to take from the 2nd and 3rd piles for 8 turns until they are empty.\nAfter that, there are fewer than two non-empty piles, so the game ends."
        ],
        "constraints": "1 <= a, b, c <= 105"
    },
    {
        "slug": "find-original-array-from-doubled-array",
        "description": "An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array.\nGiven an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order.",
        "examples": [
            "Input: changed = [1,3,4,2,6,8]\nOutput: [1,3,4]\nExplanation: One possible original array could be [1,3,4]:\n- Twice the value of 1 is 1 * 2 = 2.\n- Twice the value of 3 is 3 * 2 = 6.\n- Twice the value of 4 is 4 * 2 = 8.\nOther original arrays could be [4,3,1] or [3,1,4].",
            "Input: changed = [6,3,0,1]\nOutput: []\nExplanation: changed is not a doubled array.",
            "Input: changed = [1]\nOutput: []\nExplanation: changed is not a doubled array."
        ],
        "constraints": "1 <= changed.length <= 105\n0 <= changed[i] <= 105"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "description": "You are given a string word and an array of strings forbidden.\nA string is called valid if none of its substrings are present in forbidden.\nReturn the length of the longest valid substring of the string word.\nA substring is a contiguous sequence of characters in a string, possibly empty.",
        "examples": [
            "Input: word = \"cbaaaabc\", forbidden = [\"aaa\",\"cb\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"c\", \"b\", \"a\", \"ba\", \"aa\", \"bc\", \"baa\", \"aab\", \"ab\", \"abc\"and \"aabc\". The length of the longest valid substring is 4. \nIt can be shown that all other substrings contain either \"aaa\" or \"cb\" as a substring.",
            "Input: word = \"leetcode\", forbidden = [\"de\",\"le\",\"e\"]\nOutput: 4\nExplanation: There are 11 valid substrings in word: \"l\", \"t\", \"c\", \"o\", \"d\", \"tc\", \"co\", \"od\", \"tco\", \"cod\", and \"tcod\". The length of the longest valid substring is 4.\nIt can be shown that all other substrings contain either \"de\", \"le\", or \"e\" as a substring."
        ],
        "constraints": "1 <= word.length <= 105\nword consists only of lowercase English letters.\n1 <= forbidden.length <= 105\n1 <= forbidden[i].length <= 10\nforbidden[i] consists only of lowercase English letters."
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "description": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.",
        "examples": [
            "Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].",
            "Input: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]."
        ],
        "constraints": "The number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106"
    },
    {
        "slug": "maximum-sum-queries",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, each of length n, and a 1-indexed 2D array queries where queries[i] = [xi, yi].\nFor the ith query, find the maximum value of nums1[j] + nums2[j] among all indices j (0 <= j < n), where nums1[j] >= xi and nums2[j] >= yi, or -1 if there is no j satisfying the constraints.\nReturn an array answer where answer[i] is the answer to the ith query.",
        "examples": [
            "Input: nums1 = [4,3,1,2], nums2 = [2,4,9,5], queries = [[4,1],[1,3],[2,5]]\nOutput: [6,10,7]\nExplanation: \nFor the 1st query xi = 4\u00a0and\u00a0yi = 1, we can select index\u00a0j = 0\u00a0since\u00a0nums1[j] >= 4\u00a0and\u00a0nums2[j] >= 1. The sum\u00a0nums1[j] + nums2[j]\u00a0is 6, and we can show that 6 is the maximum we can obtain.\n\nFor the 2nd query xi = 1\u00a0and\u00a0yi = 3, we can select index\u00a0j = 2\u00a0since\u00a0nums1[j] >= 1\u00a0and\u00a0nums2[j] >= 3. The sum\u00a0nums1[j] + nums2[j]\u00a0is 10, and we can show that 10 is the maximum we can obtain. \n\nFor the 3rd query xi = 2\u00a0and\u00a0yi = 5, we can select index\u00a0j = 3\u00a0since\u00a0nums1[j] >= 2\u00a0and\u00a0nums2[j] >= 5. The sum\u00a0nums1[j] + nums2[j]\u00a0is 7, and we can show that 7 is the maximum we can obtain.\n\nTherefore, we return\u00a0[6,10,7].",
            "Input: nums1 = [3,2,5], nums2 = [2,3,4], queries = [[4,4],[3,2],[1,1]]\nOutput: [9,9,9]\nExplanation: For this example, we can use index\u00a0j = 2\u00a0for all the queries since it satisfies the constraints for each query.",
            "Input: nums1 = [2,1], nums2 = [2,3], queries = [[3,3]]\nOutput: [-1]\nExplanation: There is one query in this example with xi = 3 and yi = 3. For every index, j, either nums1[j] < xi or nums2[j] < yi. Hence, there is no solution."
        ],
        "constraints": "nums1.length == nums2.length\u00a0\nn ==\u00a0nums1.length\u00a0\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= 109\u00a0\n1 <= queries.length <= 105\nqueries[i].length ==\u00a02\nxi\u00a0== queries[i][1]\nyi == queries[i][2]\n1 <= xi, yi <= 109"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "description": "Given n points on a 2D plane where points[i] = [xi, yi], Return\u00a0the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.",
        "examples": [
            "\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.",
            "Input: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3"
        ],
        "constraints": "n == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi\u00a0<= 109"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "description": "Given a positive integer n, return the punishment number of n.\nThe punishment number of n is defined as the sum of the squares of all integers i such that:\n\n1 <= i <= n\nThe decimal representation of i * i can be partitioned into contiguous substrings such that the sum of the integer values of these substrings equals i.",
        "examples": [
            "Input: n = 10\nOutput: 182\nExplanation: There are exactly 3 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1\n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1.\n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0.\nHence, the punishment number of 10 is 1 + 81 + 100 = 182",
            "Input: n = 37\nOutput: 1478\nExplanation: There are exactly 4 integers i that satisfy the conditions in the statement:\n- 1 since 1 * 1 = 1. \n- 9 since 9 * 9 = 81 and 81 can be partitioned into 8 + 1. \n- 10 since 10 * 10 = 100 and 100 can be partitioned into 10 + 0. \n- 36 since 36 * 36 = 1296 and 1296 can be partitioned into 1 + 29 + 6.\nHence, the punishment number of 37 is 1 + 81 + 100 + 1296 = 1478"
        ],
        "constraints": "1 <= n <= 1000"
    },
    {
        "slug": "the-k-strongest-values-in-an-array",
        "description": "Given an array of integers arr and an integer k.\nA value arr[i] is said to be stronger than a value arr[j] if |arr[i] - m| > |arr[j] - m| where m is the median of the array.\nIf |arr[i] - m| == |arr[j] - m|, then arr[i] is said to be stronger than arr[j] if arr[i] > arr[j].\nReturn a list of the strongest k values in the array. return the answer in any arbitrary order.\nMedian is the middle value in an ordered integer list. More formally, if the length of the list is n, the median is the element in position ((n - 1) / 2) in the sorted list (0-indexed).\n\nFor arr = [6, -3, 7, 2, 11], n = 5 and the median is obtained by sorting the array arr = [-3, 2, 6, 7, 11] and the median is arr[m] where m = ((5 - 1) / 2) = 2. The median is 6.\nFor arr = [-7, 22, 17,\u20093], n = 4 and the median is obtained by sorting the array arr = [-7, 3, 17, 22] and the median is arr[m] where m = ((4 - 1) / 2) = 1. The median is 3.",
        "examples": [
            "Input: arr = [1,2,3,4,5], k = 2\nOutput: [5,1]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,1,4,2,3]. The strongest 2 elements are [5, 1]. [1, 5] is also accepted answer.\nPlease note that although |5 - 3| == |1 - 3| but 5 is stronger than 1 because 5 > 1.",
            "Input: arr = [1,1,3,5,5], k = 2\nOutput: [5,5]\nExplanation: Median is 3, the elements of the array sorted by the strongest are [5,5,1,1,3]. The strongest 2 elements are [5, 5].",
            "Input: arr = [6,7,11,7,6,8], k = 5\nOutput: [11,8,6,6,7]\nExplanation: Median is 7, the elements of the array sorted by the strongest are [11,8,6,6,7,7].\nAny permutation of [11,8,6,6,7] is accepted."
        ],
        "constraints": "1 <= arr.length <= 105\n-105 <= arr[i] <= 105\n1 <= k <= arr.length"
    },
    {
        "slug": "group-anagrams",
        "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
        "examples": [
            "Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]",
            "Input: strs = [\"\"]\nOutput: [[\"\"]]",
            "Input: strs = [\"a\"]\nOutput: [[\"a\"]]"
        ],
        "constraints": "1 <= strs.length <= 104\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters."
    },
    {
        "slug": "shortest-path-visiting-all-nodes",
        "description": "You have an undirected, connected graph of n nodes labeled from 0 to n - 1. You are given an array graph where graph[i] is a list of all the nodes connected with node i by an edge.\nReturn the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.",
        "examples": [
            "Input: graph = [[1,2,3],[0],[0],[0]]\nOutput: 4\nExplanation: One possible path is [1,0,2,0,3]",
            "Input: graph = [[1],[0,2,4],[1,3,4],[2],[1,2]]\nOutput: 4\nExplanation: One possible path is [0,1,4,2,3]"
        ],
        "constraints": "n == graph.length\n1 <= n <= 12\n0 <= graph[i].length <\u00a0n\ngraph[i] does not contain i.\nIf graph[a] contains b, then graph[b] contains a.\nThe input graph is always connected."
    },
    {
        "slug": "optimal-partition-of-string",
        "description": "Given a string s, partition the string into one or more substrings such that the characters in each substring are unique. That is, no letter appears in a single substring more than once.\nReturn the minimum number of substrings in such a partition.\nNote that each character should belong to exactly one substring in a partition.",
        "examples": [
            "Input: s = \"abacaba\"\nOutput: 4\nExplanation:\nTwo possible partitions are (\"a\",\"ba\",\"cab\",\"a\") and (\"ab\",\"a\",\"ca\",\"ba\").\nIt can be shown that 4 is the minimum number of substrings needed.",
            "Input: s = \"ssssss\"\nOutput: 6\nExplanation:\nThe only valid partition is (\"s\",\"s\",\"s\",\"s\",\"s\",\"s\")."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of only English lowercase letters."
    },
    {
        "slug": "next-greater-node-in-linked-list",
        "description": "You are given the head of a linked list with n nodes.\nFor each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.\nReturn an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.",
        "examples": [
            "Input: head = [2,1,5]\nOutput: [5,5,0]",
            "Input: head = [2,7,4,3,5]\nOutput: [7,0,5,5,0]"
        ],
        "constraints": "The number of nodes in the list is n.\n1 <= n <= 104\n1 <= Node.val <= 109"
    },
    {
        "slug": "sentence-similarity-iii",
        "description": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. For example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences. Words consist of only uppercase and lowercase English letters.\nTwo sentences sentence1 and sentence2 are similar if it is possible to insert an arbitrary sentence (possibly empty) inside one of these sentences such that the two sentences become equal. For example, sentence1 = \"Hello my name is Jane\" and sentence2 = \"Hello Jane\" can be made equal by inserting \"my name is\" between \"Hello\" and \"Jane\" in sentence2.\nGiven two sentences sentence1 and sentence2, return true if sentence1 and sentence2 are similar. Otherwise, return false.",
        "examples": [
            "Input: sentence1 = \"My name is Haley\", sentence2 = \"My Haley\"\nOutput: true\nExplanation: sentence2 can be turned to sentence1 by inserting \"name is\" between \"My\" and \"Haley\".",
            "Input: sentence1 = \"of\", sentence2 = \"A lot of words\"\nOutput: false\nExplanation: No single sentence can be inserted inside one of the sentences to make it equal to the other.",
            "Input: sentence1 = \"Eating right now\", sentence2 = \"Eating\"\nOutput: true\nExplanation: sentence2 can be turned to sentence1 by inserting \"right now\" at the end of the sentence."
        ],
        "constraints": "1 <= sentence1.length, sentence2.length <= 100\nsentence1 and sentence2 consist of lowercase and uppercase English letters and spaces.\nThe words in sentence1 and sentence2 are separated by a single space."
    },
    {
        "slug": "extra-characters-in-a-string",
        "description": "You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\nReturn the minimum number of extra characters left over if you break up s optimally.",
        "examples": [
            "Input: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\nOutput: 1\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.",
            "Input: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\nOutput: 3\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3."
        ],
        "constraints": "1 <= s.length <= 50\n1 <= dictionary.length <= 50\n1 <= dictionary[i].length <= 50\ndictionary[i]\u00a0and s consists of only lowercase English letters\ndictionary contains distinct words"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "description": "Given the root of a perfect binary tree, reverse the node values at each odd level of the tree.\n\nFor example, suppose the node values at level 3 are [2,1,3,4,7,11,29,18], then it should become [18,29,11,7,4,3,1,2].\n\nReturn the root of the reversed tree.\nA binary tree is perfect if all parent nodes have two children and all leaves are on the same level.\nThe level of a node is the number of edges along the path between it and the root node.",
        "examples": [
            "Input: root = [2,3,5,8,13,21,34]\nOutput: [2,5,3,8,13,21,34]\nExplanation: \nThe tree has only one odd level.\nThe nodes at level 1 are 3, 5 respectively, which are reversed and become 5, 3.",
            "Input: root = [7,13,11]\nOutput: [7,11,13]\nExplanation: \nThe nodes at level 1 are 13, 11, which are reversed and become 11, 13.",
            "Input: root = [0,1,2,0,0,0,0,1,1,1,1,2,2,2,2]\nOutput: [0,2,1,0,0,0,0,2,2,2,2,1,1,1,1]\nExplanation: \nThe odd levels have non-zero values.\nThe nodes at level 1 were 1, 2, and are 2, 1 after the reversal.\nThe nodes at level 3 were 1, 1, 1, 1, 2, 2, 2, 2, and are 2, 2, 2, 2, 1, 1, 1, 1 after the reversal."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 214].\n0 <= Node.val <= 105\nroot is a perfect binary tree."
    },
    {
        "slug": "minimum-incompatibility",
        "description": "You are given an integer array nums\u200b\u200b\u200b and an integer k. You are asked to distribute this array into k subsets of equal size such that there are no two equal elements in the same subset.\nA subset's incompatibility is the difference between the maximum and minimum elements in that array.\nReturn the minimum possible sum of incompatibilities of the k subsets after distributing the array optimally, or return -1 if it is not possible.\nA subset is a group integers that appear in the array with no particular order.",
        "examples": [
            "Input: nums = [1,2,1,4], k = 2\nOutput: 4\nExplanation: The optimal distribution of subsets is [1,2] and [1,4].\nThe incompatibility is (2-1) + (4-1) = 4.\nNote that [1,1] and [2,4] would result in a smaller sum, but the first subset contains 2 equal elements.",
            "Input: nums = [6,3,8,1,3,1,2,2], k = 4\nOutput: 6\nExplanation: The optimal distribution of subsets is [1,2], [2,3], [6,8], and [1,3].\nThe incompatibility is (2-1) + (3-2) + (8-6) + (3-1) = 6.",
            "Input: nums = [5,3,3,6,3,3], k = 3\nOutput: -1\nExplanation: It is impossible to distribute nums into 3 subsets where no two elements are equal in the same subset."
        ],
        "constraints": "1 <= k <= nums.length <= 16\nnums.length is divisible by k\n1 <= nums[i] <= nums.length"
    },
    {
        "slug": "capitalize-the-title",
        "description": "You are given a string title consisting of one or more words separated by a single space, where each word consists of English letters. Capitalize the string by changing the capitalization of each word such that:\n\nIf the length of the word is 1 or 2 letters, change all letters to lowercase.\nOtherwise, change the first letter to uppercase and the remaining letters to lowercase.\n\nReturn the capitalized title.",
        "examples": [
            "Input: title = \"capiTalIze tHe titLe\"\nOutput: \"Capitalize The Title\"\nExplanation:\nSince all the words have a length of at least 3, the first letter of each word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"First leTTeR of EACH Word\"\nOutput: \"First Letter of Each Word\"\nExplanation:\nThe word \"of\" has length 2, so it is all lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase.",
            "Input: title = \"i lOve leetcode\"\nOutput: \"i Love Leetcode\"\nExplanation:\nThe word \"i\" has length 1, so it is lowercase.\nThe remaining words have a length of at least 3, so the first letter of each remaining word is uppercase, and the remaining letters are lowercase."
        ],
        "constraints": "1 <= title.length <= 100\ntitle consists of words separated by a single space without any leading or trailing spaces.\nEach word consists of uppercase and lowercase English letters and is non-empty."
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\n\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\n\nThe values in the two lists should be returned in increasing order.\nNote:\n\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.",
        "examples": [
            "Input: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].",
            "Input: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = []."
        ],
        "constraints": "1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique."
    },
    {
        "slug": "is-graph-bipartite",
        "description": "There is an undirected graph with n nodes, where each node is numbered between 0 and n - 1. You are given a 2D array graph, where graph[u] is an array of nodes that node u is adjacent to. More formally, for each v in graph[u], there is an undirected edge between node u and node v. The graph has the following properties:\n\nThere are no self-edges (graph[u] does not contain u).\nThere are no parallel edges (graph[u] does not contain duplicate values).\nIf v is in graph[u], then u is in graph[v] (the graph is undirected).\nThe graph may not be connected, meaning there may be two nodes u and v such that there is no path between them.\n\nA graph is bipartite if the nodes can be partitioned into two independent sets A and B such that every edge in the graph connects a node in set A and a node in set B.\nReturn true if and only if it is bipartite.",
        "examples": [
            "Input: graph = [[1,2,3],[0,2],[0,1,3],[0,2]]\nOutput: false\nExplanation: There is no way to partition the nodes into two independent sets such that every edge connects a node in one and a node in the other.",
            "Input: graph = [[1,3],[0,2],[1,3],[0,2]]\nOutput: true\nExplanation: We can partition the nodes into two sets: {0, 2} and {1, 3}."
        ],
        "constraints": "graph.length == n\n1 <= n <= 100\n0 <= graph[u].length < n\n0 <= graph[u][i] <= n - 1\ngraph[u]\u00a0does not contain\u00a0u.\nAll the values of graph[u] are unique.\nIf graph[u] contains v, then graph[v] contains u."
    },
    {
        "slug": "separate-the-digits-in-an-array",
        "description": "Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.\nTo separate the digits of an integer is to get all the digits it has in the same order.\n\nFor example, for the integer 10921, the separation of its digits is [1,0,9,2,1].",
        "examples": [
            "Input: nums = [13,25,83,77]\nOutput: [1,3,2,5,8,3,7,7]\nExplanation: \n- The separation of 13 is [1,3].\n- The separation of 25 is [2,5].\n- The separation of 83 is [8,3].\n- The separation of 77 is [7,7].\nanswer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.",
            "Input: nums = [7,1,3,9]\nOutput: [7,1,3,9]\nExplanation: The separation of each integer in nums is itself.\nanswer = [7,1,3,9]."
        ],
        "constraints": "1 <= nums.length <= 1000\n1 <= nums[i] <= 105"
    },
    {
        "slug": "smallest-even-multiple",
        "description": "Given a positive integer n, return the smallest positive integer that is a multiple of both 2 and n.",
        "examples": [
            "Input: n = 5\nOutput: 10\nExplanation: The smallest multiple of both 5 and 2 is 10.",
            "Input: n = 6\nOutput: 6\nExplanation: The smallest multiple of both 6 and 2 is 6. Note that a number is a multiple of itself."
        ],
        "constraints": "1 <= n <= 150"
    },
    {
        "slug": "maximum-number-of-ways-to-partition-an-array",
        "description": "You are given a 0-indexed integer array nums of length n. The number of ways to partition nums is the number of pivot indices that satisfy both conditions:\n\n1 <= pivot < n\nnums[0] + nums[1] + ... + nums[pivot - 1] == nums[pivot] + nums[pivot + 1] + ... + nums[n - 1]\n\nYou are also given an integer k. You can choose to change the value of one element of nums to k, or to leave the array unchanged.\nReturn the maximum possible number of ways to partition nums to satisfy both conditions after changing at most one element.",
        "examples": [
            "Input: nums = [2,-1,2], k = 3\nOutput: 1\nExplanation: One optimal approach is to change nums[0] to k. The array becomes [3,-1,2].\nThere is one way to partition the array:\n- For pivot = 2, we have the partition [3,-1 | 2]: 3 + -1 == 2.",
            "Input: nums = [0,0,0], k = 1\nOutput: 2\nExplanation: The optimal approach is to leave the array unchanged.\nThere are two ways to partition the array:\n- For pivot = 1, we have the partition [0 | 0,0]: 0 == 0 + 0.\n- For pivot = 2, we have the partition [0,0 | 0]: 0 + 0 == 0.",
            "Input: nums = [22,4,-25,-20,-15,15,-16,7,19,-10,0,-13,-14], k = -33\nOutput: 4\nExplanation: One optimal approach is to change nums[2] to k. The array becomes [22,4,-33,-20,-15,15,-16,7,19,-10,0,-13,-14].\nThere are four ways to partition the array."
        ],
        "constraints": "n == nums.length\n2 <= n <= 105\n-105 <= k, nums[i] <= 105"
    },
    {
        "slug": "find-the-score-of-all-prefixes-of-an-array",
        "description": "We define the conversion array conver of an array arr as follows:\n\nconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].",
        "examples": [
            "Input: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56",
            "Input: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64"
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "description": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from node i, then edges[i] == -1.\nReturn the length of the longest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node.",
        "examples": [
            "Input: edges = [3,3,4,2,3]\nOutput: 3\nExplanation: The longest cycle in the graph is the cycle: 2 -> 4 -> 3 -> 2.\nThe length of this cycle is 3, so 3 is returned.",
            "Input: edges = [2,-1,3,1]\nOutput: -1\nExplanation: There are no cycles in this graph."
        ],
        "constraints": "n == edges.length\n2 <= n <= 105\n-1 <= edges[i] < n\nedges[i] != i"
    },
    {
        "slug": "score-after-flipping-matrix",
        "description": "You are given an m x n binary matrix grid.\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\nReturn the highest possible score after making any number of moves (including zero moves).",
        "examples": [
            "Input: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39",
            "Input: grid = [[0]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\ngrid[i][j] is either 0 or 1."
    },
    {
        "slug": "the-number-of-beautiful-subsets",
        "description": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",
        "examples": [
            "Input: nums = [2,4,6], k = 2\nOutput: 4\nExplanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].\nIt can be proved that there are only 4 beautiful subsets in the array [2,4,6].",
            "Input: nums = [1], k = 1\nOutput: 1\nExplanation: The beautiful subset of the array nums is [1].\nIt can be proved that there is only 1 beautiful subset in the array [1]."
        ],
        "constraints": "1 <= nums.length <= 20\n1 <= nums[i], k <= 1000"
    },
    {
        "slug": "minimum-time-to-repair-cars",
        "description": "You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\nYou are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\nReturn the minimum time taken to repair all the cars.\nNote: All the mechanics can repair the cars simultaneously.",
        "examples": [
            "Input: ranks = [4,2,3,1], cars = 10\nOutput: 16\nExplanation: \n- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.\n- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.\n- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.\n- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.\u200b\u200b\u200b\u200b\u200b",
            "Input: ranks = [5,1,8], cars = 6\nOutput: 16\nExplanation: \n- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.\n- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.\u200b\u200b\u200b\u200b\u200b"
        ],
        "constraints": "1 <= ranks.length <= 105\n1 <= ranks[i] <= 100\n1 <= cars <= 106"
    },
    {
        "slug": "sort-an-array",
        "description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.",
        "examples": [
            "Input: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).",
            "Input: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique."
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104"
    },
    {
        "slug": "count-servers-that-communicate",
        "description": "You are given a map of a server center, represented as a m * n integer matrix\u00a0grid, where 1 means that on that cell there is a server and 0 means that it is no server. Two servers are said to communicate if they are on the same row or on the same column.\n\nReturn the number of servers\u00a0that communicate with any other server.",
        "examples": [
            "Input: grid = [[1,0],[0,1]]\nOutput: 0\nExplanation:\u00a0No servers can communicate with others.",
            "Input: grid = [[1,0],[1,1]]\nOutput: 3\nExplanation:\u00a0All three servers can communicate with at least one other server.",
            "Input: grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]\nOutput: 4\nExplanation:\u00a0The two servers in the first row can communicate with each other. The two servers in the third column can communicate with each other. The server at right bottom corner can't communicate with any other server."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m <= 250\n1 <= n <= 250\ngrid[i][j] == 0 or 1"
    },
    {
        "slug": "find-all-numbers-disappeared-in-an-array",
        "description": "Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.",
        "examples": [
            "Input: nums = [4,3,2,7,8,2,3,1]\nOutput: [5,6]",
            "Input: nums = [1,1]\nOutput: [2]"
        ],
        "constraints": "n == nums.length\n1 <= n <= 105\n1 <= nums[i] <= n"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "description": "You are given a 0-indexed m x n binary matrix matrix and an integer numSelect, which denotes the number of distinct columns you must select from matrix.\nLet us consider s = {c1, c2, ...., cnumSelect} as the set of columns selected by you. A row row is covered by s if:\n\nFor each cell matrix[row][col] (0 <= col <= n - 1) where matrix[row][col] == 1, col is present in s or,\nNo cell in row has a value of 1.\n\nYou need to choose numSelect columns such that the number of rows that are covered is maximized.\nReturn the maximum number of rows that can be covered by a set of numSelect columns.",
        "examples": [
            "Input: matrix = [[0,0,0],[1,0,1],[0,1,1],[0,0,1]], numSelect = 2\nOutput: 3\nExplanation: One possible way to cover 3 rows is shown in the diagram above.\nWe choose s = {0, 2}.\n- Row 0 is covered because it has no occurrences of 1.\n- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.\n- Row 2 is not covered because matrix[2][1] == 1 but 1 is not present in s.\n- Row 3 is covered because matrix[2][2] == 1 and 2 is present in s.\nThus, we can cover three rows.\nNote that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.",
            "Input: matrix = [[1],[0]], numSelect = 1\nOutput: 2\nExplanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.\nTherefore, we return 2."
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 12\nmatrix[i][j] is either 0 or 1.\n1 <= numSelect\u00a0<= n"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "description": "Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n\n1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n\nNotice that there could be some signs on the cells of the grid that point outside the grid.\nYou will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.\nYou can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\nReturn the minimum cost to make the grid have at least one valid path.",
        "examples": [
            "Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\nOutput: 3\nExplanation: You will start at point (0, 0).\nThe path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\nThe total cost = 3.",
            "Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\nOutput: 0\nExplanation: You can follow the path from (0, 0) to (2, 2).",
            "Input: grid = [[1,2],[4,3]]\nOutput: 1"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n1 <= grid[i][j] <= 4"
    },
    {
        "slug": "special-binary-string",
        "description": "Special binary strings are binary strings with the following two properties:\n\nThe number of 0's is equal to the number of 1's.\nEvery prefix of the binary string has at least as many 1's as 0's.\n\nYou are given a special binary string s.\nA move consists of choosing two consecutive, non-empty, special substrings of s, and swapping them. Two strings are consecutive if the last character of the first string is exactly one index before the first character of the second string.\nReturn the lexicographically largest resulting string possible after applying the mentioned operations on the string.",
        "examples": [
            "Input: s = \"11011000\"\nOutput: \"11100100\"\nExplanation: The strings \"10\" [occuring at s[1]] and \"1100\" [at s[3]] are swapped.\nThis is the lexicographically largest string possible after some number of swaps.",
            "Input: s = \"10\"\nOutput: \"10\""
        ],
        "constraints": "1 <= s.length <= 50\ns[i] is either '0' or '1'.\ns is a special binary string."
    },
    {
        "slug": "minimum-sideway-jumps",
        "description": "There is a 3 lane road of length n that consists of n + 1 points labeled from 0 to n. A frog starts at point 0 in the second lane and wants to jump to point n. However, there could be obstacles along the way.\nYou are given an array obstacles of length n + 1 where each obstacles[i] (ranging from 0 to 3) describes an obstacle on the lane obstacles[i] at point i. If obstacles[i] == 0, there are no obstacles at point i. There will be at most one obstacle in the 3 lanes at each point.\n\nFor example, if obstacles[2] == 1, then there is an obstacle on lane 1 at point 2.\n\nThe frog can only travel from point i to point i + 1 on the same lane if there is not an obstacle on the lane at point i + 1. To avoid obstacles, the frog can also perform a side jump to jump to another lane (even if they are not adjacent) at the same point if there is no obstacle on the new lane.\n\nFor example, the frog can jump from lane 3 at point 3 to lane 1 at point 3.\n\nReturn the minimum number of side jumps the frog needs to reach any lane at point n starting from lane 2 at point 0.\nNote: There will be no obstacles on points 0 and n.",
        "examples": [
            "Input: obstacles = [0,1,2,3,0]\nOutput: 2 \nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps (red arrows).\nNote that the frog can jump over obstacles only when making side jumps (as shown at point 2).",
            "Input: obstacles = [0,1,1,3,3,0]\nOutput: 0\nExplanation: There are no obstacles on lane 2. No side jumps are required.",
            "Input: obstacles = [0,2,1,0,3,0]\nOutput: 2\nExplanation: The optimal solution is shown by the arrows above. There are 2 side jumps."
        ],
        "constraints": "obstacles.length == n + 1\n1 <= n <= 5 * 105\n0 <= obstacles[i] <= 3\nobstacles[0] == obstacles[n] == 0"
    },
    {
        "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "description": "No-Zero integer is a positive integer that does not contain any 0 in its decimal representation.\nGiven an integer n, return a list of two integers [a, b] where:\n\na and b are No-Zero integers.\na + b = n\n\nThe test cases are generated so that there is at least one valid solution. If there are many valid solutions, you can return any of them.",
        "examples": [
            "Input: n = 2\nOutput: [1,1]\nExplanation: Let a = 1 and b = 1.\nBoth a and b are no-zero integers, and a + b = 2 = n.",
            "Input: n = 11\nOutput: [2,9]\nExplanation: Let a = 2 and b = 9.\nBoth a and b are no-zero integers, and a + b = 9 = n.\nNote that there are other valid answers as [8, 3] that can be accepted."
        ],
        "constraints": "2 <= n <= 104"
    },
    {
        "slug": "sort-list",
        "description": "Given the head of a linked list, return the list after sorting it in ascending order.",
        "examples": [
            "Input: head = [4,2,1,3]\nOutput: [1,2,3,4]",
            "Input: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]",
            "Input: head = []\nOutput: []"
        ],
        "constraints": "The number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105"
    },
    {
        "slug": "flip-binary-tree-to-match-preorder-traversal",
        "description": "You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal of the binary tree.\nAny node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\nFlip the smallest number of nodes so that the pre-order traversal of the tree matches voyage.\nReturn a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].",
        "examples": [
            "Input: root = [1,2], voyage = [2,1]\nOutput: [-1]\nExplanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage.",
            "Input: root = [1,2,3], voyage = [1,3,2]\nOutput: [1]\nExplanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.",
            "Input: root = [1,2,3], voyage = [1,2,3]\nOutput: []\nExplanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped."
        ],
        "constraints": "The number of nodes in the tree is n.\nn == voyage.length\n1 <= n <= 100\n1 <= Node.val, voyage[i] <= n\nAll the values in the tree are unique.\nAll the values in voyage are unique."
    },
    {
        "slug": "minimum-impossible-or",
        "description": "You are given a 0-indexed\u00a0integer array nums.\nWe say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.\nReturn the minimum positive non-zero integer\u00a0that is not expressible from nums.",
        "examples": [
            "Input: nums = [2,1]\nOutput: 4\nExplanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.",
            "Input: nums = [5,3,2]\nOutput: 1\nExplanation: We can show that 1 is the smallest number that is not expressible."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109"
    },
    {
        "slug": "maximum-frequency-stack",
        "description": "Design a stack-like data structure to push elements to the stack and pop the most frequent element from the stack.\nImplement the FreqStack class:\n\nFreqStack() constructs an empty frequency stack.\nvoid push(int val) pushes an integer val onto the top of the stack.\nint pop() removes and returns the most frequent element in the stack.\n\t\nIf there is a tie for the most frequent element, the element closest to the stack's top is removed and returned.",
        "examples": [
            "Input\n[\"FreqStack\", \"push\", \"push\", \"push\", \"push\", \"push\", \"push\", \"pop\", \"pop\", \"pop\", \"pop\"]\n[[], [5], [7], [5], [7], [4], [5], [], [], [], []]\nOutput\n[null, null, null, null, null, null, null, 5, 7, 5, 4]\n\nExplanation\nFreqStack freqStack = new FreqStack();\nfreqStack.push(5); // The stack is [5]\nfreqStack.push(7); // The stack is [5,7]\nfreqStack.push(5); // The stack is [5,7,5]\nfreqStack.push(7); // The stack is [5,7,5,7]\nfreqStack.push(4); // The stack is [5,7,5,7,4]\nfreqStack.push(5); // The stack is [5,7,5,7,4,5]\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,5,7,4].\nfreqStack.pop();   // return 7, as 5 and 7 is the most frequent, but 7 is closest to the top. The stack becomes [5,7,5,4].\nfreqStack.pop();   // return 5, as 5 is the most frequent. The stack becomes [5,7,4].\nfreqStack.pop();   // return 4, as 4, 5 and 7 is the most frequent, but 4 is closest to the top. The stack becomes [5,7]."
        ],
        "constraints": "0 <= val <= 109\nAt most 2 * 104 calls will be made to push and pop.\nIt is guaranteed that there will be at least one element in the stack before calling pop."
    },
    {
        "slug": "transpose-matrix",
        "description": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.",
        "examples": [
            "Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]",
            "Input: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]"
        ],
        "constraints": "m == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n-109 <= matrix[i][j] <= 109"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram",
        "description": "You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.\nReturn the minimum number of steps to make t an anagram of s.\nAn Anagram of a string is a string that contains the same characters with a different (or the same) ordering.",
        "examples": [
            "Input: s = \"bab\", t = \"aba\"\nOutput: 1\nExplanation: Replace the first 'a' in t with b, t = \"bba\" which is anagram of s.",
            "Input: s = \"leetcode\", t = \"practice\"\nOutput: 5\nExplanation: Replace 'p', 'r', 'a', 'i' and 'c' from t with proper characters to make t anagram of s.",
            "Input: s = \"anagram\", t = \"mangaar\"\nOutput: 0\nExplanation: \"anagram\" and \"mangaar\" are anagrams."
        ],
        "constraints": "1 <= s.length <= 5 * 104\ns.length == t.length\ns and t consist of lowercase English letters only."
    },
    {
        "slug": "unique-binary-search-trees",
        "description": "Given an integer n, return the number of structurally unique BST's (binary search trees) which has exactly n nodes of unique values from 1 to n.",
        "examples": [
            "Input: n = 3\nOutput: 5",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 19"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "description": "You are given an array nums of non-negative integers. nums is considered special if there exists a number x such that there are exactly x numbers in nums that are greater than or equal to x.\nNotice that x does not have to be an element in nums.\nReturn x if the array is special, otherwise, return -1. It can be proven that if nums is special, the value for x is unique.",
        "examples": [
            "Input: nums = [3,5]\nOutput: 2\nExplanation: There are 2 values (3 and 5) that are greater than or equal to 2.",
            "Input: nums = [0,0]\nOutput: -1\nExplanation: No numbers fit the criteria for x.\nIf x = 0, there should be 0 numbers >= x, but there are 2.\nIf x = 1, there should be 1 number >= x, but there are 0.\nIf x = 2, there should be 2 numbers >= x, but there are 0.\nx cannot be greater since there are only 2 numbers in nums.",
            "Input: nums = [0,4,3,0,4]\nOutput: 3\nExplanation: There are 3 values that are greater than or equal to 3."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 1000"
    },
    {
        "slug": "reverse-pairs",
        "description": "Given an integer array nums, return the number of reverse pairs in the array.\nA reverse pair is a pair (i, j) where:\n\n0 <= i < j < nums.length and\nnums[i] > 2 * nums[j].",
        "examples": [
            "Input: nums = [1,3,2,3,1]\nOutput: 2\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 3, nums[4] = 1, 3 > 2 * 1",
            "Input: nums = [2,4,3,5,1]\nOutput: 3\nExplanation: The reverse pairs are:\n(1, 4) --> nums[1] = 4, nums[4] = 1, 4 > 2 * 1\n(2, 4) --> nums[2] = 3, nums[4] = 1, 3 > 2 * 1\n(3, 4) --> nums[3] = 5, nums[4] = 1, 5 > 2 * 1"
        ],
        "constraints": "1 <= nums.length <= 5 * 104\n-231 <= nums[i] <= 231 - 1"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "description": "A 0-indexed array derived with length n is derived by computing the bitwise XOR\u00a0(\u2295) of adjacent values in a binary array original of length n.\nSpecifically, for each index i in the range [0, n - 1]:\n\nIf i = n - 1, then derived[i] = original[i] \u2295 original[0].\nOtherwise, derived[i] = original[i] \u2295 original[i + 1].\n\nGiven an array derived, your task is to determine whether there exists a valid binary array original that could have formed derived.\nReturn true if such an array exists or false otherwise.\n\nA binary array is an array containing only 0's and 1's",
        "examples": [
            "Input: derived = [1,1,0]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1,0].\nderived[0] = original[0] \u2295 original[1] = 0 \u2295 1 = 1 \nderived[1] = original[1] \u2295 original[2] = 1 \u2295 0 = 1\nderived[2] = original[2] \u2295 original[0] = 0 \u2295 0 = 0",
            "Input: derived = [1,1]\nOutput: true\nExplanation: A valid original array that gives derived is [0,1].\nderived[0] = original[0] \u2295 original[1] = 1\nderived[1] = original[1] \u2295 original[0] = 1",
            "Input: derived = [1,0]\nOutput: false\nExplanation: There is no valid original array that gives derived."
        ],
        "constraints": "n == derived.length\n1 <= n\u00a0<= 105\nThe values in derived\u00a0are either 0's or 1's"
    },
    {
        "slug": "flip-string-to-monotone-increasing",
        "description": "A binary string is monotone increasing if it consists of some number of 0's (possibly none), followed by some number of 1's (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.",
        "examples": [
            "Input: s = \"00110\"\nOutput: 1\nExplanation: We flip the last digit to get 00111.",
            "Input: s = \"010110\"\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.",
            "Input: s = \"00011000\"\nOutput: 2\nExplanation: We flip to get 00000000."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is either '0' or '1'."
    },
    {
        "slug": "greatest-common-divisor-of-strings",
        "description": "For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.",
        "examples": [
            "Input: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"",
            "Input: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"",
            "Input: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\""
        ],
        "constraints": "1 <= str1.length, str2.length <= 1000\nstr1 and str2 consist of English uppercase letters."
    },
    {
        "slug": "minimum-cost-for-tickets",
        "description": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\na 1-day pass is sold for costs[0] dollars,\na 7-day pass is sold for costs[1] dollars, and\na 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\nFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.",
        "examples": [
            "Input: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.",
            "Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel."
        ],
        "constraints": "1 <= days.length <= 365\n1 <= days[i] <= 365\ndays is in strictly increasing order.\ncosts.length == 3\n1 <= costs[i] <= 1000"
    },
    {
        "slug": "maximum-number-of-pairs-in-array",
        "description": "You are given a 0-indexed integer array nums. In one operation, you may do the following:\n\nChoose two integers in nums that are equal.\nRemove both integers from nums, forming a pair.\n\nThe operation is done on nums as many times as possible.\nReturn a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.",
        "examples": [
            "Input: nums = [1,3,2,1,3,2,2]\nOutput: [3,1]\nExplanation:\nForm a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\nForm a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\nForm a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.",
            "Input: nums = [1,1]\nOutput: [1,0]\nExplanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.",
            "Input: nums = [0]\nOutput: [0,1]\nExplanation: No pairs can be formed, and there is 1 number leftover in nums."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 100"
    },
    {
        "slug": "valid-number",
        "description": "A valid number can be split up into these components (in order):\n\nA decimal number or an integer.\n(Optional) An 'e' or 'E', followed by an integer.\n\nA decimal number can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne of the following formats:\n\t\nOne or more digits, followed by a dot '.'.\nOne or more digits, followed by a dot '.', followed by one or more digits.\nA dot '.', followed by one or more digits.\n\n\n\nAn integer can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne or more digits.\n\nFor example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\nGiven a string s, return true if s is a valid number.",
        "examples": [
            "Input: s = \"0\"\nOutput: true",
            "Input: s = \"e\"\nOutput: false",
            "Input: s = \".\"\nOutput: false"
        ],
        "constraints": "1 <= s.length <= 20\ns consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'."
    },
    {
        "slug": "max-number-of-k-sum-pairs",
        "description": "You are given an integer array nums and an integer k.\nIn one operation, you can pick two numbers from the array whose sum equals k and remove them from the array.\nReturn the maximum number of operations you can perform on the array.",
        "examples": [
            "Input: nums = [1,2,3,4], k = 5\nOutput: 2\nExplanation: Starting with nums = [1,2,3,4]:\n- Remove numbers 1 and 4, then nums = [2,3]\n- Remove numbers 2 and 3, then nums = []\nThere are no more pairs that sum up to 5, hence a total of 2 operations.",
            "Input: nums = [3,1,3,4,3], k = 6\nOutput: 1\nExplanation: Starting with nums = [3,1,3,4,3]:\n- Remove the first two 3's, then nums = [1,4,3]\nThere are no more pairs that sum up to 6, hence a total of 1 operation."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= 109"
    },
    {
        "slug": "closest-subsequence-sum",
        "description": "You are given an integer array nums and an integer goal.\nYou want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal).\nReturn the minimum possible value of abs(sum - goal).\nNote that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array.",
        "examples": [
            "Input: nums = [5,-7,3,5], goal = 6\nOutput: 0\nExplanation: Choose the whole array as a subsequence, with a sum of 6.\nThis is equal to the goal, so the absolute difference is 0.",
            "Input: nums = [7,-9,15,-2], goal = -5\nOutput: 1\nExplanation: Choose the subsequence [7,-9,-2], with a sum of -4.\nThe absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum.",
            "Input: nums = [1,2,3], goal = -7\nOutput: 7"
        ],
        "constraints": "1 <= nums.length <= 40\n-107 <= nums[i] <= 107\n-109 <= goal <= 109"
    },
    {
        "slug": "count-of-smaller-numbers-after-self",
        "description": "Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].",
        "examples": [
            "Input: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.",
            "Input: nums = [-1]\nOutput: [0]",
            "Input: nums = [-1,-1]\nOutput: [0,0]"
        ],
        "constraints": "1 <= nums.length <= 105\n-104 <= nums[i] <= 104"
    },
    {
        "slug": "maximum-number-of-non-overlapping-palindrome-substrings",
        "description": "You are given a string s and a positive integer k.\nSelect a set of non-overlapping substrings from the string s that satisfy the following conditions:\n\nThe length of each substring is at least k.\nEach substring is a palindrome.\n\nReturn the maximum number of substrings in an optimal selection.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"abaccdbbd\", k = 3\nOutput: 2\nExplanation: We can select the substrings underlined in s = \"abaccdbbd\". Both \"aba\" and \"dbbd\" are palindromes and have a length of at least k = 3.\nIt can be shown that we cannot find a selection with more than two valid substrings.",
            "Input: s = \"adbcda\", k = 2\nOutput: 0\nExplanation: There is no palindrome substring of length at least 2 in the string."
        ],
        "constraints": "1 <= k <= s.length <= 2000\ns consists of lowercase English letters."
    },
    {
        "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
        "description": "You are given a rectangular cake of size h x w and two arrays of integers horizontalCuts and verticalCuts where:\n\nhorizontalCuts[i] is the distance from the top of the rectangular cake to the ith horizontal cut and similarly, and\nverticalCuts[j] is the distance from the left of the rectangular cake to the jth vertical cut.\n\nReturn the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays horizontalCuts and verticalCuts. Since the answer can be a large number, return this modulo 109 + 7.",
        "examples": [
            "Input: h = 5, w = 4, horizontalCuts = [1,2,4], verticalCuts = [1,3]\nOutput: 4 \nExplanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.",
            "Input: h = 5, w = 4, horizontalCuts = [3,1], verticalCuts = [1]\nOutput: 6\nExplanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.",
            "Input: h = 5, w = 4, horizontalCuts = [3], verticalCuts = [3]\nOutput: 9"
        ],
        "constraints": "2 <= h, w <= 109\n1 <= horizontalCuts.length <= min(h - 1, 105)\n1 <= verticalCuts.length <= min(w - 1, 105)\n1 <= horizontalCuts[i] < h\n1 <= verticalCuts[i] < w\nAll the elements in horizontalCuts are distinct.\nAll the elements in verticalCuts are distinct."
    },
    {
        "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid",
        "description": "There is an m x n grid, where (0, 0) is the top-left cell and (m - 1, n - 1) is the bottom-right cell. You are given an integer array startPos where startPos = [startrow, startcol] indicates that initially, a robot is at the cell (startrow, startcol). You are also given an integer array homePos where homePos = [homerow, homecol] indicates that its home is at the cell (homerow, homecol).\nThe robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: rowCosts of length m and colCosts of length n.\n\nIf the robot moves up or down into a cell whose row is r, then this move costs rowCosts[r].\nIf the robot moves left or right into a cell whose column is c, then this move costs colCosts[c].\n\nReturn the minimum total cost for this robot to return home.",
        "examples": [
            "Input: startPos = [1, 0], homePos = [2, 3], rowCosts = [5, 4, 3], colCosts = [8, 2, 6, 7]\nOutput: 18\nExplanation: One optimal path is that:\nStarting from (1, 0)\n-> It goes down to (2, 0). This move costs rowCosts[2] = 3.\n-> It goes right to (2, 1). This move costs colCosts[1] = 2.\n-> It goes right to (2, 2). This move costs colCosts[2] = 6.\n-> It goes right to (2, 3). This move costs colCosts[3] = 7.\nThe total cost is 3 + 2 + 6 + 7 = 18",
            "Input: startPos = [0, 0], homePos = [0, 0], rowCosts = [5], colCosts = [26]\nOutput: 0\nExplanation: The robot is already at its home. Since no moves occur, the total cost is 0."
        ],
        "constraints": "m == rowCosts.length\nn == colCosts.length\n1 <= m, n <= 105\n0 <= rowCosts[r], colCosts[c] <= 104\nstartPos.length == 2\nhomePos.length == 2\n0 <= startrow, homerow < m\n0 <= startcol, homecol < n"
    },
    {
        "slug": "tallest-billboard",
        "description": "You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.",
        "examples": [
            "Input: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.",
            "Input: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.",
            "Input: rods = [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0."
        ],
        "constraints": "1 <= rods.length <= 20\n1 <= rods[i] <= 1000\nsum(rods[i]) <= 5000"
    },
    {
        "slug": "least-operators-to-express-number",
        "description": "Given a single positive integer x, we will write an expression of the form x (op1) x (op2) x (op3) x ... where each operator op1, op2, etc. is either addition, subtraction, multiplication, or division (+, -, *, or /). For example, with x = 3, we might write 3 * 3 / 3 + 3 - 3 which is a value of 3.\nWhen writing such an expression, we adhere to the following conventions:\n\nThe division operator (/) returns rational numbers.\nThere are no parentheses placed anywhere.\nWe use the usual order of operations: multiplication and division happen before addition and subtraction.\nIt is not allowed to use the unary negation operator (-). For example, \"x - x\" is a valid expression as it only uses subtraction, but \"-x + x\" is not because it uses negation.\n\nWe would like to write an expression with the least number of operators such that the expression equals the given target. Return the least number of operators used.",
        "examples": [
            "Input: x = 3, target = 19\nOutput: 5\nExplanation: 3 * 3 + 3 * 3 + 3 / 3.\nThe expression contains 5 operations.",
            "Input: x = 5, target = 501\nOutput: 8\nExplanation: 5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5.\nThe expression contains 8 operations.",
            "Input: x = 100, target = 100000000\nOutput: 3\nExplanation: 100 * 100 * 100 * 100.\nThe expression contains 3 operations."
        ],
        "constraints": "2 <= x <= 100\n1 <= target <= 2 * 108"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "description": "Given an array of integers arr, return true if we can partition the array into three non-empty parts with equal sums.\nFormally, we can partition the array if we can find indexes i + 1 < j with (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1])",
        "examples": [
            "Input: arr = [0,2,1,-6,6,-7,9,1,2,0,1]\nOutput: true\nExplanation: 0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1",
            "Input: arr = [0,2,1,-6,6,7,9,-1,2,0,1]\nOutput: false",
            "Input: arr = [3,3,6,5,-2,2,5,1,-9,4]\nOutput: true\nExplanation: 3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4"
        ],
        "constraints": "3 <= arr.length <= 5 * 104\n-104 <= arr[i] <= 104"
    },
    {
        "slug": "subsets",
        "description": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.",
        "examples": [
            "Input: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]",
            "Input: nums = [0]\nOutput: [[],[0]]"
        ],
        "constraints": "1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll the numbers of\u00a0nums are unique."
    },
    {
        "slug": "greatest-english-letter-in-upper-and-lower-case",
        "description": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.",
        "examples": [
            "Input: s = \"lEeTcOdE\"\nOutput: \"E\"\nExplanation:\nThe letter 'E' is the only letter to appear in both lower and upper case.",
            "Input: s = \"arRAzFif\"\nOutput: \"R\"\nExplanation:\nThe letter 'R' is the greatest letter to appear in both lower and upper case.\nNote that 'A' and 'F' also appear in both lower and upper case, but 'R' is greater than 'F' or 'A'.",
            "Input: s = \"AbCdEfGhIjK\"\nOutput: \"\"\nExplanation:\nThere is no letter that appears in both lower and upper case."
        ],
        "constraints": "1 <= s.length <= 1000\ns consists of lowercase and uppercase English letters."
    },
    {
        "slug": "closest-prime-numbers-in-range",
        "description": "Given two positive integers left and right, find the two integers num1 and num2 such that:\n\nleft <= nums1 < nums2 <= right .\nnums1 and nums2 are both prime numbers.\nnums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.",
        "examples": [
            "Input: left = 10, right = 19\nOutput: [11,13]\nExplanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair.",
            "Input: left = 4, right = 6\nOutput: [-1,-1]\nExplanation: There exists only one prime number in the given range, so the conditions cannot be satisfied."
        ],
        "constraints": "1 <= left <= right <= 106"
    },
    {
        "slug": "smallest-sufficient-team",
        "description": "In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.\nConsider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n\nFor example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\n\nReturn any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\nIt is guaranteed an answer exists.",
        "examples": [
            "Input: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\nOutput: [0,2]",
            "Input: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\nOutput: [1,2]"
        ],
        "constraints": "1 <= req_skills.length <= 16\n1 <= req_skills[i].length <= 16\nreq_skills[i] consists of lowercase English letters.\nAll the strings of req_skills are unique.\n1 <= people.length <= 60\n0 <= people[i].length <= 16\n1 <= people[i][j].length <= 16\npeople[i][j] consists of lowercase English letters.\nAll the strings of people[i] are unique.\nEvery skill in people[i] is a skill in req_skills.\nIt is guaranteed a sufficient team exists."
    },
    {
        "slug": "first-letter-to-appear-twice",
        "description": "Given a string s consisting of lowercase English letters, return the first letter to appear twice.\nNote:\n\nA letter a appears twice before another letter b if the second occurrence of a is before the second occurrence of b.\ns will contain at least one letter that appears twice.",
        "examples": [
            "Input: s = \"abccbaacz\"\nOutput: \"c\"\nExplanation:\nThe letter 'a' appears on the indexes 0, 5 and 6.\nThe letter 'b' appears on the indexes 1 and 4.\nThe letter 'c' appears on the indexes 2, 3 and 7.\nThe letter 'z' appears on the index 8.\nThe letter 'c' is the first letter to appear twice, because out of all the letters the index of its second occurrence is the smallest.",
            "Input: s = \"abcdd\"\nOutput: \"d\"\nExplanation:\nThe only letter that appears twice is 'd' so we return 'd'."
        ],
        "constraints": "2 <= s.length <= 100\ns consists of lowercase English letters.\ns has at least one repeated letter."
    },
    {
        "slug": "implement-stack-using-queues",
        "description": "Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\nImplement the MyStack class:\n\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\n\nNotes:\n\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.",
        "examples": [
            "Input\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False"
        ],
        "constraints": "1 <= x <= 9\nAt most 100 calls will be made to push, pop, top, and empty.\nAll the calls to pop and top are valid.\n\n\u00a0\nFollow-up: Can you implement the stack using only one queue?"
    },
    {
        "slug": "find-the-longest-valid-obstacle-course-at-each-position",
        "description": "You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle.\nFor every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that:\n\nYou choose any number of obstacles between 0 and i inclusive.\nYou must include the ith obstacle in the course.\nYou must put the chosen obstacles in the same order as they appear in obstacles.\nEvery obstacle (except the first) is taller than or the same height as the obstacle immediately before it.\n\nReturn an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above.",
        "examples": [
            "Input: obstacles = [1,2,3,2]\nOutput: [1,2,3,3]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [1], [1] has length 1.\n- i = 1: [1,2], [1,2] has length 2.\n- i = 2: [1,2,3], [1,2,3] has length 3.\n- i = 3: [1,2,3,2], [1,2,2] has length 3.",
            "Input: obstacles = [2,2,1]\nOutput: [1,2,1]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [2], [2] has length 1.\n- i = 1: [2,2], [2,2] has length 2.\n- i = 2: [2,2,1], [1] has length 1.",
            "Input: obstacles = [3,1,5,6,4,2]\nOutput: [1,1,2,3,2,2]\nExplanation: The longest valid obstacle course at each position is:\n- i = 0: [3], [3] has length 1.\n- i = 1: [3,1], [1] has length 1.\n- i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid.\n- i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid.\n- i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid.\n- i = 5: [3,1,5,6,4,2], [1,2] has length 2."
        ],
        "constraints": "n == obstacles.length\n1 <= n <= 105\n1 <= obstacles[i] <= 107"
    },
    {
        "slug": "count-elements-with-strictly-smaller-and-greater-elements",
        "description": "Given an integer array nums, return the number of elements that have both a strictly smaller and a strictly greater element appear in nums.",
        "examples": [
            "Input: nums = [11,7,2,15]\nOutput: 2\nExplanation: The element 7 has the element 2 strictly smaller than it and the element 11 strictly greater than it.\nElement 11 has element 7 strictly smaller than it and element 15 strictly greater than it.\nIn total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums.",
            "Input: nums = [-3,3,3,90]\nOutput: 2\nExplanation: The element 3 has the element -3 strictly smaller than it and the element 90 strictly greater than it.\nSince there are two elements with the value 3, in total there are 2 elements having both a strictly smaller and a strictly greater element appear in nums."
        ],
        "constraints": "1 <= nums.length <= 100\n-105 <= nums[i] <= 105"
    },
    {
        "slug": "search-insert-position",
        "description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must\u00a0write an algorithm with\u00a0O(log n) runtime complexity.",
        "examples": [
            "Input: nums = [1,3,5,6], target = 5\nOutput: 2",
            "Input: nums = [1,3,5,6], target = 2\nOutput: 1",
            "Input: nums = [1,3,5,6], target = 7\nOutput: 4"
        ],
        "constraints": "1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104"
    },
    {
        "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "description": "Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.",
        "examples": [
            "Input: nums = [8,2,4,7], limit = 4\nOutput: 2 \nExplanation: All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 <= 4.\n[8,2] with maximum absolute diff |8-2| = 6 > 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 > 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.\n[2] with maximum absolute diff |2-2| = 0 <= 4.\n[2,4] with maximum absolute diff |2-4| = 2 <= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 > 4.\n[4] with maximum absolute diff |4-4| = 0 <= 4.\n[4,7] with maximum absolute diff |4-7| = 3 <= 4.\n[7] with maximum absolute diff |7-7| = 0 <= 4. \nTherefore, the size of the longest subarray is 2.",
            "Input: nums = [10,1,2,4,7,2], limit = 5\nOutput: 4 \nExplanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.",
            "Input: nums = [4,2,2,2,4,4,2,2], limit = 0\nOutput: 3"
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= limit <= 109"
    },
    {
        "slug": "path-with-maximum-probability",
        "description": "You are given an undirected weighted graph of\u00a0n\u00a0nodes (0-indexed), represented by an edge list where\u00a0edges[i] = [a, b]\u00a0is an undirected edge connecting the nodes\u00a0a\u00a0and\u00a0b\u00a0with a probability of success of traversing that edge\u00a0succProb[i].\nGiven two nodes\u00a0start\u00a0and\u00a0end, find the path with the maximum probability of success to go from\u00a0start\u00a0to\u00a0end\u00a0and return its success probability.\nIf there is no path from\u00a0start\u00a0to\u00a0end, return\u00a00. Your answer will be accepted if it differs from the correct answer by at most 1e-5.",
        "examples": [
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation:\u00a0There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.",
            "Input: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000",
            "Input: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation:\u00a0There is no path between 0 and 2."
        ],
        "constraints": "2 <= n <= 10^4\n0 <= start, end < n\nstart != end\n0 <= a, b < n\na != b\n0 <= succProb.length == edges.length <= 2*10^4\n0 <= succProb[i] <= 1\nThere is at most one edge between every two nodes."
    },
    {
        "slug": "maximum-value-of-a-string-in-an-array",
        "description": "The value of an alphanumeric string can be defined as:\n\nThe numeric representation of the string in base 10, if it comprises of digits only.\nThe length of the string, otherwise.\n\nGiven an array strs of alphanumeric strings, return the maximum value of any string in strs.",
        "examples": [
            "Input: strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\nOutput: 5\nExplanation: \n- \"alic3\" consists of both letters and digits, so its value is its length, i.e. 5.\n- \"bob\" consists only of letters, so its value is also its length, i.e. 3.\n- \"3\" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n- \"4\" also consists only of digits, so its value is 4.\n- \"00000\" consists only of digits, so its value is 0.\nHence, the maximum value is 5, of \"alic3\".",
            "Input: strs = [\"1\",\"01\",\"001\",\"0001\"]\nOutput: 1\nExplanation: \nEach string in the array has value 1. Hence, we return 1."
        ],
        "constraints": "1 <= strs.length <= 100\n1 <= strs[i].length <= 9\nstrs[i] consists of only lowercase English letters and digits."
    },
    {
        "slug": "count-all-possible-routes",
        "description": "You are given an array of distinct positive integers locations where locations[i] represents the position of city i. You are also given integers start, finish and fuel representing the starting city, ending city, and the initial amount of fuel you have, respectively.\nAt each step, if you are at city i, you can pick any city j such that j != i and 0 <= j < locations.length and move to city j. Moving from city i to city j reduces the amount of fuel you have by |locations[i] - locations[j]|. Please notice that |x| denotes the absolute value of x.\nNotice that fuel cannot become negative at any point in time, and that you are allowed to visit any city more than once (including start and finish).\nReturn the count of all possible routes from start to finish. Since the answer may be too large, return it modulo 109 + 7.",
        "examples": [
            "Input: locations = [2,3,6,8,4], start = 1, finish = 3, fuel = 5\nOutput: 4\nExplanation: The following are all possible routes, each uses 5 units of fuel:\n1 -> 3\n1 -> 2 -> 3\n1 -> 4 -> 3\n1 -> 4 -> 2 -> 3",
            "Input: locations = [4,3,1], start = 1, finish = 0, fuel = 6\nOutput: 5\nExplanation: The following are all possible routes:\n1 -> 0, used fuel = 1\n1 -> 2 -> 0, used fuel = 5\n1 -> 2 -> 1 -> 0, used fuel = 5\n1 -> 0 -> 1 -> 0, used fuel = 3\n1 -> 0 -> 1 -> 0 -> 1 -> 0, used fuel = 5",
            "Input: locations = [5,2,1], start = 0, finish = 2, fuel = 3\nOutput: 0\nExplanation: It is impossible to get from 0 to 2 using only 3 units of fuel since the shortest route needs 4 units of fuel."
        ],
        "constraints": "2 <= locations.length <= 100\n1 <= locations[i] <= 109\nAll integers in locations are distinct.\n0 <= start, finish < locations.length\n1 <= fuel <= 200"
    },
    {
        "slug": "minimum-operations-to-halve-array-sum",
        "description": "You are given an array nums of positive integers. In one operation, you can choose any number from nums and reduce it to exactly half the number. (Note that you may choose this reduced number in future operations.)\nReturn the minimum number of operations to reduce the sum of nums by at least half.",
        "examples": [
            "Input: nums = [5,19,8,1]\nOutput: 3\nExplanation: The initial sum of nums is equal to 5 + 19 + 8 + 1 = 33.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 19 and reduce it to 9.5.\nPick the number 9.5 and reduce it to 4.75.\nPick the number 8 and reduce it to 4.\nThe final array is [5, 4.75, 4, 1] with a total sum of 5 + 4.75 + 4 + 1 = 14.75. \nThe sum of nums has been reduced by 33 - 14.75 = 18.25, which is at least half of the initial sum, 18.25 >= 33/2 = 16.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations.",
            "Input: nums = [3,8,20]\nOutput: 3\nExplanation: The initial sum of nums is equal to 3 + 8 + 20 = 31.\nThe following is one of the ways to reduce the sum by at least half:\nPick the number 20 and reduce it to 10.\nPick the number 10 and reduce it to 5.\nPick the number 3 and reduce it to 1.5.\nThe final array is [1.5, 8, 5] with a total sum of 1.5 + 8 + 5 = 14.5. \nThe sum of nums has been reduced by 31 - 14.5 = 16.5, which is at least half of the initial sum, 16.5 >= 31/2 = 15.5.\nOverall, 3 operations were used so we return 3.\nIt can be shown that we cannot reduce the sum by at least half in less than 3 operations."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 107"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.",
        "examples": [
            "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.",
            "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.",
            "Input: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1."
        ],
        "constraints": "n == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n"
    },
    {
        "slug": "plus-one",
        "description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\nIncrement the large integer by one and return the resulting array of digits.",
        "examples": [
            "Input: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].",
            "Input: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].",
            "Input: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0]."
        ],
        "constraints": "1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's."
    },
    {
        "slug": "find-the-losers-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n1st friend receives the ball.\n\nAfter that, 1st friend passes it to the friend who is k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 2 * k steps away from them in the clockwise direction.\nAfter that, the friend who receives the ball should pass it to the friend who is 3 * k steps away from them in the clockwise direction, and so on and so forth.\n\nIn other words, on the ith turn, the friend holding the ball should pass it to the friend who is i * k steps away from them in the clockwise direction.\nThe game is finished when some friend receives the ball for the second time.\nThe losers of the game are friends who did not receive the ball in the entire game.\nGiven the number of friends, n, and an integer k, return the array answer, which contains the losers of the game in the ascending order.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: [4,5]\nExplanation: The game goes as follows:\n1) Start at 1st\u00a0friend and pass the ball to the friend who is 2 steps away from them - 3rd\u00a0friend.\n2) 3rd\u00a0friend passes the ball to the friend who is 4 steps away from them - 2nd\u00a0friend.\n3) 2nd\u00a0friend passes the ball to the friend who is 6 steps away from them  - 3rd\u00a0friend.\n4) The game ends as 3rd\u00a0friend receives the ball for the second time.",
            "Input: n = 4, k = 4\nOutput: [2,3,4]\nExplanation: The game goes as follows:\n1) Start at the 1st\u00a0friend and pass the ball to the friend who is 4 steps away from them - 1st\u00a0friend.\n2) The game ends as 1st\u00a0friend receives the ball for the second time."
        ],
        "constraints": "1 <= k <= n <= 50"
    },
    {
        "slug": "ugly-number-ii",
        "description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.",
        "examples": [
            "Input: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.",
            "Input: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5."
        ],
        "constraints": "1 <= n <= 1690"
    },
    {
        "slug": "longest-well-performing-interval",
        "description": "We are given hours, a list of the number of hours worked per day for a given employee.\nA day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.\nA well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.\nReturn the length of the longest well-performing interval.",
        "examples": [
            "Input: hours = [9,9,6,0,6,6,9]\nOutput: 3\nExplanation: The longest well-performing interval is [9,9,6].",
            "Input: hours = [6,6,6]\nOutput: 0"
        ],
        "constraints": "1 <= hours.length <= 104\n0 <= hours[i] <= 16"
    },
    {
        "slug": "add-two-numbers",
        "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum\u00a0as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.",
        "examples": [
            "Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.",
            "Input: l1 = [0], l2 = [0]\nOutput: [0]",
            "Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]"
        ],
        "constraints": "The number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros."
    },
    {
        "slug": "kth-largest-element-in-a-stream",
        "description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\n\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.",
        "examples": [
            "Input\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8"
        ],
        "constraints": "1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element."
    },
    {
        "slug": "longest-ideal-subsequence",
        "description": "You are given a string s consisting of lowercase letters and an integer k. We call a string t ideal if the following conditions are satisfied:\n\nt is a subsequence of the string s.\nThe absolute difference in the alphabet order of every two adjacent letters in t is less than or equal to k.\n\nReturn the length of the longest ideal string.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\nNote that the alphabet order is not cyclic. For example, the absolute difference in the alphabet order of 'a' and 'z' is 25, not 1.",
        "examples": [
            "Input: s = \"acfgbd\", k = 2\nOutput: 4\nExplanation: The longest ideal string is \"acbd\". The length of this string is 4, so 4 is returned.\nNote that \"acfgbd\" is not ideal because 'c' and 'f' have a difference of 3 in alphabet order.",
            "Input: s = \"abcd\", k = 3\nOutput: 4\nExplanation: The longest ideal string is \"abcd\". The length of this string is 4, so 4 is returned."
        ],
        "constraints": "1 <= s.length <= 105\n0 <= k <= 25\ns consists of lowercase English letters."
    },
    {
        "slug": "knight-probability-in-chessboard",
        "description": "On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\nReturn the probability that the knight remains on the board after it has stopped moving.",
        "examples": [
            "Input: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.",
            "Input: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000"
        ],
        "constraints": "1 <= n <= 25\n0 <= k <= 100\n0 <= row, column <= n - 1"
    },
    {
        "slug": "making-file-names-unique",
        "description": "Given an array of strings names of size n. You will create n folders in your file system such that, at the ith minute, you will create a folder with the name names[i].\nSince two files cannot have the same name, if you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\nReturn an array of strings of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.",
        "examples": [
            "Input: names = [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nOutput: [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nExplanation: Let's see how the file system creates folder names:\n\"pes\" --> not assigned before, remains \"pes\"\n\"fifa\" --> not assigned before, remains \"fifa\"\n\"gta\" --> not assigned before, remains \"gta\"\n\"pes(2019)\" --> not assigned before, remains \"pes(2019)\"",
            "Input: names = [\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\nOutput: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\nExplanation: Let's see how the file system creates folder names:\n\"gta\" --> not assigned before, remains \"gta\"\n\"gta(1)\" --> not assigned before, remains \"gta(1)\"\n\"gta\" --> the name is reserved, system adds (k), since \"gta(1)\" is also reserved, systems put k = 2. it becomes \"gta(2)\"\n\"avalon\" --> not assigned before, remains \"avalon\"",
            "Input: names = [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\nOutput: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\nExplanation: When the last folder is created, the smallest positive valid k is 4, and it becomes \"onepiece(4)\"."
        ],
        "constraints": "1 <= names.length <= 5 * 104\n1 <= names[i].length <= 20\nnames[i] consists of lowercase English letters, digits, and/or round brackets."
    },
    {
        "slug": "print-words-vertically",
        "description": "Given a string s.\u00a0Return\u00a0all the words vertically in the same order in which they appear in s.\r\nWords are returned as a list of strings, complete with\u00a0spaces when is necessary. (Trailing spaces are not allowed).\r\nEach word would be put on only one column and that in one column there will be only one word.",
        "examples": [
            "Input: s = \"HOW ARE YOU\"\r\nOutput: [\"HAY\",\"ORO\",\"WEU\"]\r\nExplanation: Each word is printed vertically. \r\n \"HAY\"\r\n\u00a0\"ORO\"\r\n\u00a0\"WEU\"",
            "Input: s = \"TO BE OR NOT TO BE\"\r\nOutput: [\"TBONTB\",\"OEROOE\",\"   T\"]\r\nExplanation: Trailing spaces is not allowed. \r\n\"TBONTB\"\r\n\"OEROOE\"\r\n\"   T\"",
            "Input: s = \"CONTEST IS COMING\"\r\nOutput: [\"CIC\",\"OSO\",\"N M\",\"T I\",\"E N\",\"S G\",\"T\"]"
        ],
        "constraints": "1 <= s.length <= 200\ns\u00a0contains only upper case English letters.\nIt's guaranteed that there is only one\u00a0space between 2 words."
    },
    {
        "slug": "range-sum-of-bst",
        "description": "Given the root node of a binary search tree and two integers low and high, return the sum of values of all nodes with a value in the inclusive range [low, high].",
        "examples": [
            "Input: root = [10,5,15,3,7,null,18], low = 7, high = 15\nOutput: 32\nExplanation: Nodes 7, 10, and 15 are in the range [7, 15]. 7 + 10 + 15 = 32.",
            "Input: root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10\nOutput: 23\nExplanation: Nodes 6, 7, and 10 are in the range [6, 10]. 6 + 7 + 10 = 23."
        ],
        "constraints": "The number of nodes in the tree is in the range [1, 2 * 104].\n1 <= Node.val <= 105\n1 <= low <= high <= 105\nAll Node.val are unique."
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "description": "Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\nA string is palindromic if it reads the same forward and backward.",
        "examples": [
            "Input: words = [\"abc\",\"car\",\"ada\",\"racecar\",\"cool\"]\nOutput: \"ada\"\nExplanation: The first string that is palindromic is \"ada\".\nNote that \"racecar\" is also palindromic, but it is not the first.",
            "Input: words = [\"notapalindrome\",\"racecar\"]\nOutput: \"racecar\"\nExplanation: The first and only string that is palindromic is \"racecar\".",
            "Input: words = [\"def\",\"ghi\"]\nOutput: \"\"\nExplanation: There are no palindromic strings, so the empty string is returned."
        ],
        "constraints": "1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consists only of lowercase English letters."
    },
    {
        "slug": "reach-a-number",
        "description": "You are standing at position 0 on an infinite number line. There is a destination at position target.\nYou can make some number of moves numMoves so that:\n\nOn each move, you can either go left or right.\nDuring the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\n\nGiven the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.",
        "examples": [
            "Input: target = 2\nOutput: 3\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).",
            "Input: target = 3\nOutput: 2\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps)."
        ],
        "constraints": "-109 <= target <= 109\ntarget != 0"
    },
    {
        "slug": "percentage-of-letter-in-string",
        "description": "Given a string s and a character letter, return the percentage of characters in s that equal letter rounded down to the nearest whole percent.",
        "examples": [
            "Input: s = \"foobar\", letter = \"o\"\nOutput: 33\nExplanation:\nThe percentage of characters in s that equal the letter 'o' is 2 / 6 * 100% = 33% when rounded down, so we return 33.",
            "Input: s = \"jjjj\", letter = \"k\"\nOutput: 0\nExplanation:\nThe percentage of characters in s that equal the letter 'k' is 0%, so we return 0."
        ],
        "constraints": "1 <= s.length <= 100\ns consists of lowercase English letters.\nletter is a lowercase English letter."
    },
    {
        "slug": "lru-cache",
        "description": "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\n\nThe functions get and put must each run in O(1) average time complexity.",
        "examples": [
            "Input\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4"
        ],
        "constraints": "1 <= capacity <= 3000\n0 <= key <= 104\n0 <= value <= 105\nAt most 2 * 105 calls will be made to get and put."
    },
    {
        "slug": "form-smallest-number-from-two-digit-arrays",
        "description": "Given two arrays of unique digits nums1 and nums2, return the smallest number that contains at least one digit from each array.",
        "examples": [
            "Input: nums1 = [4,1,3], nums2 = [5,7]\nOutput: 15\nExplanation: The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.",
            "Input: nums1 = [3,5,2,6], nums2 = [3,1,7]\nOutput: 3\nExplanation: The number 3 contains the digit 3 which exists in both arrays."
        ],
        "constraints": "1 <= nums1.length, nums2.length <= 9\n1 <= nums1[i], nums2[i] <= 9\nAll digits in each array are unique."
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "description": "A critical point in a linked list is defined as either a local maxima or a local minima.\nA node is a local maxima if the current node has a value strictly greater than the previous node and the next node.\nA node is a local minima if the current node has a value strictly smaller than the previous node and the next node.\nNote that a node can only be a local maxima/minima if there exists both a previous node and a next node.\nGiven a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any\u00a0two distinct critical points and maxDistance is the maximum distance between any\u00a0two distinct critical points. If there are fewer than two critical points, return [-1, -1].",
        "examples": [
            "Input: head = [3,1]\nOutput: [-1,-1]\nExplanation: There are no critical points in [3,1].",
            "Input: head = [5,3,1,2,5,1,2]\nOutput: [1,3]\nExplanation: There are three critical points:\n- [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2.\n- [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1.\n- [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2.\nThe minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.\nThe maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.",
            "Input: head = [1,3,2,2,3,2,2,2,7]\nOutput: [3,3]\nExplanation: There are two critical points:\n- [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2.\n- [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2.\nBoth the minimum and maximum distances are between the second and the fifth node.\nThus, minDistance and maxDistance is 5 - 2 = 3.\nNote that the last node is not considered a local maxima because it does not have a next node."
        ],
        "constraints": "The number of nodes in the list is in the range [2, 105].\n1 <= Node.val <= 105"
    },
    {
        "slug": "minimize-malware-spread",
        "description": "You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\nNote that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.",
        "examples": [
            "Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0",
            "Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0",
            "Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1"
        ],
        "constraints": "n == graph.length\nn == graph[i].length\n2 <= n <= 300\ngraph[i][j] is 0 or 1.\ngraph[i][j] == graph[j][i]\ngraph[i][i] == 1\n1 <= initial.length <= n\n0 <= initial[i] <= n - 1\nAll the integers in initial are unique."
    },
    {
        "slug": "merge-two-2d-arrays-by-summing-values",
        "description": "You are given two 2D integer arrays nums1 and nums2.\n\nnums1[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\nnums2[i] = [idi, vali]\u00a0indicate that the number with the id idi has a value equal to vali.\n\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\nEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\n\nReturn the resulting array. The returned array must be sorted in ascending order by id.",
        "examples": [
            "Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.",
            "Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list."
        ],
        "constraints": "1 <= nums1.length, nums2.length <= 200\nnums1[i].length == nums2[j].length == 2\n1 <= idi, vali <= 1000\nBoth arrays contain unique ids.\nBoth arrays are in\u00a0strictly ascending order by id."
    },
    {
        "slug": "prime-arrangements",
        "description": "Return the number of permutations of 1 to n so that prime numbers are at prime indices (1-indexed.)\n(Recall that an integer\u00a0is prime if and only if it is greater than 1, and cannot be written as a product of two positive integers\u00a0both smaller than it.)\nSince the answer may be large, return the answer modulo 10^9 + 7.",
        "examples": [
            "Input: n = 5\nOutput: 12\nExplanation: For example [1,2,5,4,3] is a valid permutation, but [5,2,3,4,1] is not because the prime number 5 is at index 1.",
            "Input: n = 100\nOutput: 682289015"
        ],
        "constraints": "1 <= n <= 100"
    },
    {
        "slug": "unique-paths-iii",
        "description": "You are given an m x n integer array grid where grid[i][j] could be:\n\n1 representing the starting square. There is exactly one starting square.\n2 representing the ending square. There is exactly one ending square.\n0 representing empty squares we can walk over.\n-1 representing obstacles that we cannot walk over.\n\nReturn the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once.",
        "examples": [
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]\nOutput: 2\nExplanation: We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)",
            "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,2]]\nOutput: 4\nExplanation: We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)",
            "Input: grid = [[0,1],[2,0]]\nOutput: 0\nExplanation: There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 20\n1 <= m * n <= 20\n-1 <= grid[i][j] <= 2\nThere is exactly one starting cell and one ending cell."
    },
    {
        "slug": "loud-and-rich",
        "description": "There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.",
        "examples": [
            "Input: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.",
            "Input: richer = [], quiet = [0]\nOutput: [0]"
        ],
        "constraints": "n == quiet.length\n1 <= n <= 500\n0 <= quiet[i] < n\nAll the values of quiet are unique.\n0 <= richer.length <= n * (n - 1) / 2\n0 <= ai, bi < n\nai != bi\nAll the pairs of richer are unique.\nThe observations in richer are all logically consistent."
    },
    {
        "slug": "steps-to-make-array-non-decreasing",
        "description": "You are given a 0-indexed integer array nums. In one step, remove all elements nums[i] where nums[i - 1] > nums[i] for all 0 < i < nums.length.\nReturn the number of steps performed until nums becomes a non-decreasing array.",
        "examples": [
            "Input: nums = [5,3,4,4,7,3,6,11,8,5,11]\nOutput: 3\nExplanation: The following are the steps performed:\n- Step 1: [5,3,4,4,7,3,6,11,8,5,11] becomes [5,4,4,7,6,11,11]\n- Step 2: [5,4,4,7,6,11,11] becomes [5,4,7,11,11]\n- Step 3: [5,4,7,11,11] becomes [5,7,11,11]\n[5,7,11,11] is a non-decreasing array. Therefore, we return 3.",
            "Input: nums = [4,5,7,7,13]\nOutput: 0\nExplanation: nums is already a non-decreasing array. Therefore, we return 0."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109"
    },
    {
        "slug": "relative-ranks",
        "description": "You are given an integer array score of size n, where score[i] is the score of the ith athlete in a competition. All the scores are guaranteed to be unique.\nThe athletes are placed based on their scores, where the 1st place athlete has the highest score, the 2nd place athlete has the 2nd highest score, and so on. The placement of each athlete determines their rank:\n\nThe 1st place athlete's rank is \"Gold Medal\".\nThe 2nd place athlete's rank is \"Silver Medal\".\nThe 3rd place athlete's rank is \"Bronze Medal\".\nFor the 4th place to the nth place athlete, their rank is their placement number (i.e., the xth place athlete's rank is \"x\").\n\nReturn an array answer of size n where answer[i] is the rank of the ith athlete.",
        "examples": [
            "Input: score = [5,4,3,2,1]\nOutput: [\"Gold Medal\",\"Silver Medal\",\"Bronze Medal\",\"4\",\"5\"]\nExplanation: The placements are [1st, 2nd, 3rd, 4th, 5th].",
            "Input: score = [10,3,8,9,4]\nOutput: [\"Gold Medal\",\"5\",\"Bronze Medal\",\"Silver Medal\",\"4\"]\nExplanation: The placements are [1st, 5th, 3rd, 2nd, 4th]."
        ],
        "constraints": "n == score.length\n1 <= n <= 104\n0 <= score[i] <= 106\nAll the values in score are unique."
    },
    {
        "slug": "construct-the-longest-new-string",
        "description": "You are given three integers x, y, and z.\nYou have x strings equal to \"AA\", y strings equal to \"BB\", and z strings equal to \"AB\". You want to choose some (possibly all or none) of these strings and concactenate them in some order to form a new string. This new string must not contain \"AAA\" or \"BBB\" as a substring.\nReturn the maximum possible length of the new string.\nA substring is a contiguous non-empty sequence of characters within a string.",
        "examples": [
            "Input: x = 2, y = 5, z = 1\nOutput: 12\nExplanation: We can concactenate the strings \"BB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AB\" in that order. Then, our new string is \"BBAABBAABBAB\". \nThat string has length 12, and we can show that it is impossible to construct a string of longer length.",
            "Input: x = 3, y = 2, z = 2\nOutput: 14\nExplanation: We can concactenate the strings \"AB\", \"AB\", \"AA\", \"BB\", \"AA\", \"BB\", and \"AA\" in that order. Then, our new string is \"ABABAABBAABBAA\". \nThat string has length 14, and we can show that it is impossible to construct a string of longer length."
        ],
        "constraints": "1 <= x, y, z <= 50"
    },
    {
        "slug": "maximize-grid-happiness",
        "description": "You are given four integers, m, n, introvertsCount, and extrovertsCount. You have an m x n grid, and there are two types of people: introverts and extroverts. There are introvertsCount introverts and extrovertsCount extroverts.\nYou should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.\nThe happiness of each person is calculated as follows:\n\nIntroverts start with 120 happiness and lose 30 happiness for each neighbor (introvert or extrovert).\nExtroverts start with 40 happiness and gain 20 happiness for each neighbor (introvert or extrovert).\n\nNeighbors live in the directly adjacent cells north, east, south, and west of a person's cell.\nThe grid happiness is the sum of each person's happiness. Return the maximum possible grid happiness.",
        "examples": [
            "Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2\nOutput: 240\nExplanation: Assume the grid is 1-indexed with coordinates (row, column).\nWe can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (0 * 30) (0 neighbors) = 120\n- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\n- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 * 20) (1 neighbor) = 60\nThe grid happiness is 120 + 60 + 60 = 240.\nThe above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.",
            "Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1\nOutput: 260\nExplanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).\n- Introvert at (1,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\n- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 * 20) (2 neighbors) = 80\n- Introvert at (3,1) happiness: 120 (starting happiness) - (1 * 30) (1 neighbor) = 90\nThe grid happiness is 90 + 80 + 90 = 260.",
            "Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0\nOutput: 240"
        ],
        "constraints": "1 <= m, n <= 5\n0 <= introvertsCount, extrovertsCount <= min(m * n, 6)"
    },
    {
        "slug": "minimum-moves-to-reach-target-with-rotations",
        "description": "In an\u00a0n*n\u00a0grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at\u00a0(n-1, n-2)\u00a0and\u00a0(n-1, n-1).\nIn one move the snake can:\n\nMove one cell to the right\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell\u00a0if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it's in a horizontal position and the two cells under it are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r, c+1)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r+1, c).\n\nRotate counterclockwise\u00a0if it's in a vertical position and the two cells to its right are both empty. In that case the snake moves from\u00a0(r, c)\u00a0and\u00a0(r+1, c)\u00a0to\u00a0(r, c)\u00a0and\u00a0(r, c+1).\n\n\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return\u00a0-1.",
        "examples": [
            "Input: grid = [[0,0,0,0,0,1],\n               [1,1,0,0,1,0],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [0,0,1,0,1,0],\n\u00a0              [0,1,1,0,0,0],\n\u00a0              [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].",
            "Input: grid = [[0,0,1,1,1,1],\n\u00a0              [0,0,0,0,1,1],\n\u00a0              [1,1,0,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,1],\n\u00a0              [1,1,1,0,0,0]]\nOutput: 9"
        ],
        "constraints": "2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells."
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "description": "Given two positive integers low and high represented as strings, find the count of stepping numbers in the inclusive range [low, high].\nA stepping number is an integer such that all of its adjacent digits have an absolute difference of exactly 1.\nReturn an integer denoting the count of stepping numbers in the inclusive range [low, high]. \nSince the answer may be very large, return it modulo 109 + 7.\nNote: A stepping number should not have a leading zero.",
        "examples": [
            "Input: low = \"1\", high = \"11\"\nOutput: 10\nExplanation: The stepping numbers in the range [1,11] are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10. There are a total of 10 stepping numbers in the range. Hence, the output is 10.",
            "Input: low = \"90\", high = \"101\"\nOutput: 2\nExplanation: The stepping numbers in the range [90,101] are 98 and 101. There are a total of 2 stepping numbers in the range. Hence, the output is 2."
        ],
        "constraints": "1 <= int(low) <= int(high) < 10100\n1 <= low.length, high.length <= 100\nlow and high consist of only digits.\nlow and high don't have any leading zeros."
    },
    {
        "slug": "fruit-into-baskets",
        "description": "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\nYou only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.\nStarting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\nOnce you reach a tree with fruit that cannot fit in your baskets, you must stop.\n\nGiven the integer array fruits, return the maximum number of fruits you can pick.",
        "examples": [
            "Input: fruits = [1,2,1]\nOutput: 3\nExplanation: We can pick from all 3 trees.",
            "Input: fruits = [0,1,2,2]\nOutput: 3\nExplanation: We can pick from trees [1,2,2].\nIf we had started at the first tree, we would only pick from trees [0,1].",
            "Input: fruits = [1,2,3,2,2]\nOutput: 4\nExplanation: We can pick from trees [2,3,2,2].\nIf we had started at the first tree, we would only pick from trees [1,2]."
        ],
        "constraints": "1 <= fruits.length <= 105\n0 <= fruits[i] < fruits.length"
    },
    {
        "slug": "longest-univalue-path",
        "description": "Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.\nThe length of the path between two nodes is represented by the number of edges between them.",
        "examples": [
            "Input: root = [5,4,5,1,1,null,5]\nOutput: 2\nExplanation: The shown image shows that the longest path of the same value (i.e. 5).",
            "Input: root = [1,4,5,4,4,null,5]\nOutput: 2\nExplanation: The shown image shows that the longest path of the same value (i.e. 4)."
        ],
        "constraints": "The number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000\nThe depth of the tree will not exceed 1000."
    },
    {
        "slug": "pascals-triangle-ii",
        "description": "Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:",
        "examples": [
            "Input: rowIndex = 3\nOutput: [1,3,3,1]",
            "Input: rowIndex = 0\nOutput: [1]",
            "Input: rowIndex = 1\nOutput: [1,1]"
        ],
        "constraints": "0 <= rowIndex <= 33"
    },
    {
        "slug": "smallest-index-with-equal-value",
        "description": "Given a 0-indexed integer array nums, return the smallest index i of nums such that i mod 10 == nums[i], or -1 if such index does not exist.\nx mod y denotes the remainder when x is divided by y.",
        "examples": [
            "Input: nums = [0,1,2]\nOutput: 0\nExplanation: \ni=0: 0 mod 10 = 0 == nums[0].\ni=1: 1 mod 10 = 1 == nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\nAll indices have i mod 10 == nums[i], so we return the smallest index 0.",
            "Input: nums = [4,3,2,1]\nOutput: 2\nExplanation: \ni=0: 0 mod 10 = 0 != nums[0].\ni=1: 1 mod 10 = 1 != nums[1].\ni=2: 2 mod 10 = 2 == nums[2].\ni=3: 3 mod 10 = 3 != nums[3].\n2 is the only index which has i mod 10 == nums[i].",
            "Input: nums = [1,2,3,4,5,6,7,8,9,0]\nOutput: -1\nExplanation: No index satisfies i mod 10 == nums[i]."
        ],
        "constraints": "1 <= nums.length <= 100\n0 <= nums[i] <= 9"
    },
    {
        "slug": "divide-players-into-teams-of-equal-skill",
        "description": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.",
        "examples": [
            "Input: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.",
            "Input: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.",
            "Input: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal."
        ],
        "constraints": "2 <= skill.length <= 105\nskill.length is even.\n1 <= skill[i] <= 1000"
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.",
        "examples": [
            "Input: left = 5, right = 7\nOutput: 4",
            "Input: left = 0, right = 0\nOutput: 0",
            "Input: left = 1, right = 2147483647\nOutput: 0"
        ],
        "constraints": "0 <= left <= right <= 231 - 1"
    },
    {
        "slug": "egg-drop-with-2-eggs-and-n-floors",
        "description": "You are given two identical eggs and you have access to a building with n floors labeled from 1 to n.\nYou know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break.\nIn each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves.\nReturn the minimum number of moves that you need to determine with certainty what the value of f is.",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: We can drop the first egg from floor 1 and the second egg from floor 2.\nIf the first egg breaks, we know that f = 0.\nIf the second egg breaks but the first egg didn't, we know that f = 1.\nOtherwise, if both eggs survive, we know that f = 2.",
            "Input: n = 100\nOutput: 14\nExplanation: One optimal strategy is:\n- Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9.\n- If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14.\n- If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100.\nRegardless of the outcome, it takes at most 14 drops to determine f."
        ],
        "constraints": "1 <= n <= 1000"
    },
    {
        "slug": "valid-boomerang",
        "description": "Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\nA boomerang is a set of three points that are all distinct and not in a straight line.",
        "examples": [
            "Input: points = [[1,1],[2,3],[3,2]]\nOutput: true",
            "Input: points = [[1,1],[2,2],[3,3]]\nOutput: false"
        ],
        "constraints": "points.length == 3\npoints[i].length == 2\n0 <= xi, yi <= 100"
    },
    {
        "slug": "prime-in-diagonal",
        "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].",
        "examples": [
            "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.",
            "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
        ],
        "constraints": "1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j]\u00a0<= 4*106"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "description": "You have a water dispenser that can dispense cold, warm, and hot water. Every second, you can either fill up 2 cups with different types of water, or 1 cup of any type of water.\nYou are given a 0-indexed integer array amount of length 3 where amount[0], amount[1], and amount[2] denote the number of cold, warm, and hot water cups you need to fill respectively. Return the minimum number of seconds needed to fill up all the cups.",
        "examples": [
            "Input: amount = [1,4,2]\nOutput: 4\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup and a warm cup.\nSecond 2: Fill up a warm cup and a hot cup.\nSecond 3: Fill up a warm cup and a hot cup.\nSecond 4: Fill up a warm cup.\nIt can be proven that 4 is the minimum number of seconds needed.",
            "Input: amount = [5,4,4]\nOutput: 7\nExplanation: One way to fill up the cups is:\nSecond 1: Fill up a cold cup, and a hot cup.\nSecond 2: Fill up a cold cup, and a warm cup.\nSecond 3: Fill up a cold cup, and a warm cup.\nSecond 4: Fill up a warm cup, and a hot cup.\nSecond 5: Fill up a cold cup, and a hot cup.\nSecond 6: Fill up a cold cup, and a warm cup.\nSecond 7: Fill up a hot cup.",
            "Input: amount = [5,0,0]\nOutput: 5\nExplanation: Every second, we fill up a cold cup."
        ],
        "constraints": "amount.length == 3\n0 <= amount[i] <= 100"
    },
    {
        "slug": "rotate-array",
        "description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.",
        "examples": [
            "Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]",
            "Input: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]"
        ],
        "constraints": "1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105"
    },
    {
        "slug": "maximum-enemy-forts-that-can-be-captured",
        "description": "You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:\n\n-1 represents there is no fort at the ith position.\n0 indicates there is an enemy fort at the ith position.\n1 indicates the fort at the ith the position is under your command.\n\nNow you have decided to move your army from one of your forts at position i to an empty position j such that:\n\n0 <= i, j <= n - 1\nThe army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.\n\nWhile moving the army, all the enemy forts that come in the way are captured.\nReturn the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.",
        "examples": [
            "Input: forts = [1,0,0,-1,0,0,0,0,1]\nOutput: 4\nExplanation:\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.",
            "Input: forts = [0,0,1,-1]\nOutput: 0\nExplanation: Since no enemy fort can be captured, 0 is returned."
        ],
        "constraints": "1 <= forts.length <= 1000\n-1 <= forts[i] <= 1"
    },
    {
        "slug": "queries-on-number-of-points-inside-a-circle",
        "description": "You are given an array points where points[i] = [xi, yi] is the coordinates of the ith point on a 2D plane. Multiple points can have the same coordinates.\nYou are also given an array queries where queries[j] = [xj, yj, rj] describes a circle centered at (xj, yj) with a radius of rj.\nFor each query queries[j], compute the number of points inside the jth circle. Points on the border of the circle are considered inside.\nReturn an array answer, where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: points = [[1,3],[3,3],[5,3],[2,2]], queries = [[2,3,1],[4,3,1],[1,1,2]]\nOutput: [3,2,2]\nExplanation: The points and circles are shown above.\nqueries[0] is the green circle, queries[1] is the red circle, and queries[2] is the blue circle.",
            "Input: points = [[1,1],[2,2],[3,3],[4,4],[5,5]], queries = [[1,2,2],[2,2,2],[4,3,2],[4,3,3]]\nOutput: [2,3,2,4]\nExplanation: The points and circles are shown above.\nqueries[0] is green, queries[1] is red, queries[2] is blue, and queries[3] is purple."
        ],
        "constraints": "1 <= points.length <= 500\npoints[i].length == 2\n0 <= x\u200b\u200b\u200b\u200b\u200b\u200bi, y\u200b\u200b\u200b\u200b\u200b\u200bi <= 500\n1 <= queries.length <= 500\nqueries[j].length == 3\n0 <= xj, yj <= 500\n1 <= rj <= 500\nAll coordinates are integers."
    },
    {
        "slug": "length-of-longest-fibonacci-subsequence",
        "description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\n\nn >= 3\nxi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].",
        "examples": [
            "Input: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].",
            "Input: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."
        ],
        "constraints": "3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109"
    },
    {
        "slug": "string-to-integer-atoi",
        "description": "Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-231, 231 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -231 should be clamped to -231, and integers greater than 231 - 1 should be clamped to 231 - 1.\nReturn the integer as the final result.\n\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.",
        "examples": [
            "Input: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-231, 231 - 1], the final result is 42.",
            "Input: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-231, 231 - 1], the final result is -42.",
            "Input: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-231, 231 - 1], the final result is 4193."
        ],
        "constraints": "0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'."
    },
    {
        "slug": "spiral-matrix-ii",
        "description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.",
        "examples": [
            "Input: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]",
            "Input: n = 1\nOutput: [[1]]"
        ],
        "constraints": "1 <= n <= 20"
    },
    {
        "slug": "partition-labels",
        "description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.",
        "examples": [
            "Input: s = \"ababcbacadefegdehijhklij\"\nOutput: [9,7,8]\nExplanation:\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.",
            "Input: s = \"eccbbbbdec\"\nOutput: [10]"
        ],
        "constraints": "1 <= s.length <= 500\ns consists of lowercase English letters."
    },
    {
        "slug": "product-of-array-except-self",
        "description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in\u00a0O(n)\u00a0time and without using the division operation.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]",
            "Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]"
        ],
        "constraints": "2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    },
    {
        "slug": "maximum-number-of-removable-characters",
        "description": "You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed).\nYou want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence.\nReturn the maximum k you can choose such that p is still a subsequence of s after the removals.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.",
        "examples": [
            "Input: s = \"abcacb\", p = \"ab\", removable = [3,1,0]\nOutput: 2\nExplanation: After removing the characters at indices 3 and 1, \"abcacb\" becomes \"accb\".\n\"ab\" is a subsequence of \"accb\".\nIf we remove the characters at indices 3, 1, and 0, \"abcacb\" becomes \"ccb\", and \"ab\" is no longer a subsequence.\nHence, the maximum k is 2.",
            "Input: s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6]\nOutput: 1\nExplanation: After removing the character at index 3, \"abcbddddd\" becomes \"abcddddd\".\n\"abcd\" is a subsequence of \"abcddddd\".",
            "Input: s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4]\nOutput: 0\nExplanation: If you remove the first index in the array removable, \"abc\" is no longer a subsequence."
        ],
        "constraints": "1 <= p.length <= s.length <= 105\n0 <= removable.length < s.length\n0 <= removable[i] < s.length\np is a subsequence of s.\ns and p both consist of lowercase English letters.\nThe elements in removable are distinct."
    },
    {
        "slug": "cherry-pickup-ii",
        "description": "You are given a rows x cols matrix grid representing a field of cherries where grid[i][j] represents the number of cherries that you can collect from the (i, j) cell.\nYou have two robots that can collect cherries for you:\n\nRobot #1 is located at the top-left corner (0, 0), and\nRobot #2 is located at the top-right corner (0, cols - 1).\n\nReturn the maximum number of cherries collection using both robots by following the rules below:\n\nFrom a cell (i, j), robots can move to cell (i + 1, j - 1), (i + 1, j), or (i + 1, j + 1).\nWhen any robot passes through a cell, It picks up all cherries, and the cell becomes an empty cell.\nWhen both robots stay in the same cell, only one takes the cherries.\nBoth robots cannot move outside of the grid at any moment.\nBoth robots should reach the bottom row in grid.",
        "examples": [
            "Input: grid = [[3,1,1],[2,5,1],[1,5,5],[2,1,1]]\nOutput: 24\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (3 + 2 + 5 + 2) = 12.\nCherries taken by Robot #2, (1 + 5 + 5 + 1) = 12.\nTotal of cherries: 12 + 12 = 24.",
            "Input: grid = [[1,0,0,0,0,0,1],[2,0,0,0,0,3,0],[2,0,9,0,0,0,0],[0,3,0,5,4,0,0],[1,0,2,3,0,0,6]]\nOutput: 28\nExplanation: Path of robot #1 and #2 are described in color green and blue respectively.\nCherries taken by Robot #1, (1 + 9 + 5 + 2) = 17.\nCherries taken by Robot #2, (1 + 3 + 4 + 3) = 11.\nTotal of cherries: 17 + 11 = 28."
        ],
        "constraints": "rows == grid.length\ncols == grid[i].length\n2 <= rows, cols <= 70\n0 <= grid[i][j] <= 100"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.",
        "examples": [
            "Input: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.",
            "Input: grid = [[3,2],[1,0]]\nOutput: 0"
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100"
    },
    {
        "slug": "coin-change-ii",
        "description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the number of combinations that make up that amount. If that amount of money cannot be made up by any combination of the coins, return 0.\nYou may assume that you have an infinite number of each kind of coin.\nThe answer is guaranteed to fit into a signed 32-bit integer.",
        "examples": [
            "Input: amount = 5, coins = [1,2,5]\nOutput: 4\nExplanation: there are four ways to make up the amount:\n5=5\n5=2+2+1\n5=2+1+1+1\n5=1+1+1+1+1",
            "Input: amount = 3, coins = [2]\nOutput: 0\nExplanation: the amount of 3 cannot be made up just with coins of 2.",
            "Input: amount = 10, coins = [10]\nOutput: 1"
        ],
        "constraints": "1 <= coins.length <= 300\n1 <= coins[i] <= 5000\nAll the values of coins are unique.\n0 <= amount <= 5000"
    },
    {
        "slug": "climbing-stairs",
        "description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
        "examples": [
            "Input: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps",
            "Input: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        ],
        "constraints": "1 <= n <= 45"
    },
    {
        "slug": "mean-of-array-after-removing-some-elements",
        "description": "Given an integer array arr, return the mean of the remaining integers after removing the smallest 5% and the largest 5% of the elements.\nAnswers within 10-5 of the actual answer will be considered accepted.",
        "examples": [
            "Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\nExplanation: After erasing the minimum and the maximum values of this array, all elements are equal to 2, so the mean is 2.",
            "Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000",
            "Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778"
        ],
        "constraints": "20 <= arr.length <= 1000\narr.length is a multiple of 20.\n0 <= arr[i] <= 105"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "description": "There are some stones in different positions on the X-axis. You are given an integer array stones, the positions of the stones.\nCall a stone an endpoint stone if it has the smallest or largest position. In one move, you pick up an endpoint stone and move it to an unoccupied position so that it is no longer an endpoint stone.\n\nIn particular, if the stones are at say, stones = [1,2,5], you cannot move the endpoint stone at position 5, since moving it to any position (such as 0, or 3) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\nReturn an integer array answer of length 2 where:\n\nanswer[0] is the minimum number of moves you can play, and\nanswer[1] is the maximum number of moves you can play.",
        "examples": [
            "Input: stones = [7,4,9]\nOutput: [1,2]\nExplanation: We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.",
            "Input: stones = [6,5,4,3,10]\nOutput: [2,3]\nExplanation: We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move."
        ],
        "constraints": "3 <= stones.length <= 104\n1 <= stones[i] <= 109\nAll the values of stones are unique."
    },
    {
        "slug": "destination-city",
        "description": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.",
        "examples": [
            "Input: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\nOutput: \"Sao Paulo\" \nExplanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".",
            "Input: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\nOutput: \"A\"\nExplanation: All possible trips are:\u00a0\n\"D\" -> \"B\" -> \"C\" -> \"A\".\u00a0\n\"B\" -> \"C\" -> \"A\".\u00a0\n\"C\" -> \"A\".\u00a0\n\"A\".\u00a0\nClearly the destination city is \"A\".",
            "Input: paths = [[\"A\",\"Z\"]]\nOutput: \"Z\""
        ],
        "constraints": "1 <= paths.length <= 100\npaths[i].length == 2\n1 <= cityAi.length, cityBi.length <= 10\ncityAi != cityBi\nAll strings consist of lowercase and uppercase English letters and the space character."
    },
    {
        "slug": "perfect-rectangle",
        "description": "Given an array rectangles where rectangles[i] = [xi, yi, ai, bi] represents an axis-aligned rectangle. The bottom-left point of the rectangle is (xi, yi) and the top-right point of it is (ai, bi).\nReturn true if all the rectangles together form an exact cover of a rectangular region.",
        "examples": [
            "Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true\nExplanation: All 5 rectangles together form an exact cover of a rectangular region.",
            "Input: rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]\nOutput: false\nExplanation: Because there is a gap between the two rectangular regions.",
            "Input: rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]\nOutput: false\nExplanation: Because two of the rectangles overlap with each other."
        ],
        "constraints": "1 <= rectangles.length <= 2 * 104\nrectangles[i].length == 4\n-105 <= xi, yi, ai, bi <= 105"
    },
    {
        "slug": "the-number-of-good-subsets",
        "description": "You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers.\n\nFor example, if nums = [1, 2, 3, 4]:\n\n\t\n[2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively.\n[1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively.\n\n\n\nReturn the number of different good subsets in nums modulo 109 + 7.\nA subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.",
        "examples": [
            "Input: nums = [1,2,3,4]\nOutput: 6\nExplanation: The good subsets are:\n- [1,2]: product is 2, which is the product of distinct prime 2.\n- [1,2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [1,3]: product is 3, which is the product of distinct prime 3.\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [3]: product is 3, which is the product of distinct prime 3.",
            "Input: nums = [4,2,3,15]\nOutput: 5\nExplanation: The good subsets are:\n- [2]: product is 2, which is the product of distinct prime 2.\n- [2,3]: product is 6, which is the product of distinct primes 2 and 3.\n- [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5.\n- [3]: product is 3, which is the product of distinct prime 3.\n- [15]: product is 15, which is the product of distinct primes 3 and 5."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 30"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "description": "There are n friends that are playing a game. The friends are sitting in a circle and are numbered from 1 to n in clockwise order. More formally, moving clockwise from the ith friend brings you to the (i+1)th friend for 1 <= i < n, and moving clockwise from the nth friend brings you to the 1st friend.\nThe rules of the game are as follows:\n\nStart at the 1st friend.\nCount the next k friends in the clockwise direction including the friend you started at. The counting wraps around the circle and may count some friends more than once.\nThe last friend you counted leaves the circle and loses the game.\nIf there is still more than one friend in the circle, go back to step 2 starting from the friend immediately clockwise of the friend who just lost and repeat.\nElse, the last friend in the circle wins the game.\n\nGiven the number of friends, n, and an integer k, return the winner of the game.",
        "examples": [
            "Input: n = 5, k = 2\nOutput: 3\nExplanation: Here are the steps of the game:\n1) Start at friend 1.\n2) Count 2 friends clockwise, which are friends 1 and 2.\n3) Friend 2 leaves the circle. Next start is friend 3.\n4) Count 2 friends clockwise, which are friends 3 and 4.\n5) Friend 4 leaves the circle. Next start is friend 5.\n6) Count 2 friends clockwise, which are friends 5 and 1.\n7) Friend 1 leaves the circle. Next start is friend 3.\n8) Count 2 friends clockwise, which are friends 3 and 5.\n9) Friend 5 leaves the circle. Only friend 3 is left, so they are the winner.",
            "Input: n = 6, k = 5\nOutput: 1\nExplanation: The friends leave in this order: 5, 4, 6, 2, 3. The winner is friend 1."
        ],
        "constraints": "1 <= k <= n <= 500"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "description": "You are given a string s consisting of digits from 1 to 9 and an integer k.\nA partition of a string s is called good if:\n\nEach digit of s is part of exactly one substring.\nThe value of each substring is less than or equal to k.\n\nReturn the minimum number of substrings in a good partition of s. If no good partition of s exists, return -1.\nNote that:\n\nThe value of a string is its result when interpreted as an integer. For example, the value of \"123\" is 123 and the value of \"1\" is 1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"165462\", k = 60\nOutput: 4\nExplanation: We can partition the string into substrings \"16\", \"54\", \"6\", and \"2\". Each substring has a value less than or equal to k = 60.\nIt can be shown that we cannot partition the string into less than 4 substrings.",
            "Input: s = \"238182\", k = 5\nOutput: -1\nExplanation: There is no good partition for this string."
        ],
        "constraints": "1 <= s.length <= 105\ns[i] is a digit from '1' to '9'.\n1 <= k <= 109"
    },
    {
        "slug": "sum-of-scores-of-built-strings",
        "description": "You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si.\n\nFor example, for s = \"abaca\", s1 == \"a\", s2 == \"ca\", s3 == \"aca\", etc.\n\nThe score of si is the length of the longest common prefix between si and sn (Note that s == sn).\nGiven the final string s, return the sum of the score of every si.",
        "examples": [
            "Input: s = \"babab\"\nOutput: 9\nExplanation:\nFor s1 == \"b\", the longest common prefix is \"b\" which has a score of 1.\nFor s2 == \"ab\", there is no common prefix so the score is 0.\nFor s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3.\nFor s4 == \"abab\", there is no common prefix so the score is 0.\nFor s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5.\nThe sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9.",
            "Input: s = \"azbazbzaz\"\nOutput: 14\nExplanation: \nFor s2 == \"az\", the longest common prefix is \"az\" which has a score of 2.\nFor s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3.\nFor s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9.\nFor all other si, the score is 0.\nThe sum of the scores is 2 + 3 + 9 = 14, so we return 14."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters."
    },
    {
        "slug": "visit-array-positions-to-maximize-score",
        "description": "You are given a 0-indexed integer array nums and a positive integer x.\nYou are initially at position 0 in the array and you can visit other positions according to the following rules:\n\nIf you are currently in position i, then you can move to any position j such that i < j.\nFor each position i that you visit, you get a score of nums[i].\nIf you move from a position i to a position j and the parities of nums[i] and nums[j] differ, then you lose a score of x.\n\nReturn the maximum total score you can get.\nNote that initially you have nums[0] points.",
        "examples": [
            "Input: nums = [2,3,6,1,9,2], x = 5\nOutput: 13\nExplanation: We can visit the following positions in the array: 0 -> 2 -> 3 -> 4.\nThe corresponding values are 2, 6, 1 and 9. Since the integers 6 and 1 have different parities, the move 2 -> 3 will make you lose a score of x = 5.\nThe total score will be: 2 + 6 + 1 + 9 - 5 = 13.",
            "Input: nums = [2,4,6,8], x = 3\nOutput: 20\nExplanation: All the integers in the array have the same parities, so we can visit all of them without losing any score.\nThe total score is: 2 + 4 + 6 + 8 = 20."
        ],
        "constraints": "2 <= nums.length <= 105\n1 <= nums[i], x <= 106"
    },
    {
        "slug": "count-number-of-possible-root-nodes",
        "description": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.",
        "examples": [
            "Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.",
            "Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess."
        ],
        "constraints": "edges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "description": "You are given a tree with n nodes numbered from 0 to n - 1 in the form of a parent array parent where parent[i] is the parent of ith node. The root of the tree is node 0. Find the kth ancestor of a given node.\nThe kth ancestor of a tree node is the kth node in the path from that node to the root node.\nImplement the TreeAncestor class:\n\nTreeAncestor(int n, int[] parent) Initializes the object with the number of nodes in the tree and the parent array.\nint getKthAncestor(int node, int k) return the kth ancestor of the given node node. If there is no such ancestor, return -1.",
        "examples": [
            "Input\n[\"TreeAncestor\", \"getKthAncestor\", \"getKthAncestor\", \"getKthAncestor\"]\n[[7, [-1, 0, 0, 1, 1, 2, 2]], [3, 1], [5, 2], [6, 3]]\nOutput\n[null, 1, 0, -1]\n\nExplanation\nTreeAncestor treeAncestor = new TreeAncestor(7, [-1, 0, 0, 1, 1, 2, 2]);\ntreeAncestor.getKthAncestor(3, 1); // returns 1 which is the parent of 3\ntreeAncestor.getKthAncestor(5, 2); // returns 0 which is the grandparent of 5\ntreeAncestor.getKthAncestor(6, 3); // returns -1 because there is no such ancestor"
        ],
        "constraints": "1 <= k <= n <= 5 * 104\nparent.length == n\nparent[0] == -1\n0 <= parent[i] < n for all 0 < i < n\n0 <= node < n\nThere will be at most 5 * 104 queries."
    },
    {
        "slug": "grumpy-bookstore-owner",
        "description": "There is a bookstore owner that has a store open for n minutes. Every minute, some number of customers enter the store. You are given an integer array customers of length n where customers[i] is the number of the customer that enters the store at the start of the ith minute and all those customers leave after the end of that minute.\nOn some minutes, the bookstore owner is grumpy. You are given a binary array grumpy where grumpy[i] is 1 if the bookstore owner is grumpy during the ith minute, and is 0 otherwise.\nWhen the bookstore owner is grumpy, the customers of that minute are not satisfied, otherwise, they are satisfied.\nThe bookstore owner knows a secret technique to keep themselves not grumpy for minutes consecutive minutes, but can only use it once.\nReturn the maximum number of customers that can be satisfied throughout the day.",
        "examples": [
            "Input: customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], minutes = 3\nOutput: 16\nExplanation: The bookstore owner keeps themselves not grumpy for the last 3 minutes. \nThe maximum number of customers that can be satisfied = 1 + 1 + 1 + 1 + 7 + 5 = 16.",
            "Input: customers = [1], grumpy = [0], minutes = 1\nOutput: 1"
        ],
        "constraints": "n == customers.length == grumpy.length\n1 <= minutes <= n <= 2 * 104\n0 <= customers[i] <= 1000\ngrumpy[i] is either 0 or 1."
    },
    {
        "slug": "count-good-numbers",
        "description": "A digit string is good if the digits (0-indexed) at even indices are even and the digits at odd indices are prime (2, 3, 5, or 7).\n\nFor example, \"2582\" is good because the digits (2 and 8) at even positions are even and the digits (5 and 2) at odd positions are prime. However, \"3245\" is not good because 3 is at an even index but is not even.\n\nGiven an integer n, return the total number of good digit strings of length n. Since the answer may be large, return it modulo 109 + 7.\nA digit string is a string consisting of digits 0 through 9 that may contain leading zeros.",
        "examples": [
            "Input: n = 1\nOutput: 5\nExplanation: The good numbers of length 1 are \"0\", \"2\", \"4\", \"6\", \"8\".",
            "Input: n = 4\nOutput: 400",
            "Input: n = 50\nOutput: 564908303"
        ],
        "constraints": "1 <= n <= 1015"
    },
    {
        "slug": "game-of-life",
        "description": "According to\u00a0Wikipedia's article: \"The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970.\"\nThe board is made up of an m x n grid of cells, where each cell has an initial state: live (represented by a 1) or dead (represented by a 0). Each cell interacts with its eight neighbors (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\nAny live cell with fewer than two live neighbors dies as if caused by under-population.\nAny live cell with two or three live neighbors lives on to the next generation.\nAny live cell with more than three live neighbors dies, as if by over-population.\nAny dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the m x n grid board, return the next state.",
        "examples": [
            "Input: board = [[0,1,0],[0,0,1],[1,1,1],[0,0,0]]\nOutput: [[0,0,0],[1,0,1],[0,1,1],[0,1,0]]",
            "Input: board = [[1,1],[1,0]]\nOutput: [[1,1],[1,1]]"
        ],
        "constraints": "m == board.length\nn == board[i].length\n1 <= m, n <= 25\nboard[i][j] is 0 or 1."
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.",
            "Input: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits."
        ],
        "constraints": "1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "description": "Given a string s, reverse only all the vowels in the string and return it.\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.",
        "examples": [
            "Input: s = \"hello\"\nOutput: \"holle\"",
            "Input: s = \"leetcode\"\nOutput: \"leotcede\""
        ],
        "constraints": "1 <= s.length <= 3 * 105\ns consist of printable ASCII characters."
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "description": "You are given an m x n grid. Each cell of grid represents a street. The street of grid[i][j] can be:\n\n1 which means a street connecting the left cell and the right cell.\n2 which means a street connecting the upper cell and the lower cell.\n3 which means a street connecting the left cell and the lower cell.\n4 which means a street connecting the right cell and the lower cell.\n5 which means a street connecting the left cell and the upper cell.\n6 which means a street connecting the right cell and the upper cell.\n\n\nYou will initially start at the street of the upper-left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1). The path should only follow the streets.\nNotice that you are not allowed to change any street.\nReturn true if there is a valid path in the grid or false otherwise.",
        "examples": [
            "Input: grid = [[2,4,3],[6,5,2]]\nOutput: true\nExplanation: As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).",
            "Input: grid = [[1,2,1],[1,2,1]]\nOutput: false\nExplanation: As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)",
            "Input: grid = [[1,1,2]]\nOutput: false\nExplanation: You will get stuck at cell (0, 1) and you cannot reach cell (0, 2)."
        ],
        "constraints": "m == grid.length\nn == grid[i].length\n1 <= m, n <= 300\n1 <= grid[i][j] <= 6"
    },
    {
        "slug": "find-good-days-to-rob-the-bank",
        "description": "You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array security, where security[i] is the number of guards on duty on the ith day. The days are numbered starting from 0. You are also given an integer time.\nThe ith day is a good day to rob the bank if:\n\nThere are at least time days before and after the ith day,\nThe number of guards at the bank for the time days before i are non-increasing, and\nThe number of guards at the bank for the time days after i are non-decreasing.\n\nMore formally, this means day i is a good day to rob the bank if and only if security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time].\nReturn a list of all days (0-indexed) that are good days to rob the bank. The order that the days are returned in does not matter.",
        "examples": [
            "Input: security = [5,3,3,3,5,6,2], time = 2\nOutput: [2,3]\nExplanation:\nOn day 2, we have security[0] >= security[1] >= security[2] <= security[3] <= security[4].\nOn day 3, we have security[1] >= security[2] >= security[3] <= security[4] <= security[5].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.",
            "Input: security = [1,1,1,1,1], time = 0\nOutput: [0,1,2,3,4]\nExplanation:\nSince time equals 0, every day is a good day to rob the bank, so return every day.",
            "Input: security = [1,2,3,4,5,6], time = 2\nOutput: []\nExplanation:\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list."
        ],
        "constraints": "1 <= security.length <= 105\n0 <= security[i], time <= 105"
    },
    {
        "slug": "count-the-number-of-beautiful-subarrays",
        "description": "You are given a 0-indexed integer array nums. In one operation, you can:\n\nChoose two different indices i and j such that 0 <= i, j < nums.length.\nChoose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\nSubtract 2k from nums[i] and nums[j].\n\nA subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\nReturn the number of beautiful subarrays in the array nums.\nA subarray is a contiguous non-empty sequence of elements within an array.",
        "examples": [
            "Input: nums = [4,3,1,2,4]\nOutput: 2\nExplanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].\n- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:\n  - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].\n  - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].\n- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:\n  - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].\n  - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].\n  - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].",
            "Input: nums = [1,10,4]\nOutput: 0\nExplanation: There are no beautiful subarrays in nums."
        ],
        "constraints": "1 <= nums.length <= 105\n0 <= nums[i] <= 106"
    },
    {
        "slug": "apply-operations-to-an-array",
        "description": "You are given a 0-indexed array nums of size n consisting of non-negative integers.\nYou need to apply n - 1 operations to this array where, in the ith operation (0-indexed), you will apply the following on the ith element of nums:\n\nIf nums[i] == nums[i + 1], then multiply nums[i] by 2 and set nums[i + 1] to 0. Otherwise, you skip this operation.\n\nAfter performing all the operations, shift all the 0's to the end of the array.\n\nFor example, the array [1,0,2,0,0,1] after shifting all its 0's to the end, is [1,2,1,0,0,0].\n\nReturn the resulting array.\nNote that the operations are applied sequentially, not all at once.",
        "examples": [
            "Input: nums = [1,2,2,1,1,0]\nOutput: [1,4,2,0,0,0]\nExplanation: We do the following operations:\n- i = 0: nums[0] and nums[1] are not equal, so we skip this operation.\n- i = 1: nums[1] and nums[2] are equal, we multiply nums[1] by 2 and change nums[2] to 0. The array becomes [1,4,0,1,1,0].\n- i = 2: nums[2] and nums[3] are not equal, so we skip this operation.\n- i = 3: nums[3] and nums[4] are equal, we multiply nums[3] by 2 and change nums[4] to 0. The array becomes [1,4,0,2,0,0].\n- i = 4: nums[4] and nums[5] are equal, we multiply nums[4] by 2 and change nums[5] to 0. The array becomes [1,4,0,2,0,0].\nAfter that, we shift the 0's to the end, which gives the array [1,4,2,0,0,0].",
            "Input: nums = [0,1]\nOutput: [1,0]\nExplanation: No operation can be applied, we just shift the 0 to the end."
        ],
        "constraints": "2 <= nums.length <= 2000\n0 <= nums[i] <= 1000"
    },
    {
        "slug": "add-binary",
        "description": "Given two binary strings a and b, return their sum as a binary string.",
        "examples": [
            "Input: a = \"11\", b = \"1\"\nOutput: \"100\"",
            "Input: a = \"1010\", b = \"1011\"\nOutput: \"10101\""
        ],
        "constraints": "1 <= a.length, b.length <= 104\na and b consist\u00a0only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself."
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "description": "You are given an integer n, the number of nodes in a directed graph where the nodes are labeled from 0 to n - 1. Each edge is red or blue in this graph, and there could be self-edges and parallel edges.\nYou are given two arrays redEdges and blueEdges where:\n\nredEdges[i] = [ai, bi] indicates that there is a directed red edge from node ai to node bi in the graph, and\nblueEdges[j] = [uj, vj] indicates that there is a directed blue edge from node uj to node vj in the graph.\n\nReturn an array answer of length n, where each answer[x] is the length of the shortest path from node 0 to node x such that the edge colors alternate along the path, or -1 if such a path does not exist.",
        "examples": [
            "Input: n = 3, redEdges = [[0,1],[1,2]], blueEdges = []\nOutput: [0,1,-1]",
            "Input: n = 3, redEdges = [[0,1]], blueEdges = [[2,1]]\nOutput: [0,1,-1]"
        ],
        "constraints": "1 <= n <= 100\n0 <= redEdges.length,\u00a0blueEdges.length <= 400\nredEdges[i].length == blueEdges[j].length == 2\n0 <= ai, bi, uj, vj < n"
    },
    {
        "slug": "range-sum-query-immutable",
        "description": "Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).",
        "examples": [
            "Input\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3"
        ],
        "constraints": "1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n0 <= left <= right < nums.length\nAt most 104 calls will be made to sumRange."
    },
    {
        "slug": "find-the-student-that-will-replace-the-chalk",
        "description": "There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again.\nYou are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk.\nReturn the index of the student that will replace the chalk pieces.",
        "examples": [
            "Input: chalk = [5,1,5], k = 22\nOutput: 0\nExplanation: The students go in turns as follows:\n- Student number 0 uses 5 chalk, so k = 17.\n- Student number 1 uses 1 chalk, so k = 16.\n- Student number 2 uses 5 chalk, so k = 11.\n- Student number 0 uses 5 chalk, so k = 6.\n- Student number 1 uses 1 chalk, so k = 5.\n- Student number 2 uses 5 chalk, so k = 0.\nStudent number 0 does not have enough chalk, so they will have to replace it.",
            "Input: chalk = [3,4,1,2], k = 25\nOutput: 1\nExplanation: The students go in turns as follows:\n- Student number 0 uses 3 chalk so k = 22.\n- Student number 1 uses 4 chalk so k = 18.\n- Student number 2 uses 1 chalk so k = 17.\n- Student number 3 uses 2 chalk so k = 15.\n- Student number 0 uses 3 chalk so k = 12.\n- Student number 1 uses 4 chalk so k = 8.\n- Student number 2 uses 1 chalk so k = 7.\n- Student number 3 uses 2 chalk so k = 5.\n- Student number 0 uses 3 chalk so k = 2.\nStudent number 1 does not have enough chalk, so they will have to replace it."
        ],
        "constraints": "chalk.length == n\n1 <= n <= 105\n1 <= chalk[i] <= 105\n1 <= k <= 109"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "description": "You are given a 2D integer array items where items[i] = [pricei, beautyi] denotes the price and beauty of an item respectively.\nYou are also given a 0-indexed integer array queries. For each queries[j], you want to determine the maximum beauty of an item whose price is less than or equal to queries[j]. If no such item exists, then the answer to this query is 0.\nReturn an array answer of the same length as queries where answer[j] is the answer to the jth query.",
        "examples": [
            "Input: items = [[1,2],[3,2],[2,4],[5,6],[3,5]], queries = [1,2,3,4,5,6]\nOutput: [2,4,5,5,6,6]\nExplanation:\n- For queries[0]=1, [1,2] is the only item which has price <= 1. Hence, the answer for this query is 2.\n- For queries[1]=2, the items which can be considered are [1,2] and [2,4]. \n  The maximum beauty among them is 4.\n- For queries[2]=3 and queries[3]=4, the items which can be considered are [1,2], [3,2], [2,4], and [3,5].\n  The maximum beauty among them is 5.\n- For queries[4]=5 and queries[5]=6, all items can be considered.\n  Hence, the answer for them is the maximum beauty of all items, i.e., 6.",
            "Input: items = [[1,2],[1,2],[1,3],[1,4]], queries = [1]\nOutput: [4]\nExplanation: \nThe price of every item is equal to 1, so we choose the item with the maximum beauty 4. \nNote that multiple items can have the same price and/or beauty.",
            "Input: items = [[10,1000]], queries = [5]\nOutput: [0]\nExplanation:\nNo item has a price less than or equal to 5, so no item can be chosen.\nHence, the answer to the query is 0."
        ],
        "constraints": "1 <= items.length, queries.length <= 105\nitems[i].length == 2\n1 <= pricei, beautyi, queries[j] <= 109"
    },
    {
        "slug": "sum-of-digits-of-string-after-convert",
        "description": "You are given a string s consisting of lowercase English letters, and an integer k.\nFirst, convert s into an integer by replacing each letter with its position in the alphabet (i.e., replace 'a' with 1, 'b' with 2, ..., 'z' with 26). Then, transform the integer by replacing it with the sum of its digits. Repeat the transform operation k times in total.\nFor example, if s = \"zbax\" and k = 2, then the resulting integer would be 8 by the following operations:\n\nConvert: \"zbax\" \u279d \"(26)(2)(1)(24)\" \u279d \"262124\" \u279d 262124\nTransform #1: 262124 \u279d 2 + 6 + 2 + 1 + 2 + 4\u00a0\u279d 17\nTransform #2: 17 \u279d 1 + 7 \u279d 8\n\nReturn the resulting integer after performing the operations described above.",
        "examples": [
            "Input: s = \"iiii\", k = 1\nOutput: 36\nExplanation: The operations are as follows:\n- Convert: \"iiii\" \u279d \"(9)(9)(9)(9)\" \u279d \"9999\" \u279d 9999\n- Transform #1: 9999 \u279d 9 + 9 + 9 + 9 \u279d 36\nThus the resulting integer is 36.",
            "Input: s = \"leetcode\", k = 2\nOutput: 6\nExplanation: The operations are as follows:\n- Convert: \"leetcode\" \u279d \"(12)(5)(5)(20)(3)(15)(4)(5)\" \u279d \"12552031545\" \u279d 12552031545\n- Transform #1: 12552031545 \u279d 1 + 2 + 5 + 5 + 2 + 0 + 3 + 1 + 5 + 4 + 5 \u279d 33\n- Transform #2: 33 \u279d 3 + 3 \u279d 6\nThus the resulting integer is 6.",
            "Input: s = \"zbax\", k = 2\nOutput: 8"
        ],
        "constraints": "1 <= s.length <= 100\n1 <= k <= 10\ns consists of lowercase English letters."
    },
    {
        "slug": "find-the-difference-of-two-arrays",
        "description": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n\nanswer[0] is a list of all distinct integers in nums1 which are not present in nums2.\nanswer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n\nNote that the integers in the lists may be returned in any order.",
        "examples": [
            "Input: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].",
            "Input: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = []."
        ],
        "constraints": "1 <= nums1.length, nums2.length <= 1000\n-1000 <= nums1[i], nums2[i] <= 1000"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "description": "Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.",
            "Input: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".",
            "Input: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s."
        ],
        "constraints": "1 <= s.length <= 300\ns contains only lowercase English letters."
    },
    {
        "slug": "integer-to-roman",
        "description": "Roman numerals are represented by seven different symbols:\u00a0I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example,\u00a02 is written as II\u00a0in Roman numeral, just two one's added together. 12 is written as\u00a0XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9.\u00a0\nX can be placed before L (50) and C (100) to make 40 and 90.\u00a0\nC can be placed before D (500) and M (1000) to make 400 and 900.\n\nGiven an integer, convert it to a roman numeral.",
        "examples": [
            "Input: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.",
            "Input: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.",
            "Input: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4."
        ],
        "constraints": "1 <= num <= 3999"
    },
    {
        "slug": "as-far-from-land-as-possible",
        "description": "Given an n x n grid\u00a0containing only values 0 and 1, where\u00a00 represents water\u00a0and 1 represents land, find a water cell such that its distance to the nearest land cell is maximized, and return the distance.\u00a0If no land or water exists in the grid, return -1.\nThe distance used in this problem is the Manhattan distance:\u00a0the distance between two cells (x0, y0) and (x1, y1) is |x0 - x1| + |y0 - y1|.",
        "examples": [
            "Input: grid = [[1,0,1],[0,0,0],[1,0,1]]\nOutput: 2\nExplanation: The cell (1, 1) is as far as possible from all the land with distance 2.",
            "Input: grid = [[1,0,0],[0,0,0],[0,0,0]]\nOutput: 4\nExplanation: The cell (2, 2) is as far as possible from all the land with distance 4."
        ],
        "constraints": "n == grid.length\nn == grid[i].length\n1 <= n\u00a0<= 100\ngrid[i][j]\u00a0is 0 or 1"
    },
    {
        "slug": "number-complement",
        "description": "The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\nFor example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n\nGiven an integer num, return its complement.",
        "examples": [
            "Input: num = 5\nOutput: 2\nExplanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.",
            "Input: num = 1\nOutput: 0\nExplanation: The binary representation of 1 is 1 (no leading zero bits), and its complement is 0. So you need to output 0."
        ],
        "constraints": "1 <= num < 231\n\n\u00a0\nNote: This question is the same as 1009: https://leetcode.com/problems/complement-of-base-10-integer/"
    },
    {
        "slug": "valid-perfect-square",
        "description": "Given a positive integer num, return true if num is a perfect square or false otherwise.\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\nYou must not use any built-in library function, such as sqrt.",
        "examples": [
            "Input: num = 16\nOutput: true\nExplanation: We return true because 4 * 4 = 16 and 4 is an integer.",
            "Input: num = 14\nOutput: false\nExplanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer."
        ],
        "constraints": "1 <= num <= 231 - 1"
    },
    {
        "slug": "knight-dialer",
        "description": "The chess knight has a unique movement,\u00a0it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\nA chess knight can move as indicated in the chess diagram below:\n\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell\u00a0(i.e. blue cell).\n\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\nAs the answer may be very large, return the answer modulo 109 + 7.",
        "examples": [
            "Input: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.",
            "Input: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]",
            "Input: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod."
        ],
        "constraints": "1 <= n <= 5000"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "description": "Hercy wants to save money for his first car. He puts money in the Leetcode\u00a0bank every day.\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday. \nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.",
        "examples": [
            "Input: n = 4\nOutput: 10\nExplanation:\u00a0After the 4th day, the total is 1 + 2 + 3 + 4 = 10.",
            "Input: n = 10\nOutput: 37\nExplanation:\u00a0After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.",
            "Input: n = 20\nOutput: 96\nExplanation:\u00a0After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96."
        ],
        "constraints": "1 <= n <= 1000"
    },
    {
        "slug": "magical-string",
        "description": "A magical string s consists of only '1' and '2' and obeys the following rules:\n\nThe string s is magical because concatenating the number of contiguous occurrences of characters '1' and '2' generates the string s itself.\n\nThe first few elements of s is s = \"1221121221221121122\u2026\u2026\". If we group the consecutive 1's and 2's in s, it will be \"1 22 11 2 1 22 1 22 11 2 11 22 ......\" and the occurrences of 1's or 2's in each group are \"1 2 2 1 1 2 1 2 2 1 2 2 ......\". You can see that the occurrence sequence is s itself.\nGiven an integer n, return the number of 1's in the first n number in the magical string s.",
        "examples": [
            "Input: n = 6\nOutput: 3\nExplanation: The first 6 elements of magical string s is \"122112\" and it contains three 1's, so return 3.",
            "Input: n = 1\nOutput: 1"
        ],
        "constraints": "1 <= n <= 105"
    },
    {
        "slug": "maximum-number-of-integers-to-choose-from-a-range-i",
        "description": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n\nThe chosen integers have to be in the range [1, n].\nEach integer can be chosen at most once.\nThe chosen integers should not be in the array banned.\nThe sum of the chosen integers should not exceed maxSum.\n\nReturn the maximum number of integers you can choose following the mentioned rules.",
        "examples": [
            "Input: banned = [1,6,5], n = 5, maxSum = 6\nOutput: 2\nExplanation: You can choose the integers 2 and 4.\n2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.",
            "Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\nOutput: 0\nExplanation: You cannot choose any integer while following the mentioned conditions.",
            "Input: banned = [11], n = 7, maxSum = 50\nOutput: 7\nExplanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\nThey are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum."
        ],
        "constraints": "1 <= banned.length <= 104\n1 <= banned[i], n <= 104\n1 <= maxSum <= 109"
    },
    {
        "slug": "fibonacci-number",
        "description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven n, calculate F(n).",
        "examples": [
            "Input: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.",
            "Input: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.",
            "Input: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3."
        ],
        "constraints": "0 <= n <= 30"
    },
    {
        "slug": "minimum-absolute-difference-between-elements-with-constraint",
        "description": "You are given a 0-indexed integer array nums and an integer x.\nFind the minimum absolute difference between two elements in the array that are at least x indices apart.\nIn other words, find two indices i and j such that abs(i - j) >= x and abs(nums[i] - nums[j]) is minimized.\nReturn an integer denoting the minimum absolute difference between two elements that are at least x indices apart.",
        "examples": [
            "Input: nums = [4,3,2,4], x = 2\nOutput: 0\nExplanation: We can select nums[0] = 4 and nums[3] = 4. \nThey are at least 2 indices apart, and their absolute difference is the minimum, 0. \nIt can be shown that 0 is the optimal answer.",
            "Input: nums = [5,3,2,10,15], x = 1\nOutput: 1\nExplanation: We can select nums[1] = 3 and nums[2] = 2.\nThey are at least 1 index apart, and their absolute difference is the minimum, 1.\nIt can be shown that 1 is the optimal answer.",
            "Input: nums = [1,2,3,4], x = 3\nOutput: 3\nExplanation: We can select nums[0] = 1 and nums[3] = 4.\nThey are at least 3 indices apart, and their absolute difference is the minimum, 3.\nIt can be shown that 3 is the optimal answer."
        ],
        "constraints": "1 <= nums.length <= 105\n1 <= nums[i] <= 109\n0 <= x < nums.length"
    },
    {
        "slug": "total-appeal-of-a-string",
        "description": "The appeal of a string is the number of distinct characters found in the string.\n\nFor example, the appeal of \"abbca\" is 3 because it has 3 distinct characters: 'a', 'b', and 'c'.\n\nGiven a string s, return the total appeal of all of its substrings.\nA substring is a contiguous sequence of characters within a string.",
        "examples": [
            "Input: s = \"abbca\"\nOutput: 28\nExplanation: The following are the substrings of \"abbca\":\n- Substrings of length 1: \"a\", \"b\", \"b\", \"c\", \"a\" have an appeal of 1, 1, 1, 1, and 1 respectively. The sum is 5.\n- Substrings of length 2: \"ab\", \"bb\", \"bc\", \"ca\" have an appeal of 2, 1, 2, and 2 respectively. The sum is 7.\n- Substrings of length 3: \"abb\", \"bbc\", \"bca\" have an appeal of 2, 2, and 3 respectively. The sum is 7.\n- Substrings of length 4: \"abbc\", \"bbca\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 5: \"abbca\" has an appeal of 3. The sum is 3.\nThe total sum is 5 + 7 + 7 + 6 + 3 = 28.",
            "Input: s = \"code\"\nOutput: 20\nExplanation: The following are the substrings of \"code\":\n- Substrings of length 1: \"c\", \"o\", \"d\", \"e\" have an appeal of 1, 1, 1, and 1 respectively. The sum is 4.\n- Substrings of length 2: \"co\", \"od\", \"de\" have an appeal of 2, 2, and 2 respectively. The sum is 6.\n- Substrings of length 3: \"cod\", \"ode\" have an appeal of 3 and 3 respectively. The sum is 6.\n- Substrings of length 4: \"code\" has an appeal of 4. The sum is 4.\nThe total sum is 4 + 6 + 6 + 4 = 20."
        ],
        "constraints": "1 <= s.length <= 105\ns consists of lowercase English letters."
    },
    {
        "slug": "target-sum",
        "description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\nFor example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\nReturn the number of different expressions that you can build, which evaluates to target.",
        "examples": [
            "Input: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3",
            "Input: nums = [1], target = 1\nOutput: 1"
        ],
        "constraints": "1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000"
    },
    {
        "slug": "merge-two-binary-trees",
        "description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.",
        "examples": [
            "Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]",
            "Input: root1 = [1], root2 = [1,2]\nOutput: [2,2]"
        ],
        "constraints": "The number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104"
    }
]