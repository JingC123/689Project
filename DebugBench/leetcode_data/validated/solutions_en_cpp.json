[
    {
        "slug": "cat-and-mouse-ii",
        "tags": "cpp",
        "release_time": 1652504475,
        "code": "class Solution {\npublic:\n    int dp[9][9][9][9][140];\n    int dx[4] = {0,1,0,-1};\n    int dy[4] = {1,0,-1,0};\n    \n    bool solve(vector<string>& grid, int catJump, int mouseJump, int catR, int catC, int mouseR, int mouseC, int moves){        \n        int r = grid.size(), c = grid[0].size();\n        if(moves >= 128) return false;\n        if(mouseR==catR && mouseC==catC) return false;\n        if(grid[catR][catC] == 'F') return false;\n        if(grid[mouseR][mouseC] == 'F') return true;\n        \n        if(dp[catR][catC][mouseR][mouseC][moves] != -1) \n            return dp[catR][catC][mouseR][mouseC][moves];\n        \n        if(moves%2 == 0){\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=mouseJump; ++j){\n                    int x = mouseR+j*dx[i], y = mouseC+j*dy[i];\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, catR, catC, x, y, moves+1) == true) \n                            return dp[catR][catC][mouseR][mouseC][moves] = true;\n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = false;\n        }else{\n            for(int i=0; i<4; ++i){\n                for(int j=0; j<=catJump; ++j){\n                    int x = catR+dx[i]*j, y = catC+dy[i]*j;\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!='#'){\n                        if(solve(grid, catJump, mouseJump, x, y, mouseR, mouseC, moves+1) == false) \n                            return dp[catR][catC][mouseR][mouseC][moves] = false; \n                    }else break;\n                }\n            }\n            return dp[catR][catC][mouseR][mouseC][moves] = true;\n        }\n    }\n    \n    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\n       memset(dp,-1,sizeof(dp));\n        int r = grid.size(), c =grid[0].size();\n        int catR, catC, mouseR, mouseC;\n        for(int i=0; i<r; ++i){\n            for(int j=0; j<c; ++j){\n                if(grid[i][j] == 'C'){\n                    catR = i, catC = j;\n                }\n                else if(grid[i][j] == 'M'){\n                    mouseR = i, mouseC = j;\n                }\n            }\n        }\n        \n        return solve(grid, catJump, mouseJump, catR, catC, mouseR, mouseC, 0);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][9][9][9][140];\\n    int dx[4] = {0,1,0,-1};\\n    int dy[4] = {1,0,-1,0};\\n    \\n    bool solve(vector<string>& grid, int catJump, int mouseJump, int catR, int catC, int mouseR, int mouseC, int moves){        \\n        int r = grid.size(), c = grid[0].size();\\n        if(moves >= 128) return false;\\n        if(mouseR==catR && mouseC==catC) return false;\\n        if(grid[catR][catC] == \\'F\\') return false;\\n        if(grid[mouseR][mouseC] == \\'F\\') return true;\\n        \\n        if(dp[catR][catC][mouseR][mouseC][moves] != -1) \\n            return dp[catR][catC][mouseR][mouseC][moves];\\n        \\n        if(moves%2 == 0){\\n            for(int i=0; i<4; ++i){\\n                for(int j=0; j<=mouseJump; ++j){\\n                    int x = mouseR+j*dx[i], y = mouseC+j*dy[i];\\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!=\\'#\\'){\\n                        if(solve(grid, catJump, mouseJump, catR, catC, x, y, moves+1) == true) \\n                            return dp[catR][catC][mouseR][mouseC][moves] = true;\\n                    }else break;\\n                }\\n            }\\n            return dp[catR][catC][mouseR][mouseC][moves] = false;\\n        }else{\\n            for(int i=0; i<4; ++i){\\n                for(int j=0; j<=catJump; ++j){\\n                    int x = catR+dx[i]*j, y = catC+dy[i]*j;\\n                    if(x>=0 && x<r && y>=0 && y<c && grid[x][y]!=\\'#\\'){\\n                        if(solve(grid, catJump, mouseJump, x, y, mouseR, mouseC, moves+1) == false) \\n                            return dp[catR][catC][mouseR][mouseC][moves] = false; \\n                    }else break;\\n                }\\n            }\\n            return dp[catR][catC][mouseR][mouseC][moves] = true;\\n        }\\n    }\\n    \\n    bool canMouseWin(vector<string>& grid, int catJump, int mouseJump) {\\n       memset(dp,-1,sizeof(dp));\\n        int r = grid.size(), c =grid[0].size();\\n        int catR, catC, mouseR, mouseC;\\n        for(int i=0; i<r; ++i){\\n            for(int j=0; j<c; ++j){\\n                if(grid[i][j] == \\'C\\'){\\n                    catR = i, catC = j;\\n                }\\n                else if(grid[i][j] == \\'M\\'){\\n                    mouseR = i, mouseC = j;\\n                }\\n            }\\n        }\\n        \\n        return solve(grid, catJump, mouseJump, catR, catC, mouseR, mouseC, 0);\\n    }\\n};\\n```\\n**Please UPVOTE**"
    },
    {
        "slug": "largest-combination-with-bitwise-and-greater-than-zero",
        "tags": "cpp",
        "release_time": 1677319841,
        "code": "class Solution {\npublic:\n    int largestCombination(vector<int>& candidates) {\n        vector<int> v(32,0);\n        int ans = 0,x,j;\n        for(auto &i: candidates){\n            for(j = 0; j <= 31; j++){\n                if(i&(1<<j)){\n                    v[j]++;\n                }\n                ans = max(ans,v[j]);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int largestCombination(vector<int>& candidates) {\\n        vector<int> v(32,0);\\n        int ans = 0,x,j;\\n        for(auto &i: candidates){\\n            for(j = 0; j <= 31; j++){\\n                if(i&(1<<j)){\\n                    v[j]++;\\n                }\\n                ans = max(ans,v[j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-the-number-of-beautiful-subarrays",
        "tags": "cpp",
        "release_time": 1679377731,
        "code": "class Solution {\npublic:\n    long long beautifulSubarrays(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        long long ans = 0;\n        \n        // declare an unordered map\n        \n        unordered_map<int, int> mp;\n        \n        // insert 0 with the frequncy of 1\n        \n        mp[0] = 1;\n        \n        int curr_xorr = 0;\n        \n        // traverse over the nums\n        \n        for(int i = 0; i < n; i++)\n        {\n            // find xorr\n            \n            curr_xorr = (curr_xorr ^ nums[i]);\n            \n            // if curr_xorr exit in map then update ans\n            \n            if(mp.count(curr_xorr))\n            {\n                ans += mp[curr_xorr];\n            }\n            \n            // increment the freq of curr_xorr\n            \n            mp[curr_xorr]++;\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Using Hashmap && Bit Manipulation***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        long long ans = 0;\\n        \\n        // declare an unordered map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // insert 0 with the frequncy of 1\\n        \\n        mp[0] = 1;\\n        \\n        int curr_xorr = 0;\\n        \\n        // traverse over the nums\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find xorr\\n            \\n            curr_xorr = (curr_xorr ^ nums[i]);\\n            \\n            // if curr_xorr exit in map then update ans\\n            \\n            if(mp.count(curr_xorr))\\n            {\\n                ans += mp[curr_xorr];\\n            }\\n            \\n            // increment the freq of curr_xorr\\n            \\n            mp[curr_xorr]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-if-path-exists-in-graph",
        "tags": "cpp",
        "release_time": 1692563940,
        "code": "class Solution {\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) \n    {\n        unordered_map<int,vector<int>> mp;\n            for(auto i : edges)\n            {\n                vector<int> temp=i;\n                int u=temp[0];\n                int v=temp[1];\n                mp[u].push_back(v);\n                mp[v].push_back(u);\n            }\n            vector<bool> visited(n+1,false);\n            queue<int>q;\n            q.push(source);\n            visited[source]=true;\n            while(!q.empty())\n            {\n                int u=q.front();\n                q.pop();\n                for(auto i :mp[u])\n                {\n                    if(visited[i]==false)\n                    {\n                        visited[i]=true;\n                        q.push(i);\n                    }\n                }\n            }\n            return visited[destination];    \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) \\n    {\\n        unordered_map<int,vector<int>> mp;\\n            for(auto i : edges)\\n            {\\n                vector<int> temp=i;\\n                int u=temp[0];\\n                int v=temp[1];\\n                mp[u].push_back(v);\\n                mp[v].push_back(u);\\n            }\\n            vector<bool> visited(n+1,false);\\n            queue<int>q;\\n            q.push(source);\\n            visited[source]=true;\\n            while(!q.empty())\\n            {\\n                int u=q.front();\\n                q.pop();\\n                for(auto i :mp[u])\\n                {\\n                    if(visited[i]==false)\\n                    {\\n                        visited[i]=true;\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n            return visited[destination];    \\n    }\\n};\\n```"
    },
    {
        "slug": "asteroid-collision",
        "tags": "cpp",
        "release_time": 1689824566,
        "code": "class Solution {\npublic:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        \n\n        stack<int>st;\n        for(int i=0;i<asteroids.size();i++){\n            if(st.empty()){\n                st.push(asteroids[i]);\n            }\n            else{\n                if(st.top()>0){\n                       if(st.top()*asteroids[i]>0){\n                         st.push(asteroids[i]); \n                        }\n                        else {\n                            if(abs(st.top()) == abs(asteroids[i])){\n                                st.pop();\n                                continue;\n                            }\n                            else if(abs(st.top())>abs(asteroids[i])){\n                                continue;\n                            }\n                            else {\n                              bool flag = false;\n                                while(!st.empty() && st.top()*asteroids[i]<0 ){\n                                   if(abs(st.top()) == abs(asteroids[i])){\n                                        st.pop();\n                                        flag = false;\n                                        break;\n                                    }\n                                    else if(abs(st.top())>abs(asteroids[i])){\n                                        flag = false;\n                                        break;\n                                    }\n                                    else {\n                                        flag = true;\n                                        st.pop();\n                                    }\n                                }\n                                if(flag)  st.push(asteroids[i]);\n                                 \n                                \n                            }\n                        }  \n                    }\n                    else{\n                      st.push(asteroids[i]);    \n                    }\n                }\n        }\n        vector<int>vect;\n        while(!st.empty()){\n            vect.push_back(st.top());\n            st.pop();\n        }\n        reverse(vect.begin(),vect.end());\n     \n    return vect;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> asteroidCollision(vector<int>& asteroids) {\\n        \\n\\n        stack<int>st;\\n        for(int i=0;i<asteroids.size();i++){\\n            if(st.empty()){\\n                st.push(asteroids[i]);\\n            }\\n            else{\\n                if(st.top()>0){\\n                       if(st.top()*asteroids[i]>0){\\n                         st.push(asteroids[i]); \\n                        }\\n                        else {\\n                            if(abs(st.top()) == abs(asteroids[i])){\\n                                st.pop();\\n                                continue;\\n                            }\\n                            else if(abs(st.top())>abs(asteroids[i])){\\n                                continue;\\n                            }\\n                            else {\\n                              bool flag = false;\\n                                while(!st.empty() && st.top()*asteroids[i]<0 ){\\n                                   if(abs(st.top()) == abs(asteroids[i])){\\n                                        st.pop();\\n                                        flag = false;\\n                                        break;\\n                                    }\\n                                    else if(abs(st.top())>abs(asteroids[i])){\\n                                        flag = false;\\n                                        break;\\n                                    }\\n                                    else {\\n                                        flag = true;\\n                                        st.pop();\\n                                    }\\n                                }\\n                                if(flag)  st.push(asteroids[i]);\\n                                 \\n                                \\n                            }\\n                        }  \\n                    }\\n                    else{\\n                      st.push(asteroids[i]);    \\n                    }\\n                }\\n        }\\n        vector<int>vect;\\n        while(!st.empty()){\\n            vect.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(vect.begin(),vect.end());\\n     \\n    return vect;\\n    }\\n};\\n\\n\\n```"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "tags": "cpp",
        "release_time": 1682999813,
        "code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i);\n        }\n        // 1 2 3 4 5 \n        while(q.size() != 1){\n            int i = 1;\n            while(i < k){\n                int f = q.front();\n                q.pop();\n                q.push(f);\n                i++;\n            }\n            q.pop();\n        }\n\n        return q.front();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        // 1 2 3 4 5 \\n        while(q.size() != 1){\\n            int i = 1;\\n            while(i < k){\\n                int f = q.front();\\n                q.pop();\\n                q.push(f);\\n                i++;\\n            }\\n            q.pop();\\n        }\\n\\n        return q.front();\\n    }\\n};\\n```"
    },
    {
        "slug": "k-closest-points-to-origin",
        "tags": "cpp",
        "release_time": 1691846558,
        "code": "class Solution {\n    class info{\n        public:\n        int x;\n        int y;\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\n        info(int a , int b)\n        {\n            x = a;\n            y = b;\n        // as always we are finding the distance from the origin so\n            distance = sqrt (x*x + y*y);\n\n        }\n    };\n\nclass compare{\n   public:\n   bool operator()(info* point1 , info* point2)\n   {\n       if( point1->distance > point2->distance)\n       {\n           return true;\n       }\n       else{\n           return false;\n       }\n   }\n};\n\n\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\n        priority_queue<info*,vector<info*>,compare> minheap;\n\n        for( int i = 0 ; i < points.size() ; i ++)\n        {\n            // current point\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            info* newinfo = new info(x1,y1);\n            minheap.push(newinfo);\n        }\n        vector<vector<int>> ans;\n        while(k > 0)\n        {\n            // make point of the top element and push it into the ans\n            info* temp = minheap.top();\n            minheap.pop();\n            int xval = temp->x;\n            int yval = temp->y;\n            // now push the point into the ans\n            vector<int> temp2 ;\n            temp2.push_back(xval);\n            temp2.push_back(yval);\n            ans.push_back(temp2);\n            k--;\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class info{\\n        public:\\n        int x;\\n        int y;\\n        float distance; // int must be avoided as for decimals we will get equall distances for diff points\\n        info(int a , int b)\\n        {\\n            x = a;\\n            y = b;\\n        // as always we are finding the distance from the origin so\\n            distance = sqrt (x*x + y*y);\\n\\n        }\\n    };\\n\\nclass compare{\\n   public:\\n   bool operator()(info* point1 , info* point2)\\n   {\\n       if( point1->distance > point2->distance)\\n       {\\n           return true;\\n       }\\n       else{\\n           return false;\\n       }\\n   }\\n};\\n\\n\\npublic:\\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\\n        // as we want the min  distance so we can use the min heap to store the distance of the min points by using the class info\\n        priority_queue<info*,vector<info*>,compare> minheap;\\n\\n        for( int i = 0 ; i < points.size() ; i ++)\\n        {\\n            // current point\\n            int x1 = points[i][0];\\n            int y1 = points[i][1];\\n            info* newinfo = new info(x1,y1);\\n            minheap.push(newinfo);\\n        }\\n        vector<vector<int>> ans;\\n        while(k > 0)\\n        {\\n            // make point of the top element and push it into the ans\\n            info* temp = minheap.top();\\n            minheap.pop();\\n            int xval = temp->x;\\n            int yval = temp->y;\\n            // now push the point into the ans\\n            vector<int> temp2 ;\\n            temp2.push_back(xval);\\n            temp2.push_back(yval);\\n            ans.push_back(temp2);\\n            k--;\\n        }\\n        return ans;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "optimal-partition-of-string",
        "tags": "cpp",
        "release_time": 1680585594,
        "code": "class Solution {\npublic:\n    int partitionString(string s) {\n        set<char>st;\n        int g=1;\n        for(int i=0;i<s.size();i++){\n            if(st.find(s[i])!=st.end()){\n                g++;\n                st.clear();\n                st.insert(s[i]);\n            }\n            else {\n                st.insert(s[i]);\n            }\n        }\n        return g;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionString(string s) {\\n        set<char>st;\\n        int g=1;\\n        for(int i=0;i<s.size();i++){\\n            if(st.find(s[i])!=st.end()){\\n                g++;\\n                st.clear();\\n                st.insert(s[i]);\\n            }\\n            else {\\n                st.insert(s[i]);\\n            }\\n        }\\n        return g;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/c842b50a-e025-48ab-8dd8-72272b9952a8_1680585578.8252864.jpeg)\\n"
    },
    {
        "slug": "sum-multiples",
        "tags": "cpp",
        "release_time": 1682768576,
        "code": "class Solution {\npublic:\n    int sumOfMultiples(int n,int count=0) {\n       \n       \n       for (int i=1;i<=n;i++)\n       {\n         if (i%3==0 || i%5==0 ||i%7==0)\n           count+=i;\n       }\n    return count;\n\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumOfMultiples(int n,int count=0) {\\n       \\n       \\n       for (int i=1;i<=n;i++)\\n       {\\n         if (i%3==0 || i%5==0 ||i%7==0)\\n           count+=i;\\n       }\\n    return count;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "integer-to-roman",
        "tags": "cpp",
        "release_time": 1672226407,
        "code": "class Solution {\npublic:\n    string intToRoman(int num) {\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\n        \n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string intToRoman(int num) {\\n        string ones[] = {\"\",\"I\",\"II\",\"III\",\"IV\",\"V\",\"VI\",\"VII\",\"VIII\",\"IX\"};\\n        string tens[] = {\"\",\"X\",\"XX\",\"XXX\",\"XL\",\"L\",\"LX\",\"LXX\",\"LXXX\",\"XC\"};\\n        string hrns[] = {\"\",\"C\",\"CC\",\"CCC\",\"CD\",\"D\",\"DC\",\"DCC\",\"DCCC\",\"CM\"};\\n        string ths[]={\"\",\"M\",\"MM\",\"MMM\"};\\n        \\n        return ths[num/1000] + hrns[(num%1000)/100] + tens[(num%100)/10] + ones[num%10];\\n    }\\n};\\n```\\n\\n# ***Please Upvote if it helps \\u2764\\uFE0F***"
    },
    {
        "slug": "maximum-sum-queries",
        "tags": "cpp",
        "release_time": 1686456112,
        "code": "long long INF = 1e14;\n\ntemplate <typename T = int> \nclass SegmentTree {\npublic:\n    \n    vector<T> st; \n    vector<T> arr; \n    int n; \n\t\n\tT invalidValue = -INF;\n    \n\tint left(int ind) {\n\t\treturn 2*ind + 1;\n\t}\n\n\tint right(int ind) {\n\t\treturn 2*ind + 2;\n\t}\n\n\tT operate(T a, T b){\n\t\treturn max(a, b);\n\t}\n\n\tvoid pull(int ind) {\n\t\tst[ind] = operate(st[left(ind)], st[right(ind)]);\n\t}\n\n    \n    void build(int l, int r, int ind){\n        if(l == r){\n            st[ind] = arr[l];\n            return;\n        }\n        \n        int m = (l+r)/2;\n        \n        build(l, m, left(ind));\n        build(m+1, r, right(ind));\n        \n        pull(ind);\n    }\n    \n    T query(int l, int r, int i, int j, int ind){\n        if(l>=i and r<=j){\n            return st[ind];\n        }\n\n        if(r<i or l>j){\n            return invalidValue;\n        }\n        \n        int m = (l+r)/2;\n\n\t\tT leftVal = query(l, m, i, j, left(ind));\n\t\tT rightVal = query(m+1, r, i, j, right(ind));\n\n        return operate(leftVal, rightVal);\n    }\n    \n    void update(int l, int r, T val, int i, int ind){\n\t\tif(l == r){\n\t\t\tif(l == i){\n\t\t\t\tst[ind] = max(st[ind], val);\n                arr[l] = max(arr[l], val);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n        if(i<l or i>r){\n            return;\n        }\n        \n        if(l != r){\n            int m = (l+r)/2;\n            update(l, m, val, i, left(ind));\n            update(m+1, r, val, i, right(ind));\n\t\t\tpull(ind);\n        }\n    }\n\n    SegmentTree(int n) {\n        this->n = n;\n        arr = vector<T>(n, -INF);\n        st = vector<T>(4*n);\n\n        build(0, n-1, 0);\n    }\n    \n    void update(int index, T val) {\n        arr[index] = val;\n        update(0, n-1, val, index, 0);\n    }\n    \n    T query(int left, int right) {\n        return query(0, n-1, left, right, 0);\n    }\n};\n\nclass Solution {\npublic:\n    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\n        vector<vector<int>> arr;\n        vector<int> points;\n        \n        for(int i=0; i<nums1.size(); i++) {\n            arr.push_back({nums1[i], nums2[i], nums1[i]+nums2[i]});\n            points.push_back(nums2[i]);\n        }\n        \n        sort(arr.begin(), arr.end(), [](vector<int>& a, vector<int>& b) {\n            if(a[0] == b[0]) return a[2] > b[2];\n            return a[0] < b[0];\n        });\n        \n        for(int i=0; i<queries.size(); i++) {\n            queries[i].push_back(i);\n            points.push_back(queries[i][1]);\n        }\n        \n        sort(points.begin(), points.end());\n        points.erase(unique(points.begin(), points.end()), points.end());\n        map<int,int> coord;\n        \n        for(int i=0; i<points.size(); i++) {\n            coord[points[i]] = i;\n        }\n        \n        sort(queries.rbegin(), queries.rend());\n        \n        vector<int> result(queries.size());\n        int i = arr.size()-1;\n        \n        using ll = long long;        \n        SegmentTree<ll> segTree(points.size());\n        \n        for(vector<int>& q : queries) {\n            while(i>=0 and arr[i][0] >= q[0]) {\n                segTree.update(coord[arr[i][1]], arr[i][2]);\n                i--;\n            }\n            \n            ll val = segTree.query(coord[q[1]], points.size());\n            \n            if(val == -INF) result[q[2]] = -1;\n            else result[q[2]] = val;\n        }\n        \n        return result;\n    }\n};",
        "content": "# Code\\n```\\nlong long INF = 1e14;\\n\\ntemplate <typename T = int> \\nclass SegmentTree {\\npublic:\\n    \\n    vector<T> st; \\n    vector<T> arr; \\n    int n; \\n\\t\\n\\tT invalidValue = -INF;\\n    \\n\\tint left(int ind) {\\n\\t\\treturn 2*ind + 1;\\n\\t}\\n\\n\\tint right(int ind) {\\n\\t\\treturn 2*ind + 2;\\n\\t}\\n\\n\\tT operate(T a, T b){\\n\\t\\treturn max(a, b);\\n\\t}\\n\\n\\tvoid pull(int ind) {\\n\\t\\tst[ind] = operate(st[left(ind)], st[right(ind)]);\\n\\t}\\n\\n    \\n    void build(int l, int r, int ind){\\n        if(l == r){\\n            st[ind] = arr[l];\\n            return;\\n        }\\n        \\n        int m = (l+r)/2;\\n        \\n        build(l, m, left(ind));\\n        build(m+1, r, right(ind));\\n        \\n        pull(ind);\\n    }\\n    \\n    T query(int l, int r, int i, int j, int ind){\\n        if(l>=i and r<=j){\\n            return st[ind];\\n        }\\n\\n        if(r<i or l>j){\\n            return invalidValue;\\n        }\\n        \\n        int m = (l+r)/2;\\n\\n\\t\\tT leftVal = query(l, m, i, j, left(ind));\\n\\t\\tT rightVal = query(m+1, r, i, j, right(ind));\\n\\n        return operate(leftVal, rightVal);\\n    }\\n    \\n    void update(int l, int r, T val, int i, int ind){\\n\\t\\tif(l == r){\\n\\t\\t\\tif(l == i){\\n\\t\\t\\t\\tst[ind] = max(st[ind], val);\\n                arr[l] = max(arr[l], val);\\n\\t\\t\\t}\\n\\t\\t\\treturn;\\n\\t\\t}\\n        if(i<l or i>r){\\n            return;\\n        }\\n        \\n        if(l != r){\\n            int m = (l+r)/2;\\n            update(l, m, val, i, left(ind));\\n            update(m+1, r, val, i, right(ind));\\n\\t\\t\\tpull(ind);\\n        }\\n    }\\n\\n    SegmentTree(int n) {\\n        this->n = n;\\n        arr = vector<T>(n, -INF);\\n        st = vector<T>(4*n);\\n\\n        build(0, n-1, 0);\\n    }\\n    \\n    void update(int index, T val) {\\n        arr[index] = val;\\n        update(0, n-1, val, index, 0);\\n    }\\n    \\n    T query(int left, int right) {\\n        return query(0, n-1, left, right, 0);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> maximumSumQueries(vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& queries) {\\n        vector<vector<int>> arr;\\n        vector<int> points;\\n        \\n        for(int i=0; i<nums1.size(); i++) {\\n            arr.push_back({nums1[i], nums2[i], nums1[i]+nums2[i]});\\n            points.push_back(nums2[i]);\\n        }\\n        \\n        sort(arr.begin(), arr.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0] == b[0]) return a[2] > b[2];\\n            return a[0] < b[0];\\n        });\\n        \\n        for(int i=0; i<queries.size(); i++) {\\n            queries[i].push_back(i);\\n            points.push_back(queries[i][1]);\\n        }\\n        \\n        sort(points.begin(), points.end());\\n        points.erase(unique(points.begin(), points.end()), points.end());\\n        map<int,int> coord;\\n        \\n        for(int i=0; i<points.size(); i++) {\\n            coord[points[i]] = i;\\n        }\\n        \\n        sort(queries.rbegin(), queries.rend());\\n        \\n        vector<int> result(queries.size());\\n        int i = arr.size()-1;\\n        \\n        using ll = long long;        \\n        SegmentTree<ll> segTree(points.size());\\n        \\n        for(vector<int>& q : queries) {\\n            while(i>=0 and arr[i][0] >= q[0]) {\\n                segTree.update(coord[arr[i][1]], arr[i][2]);\\n                i--;\\n            }\\n            \\n            ll val = segTree.query(coord[q[1]], points.size());\\n            \\n            if(val == -INF) result[q[2]] = -1;\\n            else result[q[2]] = val;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```"
    },
    {
        "slug": "pascals-triangle-ii",
        "tags": "cpp",
        "release_time": 1692420205,
        "code": "class Solution {\npublic:\n    vector<int> getRow(int rowIndex) {\n        vector<vector<int>>v;\n        vector<int>e;\n    for (int i=0;i<=rowIndex;i++)\n    {\n        vector<int>a;\n        for (int j=0;j<=i;j++)\n        {\n            if (j==0 || j==i){a.push_back(1);}\n            else\n            {\n                a.push_back(v[i-1][j]+v[i-1][j-1]);\n            }\n        }\n        if (i==rowIndex){return a;}\n        v.push_back(a);\n    }\n    return e;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getRow(int rowIndex) {\\n        vector<vector<int>>v;\\n        vector<int>e;\\n    for (int i=0;i<=rowIndex;i++)\\n    {\\n        vector<int>a;\\n        for (int j=0;j<=i;j++)\\n        {\\n            if (j==0 || j==i){a.push_back(1);}\\n            else\\n            {\\n                a.push_back(v[i-1][j]+v[i-1][j-1]);\\n            }\\n        }\\n        if (i==rowIndex){return a;}\\n        v.push_back(a);\\n    }\\n    return e;\\n    }\\n};\\n```"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "tags": "cpp",
        "release_time": 1680016299,
        "code": "class Solution {\npublic:\n    bool queryString(string s, int n)\n     {\n        unordered_set<int> seen;\n        int len = s.length();\n        for(int i=len-1;i>=0;i--)\n        {\n            int num = 0;\n            for(int j=1;j<=min(len-i,31);j++)\n            { \n                num = num*2 + (s[i+j-1] == '1' ? 1 : 0);\n                if(0 < num && num <= n) seen.insert(num);\n            }\n            if(seen.size() == n) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool queryString(string s, int n)\\n     {\\n        unordered_set<int> seen;\\n        int len = s.length();\\n        for(int i=len-1;i>=0;i--)\\n        {\\n            int num = 0;\\n            for(int j=1;j<=min(len-i,31);j++)\\n            { \\n                num = num*2 + (s[i+j-1] == \\'1\\' ? 1 : 0);\\n                if(0 < num && num <= n) seen.insert(num);\\n            }\\n            if(seen.size() == n) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "the-k-strongest-values-in-an-array",
        "tags": "cpp",
        "release_time": 1675661148,
        "code": "class Solution {\npublic:\n    vector<int> getStrongest(vector<int>& arr, int k) {\n        vector<pair<int,int>>v;\n        int sum=0,n=arr.size();\n        sort(arr.begin(),arr.end());\n        int median=arr[(n-1)/2];\n        for(int i=0;i<arr.size();i++)\n        {\n            v.push_back({abs(arr[i]-median),arr[i]});\n        }\n        sort(v.begin(),v.end());\n        reverse(v.begin(),v.end());\n        vector<int>ans;\n        for(int i=0;i<k;i++)\n        {\n            ans.push_back(v[i].second);\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getStrongest(vector<int>& arr, int k) {\\n        vector<pair<int,int>>v;\\n        int sum=0,n=arr.size();\\n        sort(arr.begin(),arr.end());\\n        int median=arr[(n-1)/2];\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            v.push_back({abs(arr[i]-median),arr[i]});\\n        }\\n        sort(v.begin(),v.end());\\n        reverse(v.begin(),v.end());\\n        vector<int>ans;\\n        for(int i=0;i<k;i++)\\n        {\\n            ans.push_back(v[i].second);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/ac5baf5d-2804-447b-b09e-5ff966529a4b_1675661178.3177938.jpeg)\\n\\n"
    },
    {
        "slug": "3sum-closest",
        "tags": "cpp",
        "release_time": 1689058105,
        "code": "class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n        int prev=nums[0]+nums[1]+nums[2];\n        for(int i=0;i<nums.size()-1;i++){\n            int j=i+1;\n            int k=nums.size()-1;\n            while(j<k){\n                int sum=nums[i]+nums[j]+nums[k];\n                if(abs(sum-target)<abs(prev-target))\n                prev=sum;\n                \n                if(sum<target)\n                j++;\n                else\n                k--;\n            }\n        }\n        return prev;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts",
        "tags": "cpp",
        "release_time": 1679675511,
        "code": "class Solution {\npublic:\n    int maxArea(int h, int x, vector<int>& ha, vector<int>& v) {   \n        ha.push_back(h);\n        sort(ha.begin(), ha.end());\n\t\tint maxh = ha[0];\n        for(int i=1; i<ha.size(); i++){\n            maxh = max(maxh, ha[i] - ha[i-1]);\n        }\n        v.push_back(x);\n        sort(v.begin(), v.end());\n\t\tint maxv = v[0];\n        for(int i=1; i<v.size(); i++){\n            maxv = max(maxv, v[i] - v[i-1]);\n        }\n        return (1LL*maxh*maxv) % 1000000007;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxArea(int h, int x, vector<int>& ha, vector<int>& v) {   \\n        ha.push_back(h);\\n        sort(ha.begin(), ha.end());\\n\\t\\tint maxh = ha[0];\\n        for(int i=1; i<ha.size(); i++){\\n            maxh = max(maxh, ha[i] - ha[i-1]);\\n        }\\n        v.push_back(x);\\n        sort(v.begin(), v.end());\\n\\t\\tint maxv = v[0];\\n        for(int i=1; i<v.size(); i++){\\n            maxv = max(maxv, v[i] - v[i-1]);\\n        }\\n        return (1LL*maxh*maxv) % 1000000007;\\n    }\\n};\\n```"
    },
    {
        "slug": "add-binary",
        "tags": "cpp",
        "release_time": 1676392785,
        "code": "class Solution {\npublic:\n    string addBinary(string a, string b) {\n        int c=0;\n        string s=\"\";\n        int i=0;\n        while(i<a.length() || i<b.length() || c!=0){\n            int x=0;\n            if(i<a.length() && a[a.length()-i-1]=='1')\n                x=1;\n            int y=0;\n            if(i<b.length() && b[b.length()-1-i]=='1')\n                y=1;\n            s=to_string((x+y+c)%2)+s;\n            c=(x+y+c)/2;\n            i++;\n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addBinary(string a, string b) {\\n        int c=0;\\n        string s=\"\";\\n        int i=0;\\n        while(i<a.length() || i<b.length() || c!=0){\\n            int x=0;\\n            if(i<a.length() && a[a.length()-i-1]==\\'1\\')\\n                x=1;\\n            int y=0;\\n            if(i<b.length() && b[b.length()-1-i]==\\'1\\')\\n                y=1;\\n            s=to_string((x+y+c)%2)+s;\\n            c=(x+y+c)/2;\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```"
    },
    {
        "slug": "spiral-matrix-ii",
        "tags": "cpp",
        "release_time": 1683691003,
        "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> mat(n,vector<int>(n,0));\n\n        int startingRow=0;\n        int endingRow=n-1;\n        int startingCol=0;\n        int endingCol=n-1;\n        int k=1;\n        int last=n*n;\n    while(k<=last){\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\n            mat[startingRow][i]=k++;\n        }\n        startingRow++;\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\n            mat[i][endingCol]=k++;\n        }\n\n        endingCol--;\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\n            mat[endingRow][i]=k++;\n        }\n        endingRow--;\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\n            mat[i][startingCol]=k++;\n        }\n        startingCol++;\n     }\n     return mat;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to generate a square matrix of size n with elements from 1 to n^2 in spiral order. To generate the matrix in spiral order, we can start by filling in the top row from left to right, then the right column from top to bottom, then the bottom row from right to left, and finally the left column from bottom to top. We can repeat this process until all the elements of the matrix have been filled in.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Create an n x n matrix with all elements initialized to 0.\\n2.Initialize variables startingRow, endingRow, startingCol, and endingCol to keep track of the current boundaries of the matrix.\\n3.Initialize k to 1, which represents the current element to be filled in the matrix.\\n4.Use a while loop to iterate over the matrix until all elements have been filled.\\n5.Within the while loop, use four for loops to fill in the elements of the matrix in spiral order:\\n6.The first loop fills in the top row of the matrix from left to right.\\n7.The second loop fills in the right column of the matrix from top to bottom.\\n8.The third loop fills in the bottom row of the matrix from right to left.\\n9.The fourth loop fills in the left column of the matrix from bottom to top.\\n10.After each loop, update the boundaries of the matrix by incrementing or decrementing the appropriate variables.\\n11.Increment k after each element is filled in the matrix.\\n12.Return the resulting matrix.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n^2) because the while loop iterates over all n^2 elements of the matrix, and each element is filled in exactly once.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n^2) because we create an n x n matrix to store the resulting elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> generateMatrix(int n) {\\n        vector<vector<int>> mat(n,vector<int>(n,0));\\n\\n        int startingRow=0;\\n        int endingRow=n-1;\\n        int startingCol=0;\\n        int endingCol=n-1;\\n        int k=1;\\n        int last=n*n;\\n    while(k<=last){\\n        for(int i=startingCol;k<=last,i<=endingCol;i++){\\n            mat[startingRow][i]=k++;\\n        }\\n        startingRow++;\\n        for(int i=startingRow;k<=last,i<=endingRow;i++){\\n            mat[i][endingCol]=k++;\\n        }\\n\\n        endingCol--;\\n        for(int i=endingCol;k<=last,i>=startingCol;i--){\\n            mat[endingRow][i]=k++;\\n        }\\n        endingRow--;\\n        for(int i=endingRow;k<=last, i>=startingRow;i--){\\n            mat[i][startingCol]=k++;\\n        }\\n        startingCol++;\\n     }\\n     return mat;\\n    }\\n};\\n```"
    },
    {
        "slug": "target-sum",
        "tags": "cpp",
        "release_time": 1689667126,
        "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // idx, target -> no of ways\n        map<pair<int, int>, int> memo;\n        return dp(nums, target, 0, memo); \n    }\n\nprivate:\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\n        if (idx == nums.size()) return target == 0;\n        if (memo.count({idx, target})) return memo[{idx, target}];\n\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\n\n        return memo[{idx, target}] = positive + negative;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findTargetSumWays(vector<int>& nums, int target) {\\n        // idx, target -> no of ways\\n        map<pair<int, int>, int> memo;\\n        return dp(nums, target, 0, memo); \\n    }\\n\\nprivate:\\n    int dp(vector<int>& nums, int target, int idx, map<pair<int, int>, int>& memo) {\\n        if (idx == nums.size()) return target == 0;\\n        if (memo.count({idx, target})) return memo[{idx, target}];\\n\\n        int positive = dp(nums, target + nums[idx], idx + 1, memo);\\n        int negative = dp(nums, target - nums[idx], idx + 1, memo);\\n\\n        return memo[{idx, target}] = positive + negative;\\n    }\\n};\\n```"
    },
    {
        "slug": "prime-arrangements",
        "tags": "cpp",
        "release_time": 1674659389,
        "code": "class Solution {\npublic:\n    long long fact(int n)\n    {\n        if(n<=1)return 1;\n        return (n*fact(n-1)%1000000007)%1000000007;\n    }\n    int numPrimeArrangements(int n) {\n        if(n==1)return 1;\n        if(n<=3)return n-1;\n        int t=0,flag;\n        for(int i=2;i<=n;i++)\n        {\n            flag=0;\n            for(int j=2;j<=sqrt(i);j++)\n            {\n                if(i%j==0)\n                {\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0)\n            {\n                t++;\n            }\n        }\n        return (fact(t)*fact(n-t))%1000000007;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long fact(int n)\\n    {\\n        if(n<=1)return 1;\\n        return (n*fact(n-1)%1000000007)%1000000007;\\n    }\\n    int numPrimeArrangements(int n) {\\n        if(n==1)return 1;\\n        if(n<=3)return n-1;\\n        int t=0,flag;\\n        for(int i=2;i<=n;i++)\\n        {\\n            flag=0;\\n            for(int j=2;j<=sqrt(i);j++)\\n            {\\n                if(i%j==0)\\n                {\\n                    flag=1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                t++;\\n            }\\n        }\\n        return (fact(t)*fact(n-t))%1000000007;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "sort-an-array",
        "tags": "cpp",
        "release_time": 1677690796,
        "code": "class Solution {\npublic:\n    void merge(int low, int mid, int high, vector<int> &nums) {\n        if (low >= high) \n        return;\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\n        vector<int> sorted(size, 0);\n        while (l <= mid and r <= high)\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\n        while (l <= mid) \n            sorted[k++] = nums[l++];\n        while (r <= high) \n            sorted[k++] = nums[r++];\n        for (k = 0; k < size; k++)\n            nums[k + low] = sorted[k];\n    }\n\n    void mergeSort(vector<int>& nums, int start, int end){\n        if(start < end){\n            int mid = start + (end - start) / 2;\n            mergeSort(nums, start, mid);\n            mergeSort(nums, mid + 1, end);\n            merge(start, mid, end, nums);\n        }\n    }\n\n    vector<int> sortArray(vector<int>& nums) {\n        mergeSort(nums, 0, nums.size()-1);\n        return nums;\n    }\n};",
        "content": "# Approach\\nThis is an implementation of the merge sort algorithm in C++. The merge sort algorithm uses a divide-and-conquer approach to sort a given array by recursively dividing the input array into two halves, sorting them separately, and then merging them back together in the correct order.\\n\\nThe merge function takes in four parameters: low, mid, high, and nums. low and high represent the indices of the start and end of the subarray that needs to be merged, respectively. mid represents the index of the middle element of the subarray. nums is a reference to the vector of integers that needs to be sorted.\\n\\nIn the merge function, a new vector sorted of size high - low + 1 is created to store the sorted subarray. The two halves of the subarray are then compared and merged into sorted using a while loop. Finally, the sorted subarray is copied back into the original array nums using a for loop.\\n\\nThe mergeSort function takes in three parameters: nums, start, and end. nums is a reference to the vector of integers that needs to be sorted. start and end represent the indices of the start and end of the subarray that needs to be sorted, respectively. In the mergeSort function, the input subarray is recursively divided into two halves using mid, and each half is sorted using the mergeSort function. The merge function is then called to merge the two sorted halves back together in the correct order.\\n\\nFinally, the sortArray function takes in a reference to the vector of integers that needs to be sorted and calls the mergeSort function to sort the entire array. It then returns the sorted array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void merge(int low, int mid, int high, vector<int> &nums) {\\n        if (low >= high) \\n        return;\\n        int l = low, r = mid + 1, k = 0, size = high - low + 1;\\n        vector<int> sorted(size, 0);\\n        while (l <= mid and r <= high)\\n            sorted[k++] = nums[l] < nums[r] ? nums[l++] : nums[r++];\\n        while (l <= mid) \\n            sorted[k++] = nums[l++];\\n        while (r <= high) \\n            sorted[k++] = nums[r++];\\n        for (k = 0; k < size; k++)\\n            nums[k + low] = sorted[k];\\n    }\\n\\n    void mergeSort(vector<int>& nums, int start, int end){\\n        if(start < end){\\n            int mid = start + (end - start) / 2;\\n            mergeSort(nums, start, mid);\\n            mergeSort(nums, mid + 1, end);\\n            merge(start, mid, end, nums);\\n        }\\n    }\\n\\n    vector<int> sortArray(vector<int>& nums) {\\n        mergeSort(nums, 0, nums.size()-1);\\n        return nums;\\n    }\\n};"
    },
    {
        "slug": "the-number-of-beautiful-subsets",
        "tags": "cpp",
        "release_time": 1679198543,
        "code": "class Solution {\npublic:\n    int beautifulSubsets(vector<int>& nums, int k) {\n        vector<int> cur;\n        return helper(nums, k, cur, 0);\n    }\n    private:\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\n        int cnt = 0;\n        for (int i = start; i < nums.size(); ++i) {\n            if (!test(cur, nums[i], k))\n                continue;\n            cur.push_back(nums[i]);\n            cnt++;\n            cnt += helper(nums, k, cur, i + 1);\n            cur.pop_back();\n        }\n        return cnt;\n    }\n    bool test(vector<int>& cur, int num, int k) {\n        for (auto &c : cur)\n            if (abs(num - c) == k)\n                return false;\n        return true;\n    }\n};",
        "content": "\\n# Solution 1\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\n    private:\\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (!test(cur, nums[i], k))\\n                continue;\\n            cur.push_back(nums[i]);\\n            cnt++;\\n            cnt += helper(nums, k, cur, i + 1);\\n            cur.pop_back();\\n        }\\n        return cnt;\\n    }\\n    bool test(vector<int>& cur, int num, int k) {\\n        for (auto &c : cur)\\n            if (abs(num - c) == k)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n# Solution2 : HashMap cur frequency\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\nprivate:\\n    int helper(vector<int>& nums, int k, unordered_map<int, int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (cur[nums[i] - k] || cur[nums[i] + k])\\n                continue;\\n            cur[nums[i]]++;\\n            cnt += 1 + helper(nums, k, cur, i + 1);\\n            cur[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```"
    },
    {
        "slug": "most-profit-assigning-work",
        "tags": "cpp",
        "release_time": 1680459830,
        "code": "class Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\n        int n=difficulty.size();\n        vector<pair<int,int>> nums;\n\n        for(int i=0;i<n;i++){\n            nums.push_back({profit[i],difficulty[i]});\n        }\n        sort(nums.begin(),nums.end());\n        int index=n-1;\n        int ans=0;\n        sort(worker.begin(),worker.end());\n        \n        for(int i=worker.size()-1;i>=0;i--){\n            while(index>=0 && nums[index].second>worker[i]) index--;\n            if(index==-1) continue;\n            ans+=nums[index].first;\n        }\n        return ans;        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. make **vector{profit,difficulty}** and sort it \\n2. sort worker array \\n3. keep index at last of sorted vector{profit,difficulty}\\n4. **start from last of sorted worker array** and check for worker[i]>=difficulty of sorted array{profit,difficulty} \\n4,1. If not greater, do index-- till greater found and add that profit to final ans **because profits beyond that cannot be acquired by other workers futher in iteration** \\n4,2. Else add vector{profit,difficulty}[index] to finalAns\\n5. Return final Answer\\n \\n\\n\\n# Complexity\\nlength of difficulty array=n\\nlength of worker array=m\\n- Time complexity:O(nlogn+mlogm+n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfitAssignment(vector<int>& difficulty, vector<int>& profit, vector<int>& worker){\\n        int n=difficulty.size();\\n        vector<pair<int,int>> nums;\\n\\n        for(int i=0;i<n;i++){\\n            nums.push_back({profit[i],difficulty[i]});\\n        }\\n        sort(nums.begin(),nums.end());\\n        int index=n-1;\\n        int ans=0;\\n        sort(worker.begin(),worker.end());\\n        \\n        for(int i=worker.size()-1;i>=0;i--){\\n            while(index>=0 && nums[index].second>worker[i]) index--;\\n            if(index==-1) continue;\\n            ans+=nums[index].first;\\n        }\\n        return ans;        \\n    }\\n};\\n```"
    },
    {
        "slug": "largest-1-bordered-square",
        "tags": "cpp",
        "release_time": 1689400545,
        "code": "class Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int r = grid.size();\n        int c = grid[0].size();\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\n        \n        int mx = 0;\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(grid[i][j]!=0){\n                    \n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\n                    \n                    int sz = min(dp[i][j].first, dp[i][j].second);\n                    while(sz>mx){\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\n                        if(p>=sz)\n                            mx = max(mx,sz);\n                        sz--;\n                    }\n                }\n            }\n        }\n            \n        return mx*mx;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\\n        int r = grid.size();\\n        int c = grid[0].size();\\n        vector<vector<pair<int,int>>> dp(r, vector<pair<int,int>>(c,{0,0}));\\n        \\n        int mx = 0;\\n\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(grid[i][j]!=0){\\n                    \\n                    dp[i][j].first = i == 0 ? 1 : dp[i-1][j].first+1;\\n                    dp[i][j].second = j == 0 ? 1 : dp[i][j-1].second+1;\\n                    \\n                    int sz = min(dp[i][j].first, dp[i][j].second);\\n                    while(sz>mx){\\n                        int p = min(dp[i-sz+1][j].second,dp[i][j-sz+1].first);\\n                        if(p>=sz)\\n                            mx = max(mx,sz);\\n                        sz--;\\n                    }\\n                }\\n            }\\n        }\\n            \\n        return mx*mx;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-gap",
        "tags": "cpp",
        "release_time": 1689500719,
        "code": "class Solution {\npublic:\n\nvector<int> countsort(vector<int> &nums)\n{\n    int n = nums.size();\n    map<int, int> m;\n    for (int i = 0; i < n; i++ )\n        m[nums[i]]++;\n\n    nums.clear();\n    for (auto it : m)\n    {\n        int cnt = it.second;\n        while (cnt--)\n        {\n            nums.push_back(it.first);\n        }\n    }\n    return nums;\n}\n\nint maximumGap(vector<int> &nums)\n{\n    int n = nums.size();\n    if (n < 2)\n        return 0;\n    vector<int> sortednums = countsort(nums);\n\n    int maxgap = INT_MIN;\n    for (int i = 1; i < n; i++)\n    {\n        int currgap = sortednums[i] - sortednums[i - 1];\n        maxgap = max(maxgap, currgap);\n    }\n\n    return maxgap;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsince it is given in the question that we can use only linear time and space so we can only use a kind of counting sort , where we required a hash map which take an extra o(n) time complexity.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn counting sort first we required an hash map where we store the frequency of each element and after storing the frequency we just need to fill the original array based on there frequency , here we use an map not unordered map because the map is store value in sorted order.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwe are traversing the array once , so  it is O(n) and an extra (logn)\\nfactor comes because of using the map, but still it is better in terms of time from inbuilt sort function..\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) we are using only an map so the total extra space is equal to the size of map.\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvector<int> countsort(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    map<int, int> m;\\n    for (int i = 0; i < n; i++ )\\n        m[nums[i]]++;\\n\\n    nums.clear();\\n    for (auto it : m)\\n    {\\n        int cnt = it.second;\\n        while (cnt--)\\n        {\\n            nums.push_back(it.first);\\n        }\\n    }\\n    return nums;\\n}\\n\\nint maximumGap(vector<int> &nums)\\n{\\n    int n = nums.size();\\n    if (n < 2)\\n        return 0;\\n    vector<int> sortednums = countsort(nums);\\n\\n    int maxgap = INT_MIN;\\n    for (int i = 1; i < n; i++)\\n    {\\n        int currgap = sortednums[i] - sortednums[i - 1];\\n        maxgap = max(maxgap, currgap);\\n    }\\n\\n    return maxgap;\\n}\\n};\\n```"
    },
    {
        "slug": "design-twitter",
        "tags": "cpp",
        "release_time": 1678027467,
        "code": "class Twitter {\npublic:\n    struct Tweet {\n        int tweetId;\n        int timestamp;\n        Tweet(int tweetId, int timestamp): tweetId(tweetId), timestamp(timestamp) {}\n    };\n\n    class MyComparator {\n    public:\n        bool operator() (const Tweet* tweet1, const Tweet* tweet2) {\n            return tweet1->timestamp < tweet2->timestamp;\n        }\n    };\n\n    unordered_map<int, vector<Tweet*>> userTweets;\n    unordered_map<int, unordered_set<int>> userFollowings;\n    int counter = 0;\n\n    Twitter() {\n        \n    }\n    \n    void postTweet(int userId, int tweetId) {\n        Tweet* tweet = new Tweet(tweetId, counter);\n        counter++;\n\n        if (userTweets.count(userId)) {\n            if (userTweets[userId].size() == 10) {\n                userTweets[userId].erase(userTweets[userId].begin());\n                userTweets[userId].push_back(tweet);\n            } else {\n                userTweets[userId].push_back(tweet);\n            }\n        } else {\n            userTweets[userId].push_back(tweet);\n        }\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        priority_queue<Tweet*, vector<Tweet*>, MyComparator> tweets;\n        unordered_set<int> followers = userFollowings[userId];\n        for (auto it = followers.begin(); it != followers.end(); it++) {\n            for (Tweet* tweet : userTweets[*it]) {\n                tweets.push(tweet);\n            }\n        }\n        for (Tweet* tweet : userTweets[userId]) {\n            tweets.push(tweet);\n        }\n        int count = 0;\n        vector<int> res;\n        while (count < 10 && !tweets.empty()) {\n            Tweet* tweet = tweets.top(); tweets.pop();\n            res.push_back(tweet->tweetId);\n            count++;\n        }\n        return res;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        userFollowings[followerId].insert(followeeId);\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        userFollowings[followerId].erase(followeeId);\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj->postTweet(userId,tweetId);\n * vector<int> param_2 = obj->getNewsFeed(userId);\n * obj->follow(followerId,followeeId);\n * obj->unfollow(followerId,followeeId);\n */",
        "content": "# Complexity\\n- Time complexity: \\n    - As each user\\'s tweet has a max length of 10, `postTweet` time complexity is O(1).\\n    - `follow` and `unfollow` time complexity is O(1).\\n    - `getNewsFeed` uses priority_queue, which has O(nlogn) complexity to build, where N is the number of followers the user follows \\n\\n# Code\\n```\\nclass Twitter {\\npublic:\\n    struct Tweet {\\n        int tweetId;\\n        int timestamp;\\n        Tweet(int tweetId, int timestamp): tweetId(tweetId), timestamp(timestamp) {}\\n    };\\n\\n    class MyComparator {\\n    public:\\n        bool operator() (const Tweet* tweet1, const Tweet* tweet2) {\\n            return tweet1->timestamp < tweet2->timestamp;\\n        }\\n    };\\n\\n    unordered_map<int, vector<Tweet*>> userTweets;\\n    unordered_map<int, unordered_set<int>> userFollowings;\\n    int counter = 0;\\n\\n    Twitter() {\\n        \\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        Tweet* tweet = new Tweet(tweetId, counter);\\n        counter++;\\n\\n        if (userTweets.count(userId)) {\\n            if (userTweets[userId].size() == 10) {\\n                userTweets[userId].erase(userTweets[userId].begin());\\n                userTweets[userId].push_back(tweet);\\n            } else {\\n                userTweets[userId].push_back(tweet);\\n            }\\n        } else {\\n            userTweets[userId].push_back(tweet);\\n        }\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        priority_queue<Tweet*, vector<Tweet*>, MyComparator> tweets;\\n        unordered_set<int> followers = userFollowings[userId];\\n        for (auto it = followers.begin(); it != followers.end(); it++) {\\n            for (Tweet* tweet : userTweets[*it]) {\\n                tweets.push(tweet);\\n            }\\n        }\\n        for (Tweet* tweet : userTweets[userId]) {\\n            tweets.push(tweet);\\n        }\\n        int count = 0;\\n        vector<int> res;\\n        while (count < 10 && !tweets.empty()) {\\n            Tweet* tweet = tweets.top(); tweets.pop();\\n            res.push_back(tweet->tweetId);\\n            count++;\\n        }\\n        return res;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        userFollowings[followerId].insert(followeeId);\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        userFollowings[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```"
    },
    {
        "slug": "longest-univalue-path",
        "tags": "cpp",
        "release_time": 1671641812,
        "code": "class Solution {\n    pair<int, int> dfs(TreeNode* root, int &ans) {\n        if(!root) return {1e9, 0};\n        auto p1 = dfs(root -> left, ans);\n        auto p2 = dfs(root -> right, ans);\n\n        int l1 = 0, l2 = 0;\n        if(p1.first == root -> val) l1 += p1.second + 1;\n        if(p2.first == root -> val) l2 += p2.second + 1;\n        ans = max(ans, l1 + l2);\n        return {root -> val, max(l1, l2)};\n    }\npublic:\n    int longestUnivaluePath(TreeNode* root) {\n        int ans = 0;\n        dfs(root, ans);\n\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {1e9, 0};\\n        auto p1 = dfs(root -> left, ans);\\n        auto p2 = dfs(root -> right, ans);\\n\\n        int l1 = 0, l2 = 0;\\n        if(p1.first == root -> val) l1 += p1.second + 1;\\n        if(p2.first == root -> val) l2 += p2.second + 1;\\n        ans = max(ans, l1 + l2);\\n        return {root -> val, max(l1, l2)};\\n    }\\npublic:\\n    int longestUnivaluePath(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "egg-drop-with-2-eggs-and-n-floors",
        "tags": "cpp",
        "release_time": 1680711616,
        "code": "class Solution {\npublic:\n    int twoEggDrop(int n) {\n        int i=1,steps=0;\n        while(n>0){\n            n-=i;\n            i++;\n            steps++;\n        }\n        return steps;\n    }\n};",
        "content": "![image.png](https://assets.leetcode.com/users/images/618df341-7dc8-4da2-bd73-cf5f26afc785_1680711701.8926115.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int twoEggDrop(int n) {\\n        int i=1,steps=0;\\n        while(n>0){\\n            n-=i;\\n            i++;\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```"
    },
    {
        "slug": "flood-fill",
        "tags": "cpp",
        "release_time": 1685971605,
        "code": "class Solution {\npublic:\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\n    {\n        // it'll ease the work\n        queue<pair<int,int>> q;\n        q.push({row,col});\n        visited[row][col]=1;\n\n        while(!q.empty())\n        {\n            row = q.front().first;\n            col = q.front().second;\n            q.pop();\n\n            // if img is of the starting color.\n            if(image[row][col]==prevcolor) image[row][col]=color;\n\n            // up\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\n\n            // right\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\n\n            //down\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\n\n            // left\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\n        }\n    }\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\n          int prevcolor = image[sr][sc];\n\n          // visiting array.\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\n\n          bfs(prevcolor,sr,sc,color,visited,image);\n\n          return image;\n    }\n};",
        "content": "# Algo\\n\\n1.  Make a visited array of n*m\\n2. store the initial color.\\n3. do the traversal\\n4. Use queue data structure. \\n\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int prevcolor,int row,int col,int color,vector<vector<int>>&visited,vector<vector<int>>&image)\\n    {\\n        // it\\'ll ease the work\\n        queue<pair<int,int>> q;\\n        q.push({row,col});\\n        visited[row][col]=1;\\n\\n        while(!q.empty())\\n        {\\n            row = q.front().first;\\n            col = q.front().second;\\n            q.pop();\\n\\n            // if img is of the starting color.\\n            if(image[row][col]==prevcolor) image[row][col]=color;\\n\\n            // up\\n            if(row-1>=0 && !visited[row-1][col] && image[row-1][col]==prevcolor) q.push({row-1,col}),visited[row-1][col]=1, image[row-1][col]=color;\\n\\n            // right\\n            if(col+1<image[0].size() &&  !visited[row][col+1] && image[row][col+1]==prevcolor) q.push({row,col+1}),visited[row][col+1]=1, image[row][col+1]=color;\\n\\n            //down\\n            if(row+1<image.size() && !visited[row+1][col] && image[row+1][col]==prevcolor) q.push({row+1,col}),visited[row+1][col]=1, image[row+1][col]=color;\\n\\n            // left\\n            if(col-1>=0 && !visited[row][col-1] && image[row][col-1]==prevcolor) q.push({row,col-1}),visited[row][col-1]=1, image[row][col-1]=color;\\n        }\\n    }\\n    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int color) {\\n          int prevcolor = image[sr][sc];\\n\\n          // visiting array.\\n          vector<vector<int>> visited(image.size(),vector<int>(image[0].size(),0));\\n\\n          bfs(prevcolor,sr,sc,color,visited,image);\\n\\n          return image;\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-path-with-alternating-colors",
        "tags": "cpp",
        "release_time": 1676113078,
        "code": "class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \n    {\n        multiset<int>temp;\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\n        for(auto j:redEdges)\n        {\n            redchilds[j[0]].insert(j[1]);\n        }\n        for(auto j:blueEdges)\n        {\n            bluechilds[j[0]].insert(j[1]);\n        }\n        vector<int>ans;\n        for(int i=0;i<n;i++)\n        {\n            //BFS for all\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\n            queue<pair<char,int>>visit;\n            visit.push({'n',0});//neutral='n'\n            int steps=0;\n            while(!visit.empty())\n            {\n                bool justbreak=false;\n                int n=visit.size();\n                for(int j=0;j<n;j++)\n                {\n                    pair<char,int>x=visit.front();\n                    visit.pop();\n                    if(x.second==i)\n                    {\n                        ans.push_back(steps);\n                        justbreak=true;\n                        break;\n                    }\n                    if(x.first=='n')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});//blue='b'\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='b')\n                    {\n                        for(auto j:reds[x.second])\n                        {\n                            visit.push({'r',j});//red='r'\n                            auto itr1=reds[x.second].find(j);\n                            reds[x.second].erase(itr1);\n                        }\n                    }\n                    else if(x.first=='r')\n                    {\n                        for(auto j:blues[x.second])\n                        {\n                            visit.push({'b',j});\n                            auto itr1=blues[x.second].find(j);\n                            blues[x.second].erase(itr1);\n                        }\n                    }\n                }\n                if(justbreak)\n                {\n                    break;\n                }\n                steps++;\n            }\n            if(i==ans.size())\n            {\n                ans.push_back(-1);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "*E denotes number of Edges*\\n\\n# Complexity\\n- Time complexity:\\nO((N^2)+(N)*(E)*LOG(E))\\n\\n- Space complexity:\\nO(E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shortestAlternatingPaths(int n,vector<vector<int>>&redEdges,vector<vector<int>>& blueEdges) \\n    {\\n        multiset<int>temp;\\n        vector<multiset<int>>redchilds(n,temp),bluechilds(n,temp);\\n        for(auto j:redEdges)\\n        {\\n            redchilds[j[0]].insert(j[1]);\\n        }\\n        for(auto j:blueEdges)\\n        {\\n            bluechilds[j[0]].insert(j[1]);\\n        }\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            //BFS for all\\n            vector<multiset<int>>reds=redchilds,blues=bluechilds;\\n            queue<pair<char,int>>visit;\\n            visit.push({\\'n\\',0});//neutral=\\'n\\'\\n            int steps=0;\\n            while(!visit.empty())\\n            {\\n                bool justbreak=false;\\n                int n=visit.size();\\n                for(int j=0;j<n;j++)\\n                {\\n                    pair<char,int>x=visit.front();\\n                    visit.pop();\\n                    if(x.second==i)\\n                    {\\n                        ans.push_back(steps);\\n                        justbreak=true;\\n                        break;\\n                    }\\n                    if(x.first==\\'n\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});//blue=\\'b\\'\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'b\\')\\n                    {\\n                        for(auto j:reds[x.second])\\n                        {\\n                            visit.push({\\'r\\',j});//red=\\'r\\'\\n                            auto itr1=reds[x.second].find(j);\\n                            reds[x.second].erase(itr1);\\n                        }\\n                    }\\n                    else if(x.first==\\'r\\')\\n                    {\\n                        for(auto j:blues[x.second])\\n                        {\\n                            visit.push({\\'b\\',j});\\n                            auto itr1=blues[x.second].find(j);\\n                            blues[x.second].erase(itr1);\\n                        }\\n                    }\\n                }\\n                if(justbreak)\\n                {\\n                    break;\\n                }\\n                steps++;\\n            }\\n            if(i==ans.size())\\n            {\\n                ans.push_back(-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "string-to-integer-atoi",
        "tags": "cpp",
        "release_time": 1689150590,
        "code": "class Solution {\npublic:\n    int myAtoi(string s) {\n        long long res = 0; // stores our integer value\n        bool neg = 0; // checks whether integer will be -ve or +ve\n        bool leading = true; // true if theres leading spaces \n        \n        int n = s.size();\n\n        for (int i = 0; i<n; i++) {\n            if (s[i] == ' ') { // checks for leading spaces\n                if (leading) continue;\n                else break;\n            }\n            else if (s[i] == '-') { // checks -ve \n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\n                else break; // break if next char is non-digit\n            }\n            else if (s[i] == '+') { // checks for +ve\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\n                else break; // break if next char is non-digit\n            }\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\n            else { // storing our integer value to res\n                if (res < 1e11) {\n                    res = res*10 + (s[i]-'0');\n                    if (i+1 < n && !isdigit(s[i+1])) \n                        break;// break if next char is non-digit\n                }\n                else break;\n                leading = false; // tells that integer has been encoutered\n            }\n        }\n\n        if (res > INT_MAX && neg) return INT_MIN;\n        if (res > INT_MAX) return INT_MAX;\n\n        return neg ? -1*res : res;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int myAtoi(string s) {\\n        long long res = 0; // stores our integer value\\n        bool neg = 0; // checks whether integer will be -ve or +ve\\n        bool leading = true; // true if theres leading spaces \\n        \\n        int n = s.size();\\n\\n        for (int i = 0; i<n; i++) {\\n            if (s[i] == \\' \\') { // checks for leading spaces\\n                if (leading) continue;\\n                else break;\\n            }\\n            else if (s[i] == \\'-\\') { // checks -ve \\n                if (i+1 < n && isdigit(s[i+1])) neg = 1;\\n                else break; // break if next char is non-digit\\n            }\\n            else if (s[i] == \\'+\\') { // checks for +ve\\n                if (i+1 < n && isdigit(s[i+1])) neg = 0;\\n                else break; // break if next char is non-digit\\n            }\\n            else if (!isdigit(s[i])) break; // break on encoutring non-digit\\n            else { // storing our integer value to res\\n                if (res < 1e11) {\\n                    res = res*10 + (s[i]-\\'0\\');\\n                    if (i+1 < n && !isdigit(s[i+1])) \\n                        break;// break if next char is non-digit\\n                }\\n                else break;\\n                leading = false; // tells that integer has been encoutered\\n            }\\n        }\\n\\n        if (res > INT_MAX && neg) return INT_MIN;\\n        if (res > INT_MAX) return INT_MAX;\\n\\n        return neg ? -1*res : res;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "tags": "cpp",
        "release_time": 1685534792,
        "code": "class Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        vector<int> ans={-1,-1};\n        ListNode* prev=head;\n        if(!prev) return ans;\n        ListNode* curr=prev->next;\n        if(!curr) return ans;\n        ListNode* next=curr->next;\n        if(!next) return ans;\n\n        int first=-1;\n        int last=-1;\n        int mind=INT_MAX;\n        int i=1;\n        while(next){\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\n            if(iscp&&first==-1){\n                first=i;\n                last=i;\n            }\n            else if(iscp){\n                mind=min(mind,i-last);\n                last=i;\n            }\n            i++;\n            prev=curr;\n            curr=next;\n            next=next->next;\n        }\n        if(first==last)\n         return ans;\n         else\n         {\n             ans[0]=mind;\n             ans[1]=last-first;\n         }\n         return ans;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        vector<int> ans={-1,-1};\\n        ListNode* prev=head;\\n        if(!prev) return ans;\\n        ListNode* curr=prev->next;\\n        if(!curr) return ans;\\n        ListNode* next=curr->next;\\n        if(!next) return ans;\\n\\n        int first=-1;\\n        int last=-1;\\n        int mind=INT_MAX;\\n        int i=1;\\n        while(next){\\n            bool iscp=((curr->val>prev->val && curr->val>next->val)||(curr->val<prev->val&&curr->val<next->val))?true:false;\\n            if(iscp&&first==-1){\\n                first=i;\\n                last=i;\\n            }\\n            else if(iscp){\\n                mind=min(mind,i-last);\\n                last=i;\\n            }\\n            i++;\\n            prev=curr;\\n            curr=next;\\n            next=next->next;\\n        }\\n        if(first==last)\\n         return ans;\\n         else\\n         {\\n             ans[0]=mind;\\n             ans[1]=last-first;\\n         }\\n         return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "bitwise-and-of-numbers-range",
        "tags": "cpp",
        "release_time": 1689346823,
        "code": "class Solution {\npublic:\n    int solve(int left , int right){\n        if(left == 0)return 0;\n        int bit1 = log2(left);\n        int bit2 = log2(right);\n        if(bit1 < bit2)return 0;\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \n    }\n    int rangeBitwiseAnd(int left, int right) {\n         return solve(left , right);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int left , int right){\\n        if(left == 0)return 0;\\n        int bit1 = log2(left);\\n        int bit2 = log2(right);\\n        if(bit1 < bit2)return 0;\\n        return (1<<bit1) | solve((left^(1<<bit1)) , (right^(1<<bit1))); \\n    }\\n    int rangeBitwiseAnd(int left, int right) {\\n         return solve(left , right);\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-pairs-in-array",
        "tags": "cpp",
        "release_time": 1691523060,
        "code": "class Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        int n = nums.size();\n        vector<int>ans;\n        int cnt = 0;\n        sort(nums.begin(),nums.end());\n        for(int i = 1; i<n; i++){\n            if(nums[i]==nums[i-1]){\n                nums[i]=-1;\n                nums[i-1] = -1;\n                cnt++;\n            }\n        }\n        ans.push_back(cnt);\n        ans.push_back(n-2*cnt);\n\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numberOfPairs(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        int cnt = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 1; i<n; i++){\\n            if(nums[i]==nums[i-1]){\\n                nums[i]=-1;\\n                nums[i-1] = -1;\\n                cnt++;\\n            }\\n        }\\n        ans.push_back(cnt);\\n        ans.push_back(n-2*cnt);\\n\\n        return ans;\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "reverse-vowels-of-a-string",
        "tags": "cpp",
        "release_time": 1667534256,
        "code": "class Solution {\npublic:\n    string reverseVowels(string s) {\n        \n        vector<char> v;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U')\n                v.push_back(s[i]);\n        }\n        reverse(v.begin(), v.end());\n        int rev = 0;\n        for(int i = 0 ; i < s.length(); i++)\n        {\n            if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u'\n              || s[i] == 'A' || s[i] == 'E' || s[i] == 'O' || s[i] == 'I' || s[i] == 'U'){\n                s[i] = v[rev];\n                rev++;\n            }\n        }\n        return s;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseVowels(string s) {\\n        \\n        vector<char> v;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\')\\n                v.push_back(s[i]);\\n        }\\n        reverse(v.begin(), v.end());\\n        int rev = 0;\\n        for(int i = 0 ; i < s.length(); i++)\\n        {\\n            if(s[i] == \\'a\\' || s[i] == \\'e\\' || s[i] == \\'i\\' || s[i] == \\'o\\' || s[i] == \\'u\\'\\n              || s[i] == \\'A\\' || s[i] == \\'E\\' || s[i] == \\'O\\' || s[i] == \\'I\\' || s[i] == \\'U\\'){\\n                s[i] = v[rev];\\n                rev++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-events-that-can-be-attended-ii",
        "tags": "cpp",
        "release_time": 1689383558,
        "code": "class Solution {\npublic:\n    \n    vector<vector<int>> memo;\n    \n    // searching for 1st next non-conflicting event \n    int search(vector<vector<int>>& events, int end, int idx){\n        int n=events.size();\n        int l=idx, r=n-1;\n        while(l<r){\n            int m=l+(r-l)/2;\n            int start=events[m][0];\n            if(start>end){\n                r=m;\n            }else{\n                l=m+1;\n            }\n        }\n        \n        return ((l<n && events[l][0]>end) ? l:-1);\n    }\n    \n    int profit(vector<vector<int>>& events, int n, int k, int idx){\n        if(idx==n || k==0) return 0;\n        \n        if(memo[idx][k]!=-1) return memo[idx][k];\n        \n        int maxval=0;\n        \n        // not attend\n        maxval = profit(events, n, k, idx+1);\n        \n        // attend event\n        int next_possible_idx = search(events, events[idx][1], idx+1);\n        maxval = max(maxval, events[idx][2] + (next_possible_idx==-1 ? 0:profit(events,n,k-1,next_possible_idx)));\n        \n        return memo[idx][k]=maxval;\n    }\n    \n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());\n        \n        memo.resize(n,vector<int>(k+1,-1));\n        \n        return profit(events,n,k,0);\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n1. for each event we have 2 choices: attend or not attend\\n2. Not-Attend: just skip to next event \\n3. Attend: if start time of current event >end time of previously attended event\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> memo;\\n    \\n    // searching for 1st next non-conflicting event \\n    int search(vector<vector<int>>& events, int end, int idx){\\n        int n=events.size();\\n        int l=idx, r=n-1;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            int start=events[m][0];\\n            if(start>end){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        \\n        return ((l<n && events[l][0]>end) ? l:-1);\\n    }\\n    \\n    int profit(vector<vector<int>>& events, int n, int k, int idx){\\n        if(idx==n || k==0) return 0;\\n        \\n        if(memo[idx][k]!=-1) return memo[idx][k];\\n        \\n        int maxval=0;\\n        \\n        // not attend\\n        maxval = profit(events, n, k, idx+1);\\n        \\n        // attend event\\n        int next_possible_idx = search(events, events[idx][1], idx+1);\\n        maxval = max(maxval, events[idx][2] + (next_possible_idx==-1 ? 0:profit(events,n,k-1,next_possible_idx)));\\n        \\n        return memo[idx][k]=maxval;\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        \\n        memo.resize(n,vector<int>(k+1,-1));\\n        \\n        return profit(events,n,k,0);\\n    }\\n};\\n```"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "tags": "cpp",
        "release_time": 1662523826,
        "code": "class Solution {\npublic:\n   \n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\n             \n        vis[i]=1;\n        \n        for(auto t:ans[i]){\n            if(!vis[t]){\n                dfs(t,ansc,ans,vis,res);\n            }\n        }\n       \n        if(i!=ansc)\n            res[i].push_back(ansc);\n    }\n    \n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n        \n        vector<vector<int>>ans(n),result(n);\n        \n        for(auto a:edges){\n            ans[a[0]].push_back(a[1]);\n        }\n        \n        for(int i=0;i<n;i++){\n            vector<int>visited(n);\n            dfs(i,i,ans,visited,result);\n        }\n      \n        return result;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n   \\n    void dfs(int i,int ansc,vector<vector<int>>&ans,vector<int>&vis,vector<vector<int>>&res){\\n             \\n        vis[i]=1;\\n        \\n        for(auto t:ans[i]){\\n            if(!vis[t]){\\n                dfs(t,ansc,ans,vis,res);\\n            }\\n        }\\n       \\n        if(i!=ansc)\\n            res[i].push_back(ansc);\\n    }\\n    \\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\\n        \\n        vector<vector<int>>ans(n),result(n);\\n        \\n        for(auto a:edges){\\n            ans[a[0]].push_back(a[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>visited(n);\\n            dfs(i,i,ans,visited,result);\\n        }\\n      \\n        return result;\\n    }\\n};"
    },
    {
        "slug": "reverse-pairs",
        "tags": "cpp",
        "release_time": 1673281894,
        "code": "class Solution {\npublic:\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\n    int i=low,j=mid+1;\n    int r=j;\n    int c=0;\n    vector<int>v;\n     while(i<=mid){\n        while(r<=high and arr[i]>(long long)2*arr[r]){\n            c++;\n            r++;\n        }\n        cnt+=c;\n        \n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\n          v.push_back(arr[i++]);\n     }\n     while(j<=high)v.push_back(arr[j++]);\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\n}\n\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\n       if(low<high){\n      int mid=low+(high-low)/2;\n      mergesort(arr,low,mid,cnt);\n      mergesort(arr,mid+1,high,cnt);\n      merge(arr,low,mid,high,cnt);\n       }\n   }\n    int reversePairs(vector<int>& arr) {\n      // merge sort -> modified merge function \n    int cnt=0;\n    int n=arr.size();\n    mergesort(arr,0,n-1,cnt);\n    if(n<=1 or cnt==0)return 0;\n    return cnt;\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo get an intuition of merge sort u think basically we have to check how many elements are greater as per some condtion like inversions SO in these kind of problems merge sort can be used beacuase we comapre left subarray which is sorted to right subarray through that we can minimize time complexity beacuse we don\\'t need to chekc all combinations .. That is key thing about merge sort just like it makes  sorting in nlogn \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust Modified Merge sort only a change in merge function count as per condition rest is same\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid merge(vector<int>&arr,int low,int mid,int high,int &cnt){\\n    int i=low,j=mid+1;\\n    int r=j;\\n    int c=0;\\n    vector<int>v;\\n     while(i<=mid){\\n        while(r<=high and arr[i]>(long long)2*arr[r]){\\n            c++;\\n            r++;\\n        }\\n        cnt+=c;\\n        \\n          while(j<=high and arr[j]<=arr[i])v.push_back(arr[j++]);\\n          v.push_back(arr[i++]);\\n     }\\n     while(j<=high)v.push_back(arr[j++]);\\n     for(int i=low;i<=high;i++)arr[i]=v[i-low];\\n}\\n\\n   void mergesort(vector<int>&arr,int low,int high,int &cnt){\\n       if(low<high){\\n      int mid=low+(high-low)/2;\\n      mergesort(arr,low,mid,cnt);\\n      mergesort(arr,mid+1,high,cnt);\\n      merge(arr,low,mid,high,cnt);\\n       }\\n   }\\n    int reversePairs(vector<int>& arr) {\\n      // merge sort -> modified merge function \\n    int cnt=0;\\n    int n=arr.size();\\n    mergesort(arr,0,n-1,cnt);\\n    if(n<=1 or cnt==0)return 0;\\n    return cnt;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "score-after-flipping-matrix",
        "tags": "cpp",
        "release_time": 1688626701,
        "code": "class Solution {\npublic:\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\n    {\n        for(int i=0; i<grid[0].size(); i++){\n            grid[r][i]=1-grid[r][i];\n        }\n    }\n\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\n        for(int j=0; j<grid.size(); j++){\n            grid[j][c]=1-grid[j][c];\n        }\n    }\n\n    int matrixScore(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\n        for(int i=0; i<n; i++){\n            if(grid[i][0]==0){    \n                fliprow(i,grid);\n            }\n        }\n//traversing and checking which colums have more zeroes than 1, toggling them too\n        for(int j=0; j<m; j++){\n            int cnt0=0;\n            int cnt1=0;\n            for(int i=0; i<n; i++){\n                if(grid[i][j]==0) cnt0++;\n                else cnt1++;\n            }\n            if(cnt0>cnt1){\n                flipcol(j,grid);\n            }\n        }\n//finally calculating the ans\n        int sum=0;\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                if(grid[i][j]==1){\n                    sum+= (1<<(m-j-1));\n                }\n            }\n        }\n        return sum;\n        \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void fliprow(int &r,vector<vector<int>>& grid) //function to toggle row\\n    {\\n        for(int i=0; i<grid[0].size(); i++){\\n            grid[r][i]=1-grid[r][i];\\n        }\\n    }\\n\\n    void flipcol(int &c,vector<vector<int>>& grid){ //function to toggle column\\n        for(int j=0; j<grid.size(); j++){\\n            grid[j][c]=1-grid[j][c];\\n        }\\n    }\\n\\n    int matrixScore(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n//Making the MSB to 1, all values in column 0 should be 1 to get max value\\n        for(int i=0; i<n; i++){\\n            if(grid[i][0]==0){    \\n                fliprow(i,grid);\\n            }\\n        }\\n//traversing and checking which colums have more zeroes than 1, toggling them too\\n        for(int j=0; j<m; j++){\\n            int cnt0=0;\\n            int cnt1=0;\\n            for(int i=0; i<n; i++){\\n                if(grid[i][j]==0) cnt0++;\\n                else cnt1++;\\n            }\\n            if(cnt0>cnt1){\\n                flipcol(j,grid);\\n            }\\n        }\\n//finally calculating the ans\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid[i][j]==1){\\n                    sum+= (1<<(m-j-1));\\n                }\\n            }\\n        }\\n        return sum;\\n        \\n\\n    }\\n};\\n```"
    },
    {
        "slug": "steps-to-make-array-non-decreasing",
        "tags": "cpp",
        "release_time": 1687621130,
        "code": "class Solution {\npublic:\n    int totalSteps(vector<int>& nums) {\n        stack<pair<int,int>>st;\n        int n=nums.size();\n        int ans=0;\n        st.push({nums[n-1],0});\n       for(int i=n-2;i>=0;i--){\n            int cnt=0;\n            while(!st.empty() && st.top().first<nums[i]){\n                \n                cnt=max(cnt+1,st.top().second);\n                st.pop();\n            }\n            ans=max(cnt,ans);\n            st.push({nums[i],cnt});\n       } \n\n       return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalSteps(vector<int>& nums) {\\n        stack<pair<int,int>>st;\\n        int n=nums.size();\\n        int ans=0;\\n        st.push({nums[n-1],0});\\n       for(int i=n-2;i>=0;i--){\\n            int cnt=0;\\n            while(!st.empty() && st.top().first<nums[i]){\\n                \\n                cnt=max(cnt+1,st.top().second);\\n                st.pop();\\n            }\\n            ans=max(cnt,ans);\\n            st.push({nums[i],cnt});\\n       } \\n\\n       return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-string-with-lcp",
        "tags": "cpp",
        "release_time": 1685466785,
        "code": "class Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n       int n= lcp.size();\n       string ans =\"\";\n       if(lcp[0][0]!=n)\n       return ans;\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\n               return ans;\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\n            return ans;\n           }\n       }\n\n       int t=0;\n       for(int i=0;i<n;i++)\n       ans +='1';\n\n       for(int i=0;i<n;i++){\n           bool flag = false;\n           for(int j=i;j<n;j++){\n               if(ans[j]=='1' && lcp[i][j]!=0){\n                   if(t>=26)\n                   return \"\";\n                   ans[j] ='a'+t;\n                   flag = true;\n               }\n           }\n           if(flag ==true)\n           t++;\n       }\n\n       for(int i=0;i<n;i++){\n           for(int j=0;j<n;j++){\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\n               return \"\";\n           }\n       }\n       return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    string findTheString(vector<vector<int>>& lcp) {\\n       int n= lcp.size();\\n       string ans =\"\";\\n       if(lcp[0][0]!=n)\\n       return ans;\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=lcp[j][i]||lcp[i][j]>n-max(i,j))\\n               return ans;\\n               if(i+1<n && j+1<n && lcp[i][j]>0 && lcp[i+1][j+1]!=lcp[i][j]-1)\\n            return ans;\\n           }\\n       }\\n\\n       int t=0;\\n       for(int i=0;i<n;i++)\\n       ans +=\\'1\\';\\n\\n       for(int i=0;i<n;i++){\\n           bool flag = false;\\n           for(int j=i;j<n;j++){\\n               if(ans[j]==\\'1\\' && lcp[i][j]!=0){\\n                   if(t>=26)\\n                   return \"\";\\n                   ans[j] =\\'a\\'+t;\\n                   flag = true;\\n               }\\n           }\\n           if(flag ==true)\\n           t++;\\n       }\\n\\n       for(int i=0;i<n;i++){\\n           for(int j=0;j<n;j++){\\n               if(lcp[i][j]!=0 && ans[i]!=ans[j])\\n               return \"\";\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "keep-multiplying-found-values-by-two",
        "tags": "cpp",
        "release_time": 1681395629,
        "code": "class Solution {\npublic:\n    int findFinalValue(vector<int>& nums, int original) {\n        int i = 0;\n        while(i != nums.size()) {\n            if(nums[i] == original) {\n                i = 0;\n                original *= 2;\n            }\n            else i++;\n        }\n        return original;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findFinalValue(vector<int>& nums, int original) {\\n        int i = 0;\\n        while(i != nums.size()) {\\n            if(nums[i] == original) {\\n                i = 0;\\n                original *= 2;\\n            }\\n            else i++;\\n        }\\n        return original;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-servers-that-communicate",
        "tags": "cpp",
        "release_time": 1687437858,
        "code": "class Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) \n    {\n        int m=grid.size(),n=grid[0].size(), ans=0;\n        for(int i=0;i<m;i++){\n            int c=0;\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==1)   c++;\n            }\n            if(c<2)        continue;\n            for(int j=0;j<n;j++){\n                if(grid[i][j]==1){\n                    grid[i][j]=-1;\n                    ans++;\n                }\n            }\n        }\n        for(int j=0;j<n;j++){\n            int c=0;\n            for(int i=0;i<m;i++){\n                if(grid[i][j]==1 || grid[i][j]==-1)     c++;    \n            }\n            if(c<2)        continue;\n            for(int i=0;i<m;i++){\n                if(grid[i][j]==1 )     ans++;    \n            }\n        }\n        return ans;  \n\n                \n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countServers(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size(), ans=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1)   c++;\\n            }\\n            if(c<2)        continue;\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    grid[i][j]=-1;\\n                    ans++;\\n                }\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            int c=0;\\n            for(int i=0;i<m;i++){\\n                if(grid[i][j]==1 || grid[i][j]==-1)     c++;    \\n            }\\n            if(c<2)        continue;\\n            for(int i=0;i<m;i++){\\n                if(grid[i][j]==1 )     ans++;    \\n            }\\n        }\\n        return ans;  \\n\\n                \\n    }\\n};\\n```"
    },
    {
        "slug": "palindrome-linked-list",
        "tags": "cpp",
        "release_time": 1684173184,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool flag;\n    ListNode*Head;\n    void checkpalindrome(ListNode* Revhead){\n        if(Revhead==NULL){\n            return;\n        }\n         checkpalindrome(Revhead->next);\n         if(Revhead!=NULL){\n             if(Revhead->val!=Head->val){\n                 flag=false;\n             }\n             Head=Head->next;\n         }\n    }\n    bool isPalindrome(ListNode* head) {\n        flag=true;\n        Head=head;\n        checkpalindrome(head);\n        return flag;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool flag;\\n    ListNode*Head;\\n    void checkpalindrome(ListNode* Revhead){\\n        if(Revhead==NULL){\\n            return;\\n        }\\n         checkpalindrome(Revhead->next);\\n         if(Revhead!=NULL){\\n             if(Revhead->val!=Head->val){\\n                 flag=false;\\n             }\\n             Head=Head->next;\\n         }\\n    }\\n    bool isPalindrome(ListNode* head) {\\n        flag=true;\\n        Head=head;\\n        checkpalindrome(head);\\n        return flag;\\n    }\\n};\\n```"
    },
    {
        "slug": "valid-boomerang",
        "tags": "cpp",
        "release_time": 1683522404,
        "code": "class Solution {\npublic:\n    bool isBoomerang(vector<vector<int>>& points) {\n        float a,b,c,d;\n        a = (points[1][1]-points[0][1]);\n        b = (points[1][0]-points[0][0]);\n        c = (points[2][1]-points[1][1]);\n        d = (points[2][0]-points[1][0]);\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\n        {\n            return false;\n        }\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\n        {\n            return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSlopes are matched : (y2-y1)/(x2-x1)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isBoomerang(vector<vector<int>>& points) {\\n        float a,b,c,d;\\n        a = (points[1][1]-points[0][1]);\\n        b = (points[1][0]-points[0][0]);\\n        c = (points[2][1]-points[1][1]);\\n        d = (points[2][0]-points[1][0]);\\n        if((b!=0 && d!=0 && a*d==b*c) || (b==0 && d==0 && points[0][0]==points[1][0]))\\n        {\\n            return false;\\n        }\\n        if((points[0][0]==points[1][0] && points[0][1]==points[1][1]) || (points[0][0]==points[2][0] && points[0][1]==points[2][1]) || (points[1][0]==points[2][0] && points[1][1]==points[2][1]))\\n        {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6d6312fc-589e-44f6-989d-a97c5ba0b0c3_1683522399.5758274.jpeg)\\n"
    },
    {
        "slug": "merge-two-2d-arrays-by-summing-values",
        "tags": "cpp",
        "release_time": 1676826712,
        "code": "class Solution {\npublic:\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\n         vector<vector<int>> ans;\n        int i=0,j=0;\n        int n=nums1.size(),m=nums2.size();\n        while(i<n&&j<m){\n            if(nums1[i][0]>nums2[j][0]){ans.push_back({nums2[j][0],nums2[j][1]});\n                                       j++;}\n            else if(nums1[i][0]<nums2[j][0]){ ans.push_back({nums1[i][0],nums1[i][1]});\n                                            i++;}\n            else{\n               // cout<<\"kk\";\n            ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\n                i++,j++;\n            }\n        }\n        while(i<n) ans.push_back(nums1[i++]);\n        while(j<m) ans.push_back(nums2[j++]);\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\\n         vector<vector<int>> ans;\\n        int i=0,j=0;\\n        int n=nums1.size(),m=nums2.size();\\n        while(i<n&&j<m){\\n            if(nums1[i][0]>nums2[j][0]){ans.push_back({nums2[j][0],nums2[j][1]});\\n                                       j++;}\\n            else if(nums1[i][0]<nums2[j][0]){ ans.push_back({nums1[i][0],nums1[i][1]});\\n                                            i++;}\\n            else{\\n               // cout<<\"kk\";\\n            ans.push_back({nums1[i][0],nums1[i][1]+nums2[j][1]});\\n                i++,j++;\\n            }\\n        }\\n        while(i<n) ans.push_back(nums1[i++]);\\n        while(j<m) ans.push_back(nums2[j++]);\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-original-array-from-doubled-array",
        "tags": "cpp",
        "release_time": 1680631990,
        "code": "class Solution {\npublic:\n    int next(int l,vector<int> &changed){\n        while(l<changed.size() && changed[l]==-1){\n            l++;\n        }\n        return l;\n    }\n    vector<int> findOriginalArray(vector<int>& changed) {\n        sort(changed.begin(),changed.end());\n        int l=0,h=1,n=changed.size(),count=0;\n        if(n%2) return {};\n        vector<int> ans;\n        while(h<n){\n            if((long long)changed[l]*2==changed[h]){\n                count++;\n                ans.push_back(changed[l]);\n                changed[l]=-1;\n                changed[h]=-1;\n                l=next(l,changed);\n                h++;\n                if(l==h) h++;\n            }else{\n                h++;\n            }\n        }\n        if(count!=n/2) ans={};\n        return ans;\n\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n/2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int next(int l,vector<int> &changed){\\n        while(l<changed.size() && changed[l]==-1){\\n            l++;\\n        }\\n        return l;\\n    }\\n    vector<int> findOriginalArray(vector<int>& changed) {\\n        sort(changed.begin(),changed.end());\\n        int l=0,h=1,n=changed.size(),count=0;\\n        if(n%2) return {};\\n        vector<int> ans;\\n        while(h<n){\\n            if((long long)changed[l]*2==changed[h]){\\n                count++;\\n                ans.push_back(changed[l]);\\n                changed[l]=-1;\\n                changed[h]=-1;\\n                l=next(l,changed);\\n                h++;\\n                if(l==h) h++;\\n            }else{\\n                h++;\\n            }\\n        }\\n        if(count!=n/2) ans={};\\n        return ans;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "relative-ranks",
        "tags": "cpp",
        "release_time": 1688035608,
        "code": "class Solution {\npublic:\n    vector<string> findRelativeRanks(vector<int>& score) {\n        int n = score.size();\n        \n        vector<pair<int, int>> arr;\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\n\n        sort(rbegin(arr), rend(arr));\n\n        vector<string> res(n);\n        for (int i=0; i<n; i++) \n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\n\n        return res;\n    }\n};",
        "content": "**vector solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        vector<pair<int, int>> arr;\\n        for (int i=0; i<n; i++) arr.push_back({score[i], i});\\n\\n        sort(rbegin(arr), rend(arr));\\n\\n        vector<string> res(n);\\n        for (int i=0; i<n; i++) \\n            res[arr[i].second] = i==0? \"Gold Medal\": (i==1? \"Silver Medal\": (i==2? \"Bronze Medal\": to_string(i+1)));\\n\\n        return res;\\n    }\\n};\\n```\\n---\\n**priority queue solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findRelativeRanks(vector<int>& score) {\\n        int n = score.size();\\n        \\n        priority_queue< pair<int, int>, vector<pair<int,int>> > pq;\\n        for (int i=0; i<n; i++) pq.push({score[i], i});\\n\\n        vector<string> res(n);\\n        while (!pq.empty()) {\\n            auto x = pq.top();\\n            int size = pq.size();\\n            res[x.second] = (size == n? \"Gold Medal\": (size == n-1? \"Silver Medal\": (size == n-2? \"Bronze Medal\": to_string(n-size+1))));\\n            pq.pop();\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-eventual-safe-states",
        "tags": "cpp",
        "release_time": 1689147609,
        "code": "class Solution {\npublic:\n    bool dfs(int node , vector<vector<int>>& graph , vector<int>& vis , vector<int>& dfsVisited , vector<int>& check){\n        vis[node] = 1;\n        dfsVisited[node] = 1;\n        check[node] = 0;\n        for (int neighbour : graph[node]){\n            if (!vis[neighbour]){\n                if (dfs(neighbour , graph , vis , dfsVisited , check))\n                    return true;\n            }\n            else if (dfsVisited[neighbour]){\n                return true;\n            }\n        }\n        check[node] = 1;\n        dfsVisited[node] = 0;\n        return false;\n    }\n\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        vector<int> ans;\n\n        vector<int> vis(graph.size());\n        vector<int> dfsVisited(graph.size());\n        vector<int> check(graph.size());\n\n        for (int i=0 ; i<graph.size() ; i++){\n            if (!vis[i]){\n                dfs(i , graph , vis , dfsVisited , check);\n            }\n        }    \n\n        for (int i=0 ; i<graph.size() ; i++){\n            if (check[i]==1)\n                ans.push_back(i);\n        }\n\n        return ans;\n    }\n};",
        "content": "# C++ | DFS | Easy to Understand | Optimal | Medium Problem | 802. Find Eventual Safe States\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node , vector<vector<int>>& graph , vector<int>& vis , vector<int>& dfsVisited , vector<int>& check){\\n        vis[node] = 1;\\n        dfsVisited[node] = 1;\\n        check[node] = 0;\\n        for (int neighbour : graph[node]){\\n            if (!vis[neighbour]){\\n                if (dfs(neighbour , graph , vis , dfsVisited , check))\\n                    return true;\\n            }\\n            else if (dfsVisited[neighbour]){\\n                return true;\\n            }\\n        }\\n        check[node] = 1;\\n        dfsVisited[node] = 0;\\n        return false;\\n    }\\n\\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\\n        vector<int> ans;\\n\\n        vector<int> vis(graph.size());\\n        vector<int> dfsVisited(graph.size());\\n        vector<int> check(graph.size());\\n\\n        for (int i=0 ; i<graph.size() ; i++){\\n            if (!vis[i]){\\n                dfs(i , graph , vis , dfsVisited , check);\\n            }\\n        }    \\n\\n        for (int i=0 ; i<graph.size() ; i++){\\n            if (check[i]==1)\\n                ans.push_back(i);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "tags": "cpp",
        "release_time": 1692446889,
        "code": "class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        if(veganFriendly == 1){\n            for(int i = 0; i<restaurants.size(); i++){\n                if(restaurants[i][2] != veganFriendly){\n                    restaurants[i][0] = -1;\n                }\n            }\n        }\n\n        for(int i = 0; i<restaurants.size(); i++){\n            if(restaurants[i][3] > maxPrice){   \n                restaurants[i][0] = -1;\n            }\n            if(restaurants[i][4] > maxDistance){  \n                restaurants[i][0]=-1;\n            }\n        }\n\n        vector<int> id;\n        vector<int>rating;\n        for(int i=0; i<restaurants.size(); i++){\n            if(restaurants[i][0]>0){\n                id.push_back(restaurants[i][0]);\n                rating.push_back(restaurants[i][1]);\n            }\n            \n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] < rating[j]){\n                    swap(rating[i], rating[j]);\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        for(int i=0; i<rating.size(); i++){\n            for(int j=i+1; j<rating.size(); j++){\n                if(rating[i] == rating[j] && id[i] < id[j]){\n                    swap(id[i], id[j]);\n                }\n            }\n        }\n\n        return id;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\\n        if(veganFriendly == 1){\\n            for(int i = 0; i<restaurants.size(); i++){\\n                if(restaurants[i][2] != veganFriendly){\\n                    restaurants[i][0] = -1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0; i<restaurants.size(); i++){\\n            if(restaurants[i][3] > maxPrice){   \\n                restaurants[i][0] = -1;\\n            }\\n            if(restaurants[i][4] > maxDistance){  \\n                restaurants[i][0]=-1;\\n            }\\n        }\\n\\n        vector<int> id;\\n        vector<int>rating;\\n        for(int i=0; i<restaurants.size(); i++){\\n            if(restaurants[i][0]>0){\\n                id.push_back(restaurants[i][0]);\\n                rating.push_back(restaurants[i][1]);\\n            }\\n            \\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] < rating[j]){\\n                    swap(rating[i], rating[j]);\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<rating.size(); i++){\\n            for(int j=i+1; j<rating.size(); j++){\\n                if(rating[i] == rating[j] && id[i] < id[j]){\\n                    swap(id[i], id[j]);\\n                }\\n            }\\n        }\\n\\n        return id;\\n    }\\n};\\n```"
    },
    {
        "slug": "number-of-different-integers-in-a-string",
        "tags": "cpp",
        "release_time": 1669008957,
        "code": "class Solution {\npublic:\n   int numDifferentIntegers(string word) {\n        int n = word.length();\n        unordered_set<string>s;\n        int i=0;\n        while(i<n){\n            if(isdigit(word[i]) == false){\n                i++;\n                continue;\n            }\n            string temp = \"\";\n            while(i<n && isdigit(word[i])){\n                temp+=word[i];\n                i++;\n            }\n            int j=0;\n            while(j<temp.length() && temp[j] == '0') j++;\n            temp = temp.substr(j);\n            s.insert(temp);\n        }\n        return s.size();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int numDifferentIntegers(string word) {\\n        int n = word.length();\\n        unordered_set<string>s;\\n        int i=0;\\n        while(i<n){\\n            if(isdigit(word[i]) == false){\\n                i++;\\n                continue;\\n            }\\n            string temp = \"\";\\n            while(i<n && isdigit(word[i])){\\n                temp+=word[i];\\n                i++;\\n            }\\n            int j=0;\\n            while(j<temp.length() && temp[j] == \\'0\\') j++;\\n            temp = temp.substr(j);\\n            s.insert(temp);\\n        }\\n        return s.size();\\n    }\\n};\\n```"
    },
    {
        "slug": "product-of-array-except-self",
        "tags": "cpp",
        "release_time": 1691071622,
        "code": "class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        vector<int>prefVector(nums.size(),1);\n        vector<int>suffVector(nums.size(),1);\n        int prefPro=1;\n        for(int i=0;i<nums.size();i++){\n            prefVector[i]=prefPro;\n            prefPro*=nums[i];\n        }\n        int suffPro=1;\n        for(int i=nums.size()-1;i>=0;i--){\n            suffVector[i]=suffPro;\n            suffPro*=nums[i];\n        }\n        vector<int>ans(nums.size());\n        for(int i=0;i<nums.size();i++){\n            ans[i]=prefVector[i]*suffVector[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition:\\nwe use two different vectors to store the product of all left elements to that element and another vector to store the product of all right values to that value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>prefVector(nums.size(),1);\\n        vector<int>suffVector(nums.size(),1);\\n        int prefPro=1;\\n        for(int i=0;i<nums.size();i++){\\n            prefVector[i]=prefPro;\\n            prefPro*=nums[i];\\n        }\\n        int suffPro=1;\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffVector[i]=suffPro;\\n            suffPro*=nums[i];\\n        }\\n        vector<int>ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]=prefVector[i]*suffVector[i];\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "tags": "cpp",
        "release_time": 1688006204,
        "code": "class Solution {\npublic:\n\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n        int m = grid.size();\n        int n = grid[0].size();\n        queue<pair<pair<int, int>, int>> que;\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\n        int target = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    target |= 1 << (grid[i][j] - 'a');\n                    continue;\n                }\n\n                if (grid[i][j] == '@') {\n                    que.emplace(pair<int, int>(i, j), 0);\n                    mapKey[i][j] = 1;\n                }\n            }\n        }\n\n\n        int step = 0;\n        while (!que.empty()) {\n            int size = que.size();\n            for (int s = 0; s < size; s++) {\n                int i = que.front().first.first;\n                int j = que.front().first.second;\n                int key = que.front().second;\n                que.pop();\n                \n                if ('a' <= grid[i][j] && grid[i][j] <= 'f') {\n                    key |= 1 << (grid[i][j] - 'a');\n                    if (key == target)\n                        return step;\n\n                    mapKey[i][j] |= 1l << key;\n                }\n\n                for (int d = 0; d < 4; d++) {\n                    int newi = i + dir[d][0];\n                    int newj = j + dir[d][1];\n                    \n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\n                        continue;\n                        \n                    int val = grid[newi][newj];\n                    if (val == '#')\n                        continue;\n                        \n                    if ('A' <= val && val <= 'F' && (key & (1 << (val - 'A'))) == 0)\n                        continue;\n                        \n                    if (mapKey[newi][newj] & (1l << key))\n                        continue;\n                        \n                     mapKey[newi][newj] |= 1l << key;\n                     que.emplace(pair<int, int>(newi, newj), key);\n                }\n            }\n            step++;\n        }\n        return -1;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        queue<pair<pair<int, int>, int>> que;\\n        vector<vector<unsigned long>> mapKey(m, vector<unsigned long>(n, 0));\\n        int target = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    target |= 1 << (grid[i][j] - \\'a\\');\\n                    continue;\\n                }\\n\\n                if (grid[i][j] == \\'@\\') {\\n                    que.emplace(pair<int, int>(i, j), 0);\\n                    mapKey[i][j] = 1;\\n                }\\n            }\\n        }\\n\\n\\n        int step = 0;\\n        while (!que.empty()) {\\n            int size = que.size();\\n            for (int s = 0; s < size; s++) {\\n                int i = que.front().first.first;\\n                int j = que.front().first.second;\\n                int key = que.front().second;\\n                que.pop();\\n                \\n                if (\\'a\\' <= grid[i][j] && grid[i][j] <= \\'f\\') {\\n                    key |= 1 << (grid[i][j] - \\'a\\');\\n                    if (key == target)\\n                        return step;\\n\\n                    mapKey[i][j] |= 1l << key;\\n                }\\n\\n                for (int d = 0; d < 4; d++) {\\n                    int newi = i + dir[d][0];\\n                    int newj = j + dir[d][1];\\n                    \\n                    if (!(0 <= newi && newi < m && 0 <= newj && newj < n))\\n                        continue;\\n                        \\n                    int val = grid[newi][newj];\\n                    if (val == \\'#\\')\\n                        continue;\\n                        \\n                    if (\\'A\\' <= val && val <= \\'F\\' && (key & (1 << (val - \\'A\\'))) == 0)\\n                        continue;\\n                        \\n                    if (mapKey[newi][newj] & (1l << key))\\n                        continue;\\n                        \\n                     mapKey[newi][newj] |= 1l << key;\\n                     que.emplace(pair<int, int>(newi, newj), key);\\n                }\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-removable-characters",
        "tags": "cpp",
        "release_time": 1667447295,
        "code": "class Solution {\n int rm[100001] = {};\n    bool valid(string &s, string &p, vector<int> &A, int k) {\n        memset(rm, 0, sizeof(rm));\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \n        int N = s.size(), M = p.size(), j = 0; \n        for (int i = 0; i < N && j < M; ++i) {\n            if (rm[i] == 1) continue; \n            if (s[i] == p[j]) ++j; \n        }\n        return j == M; \n    }\npublic:\n    int maximumRemovals(string s, string p, vector<int>& A) {\n        int L = 0, R = A.size();\n        while (L <= R) {\n            int M = (L + R) / 2;\n            if (valid(s, p, A, M)) L = M + 1;\n            else R = M - 1;\n        }\n        return R;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n int rm[100001] = {};\\n    bool valid(string &s, string &p, vector<int> &A, int k) {\\n        memset(rm, 0, sizeof(rm));\\n        for (int i = 0; i < k; ++i) rm[A[i]] = 1; \\n        int N = s.size(), M = p.size(), j = 0; \\n        for (int i = 0; i < N && j < M; ++i) {\\n            if (rm[i] == 1) continue; \\n            if (s[i] == p[j]) ++j; \\n        }\\n        return j == M; \\n    }\\npublic:\\n    int maximumRemovals(string s, string p, vector<int>& A) {\\n        int L = 0, R = A.size();\\n        while (L <= R) {\\n            int M = (L + R) / 2;\\n            if (valid(s, p, A, M)) L = M + 1;\\n            else R = M - 1;\\n        }\\n        return R;\\n    }\\n};\\n```"
    },
    {
        "slug": "my-calendar-i",
        "tags": "cpp",
        "release_time": 1659502656,
        "code": "class MyCalendar {\npublic:\n    map<int,int> m;\n    MyCalendar() {\n        \n    }\n    \n    bool book(int start, int end) {\n        auto p= m.upper_bound(start);\n        if(p== m.end() || end <= p->second) \n        {\n            m[end]=start;\n            return true;\n        } \n        return false;\n    }\n};",
        "content": "Please Upvote :)\\n\\n```\\nclass MyCalendar {\\npublic:\\n    map<int,int> m;\\n    MyCalendar() {\\n        \\n    }\\n    \\n    bool book(int start, int end) {\\n        auto p= m.upper_bound(start);\\n        if(p== m.end() || end <= p->second) \\n        {\\n            m[end]=start;\\n            return true;\\n        } \\n        return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "largest-rectangle-in-histogram",
        "tags": "cpp",
        "release_time": 1691746356,
        "code": "#include<stack>\n \nclass Solution {\npublic:\n    //function to find the index of next smallerNumber\n    vector<int> nextSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=n-1;i>=0;i--){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    //function to find the index of prev smallerNumber\n    vector<int> prevSmallNumberIndex(vector<int>& v){\n        int n=v.size(),num=0;\n        vector<int> ans(n);\n        stack<int> s;\n        s.push(-1);\n        for(int i=0;i<n;i++){\n            num=v[i];\n            while(s.top()!=-1 && v[s.top()]>=num){\n                s.pop();\n            }\n            ans[i]=s.top();\n            s.push(i);\n        }\n        return ans;\n\n    }\n    int largestRectangleArea(vector<int>& heights) {\n        int size=heights.size(),h,l,area=0,curArea;\n        vector<int> next=nextSmallNumberIndex(heights);\n         vector<int> prev=prevSmallNumberIndex(heights);\n         for(int i=0;i<size;i++){\n            h=heights[i];\n            //if index of next smaller number is -1 we change its value to size \n            if(next[i]==-1)next[i]=size;\n            l=next[i]-prev[i]-1;\n            curArea=l*h;\n             area=max(area,curArea);\n\n        }\n        return area;\n        \n    }\n};",
        "content": "\\n\\n# Code\\n```\\n#include<stack>\\n \\nclass Solution {\\npublic:\\n    //function to find the index of next smallerNumber\\n    vector<int> nextSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=n-1;i>=0;i--){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    //function to find the index of prev smallerNumber\\n    vector<int> prevSmallNumberIndex(vector<int>& v){\\n        int n=v.size(),num=0;\\n        vector<int> ans(n);\\n        stack<int> s;\\n        s.push(-1);\\n        for(int i=0;i<n;i++){\\n            num=v[i];\\n            while(s.top()!=-1 && v[s.top()]>=num){\\n                s.pop();\\n            }\\n            ans[i]=s.top();\\n            s.push(i);\\n        }\\n        return ans;\\n\\n    }\\n    int largestRectangleArea(vector<int>& heights) {\\n        int size=heights.size(),h,l,area=0,curArea;\\n        vector<int> next=nextSmallNumberIndex(heights);\\n         vector<int> prev=prevSmallNumberIndex(heights);\\n         for(int i=0;i<size;i++){\\n            h=heights[i];\\n            //if index of next smaller number is -1 we change its value to size \\n            if(next[i]==-1)next[i]=size;\\n            l=next[i]-prev[i]-1;\\n            curArea=l*h;\\n             area=max(area,curArea);\\n\\n        }\\n        return area;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "check-if-there-is-a-valid-path-in-a-grid",
        "tags": "cpp",
        "release_time": 1686021362,
        "code": "class DisjointSet{\npublic:\n    vector<int>par,size;\n    DisjointSet(int n){\n        par.resize(n+1);\n        size.resize(n+1,1);\n        for(int i=0; i<=n; i++){\n            par[i] = i;\n        }\n    }\n    int findpar(int u){\n        if(u == par[u]) return u;\n        return par[u] = findpar(par[u]);\n    }\n\n    void unionBySize(int u, int v){\n        u = findpar(u);\n        v = findpar(v);\n\n        if(u == v) return;\n\n        if(size[u] >= size[v]){\n            par[v] = u;\n            size[u] += size[v];\n        }\n        else{\n            par[u] = v;\n            size[v] += size[u];\n        }\n    }\n    \n};\nclass Solution {\npublic:\n    bool hasValidPath(vector<vector<int>>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n        DisjointSet ds(n*m);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<m; j++){\n                int p = i * m + j;\n                int p1 = (i-1)*m + j;  // 1\n                int p2 = (i+1)*m + j;  // 1\n                int p3 = i*m + (j+1);  // 2\n                int p4 = i*m + (j-1);  // 2\n\n                if(grid[i][j] == 1){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 2){\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                }\n                else if(grid[i][j] == 3){\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 4){\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\n                        ds.unionBySize(p,p2);\n                    }\n                }\n                else if(grid[i][j] == 5){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\n                        ds.unionBySize(p,p4);\n                    }\n                }\n                else if(grid[i][j] == 6){\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\n                        ds.unionBySize(p,p1);\n                    }\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\n                        ds.unionBySize(p,p3);\n                    }\n                }\n            }\n        }\n        return ds.findpar(0) == ds.findpar(n*m-1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet{\\npublic:\\n    vector<int>par,size;\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n        for(int i=0; i<=n; i++){\\n            par[i] = i;\\n        }\\n    }\\n    int findpar(int u){\\n        if(u == par[u]) return u;\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionBySize(int u, int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] >= size[v]){\\n            par[v] = u;\\n            size[u] += size[v];\\n        }\\n        else{\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    bool hasValidPath(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        DisjointSet ds(n*m);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                int p = i * m + j;\\n                int p1 = (i-1)*m + j;  // 1\\n                int p2 = (i+1)*m + j;  // 1\\n                int p3 = i*m + (j+1);  // 2\\n                int p4 = i*m + (j-1);  // 2\\n\\n                if(grid[i][j] == 1){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 2){\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                }\\n                else if(grid[i][j] == 3){\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 4){\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                    if(i+1 < n && (grid[i+1][j] == 2 || grid[i+1][j] == 5 || grid[i+1][j] == 6) ){\\n                        ds.unionBySize(p,p2);\\n                    }\\n                }\\n                else if(grid[i][j] == 5){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j-1 >= 0 && (grid[i][j-1] == 1 || grid[i][j-1] == 4 || grid[i][j-1] == 6) ){\\n                        ds.unionBySize(p,p4);\\n                    }\\n                }\\n                else if(grid[i][j] == 6){\\n                    if(i-1>=0 && (grid[i-1][j] == 2 || grid[i-1][j] == 3 || grid[i-1][j] == 4)){\\n                        ds.unionBySize(p,p1);\\n                    }\\n                    if(j+1 < m && (grid[i][j+1] == 1 || grid[i][j+1] == 3 || grid[i][j+1] == 5) ){\\n                        ds.unionBySize(p,p3);\\n                    }\\n                }\\n            }\\n        }\\n        return ds.findpar(0) == ds.findpar(n*m-1);\\n    }\\n};\\n```"
    },
    {
        "slug": "ugly-number-ii",
        "tags": "cpp",
        "release_time": 1690716711,
        "code": "class Solution {\npublic:\n    int nthUglyNumber(int n) \n    {\n        vector<int>dp(n);\n        dp[0]=1;\n        int p1=0;\n        int p2=0;\n        int p3=0;\n        for(int i=1;i<n;i++)\n        {\n            int two=dp[p1]*2;\n            int three=dp[p2]*3;\n            int five=dp[p3]*5;\n            dp[i]=min(two,min(three,five));\n            if(dp[i]==two)\n            p1++;\n            if(dp[i]==three)\n            p2++;\n            if(dp[i]==five)\n            p3++;\n        }\n        return dp[n-1];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int nthUglyNumber(int n) \\n    {\\n        vector<int>dp(n);\\n        dp[0]=1;\\n        int p1=0;\\n        int p2=0;\\n        int p3=0;\\n        for(int i=1;i<n;i++)\\n        {\\n            int two=dp[p1]*2;\\n            int three=dp[p2]*3;\\n            int five=dp[p3]*5;\\n            dp[i]=min(two,min(three,five));\\n            if(dp[i]==two)\\n            p1++;\\n            if(dp[i]==three)\\n            p2++;\\n            if(dp[i]==five)\\n            p3++;\\n        }\\n        return dp[n-1];\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "tags": "cpp",
        "release_time": 1680896174,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int>in;\n    void fun(TreeNode *root)\n    {\n        if(!root) return ;\n        fun(root->left);\n        in.push_back(root->val);\n        fun(root->right);\n    }\n    void low(int &x,int k)\n    {\n        int l=0;\n        int h=in.size()-1;\n        while(h>=l)\n        {\n            int m=l+(h-l)/2;\n            if(in[m]>k) h=m-1;\n            else \n            {\n                x=in[m];\n                l=m+1;\n            }\n        }\n    }\n     void upp(int &x,int k)\n    {\n        int l=0;\n        int h=in.size()-1;\n        while(h>=l)\n        {\n            int m=l+(h-l)/2;\n            if(in[m]<k) l=m+1;\n            else \n            {\n                x=in[m];\n                h=m-1;\n            }\n        }\n    }\n\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        \n        fun(root);\n        vector<vector<int>> v;\n        for(auto q:queries)\n        {\n            int x=-1;\n            int y=-1;\n            low(x,q);\n            upp(y,q);\n            v.push_back({x,y});\n            \n        }\n        return v;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)+q*O(log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>in;\\n    void fun(TreeNode *root)\\n    {\\n        if(!root) return ;\\n        fun(root->left);\\n        in.push_back(root->val);\\n        fun(root->right);\\n    }\\n    void low(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]>k) h=m-1;\\n            else \\n            {\\n                x=in[m];\\n                l=m+1;\\n            }\\n        }\\n    }\\n     void upp(int &x,int k)\\n    {\\n        int l=0;\\n        int h=in.size()-1;\\n        while(h>=l)\\n        {\\n            int m=l+(h-l)/2;\\n            if(in[m]<k) l=m+1;\\n            else \\n            {\\n                x=in[m];\\n                h=m-1;\\n            }\\n        }\\n    }\\n\\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        \\n        fun(root);\\n        vector<vector<int>> v;\\n        for(auto q:queries)\\n        {\\n            int x=-1;\\n            int y=-1;\\n            low(x,q);\\n            upp(y,q);\\n            v.push_back({x,y});\\n            \\n        }\\n        return v;\\n    }\\n};\\n```"
    },
    {
        "slug": "smallest-sufficient-team",
        "tags": "cpp",
        "release_time": 1689483636,
        "code": "class Solution {\npublic:\n    vector<int> smallestSufficientTeam(vector<string>& req, vector<vector<string>>& a)\n    {\n        int n = req.size();\n        \n        map<string,int>m;\n        \n        for(int i=0;i<req.size();i++)\n        {\n            m[req[i]] = i;\n        }\n        \n        vector<vector<int>>v;\n        \n        for(int i=0;i<a.size();i++)\n        {\n            vector<int>t;\n            for(int j=0;j<a[i].size();j++)\n            {\n                t.push_back(m[a[i][j]]);\n            }\n            v.push_back(t);\n        }\n        \n        unordered_map<int,vector<int>>dp;\n         \n        dp.reserve(1<<n);\n        dp[0] = {};\n        \n        for(int i=0;i<v.size();i++)\n        {\n            int cur_skill = 0;\n            for(int j=0;j<v[i].size();j++)\n            {\n                  cur_skill = (cur_skill)|(1<<v[i][j]);\n            } \n            \n            for(auto it = dp.begin(); it!= dp.end() ;it++)\n            {\n                int comb = (cur_skill)|(it->first);\n                if(dp.find(comb)==dp.end() or dp[comb].size()>1+dp[it->first].size())\n                {\n                    dp[comb] = it->second;\n                    dp[comb].push_back(i);\n                }\n            }\n        } \n        \n        return dp[(1<<n)-1];\n    }\n};",
        "content": "# C++ | DP | Bitmask | Easy to Understand | Optimal | Hard Problem | 1125. Smallest Sufficient Team\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestSufficientTeam(vector<string>& req, vector<vector<string>>& a)\\n    {\\n        int n = req.size();\\n        \\n        map<string,int>m;\\n        \\n        for(int i=0;i<req.size();i++)\\n        {\\n            m[req[i]] = i;\\n        }\\n        \\n        vector<vector<int>>v;\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            vector<int>t;\\n            for(int j=0;j<a[i].size();j++)\\n            {\\n                t.push_back(m[a[i][j]]);\\n            }\\n            v.push_back(t);\\n        }\\n        \\n        unordered_map<int,vector<int>>dp;\\n         \\n        dp.reserve(1<<n);\\n        dp[0] = {};\\n        \\n        for(int i=0;i<v.size();i++)\\n        {\\n            int cur_skill = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                  cur_skill = (cur_skill)|(1<<v[i][j]);\\n            } \\n            \\n            for(auto it = dp.begin(); it!= dp.end() ;it++)\\n            {\\n                int comb = (cur_skill)|(it->first);\\n                if(dp.find(comb)==dp.end() or dp[comb].size()>1+dp[it->first].size())\\n                {\\n                    dp[comb] = it->second;\\n                    dp[comb].push_back(i);\\n                }\\n            }\\n        } \\n        \\n        return dp[(1<<n)-1];\\n    }\\n};\\n```"
    },
    {
        "slug": "range-sum-of-bst",
        "tags": "cpp",
        "release_time": 1670382055,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\nint sum = 0; // Initialised Sum\n    void Traversal(TreeNode* root,int low,int high)\n    {\n        if(root==NULL) // If Node is NULL then we return \n        return;\n        Traversal(root->left,low,high); // To check for left Node\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\n        Traversal(root->right,low,high); // To check for right Node\n    }\n    int rangeSumBST(TreeNode* root, int low, int high) {\n        ios_base::sync_with_stdio(false);\n        cin.tie(nullptr);\n        cout.tie(nullptr); // To make input output fast\n        Traversal(root,low,high); //To Traverse in BST\n        return sum;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSelf Explainatory Code.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHopeYou Understand!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$ for recursion stack space\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint sum = 0; // Initialised Sum\\n    void Traversal(TreeNode* root,int low,int high)\\n    {\\n        if(root==NULL) // If Node is NULL then we return \\n        return;\\n        Traversal(root->left,low,high); // To check for left Node\\n        if(root->val <= high && root->val >=low)sum+=root->val;// If value of node is in range then add to sum.\\n        Traversal(root->right,low,high); // To check for right Node\\n    }\\n    int rangeSumBST(TreeNode* root, int low, int high) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr); // To make input output fast\\n        Traversal(root,low,high); //To Traverse in BST\\n        return sum;\\n    }\\n};\\n```"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "tags": "cpp",
        "release_time": 1689057293,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string BFS(TreeNode* root)\n    {\n        if(!root) return \"\";\n        queue<pair<TreeNode*,string>> q;\n        vector<string> ans;\n        string s = \"\";\n        s+=root->val+97;\n        q.push({root,s});\n        while(!q.empty())\n        {\n            TreeNode* node = q.front().first;\n            string str = q.front().second;\n            q.pop();\n            if(!node->left && !node->right)\n            {\n                reverse(str.begin(),str.end());\n                ans.push_back(str);\n            }\n            if(node->left)\n            {\n                string tmp = str;\n                tmp+=node->left->val+97;\n                q.push({node->left,tmp});\n            }\n            if(node->right)\n            {\n                string tmp = str;\n                tmp+=node->right->val+97;\n                q.push({node->right,tmp});\n            }\n        }\n        sort(ans.begin(),ans.end());\n        return ans[0];\n    }\n    string smallestFromLeaf(TreeNode* root) {\n       return BFS(root);\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo the BFS Traversal from  **Root Node** to **Leaf Node** and Store the **Path as a string** and return the **lexicographically smallest** string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    string BFS(TreeNode* root)\\n    {\\n        if(!root) return \"\";\\n        queue<pair<TreeNode*,string>> q;\\n        vector<string> ans;\\n        string s = \"\";\\n        s+=root->val+97;\\n        q.push({root,s});\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front().first;\\n            string str = q.front().second;\\n            q.pop();\\n            if(!node->left && !node->right)\\n            {\\n                reverse(str.begin(),str.end());\\n                ans.push_back(str);\\n            }\\n            if(node->left)\\n            {\\n                string tmp = str;\\n                tmp+=node->left->val+97;\\n                q.push({node->left,tmp});\\n            }\\n            if(node->right)\\n            {\\n                string tmp = str;\\n                tmp+=node->right->val+97;\\n                q.push({node->right,tmp});\\n            }\\n        }\\n        sort(ans.begin(),ans.end());\\n        return ans[0];\\n    }\\n    string smallestFromLeaf(TreeNode* root) {\\n       return BFS(root);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/67c6667a-66b6-4d36-846d-56e86a3b137a_1689057284.4817927.jpeg)\\n"
    },
    {
        "slug": "subsets",
        "tags": "cpp",
        "release_time": 1685597536,
        "code": "class Solution {\npublic:\n\n    void solve(vector<int> &nums, vector<vector<int>> &result, vector<int> &ans, int idx, int n){\n        result.push_back(ans);\n\n        for(int i=idx;i<n;i++){\n            ans.push_back(nums[i]);\n            solve(nums, result, ans, i+1, n);\n            ans.pop_back();\n        }\n    }\n\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> result;\n        vector<int> ans;\n        int n = nums.size();\n\n        solve(nums, result, ans, 0, n);\n    \n        return result;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void solve(vector<int> &nums, vector<vector<int>> &result, vector<int> &ans, int idx, int n){\\n        result.push_back(ans);\\n\\n        for(int i=idx;i<n;i++){\\n            ans.push_back(nums[i]);\\n            solve(nums, result, ans, i+1, n);\\n            ans.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> result;\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        solve(nums, result, ans, 0, n);\\n    \\n        return result;\\n    }\\n};\\n```"
    },
    {
        "slug": "greatest-common-divisor-of-strings",
        "tags": "cpp",
        "release_time": 1675286920,
        "code": "class Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n\n        if(str1+str2==str2+str1)\n        {\n            return str1.substr(0,gcd(str1.length(),str2.length()));\n        }\n        else{\n            return \"\";\n        }\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string gcdOfStrings(string str1, string str2) {\\n\\n        if(str1+str2==str2+str1)\\n        {\\n            return str1.substr(0,gcd(str1.length(),str2.length()));\\n        }\\n        else{\\n            return \"\";\\n        }\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "determine-whether-matrix-can-be-obtained-by-rotation",
        "tags": "cpp",
        "release_time": 1691842204,
        "code": "class Solution {\n    void rotate(vector<vector<int>>& mat){\n        int n = mat.size();\n        for(int i = 0;i < n;i++){\n            for(int j = i+1;j < n;j++){\n                swap(mat[i][j], mat[j][i]);\n            }\n        }\n        for(int i = 0;i < n;i++)\n            reverse(mat[i].begin(), mat[i].end());\n    }\npublic:\n    bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\n        for(int i = 0;i < 4;i++){\n            rotate(mat);\n            if(mat == target) return true;\n        }\n        return false;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\n    void rotate(vector<vector<int>>& mat){\\n        int n = mat.size();\\n        for(int i = 0;i < n;i++){\\n            for(int j = i+1;j < n;j++){\\n                swap(mat[i][j], mat[j][i]);\\n            }\\n        }\\n        for(int i = 0;i < n;i++)\\n            reverse(mat[i].begin(), mat[i].end());\\n    }\\npublic:\\n    bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {\\n        for(int i = 0;i < 4;i++){\\n            rotate(mat);\\n            if(mat == target) return true;\\n        }\\n        return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximize-win-from-two-segments",
        "tags": "cpp",
        "release_time": 1675528605,
        "code": "class Solution \n{\npublic:\n    int maximizeWin(vector<int>& a, int k) \n    {\n        int n = a.size();\n        vector<pair<int, int>> b(n), s(n);\n        for (int i = 0; i < n; ++i)\n        {\n            int target = a[i] + k;\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\n            b[i] = {i, idx};\n        }\n        \n        int mx = 0;\n        pair<int, int> curr;\n        for (int i = n - 1; i >= 0; --i)\n        {\n            if (b[i].second - b[i].first + 1 > mx)\n            {\n                mx = b[i].second - b[i].first + 1;\n                curr = {b[i].first, b[i].second}; \n            }\n            \n            s[i] = curr;\n        }\n        \n        int res = 1;\n        for (int i = 0; i < n; ++i)\n        {\n            int j = b[i].second;\n            \n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\n        }\n        \n        return res;\n    }\n};",
        "content": "# Time Complexity: $$O(nlog(n))$$\\n\\n```\\nclass Solution \\n{\\npublic:\\n    int maximizeWin(vector<int>& a, int k) \\n    {\\n        int n = a.size();\\n        vector<pair<int, int>> b(n), s(n);\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int target = a[i] + k;\\n            int idx = max(0, (int)(upper_bound(a.begin(), a.end(), target) - a.begin()) - 1);\\n            b[i] = {i, idx};\\n        }\\n        \\n        int mx = 0;\\n        pair<int, int> curr;\\n        for (int i = n - 1; i >= 0; --i)\\n        {\\n            if (b[i].second - b[i].first + 1 > mx)\\n            {\\n                mx = b[i].second - b[i].first + 1;\\n                curr = {b[i].first, b[i].second}; \\n            }\\n            \\n            s[i] = curr;\\n        }\\n        \\n        int res = 1;\\n        for (int i = 0; i < n; ++i)\\n        {\\n            int j = b[i].second;\\n            \\n            res = max(res, b[i].second - b[i].first + 1 + s[j].second - s[j].first + 1 - (s[j].first == b[i].second));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "number-complement",
        "tags": "cpp",
        "release_time": 1640574941,
        "code": "class Solution {\npublic:\n    int findComplement(int num) {\n        unsigned mask = ~0;\n        while( mask & num ) mask = mask << 1;\n        return ~num ^ mask;\n    }\n};",
        "content": "Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.\\n\\n**Intuition:-**\\nThere is not much of a intuition in this question as the question is loud and clear about it\\'s use of bit manipulation .\\n\\nTo make things a bit more interesting let\\'s do this question with and wihout bit manipulation\\n\\n* **Using Bit Manipulations:---**\\n\\n**Bit masking can be summarized with this image (^_^)**\\n![image](https://assets.leetcode.com/users/images/d478c8d2-3fbb-49fd-956a-ae31a014a926_1640579005.4899502.jpeg) \\nThus, we can conclude that masking means to keep/change/remove a desired part of information.\\n\\n**Dry run of bitmasking:-**\\n![image](https://assets.leetcode.com/users/images/face3402-7526-4282-becd-7564dc8b4a95_1640574890.4955626.png)\\n\\n**Code1[Using bitmasking]:-**\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        unsigned mask = ~0;\\n        while( mask & num ) mask = mask << 1;\\n        return ~num ^ mask;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(log(num)) = O(since we will be moving at most 32bits only) = O(1)`*\\n**Space Complexity:** *`O(1)`*\\n\\n**Code2[Using xor]:-**\\nBasic idea is to find the smallest power of 2 that is larger than the `input number num`, and output the difference between `powerof2s` and `num` . \\n\\n**Dry run:-**\\n```\\nFor example let\\'s the example from description of the question:-\\nInput: num = 5(101) ,\\nThus the smallest power of 2 (and larger than 5) is 8 (1000)\\nThe output should be 8 - 5 - 1 = 2 (010).\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        long powerof2s = 2, temp = num;\\n        \\n        while(temp>>1) {\\n            temp >>= 1;\\n            powerof2s <<= 1;\\n        }\\n        \\n        return powerof2s - num - 1;\\n    }\\n};\\n```\\n.\\n\\n* **Without using Bit manipulation:-**\\n\\n***Code:-***\\n```\\nclass Solution {\\npublic:\\n    int findComplement(int num) {\\n        vector<int> temp; \\n\\t\\t// convert to binary representation\\n        while( num != 0 ){\\n            temp.push_back( num % 2 );\\n            num /= 2;\\n        } \\n\\t\\t// make complement\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i] == 1 ) temp[i] = 0;\\n            else if( temp[i] == 0 ) temp[i] = 1;\\n        } int res = 0;\\n        for(int i=temp.size()-1; i>-1; i--) res = res * 2 + temp[i];\\n        return res;\\n    }\\n};\\n```\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n......*Continuation from previous posts..\\nTill now in Dr.Cheems ancient ruins arc, JThree,Doggo,Dogenderous,Dogelina and yomru all of them reached the crystal white ceiling of the Dr Cheems ancient laboratory . When they were just above the ceiling everyone saw some black texts at all 4 directions . Once they landed on the ceiling. JThree,Doggo,yomru and Dogelina all of them started moving in those directions to find those texts that were present on the ceiling . All of them found the texts .\\nTo be Continued in the next post* ......\\n\\n"
    },
    {
        "slug": "minimum-difference-between-largest-and-smallest-value-in-three-moves",
        "tags": "cpp",
        "release_time": 1676910148,
        "code": "class Solution {\npublic:\n    int minDifference(vector<int>& nums) {\n        if(nums.size() <= 4) return 0;\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int minDifference(vector<int>& nums) {\\n        if(nums.size() <= 4) return 0;\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        return min({nums[n - 4] - nums[0], nums[n - 1] - nums[3], nums[n - 3] - nums[1], nums[n - 2] - nums[2]});\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "total-appeal-of-a-string",
        "tags": "cpp",
        "release_time": 1684999206,
        "code": "class Solution {\npublic:\n    long long appealSum(string s) {\n        long long int x = 1, y = 1, k = 0;\n        vector<int> v(26,-1);//make an array store index of chars\n\n        v[s[0]-'a'] = 1; \n        // cout<<1<<\" \";\n        for(int i = 1; i < s.length(); i++){\n            x += i+1;//x is strore ans till ith index.\n            if(v[s[i]-'a'] > 0){//if char previously came than increment and by curr index - pre index\n                x -= v[s[i]-'a'];\n            }\n            // cout<<x<<\" \";\n            y += x;\n            v[s[i]-'a'] = i+1;//storing index\n        }\n        return y;//y is ans variable\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long appealSum(string s) {\\n        long long int x = 1, y = 1, k = 0;\\n        vector<int> v(26,-1);//make an array store index of chars\\n\\n        v[s[0]-\\'a\\'] = 1; \\n        // cout<<1<<\" \";\\n        for(int i = 1; i < s.length(); i++){\\n            x += i+1;//x is strore ans till ith index.\\n            if(v[s[i]-\\'a\\'] > 0){//if char previously came than increment and by curr index - pre index\\n                x -= v[s[i]-\\'a\\'];\\n            }\\n            // cout<<x<<\" \";\\n            y += x;\\n            v[s[i]-\\'a\\'] = i+1;//storing index\\n        }\\n        return y;//y is ans variable\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-common-prefix",
        "tags": "cpp",
        "release_time": 1692119515,
        "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& str) \n    {\n        sort(str.begin(), str.end()); //sorting the array\n        string ans=\"\"; //creating a new empty string to store the common prefixes\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\n        {\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\n                break;\n            ans+=str[0][i]; // concatinate if the characters are matching\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "valid-perfect-square",
        "tags": "cpp",
        "release_time": 1683215984,
        "code": "class Solution {\npublic:\n    bool isPerfectSquare(int num) {\n        int lNum=num%10;\n        if(lNum==2 || lNum==3 || lNum==7 || lNum==8){\n            return false;\n        }\n        int start=1;\n        int end=num;\n        long long int mid= start+(end-start)/2;\n        while(start<=end){\n            long long int res = mid*mid;\n            if(res==num){\n                return true;\n            }else if(res>num){\n                end=mid-1;\n            }else if(res<num){\n                start=mid+1;\n            }\n            mid= (start+end)>>1;\n        }\n        return false;\n    }\n};",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **All the values ends with 2, 3, 7, 8 are never perfect squares (just an simple observation). So if any value ends with these values then simply return false.** \\n\\n- Otherwise, \\n **Do Binary search from 1 to num (given), if square of mid is equal to sum then it\\'s true. if square of mid is greater than given num then if there is any possible value then  it must lie in the right side of mid otherwise if square of mid is less than given num then if there is a possible value then it must lie in the left side of the mid.** \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logn)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPerfectSquare(int num) {\\n        int lNum=num%10;\\n        if(lNum==2 || lNum==3 || lNum==7 || lNum==8){\\n            return false;\\n        }\\n        int start=1;\\n        int end=num;\\n        long long int mid= start+(end-start)/2;\\n        while(start<=end){\\n            long long int res = mid*mid;\\n            if(res==num){\\n                return true;\\n            }else if(res>num){\\n                end=mid-1;\\n            }else if(res<num){\\n                start=mid+1;\\n            }\\n            mid= (start+end)>>1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful \\u2B06\\uFE0F"
    },
    {
        "slug": "add-two-numbers",
        "tags": "cpp",
        "release_time": 1691909288,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        //initializing tem and temp so that l1 and l2 reamins preserved,\n        //though this isn't needed but it a good practice\n        ListNode* temp=l1;\n        ListNode* tem=l2;\n        ListNode *ans;\n        ListNode *head;\n        int carry=0;\n        int valu;\n        //initiallize the first node of answer\n        int sum=tem->val+temp->val+carry;\n        valu=sum%10;\n        carry=sum/10;\n        ListNode* node =new ListNode(valu);\n        ans=node;\n        head=ans;\n        tem=tem->next;\n        temp=temp->next;\n        while(tem!=NULL && temp!=NULL)\n        {\n            sum=tem->val+temp->val+carry;\n            valu=sum%10;\n            carry=sum/10;\n            ListNode* node =new ListNode(valu);\n            ans->next=node;\n            ans=ans->next;\n            temp=temp->next;\n            tem=tem->next;\n        }\n        //if l1 gets over and there are still some elements in l2\n        if(tem==NULL && temp!=NULL)\n        {\n            while(temp!=NULL)\n            {\n                sum=temp->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                temp=temp->next;\n            }\n        }\n        //if l2 gets over and there are still some elements in l1\n        if(tem!=NULL && temp==NULL)\n        {\n            while(tem!=NULL)\n            {\n                sum=tem->val+carry;\n                valu=sum%10;\n                carry=sum/10;\n                ListNode* node =new ListNode(valu);\n                ans->next=node;\n                ans=ans->next;\n                tem=tem->next;\n            }\n        }\n        //if there is still a carry left\n        if(carry!=0)\n        {\n            ListNode* node =new ListNode(carry);\n            ans->next=node;\n        }\n        return head;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code might seem really complex for the first time, but this only because i have specified every corner case differently, cmon i will give u a walk through my code.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just using a variable for the value we want as node\\'s vale and a carry, rest the operation is as simple as we add two numbers.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        //initializing tem and temp so that l1 and l2 reamins preserved,\\n        //though this isn\\'t needed but it a good practice\\n        ListNode* temp=l1;\\n        ListNode* tem=l2;\\n        ListNode *ans;\\n        ListNode *head;\\n        int carry=0;\\n        int valu;\\n        //initiallize the first node of answer\\n        int sum=tem->val+temp->val+carry;\\n        valu=sum%10;\\n        carry=sum/10;\\n        ListNode* node =new ListNode(valu);\\n        ans=node;\\n        head=ans;\\n        tem=tem->next;\\n        temp=temp->next;\\n        while(tem!=NULL && temp!=NULL)\\n        {\\n            sum=tem->val+temp->val+carry;\\n            valu=sum%10;\\n            carry=sum/10;\\n            ListNode* node =new ListNode(valu);\\n            ans->next=node;\\n            ans=ans->next;\\n            temp=temp->next;\\n            tem=tem->next;\\n        }\\n        //if l1 gets over and there are still some elements in l2\\n        if(tem==NULL && temp!=NULL)\\n        {\\n            while(temp!=NULL)\\n            {\\n                sum=temp->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                temp=temp->next;\\n            }\\n        }\\n        //if l2 gets over and there are still some elements in l1\\n        if(tem!=NULL && temp==NULL)\\n        {\\n            while(tem!=NULL)\\n            {\\n                sum=tem->val+carry;\\n                valu=sum%10;\\n                carry=sum/10;\\n                ListNode* node =new ListNode(valu);\\n                ans->next=node;\\n                ans=ans->next;\\n                tem=tem->next;\\n            }\\n        }\\n        //if there is still a carry left\\n        if(carry!=0)\\n        {\\n            ListNode* node =new ListNode(carry);\\n            ans->next=node;\\n        }\\n        return head;\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "maximum-number-of-ways-to-partition-an-array",
        "tags": "cpp",
        "release_time": 1679484439,
        "code": "class Solution {\npublic:\n    long long int getSum(vector<int> &nums){\n        long long int temp = 0;\n        for(auto &i : nums) temp += i;\n        return temp;\n    }\n\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\n        \n        // If flag, then we need to change element from right subarray\n        if(flag){\n            if(mp[val].second >= pivot) return true;\n            return false;\n        }\n\n        // Else we need to change element from left subarray\n        else{\n            if(mp[val].first < pivot) return true;\n            return false;\n        }\n    }\n\n    int waysToPartition(vector<int>& nums, int k) {\n        unordered_map<long long int, pair<int, int>> mp;\n        unordered_map<long long int, pair<int, int>> count;\n\n        // mp stores first and last occurence of an element\n        for(int i=0; i<nums.size(); i++){\n            if(mp.find(nums[i]) == mp.end()){\n                mp[nums[i]].first = i;\n            }\n            mp[nums[i]].second = i;\n        }\n\n        long long int totSum = getSum(nums);\n        long long int left = nums[0];\n        int ans = 0;\n\n        for(int i=1; i<nums.size(); i++){\n            long long int right = totSum - left;\n\n            if(left == right){\n                ans++;\n            }\n            else{\n                long long int diff = left - right;\n\n                // num is the value of element we need to change with k wo satisfy the condition\n                long long int num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 1)){\n\n                        // count.second means we have got the element in right subarray with which we can replace our k\n                        count[num].second++;\n                    }\n                }\n\n                diff = right - left;\n                num = k - diff;\n\n                if(mp.find(num) != mp.end()){\n                    if(check(mp, num, i, 0)){\n\n                        // count.first means we got element in left subarray to get replaced \n\n                        count[num].first++; \n                    }\n                }\n            }\n\n            left += nums[i];\n\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\n        }\n\n        int maxi = INT_MIN;\n        for(auto [i,j] : count){\n            maxi = max(maxi, max(j.first, j.second));\n        }\n\n        return max(maxi, ans);\n    }\n};",
        "content": "# Intuition\\nTry to play between left and right subarray in form of variables.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int getSum(vector<int> &nums){\\n        long long int temp = 0;\\n        for(auto &i : nums) temp += i;\\n        return temp;\\n    }\\n\\n    bool check(unordered_map<long long int, pair<int, int>> &mp, long long int val, int pivot, bool flag){\\n        \\n        // If flag, then we need to change element from right subarray\\n        if(flag){\\n            if(mp[val].second >= pivot) return true;\\n            return false;\\n        }\\n\\n        // Else we need to change element from left subarray\\n        else{\\n            if(mp[val].first < pivot) return true;\\n            return false;\\n        }\\n    }\\n\\n    int waysToPartition(vector<int>& nums, int k) {\\n        unordered_map<long long int, pair<int, int>> mp;\\n        unordered_map<long long int, pair<int, int>> count;\\n\\n        // mp stores first and last occurence of an element\\n        for(int i=0; i<nums.size(); i++){\\n            if(mp.find(nums[i]) == mp.end()){\\n                mp[nums[i]].first = i;\\n            }\\n            mp[nums[i]].second = i;\\n        }\\n\\n        long long int totSum = getSum(nums);\\n        long long int left = nums[0];\\n        int ans = 0;\\n\\n        for(int i=1; i<nums.size(); i++){\\n            long long int right = totSum - left;\\n\\n            if(left == right){\\n                ans++;\\n            }\\n            else{\\n                long long int diff = left - right;\\n\\n                // num is the value of element we need to change with k wo satisfy the condition\\n                long long int num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 1)){\\n\\n                        // count.second means we have got the element in right subarray with which we can replace our k\\n                        count[num].second++;\\n                    }\\n                }\\n\\n                diff = right - left;\\n                num = k - diff;\\n\\n                if(mp.find(num) != mp.end()){\\n                    if(check(mp, num, i, 0)){\\n\\n                        // count.first means we got element in left subarray to get replaced \\n\\n                        count[num].first++; \\n                    }\\n                }\\n            }\\n\\n            left += nums[i];\\n\\n            // Suppose there is an element which was on the right side earlier but now as we moving, it came to the left side, so update left usage with it\\n            count[nums[i]].first = max(count[nums[i]].first, count[nums[i]].second);\\n        }\\n\\n        int maxi = INT_MIN;\\n        for(auto [i,j] : count){\\n            maxi = max(maxi, max(j.first, j.second));\\n        }\\n\\n        return max(maxi, ans);\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "tags": "cpp",
        "release_time": 1670688199,
        "code": "class Solution {\npublic:\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\n        long long ans = 0;\n        \n        vector<int> counts(100005, 0);\n        int dominantCnt = 0;\n        int dominantNum = -1;\n        int involvedCnt = 0;\n        int n = nums1.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums1[i] == nums2[i]) {\n                ans += i;\n                counts[nums1[i]]++;\n                if (counts[nums1[i]] > dominantCnt) {\n                    dominantCnt = counts[nums1[i]];\n                    dominantNum = nums1[i];\n                }\n                involvedCnt++;\n            }\n        }\n        if (dominantCnt > involvedCnt / 2) {\n            for (int i = 0; i < n; ++i) {\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\n                    counts[nums1[i]]++;\n                    involvedCnt++;\n                    ans += i;\n                    if (dominantCnt <= involvedCnt / 2) {\n                        return ans;\n                    }\n                }\n            }\n            return -1;\n        }\n        else {\n            return ans;\n        }\n    }\n};",
        "content": "# Intuition and Approach\\n1. The cost of swapping numbers at idx1 and idx2 is `idx1 + idx2`\\n2. You only need to swap numbers at i that are identical in nums1[i] and nums2[i].\\n- e.g., `nums1 = [1,2,3,4,5]; nums2 = [2,2,3,5,5]` => extract `[2,3,5]`\\n3. Let\\'s consider two cases\\n- The `count of dominant element <= the count of all extracted elements / 2`. See 4\\n- The `count of dominant element > the count of all extracted elements / 2`. See 6\\n4. You can just sum all idx of them. There must be one permutation that can achieve the criteria: no identical number. For example, `[2,3,5]` can be permutated into `[5,2,3]`, and `[2,2,4,4]` can be permuted into `[4,4,2,2]`. \\n5. You might wonder what is the least cost to make such permutation. Consider you want to swap idx `i` to somewhere `j`, you must cost `i` first and then `j`, and if `j=0` the cost is `i`. So any swap of two numbers can be regarded as a process of swapping `i <-> 0 (of the original array) <-> j`. The total cost would be the sum of all idx. For the proof, please see [l_returns\\'s](https://leetcode.com/problems/minimum-total-cost-to-make-arrays-unequal/solutions/2897969/c-simple-greedy-in-on-with-explanation/comments/1712870) comment.\\n6. If there is case like `[2,2,2,3,3]`, there is no permutation that can achieve the goal. So keep adding other elements from the original array for changing `2`, which is the dominant element in the example. Besides, you should avoid the idx `k` that `nums1[k] == dominant number || nums2[k] == dominant number`.\\n7. If the left numbers are exhausted and you still can not achieve `count of dominant element <= the count of all extract elements / 2`, return -1.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(The range of the numbers)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTotalCost(vector<int>& nums1, vector<int>& nums2) {\\n        long long ans = 0;\\n        \\n        vector<int> counts(100005, 0);\\n        int dominantCnt = 0;\\n        int dominantNum = -1;\\n        int involvedCnt = 0;\\n        int n = nums1.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (nums1[i] == nums2[i]) {\\n                ans += i;\\n                counts[nums1[i]]++;\\n                if (counts[nums1[i]] > dominantCnt) {\\n                    dominantCnt = counts[nums1[i]];\\n                    dominantNum = nums1[i];\\n                }\\n                involvedCnt++;\\n            }\\n        }\\n        if (dominantCnt > involvedCnt / 2) {\\n            for (int i = 0; i < n; ++i) {\\n                if (nums1[i] != nums2[i] && nums1[i] != dominantNum && nums2[i] != dominantNum) {\\n                    counts[nums1[i]]++;\\n                    involvedCnt++;\\n                    ans += i;\\n                    if (dominantCnt <= involvedCnt / 2) {\\n                        return ans;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n        else {\\n            return ans;\\n        }\\n    }\\n};\\n```"
    },
    {
        "slug": "next-greater-node-in-linked-list",
        "tags": "cpp",
        "release_time": 1683452943,
        "code": "class Solution {\npublic:\n    int find(ListNode* temp)\n    {\n        int reqval = temp->val;\n        temp = temp->next;\n        while(temp!=NULL)\n        {\n            if(temp->val > reqval)\n            {\n                return temp->val;\n            }\n            temp = temp->next;\n        }\n        return 0;\n    }\n    vector<int> nextLargerNodes(ListNode* head) {\n        vector<int> ans;\n        ListNode* temp = head;\n        while(temp!=NULL)\n        {\n            int result = find(temp);\n            ans.push_back(result);\n            temp = temp->next;\n        }\n        return ans;      \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(ListNode* temp)\\n    {\\n        int reqval = temp->val;\\n        temp = temp->next;\\n        while(temp!=NULL)\\n        {\\n            if(temp->val > reqval)\\n            {\\n                return temp->val;\\n            }\\n            temp = temp->next;\\n        }\\n        return 0;\\n    }\\n    vector<int> nextLargerNodes(ListNode* head) {\\n        vector<int> ans;\\n        ListNode* temp = head;\\n        while(temp!=NULL)\\n        {\\n            int result = find(temp);\\n            ans.push_back(result);\\n            temp = temp->next;\\n        }\\n        return ans;      \\n    }\\n};\\n```"
    },
    {
        "slug": "visit-array-positions-to-maximize-score",
        "tags": "cpp",
        "release_time": 1690044797,
        "code": "class Solution {\npublic:\n    long long f(int ind, vector<int>&nums , int x, int parity, vector<vector<long long>>&dp)\n    {\n        if(ind == nums.size())\n            return 0;\n        if(dp[ind][parity] != -1)\n            return dp[ind][parity];\n        long long ntake = f(ind+1,nums,x,parity,dp);\n        long long take = 0;\n        if(nums[ind] % 2 == parity)\n            take = nums[ind] + f(ind+1,nums,x,parity,dp);\n        else\n            take = nums[ind] - x + f(ind+1,nums,x,nums[ind]%2,dp);\n        return dp[ind][parity] = max(take,ntake);\n    }\n    long long tabulation(vector<int>&nums, int x)\n    {\n        int n = nums.size();\n        vector<vector<long long>>dp(n+1,vector<long long>(2,0));\n        for(int ind = n-1 ; ind >= 0 ; ind--)\n        {\n            for(int parity = 0 ; parity <= 1 ; parity++)\n            {\n                long long ntake = dp[ind+1][parity];\n                long long take = 0;\n                if(nums[ind] % 2 == parity)\n                    take = nums[ind] + dp[ind+1][parity];\n                else\n                    take = nums[ind] - x + dp[ind+1][nums[ind]%2];\n                 dp[ind][parity] = max(take,ntake);\n            }\n        }\n        return dp[0][nums[0]%2];\n    }\n    long long spaceOptimized(vector<int>&nums, int x)\n    {\n        int n = nums.size();\n        vector<long long>dp(2,0);\n        vector<long long>temp(2,0);\n        for(int ind = n-1 ; ind >= 0 ; ind--)\n        {\n            for(int parity = 0 ; parity <= 1 ; parity++)\n            {\n                long long ntake = dp[parity];\n                long long take = 0;\n                if(nums[ind] % 2 == parity)\n                    take = nums[ind] + dp[parity];\n                else\n                    take = nums[ind] - x + dp[nums[ind]%2];\n                 temp[parity] = max(take,ntake);\n            }\n            dp = temp;\n        }\n        return dp[nums[0]%2];\n    }\n    long long maxScore(vector<int>& nums, int x) {\n        long long n = nums.size();\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\n        int parity = nums[0]%2;\n        //return nums[0] + f(1,nums,x,parity,dp);   \n        //return tabulation(nums,x);\n        return spaceOptimized(nums,x);\n    }\n};",
        "content": "\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int ind, vector<int>&nums , int x, int parity, vector<vector<long long>>&dp)\\n    {\\n        if(ind == nums.size())\\n            return 0;\\n        if(dp[ind][parity] != -1)\\n            return dp[ind][parity];\\n        long long ntake = f(ind+1,nums,x,parity,dp);\\n        long long take = 0;\\n        if(nums[ind] % 2 == parity)\\n            take = nums[ind] + f(ind+1,nums,x,parity,dp);\\n        else\\n            take = nums[ind] - x + f(ind+1,nums,x,nums[ind]%2,dp);\\n        return dp[ind][parity] = max(take,ntake);\\n    }\\n    long long tabulation(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<vector<long long>>dp(n+1,vector<long long>(2,0));\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[ind+1][parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[ind+1][parity];\\n                else\\n                    take = nums[ind] - x + dp[ind+1][nums[ind]%2];\\n                 dp[ind][parity] = max(take,ntake);\\n            }\\n        }\\n        return dp[0][nums[0]%2];\\n    }\\n    long long spaceOptimized(vector<int>&nums, int x)\\n    {\\n        int n = nums.size();\\n        vector<long long>dp(2,0);\\n        vector<long long>temp(2,0);\\n        for(int ind = n-1 ; ind >= 0 ; ind--)\\n        {\\n            for(int parity = 0 ; parity <= 1 ; parity++)\\n            {\\n                long long ntake = dp[parity];\\n                long long take = 0;\\n                if(nums[ind] % 2 == parity)\\n                    take = nums[ind] + dp[parity];\\n                else\\n                    take = nums[ind] - x + dp[nums[ind]%2];\\n                 temp[parity] = max(take,ntake);\\n            }\\n            dp = temp;\\n        }\\n        return dp[nums[0]%2];\\n    }\\n    long long maxScore(vector<int>& nums, int x) {\\n        long long n = nums.size();\\n        vector<vector<long long>>dp(n,vector<long long>(2,-1));\\n        int parity = nums[0]%2;\\n        //return nums[0] + f(1,nums,x,parity,dp);   \\n        //return tabulation(nums,x);\\n        return spaceOptimized(nums,x);\\n    }\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public long maxScore(int[] nums, int x) {\\n        int n = nums.length;\\n        // long[][] dp = new long[n][2];\\n        // for (long[] a : dp)\\n        //     Arrays.fill(a, -1);\\n        // int parity = nums[0] % 2;\\n        // return nums[0] + solve(nums, 1, x, parity, dp);\\n        // return tabulation(nums, n, x);\\n        return spaceOptimization(nums, n, x);\\n    }\\n    \\n    private long solve(int[] nums, int index, int x, int parity, long[][] dp) {\\n        if (index == nums.length) {\\n            return 0;\\n        }\\n        if (dp[index][parity] != -1)\\n            return dp[index][parity];\\n        long notTake = solve(nums, index + 1, x, parity, dp);\\n        long take = 0;\\n        if (nums[index] % 2 == parity) {\\n            take = nums[index] + solve(nums, index + 1, x, parity, dp);\\n        } else {\\n            take = nums[index] - x + solve(nums, index + 1, x, nums[index] % 2, dp);\\n        }\\n        return dp[index][parity] = Math.max(take, notTake);\\n    }\\n    \\n    private long tabulation (int[] nums, int n, int x) {\\n        long[][] dp = new long[n + 1][2];\\n        dp[n][0] = 0;\\n        dp[n][1] = 0;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = dp[i + 1][j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + dp[i + 1][j];\\n                } else {\\n                    take = nums[i] - x + dp[i + 1][nums[i] % 2];\\n                }\\n                dp[i][j] = Math.max(take, notTake);\\n            }\\n        }\\n        return dp[0][nums[0] % 2];\\n    }\\n    \\n    private long spaceOptimization (int[] nums, int n, int x) {\\n        long[] prev = new long[2];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            long[] curr = new long[2];\\n            for (int j = 0; j <= 1; j++) {\\n                long notTake = prev[j];\\n                long take = 0;\\n                if (nums[i] % 2 == j) {\\n                    take = nums[i] + prev[j];\\n                } else {\\n                    take = nums[i] - x + prev[nums[i] % 2];\\n                }\\n                curr[j] = Math.max(take, notTake);\\n            }\\n            prev = curr;\\n        }\\n        return prev[nums[0] % 2];\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-point-is-reachable",
        "tags": "cpp",
        "release_time": 1674372109,
        "code": "class Solution {\npublic:\n    bool isReachable(int x, int y) {\n        while(!(x&1)){\n            x >>= 1;\n        }\n        while(!(y&1)){\n            y >>= 1;\n        }\n        return __gcd(x,y)==1;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool isReachable(int x, int y) {\\n        while(!(x&1)){\\n            x >>= 1;\\n        }\\n        while(!(y&1)){\\n            y >>= 1;\\n        }\\n        return __gcd(x,y)==1;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "tags": "cpp",
        "release_time": 1678208037,
        "code": "#define ll long long \nclass Solution {\npublic:\n    long long minimumTime(vector<int>& time, int totalTrips) {\n        ll l = 1, r = 1e14;\n        while(l <= r) {\n            ll trip = 0, mid = (l + r) / 2;\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\n            if(trip < totalTrips) l = mid + 1;\n            else r = mid - 1;\n        }\n        return l;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```"
    },
    {
        "slug": "widest-vertical-area-between-two-points-containing-no-points",
        "tags": "cpp",
        "release_time": 1666839967,
        "code": "class Solution {\npublic:\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n    set<int> x;\n    int res = 0;\n    for (auto &p : points)\n        x.insert(p[0]);\n    for (auto it = next(begin(x)); it != end(x); ++it)\n        res = max(res, *it - *prev(it));\n    return res;\n}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int maxWidthOfVerticalArea(vector<vector<int>>& points) {\\n    set<int> x;\\n    int res = 0;\\n    for (auto &p : points)\\n        x.insert(p[0]);\\n    for (auto it = next(begin(x)); it != end(x); ++it)\\n        res = max(res, *it - *prev(it));\\n    return res;\\n}\\n};\\n```"
    },
    {
        "slug": "hamming-distance",
        "tags": "cpp",
        "release_time": 1692183390,
        "code": "class Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        int ans=0;\n        while(x || y){\n            int mask=x&1;\n            int mask2=y&1;\n            if(mask!=mask2){\n                ans++;\n            }\n            x>>=1;\n            y>>=1;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just have to check the number of bits that are different.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor this approach we follow these steps.\\n1.Run a loop until both the numbers are zero.\\n2.Get the last bit of the two numbers and compare them.\\n3.If the two bits didn\\'t match increase the count.\\n4.After each iteration right shift both the numbers by 1.\\n5.At last return the count.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int hammingDistance(int x, int y) {\\n        int ans=0;\\n        while(x || y){\\n            int mask=x&1;\\n            int mask2=y&1;\\n            if(mask!=mask2){\\n                ans++;\\n            }\\n            x>>=1;\\n            y>>=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **PLEASE DO UPVOTE!!!\\uD83E\\uDD79**"
    },
    {
        "slug": "unique-binary-search-trees",
        "tags": "cpp",
        "release_time": 1689908252,
        "code": "class Solution {\npublic:\nint solve(int n)\n{\n    vector<int>dp(n+1,0);    \n    dp[0]=dp[1]=1;\n    for(int i=2;i<=n;i++)\n    {\n        for(int j= 1;j<=i;j++)\n        {\n            dp[i]+= dp[j-1]*dp[i-j];\n        }\n    }\n        return dp[n];\n}\n    int numTrees(int n) {\n    return solve(n); \n    }\n};",
        "content": "# Homework for you\\nSolve using catalan number and comment the code \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main function numTrees(n) takes an integer n as input and returns the total number of unique binary search trees that can be formed with n nodes.\\n\\nThe helper function solve(n) takes an integer n (representing the number of nodes to form a binary search tree) and returns the number of unique binary search trees that can be formed with n nodes.\\n\\nIn the helper function solve, it initializes a vector dp of size n + 1 with all elements set to 0. The vector dp will be used to store the number of unique binary search trees for i nodes.\\n\\nInitialize dp[0] and dp[1] to 1 since there is only one way to form binary search trees with 0 and 1 nodes (empty tree and single-node tree).\\n\\nIterate from i = 2 up to n. For each i, calculate the number of unique binary search trees using the Catalan number formula: dp[i] = dp[0] * dp[i - 1] + dp[1] * dp[i - 2] + ... + dp[i - 1] * dp[0]. This calculation is done by considering each element j as the root and multiplying the number of unique binary search trees for the left subtree (with j - 1 nodes) and the right subtree (with i - j nodes).\\n\\nReturn dp[n], which represents the total number of unique binary search trees with n nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(int n)\\n{\\n    vector<int>dp(n+1,0);    \\n    dp[0]=dp[1]=1;\\n    for(int i=2;i<=n;i++)\\n    {\\n        for(int j= 1;j<=i;j++)\\n        {\\n            dp[i]+= dp[j-1]*dp[i-j];\\n        }\\n    }\\n        return dp[n];\\n}\\n    int numTrees(int n) {\\n    return solve(n); \\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid",
        "tags": "cpp",
        "release_time": 1680859470,
        "code": "class Solution {\npublic:\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\n        int minRow = min(startPos[0],homePos[0]);\n        int maxRow = max(startPos[0],homePos[0]);\n        int minCol = min(startPos[1],homePos[1]);\n        int maxCol = max(startPos[1],homePos[1]);\n        int cost=0;\n        for (int i=minRow;i<=maxRow;i++) {\n            cost += rowCosts[i];\n        }\n        cost -= rowCosts[startPos[0]];\n        for (int i=minCol;i<=maxCol;i++) {\n            cost += colCosts[i];\n        }\n        cost -= colCosts[startPos[1]];\n        return cost;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& startPos, vector<int>& homePos, vector<int>& rowCosts, vector<int>& colCosts) {\\n        int minRow = min(startPos[0],homePos[0]);\\n        int maxRow = max(startPos[0],homePos[0]);\\n        int minCol = min(startPos[1],homePos[1]);\\n        int maxCol = max(startPos[1],homePos[1]);\\n        int cost=0;\\n        for (int i=minRow;i<=maxRow;i++) {\\n            cost += rowCosts[i];\\n        }\\n        cost -= rowCosts[startPos[0]];\\n        for (int i=minCol;i<=maxCol;i++) {\\n            cost += colCosts[i];\\n        }\\n        cost -= colCosts[startPos[1]];\\n        return cost;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-occurrences-of-a-substring",
        "tags": "cpp",
        "release_time": 1678390123,
        "code": "class Solution {//TC:O(N) SC:O(N)\npublic:\n    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\n        int n = s.length();\n        int ans = 0;\n        map<string,int>map;\n        for(int i = 0;i<= n - minSize;i++) {\n            map[s.substr(i,minSize)]++;\n        }\n\n        for(auto [x,y]:map) {\n            set<char>substring(x.begin(),x.end());//for unique characters in the substring\n            if(substring.size() <= maxLetters) {\n                ans = max(ans,y);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {//TC:O(N) SC:O(N)\\npublic:\\n    int maxFreq(string s, int maxLetters, int minSize, int maxSize) {\\n        int n = s.length();\\n        int ans = 0;\\n        map<string,int>map;\\n        for(int i = 0;i<= n - minSize;i++) {\\n            map[s.substr(i,minSize)]++;\\n        }\\n\\n        for(auto [x,y]:map) {\\n            set<char>substring(x.begin(),x.end());//for unique characters in the substring\\n            if(substring.size() <= maxLetters) {\\n                ans = max(ans,y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "divide-players-into-teams-of-equal-skill",
        "tags": "cpp",
        "release_time": 1676557676,
        "code": "// // **************** Using sorting *****************\n// class Solution {\n// public:\n//     long long dividePlayers(vector<int>& skill) {\n//         int n=skill.size();\n//         sort(skill.begin(), skill.end());\n//         long long ans=0;\n//         int low=0, high=n-1;\n//         int skl=skill[low]+skill[high];\n\n//         while(low<=high){\n//             if( (skill[low]+skill[high])!=skl) return -1;\n//             ans+=skill[low]*skill[high];\n//             low++;\n//             high--;\n//         }\n\n//         return ans;\n//     }\n// };\n\n\n\n\n\n// **************** Using map *****************\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        int n=skill.size();\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\n        if(sum%(n/2)) return -1;\n        long long skillTeam=sum/(n/2);\n\n        unordered_map<int,int>mp;\n        for(auto it: skill){\n            mp[it]++;\n        }\n\n        long long ans=0;\n\n        for(auto it: skill){\n            if(mp.find(it)==mp.end()) continue;\n            mp[it]--;\n\n            int temp=skillTeam-it;\n            if(mp.find(temp)!=mp.end()){\n                mp[temp]--;\n                if(mp[temp]==0) mp.erase(temp);\n                ans+=it*temp;\n                if(mp[it]==0) mp.erase(it);\n            }\n        }\n\n        if(mp.size()>0) return -1;\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan\\'t we just sort and check for the elements????\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust sort the array and check the sum of end elements.\\nIf the sum of the end elements are same then store their product in a variable \"ans\" and repeat the process till the mid.\\n\\nIf any pair don\\'t sum-up equal to its previous pair-sum then simply return \\'-1\\'.\\nOtherwise return \"ans\" in the end.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n// // **************** Using sorting *****************\\n// class Solution {\\n// public:\\n//     long long dividePlayers(vector<int>& skill) {\\n//         int n=skill.size();\\n//         sort(skill.begin(), skill.end());\\n//         long long ans=0;\\n//         int low=0, high=n-1;\\n//         int skl=skill[low]+skill[high];\\n\\n//         while(low<=high){\\n//             if( (skill[low]+skill[high])!=skl) return -1;\\n//             ans+=skill[low]*skill[high];\\n//             low++;\\n//             high--;\\n//         }\\n\\n//         return ans;\\n//     }\\n// };\\n\\n\\n\\n\\n\\n// **************** Using map *****************\\nclass Solution {\\npublic:\\n    long long dividePlayers(vector<int>& skill) {\\n        int n=skill.size();\\n        long long sum=accumulate(skill.begin(), skill.end(), 0);\\n        if(sum%(n/2)) return -1;\\n        long long skillTeam=sum/(n/2);\\n\\n        unordered_map<int,int>mp;\\n        for(auto it: skill){\\n            mp[it]++;\\n        }\\n\\n        long long ans=0;\\n\\n        for(auto it: skill){\\n            if(mp.find(it)==mp.end()) continue;\\n            mp[it]--;\\n\\n            int temp=skillTeam-it;\\n            if(mp.find(temp)!=mp.end()){\\n                mp[temp]--;\\n                if(mp[temp]==0) mp.erase(temp);\\n                ans+=it*temp;\\n                if(mp[it]==0) mp.erase(it);\\n            }\\n        }\\n\\n        if(mp.size()>0) return -1;\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "tags": "cpp",
        "release_time": 1672236479,
        "code": "class TreeAncestor {\npublic:\n    int n;\n\n    vector<int>belong;\n    vector<int>ind;\n    vector<bool>leaf;\n    vector<vector<int>>path_leaf;\n\n    TreeAncestor(int n, vector<int>& parent) {\n        this->n=n;\n        path_leaf.resize(n);\n        belong.resize(n,-1);\n        ind.resize(n,-1);\n        leaf.resize(n,1);\n\n        for(int i=0;i<n;i++){\n            if(parent[i]!=-1)   \n            leaf[parent[i]]=0;\n        }\n        \n        for(int i=0;i<n;i++){\n            if(!leaf[i]) continue;\n            int curr=i;\n            belong[curr]=curr;\n            while(curr!=-1){\n                curr=parent[curr];\n                path_leaf[i].push_back(curr);\n                if(curr!=-1){\n                    belong[curr]=i;\n                    ind[curr]=path_leaf[i].size()-1;\n                }\n            }\n        }\n\n    }\n    \n    int getKthAncestor(int node, int k) {\n        return path_leaf[belong[node]][min(k+ind[node],(int)path_leaf[belong[node]].size()-1)];\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    int n;\\n\\n    vector<int>belong;\\n    vector<int>ind;\\n    vector<bool>leaf;\\n    vector<vector<int>>path_leaf;\\n\\n    TreeAncestor(int n, vector<int>& parent) {\\n        this->n=n;\\n        path_leaf.resize(n);\\n        belong.resize(n,-1);\\n        ind.resize(n,-1);\\n        leaf.resize(n,1);\\n\\n        for(int i=0;i<n;i++){\\n            if(parent[i]!=-1)   \\n            leaf[parent[i]]=0;\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!leaf[i]) continue;\\n            int curr=i;\\n            belong[curr]=curr;\\n            while(curr!=-1){\\n                curr=parent[curr];\\n                path_leaf[i].push_back(curr);\\n                if(curr!=-1){\\n                    belong[curr]=i;\\n                    ind[curr]=path_leaf[i].size()-1;\\n                }\\n            }\\n        }\\n\\n    }\\n    \\n    int getKthAncestor(int node, int k) {\\n        return path_leaf[belong[node]][min(k+ind[node],(int)path_leaf[belong[node]].size()-1)];\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```"
    },
    {
        "slug": "shortest-cycle-in-a-graph",
        "tags": "cpp",
        "release_time": 1686762783,
        "code": "class Solution {\npublic:\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\n    {\n        queue<pair<int, int>> q;\n        unordered_map<int, int> vis;\n        q.push({a, 0});\n        vis[a]=1;\n        while(!q.empty())\n        {\n            int curr = q.front().first;\n            int dis = q.front().second;\n            q.pop();\n            for(auto &x: mp[curr])\n            {\n                if(x.second==ind || vis[x.first]==1)\n                    continue;\n                if(x.first == b)\n                    return dis+1;\n                q.push({x.first, dis+1});\n                vis[x.first]=1;\n            }\n        }\n        return 10000;\n    }\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\n        unordered_map<int, vector<pair<int, int>>> mp;\n        for(int i=0; i<edges.size(); i++)\n        {\n            mp[edges[i][0]].push_back({edges[i][1], i});\n            mp[edges[i][1]].push_back({edges[i][0], i});\n        }\n        int mn = 10000;\n        for(int i=0; i<edges.size(); i++)\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\n        if(mn>=10000)\n            return -1;\n        return mn+1;\n    }\n};",
        "content": "\\n# Approach\\nIdea is to delete an edge connecting a and b, and then find the minimum distance between a and b (without considering the deleted edge), this shortest path plus one is the size of the smallest loop having both nodes a and b. \\nRepeat the same for each edge and return the the size of minimum loop.\\n\\n# Complexity\\n- Time complexity: O(E^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, unordered_map<int, vector<pair<int, int>>> &mp, int a, int b)\\n    {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, int> vis;\\n        q.push({a, 0});\\n        vis[a]=1;\\n        while(!q.empty())\\n        {\\n            int curr = q.front().first;\\n            int dis = q.front().second;\\n            q.pop();\\n            for(auto &x: mp[curr])\\n            {\\n                if(x.second==ind || vis[x.first]==1)\\n                    continue;\\n                if(x.first == b)\\n                    return dis+1;\\n                q.push({x.first, dis+1});\\n                vis[x.first]=1;\\n            }\\n        }\\n        return 10000;\\n    }\\n    int findShortestCycle(int n, vector<vector<int>>& edges) {\\n        unordered_map<int, vector<pair<int, int>>> mp;\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            mp[edges[i][0]].push_back({edges[i][1], i});\\n            mp[edges[i][1]].push_back({edges[i][0], i});\\n        }\\n        int mn = 10000;\\n        for(int i=0; i<edges.size(); i++)\\n            mn = min(mn, f(i, mp, edges[i][0], edges[i][1]));\\n        if(mn>=10000)\\n            return -1;\\n        return mn+1;\\n    }\\n};\\n```"
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "tags": "cpp",
        "release_time": 1675357427,
        "code": "class Solution {\npublic:\n    bool isAlienSorted(vector<string>& words, string order) {\n        unordered_map<char,int> mp;\n        for(int i=0;i<order.size();i++){\n            mp[order[i]] = i;\n        }\n        for(int i=0;i<words.size()-1;i++){\n            string w1 = words[i],w2 = words[i+1];\n            for(int j=0;j<w1.size();j++){\n                if(j == w2.size()) return false;\n            \n            if(w1[j] != w2[j]) {\n                if(mp[w1[j]] > mp[w2[j]]) return false;\n                break;\n            }\n            }\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<order.size();i++){\\n            mp[order[i]] = i;\\n        }\\n        for(int i=0;i<words.size()-1;i++){\\n            string w1 = words[i],w2 = words[i+1];\\n            for(int j=0;j<w1.size();j++){\\n                if(j == w2.size()) return false;\\n            \\n            if(w1[j] != w2[j]) {\\n                if(mp[w1[j]] > mp[w2[j]]) return false;\\n                break;\\n            }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "queries-on-number-of-points-inside-a-circle",
        "tags": "cpp",
        "release_time": 1670308045,
        "code": "class Solution {\npublic:\n\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\n\n        if(dist<=r*r) return true;\n        return false;\n    }\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n\n        vector<int> ans;\n\n        for( auto c: queries){\n            int x1=c[0];\n            int y1=c[1];\n            int r=c[2];\n            int temp=0;\n            \n            for(auto i:points){\n                int x2=i[0];\n                int y2=i[1];\n\n                if(Manhattan(x1,x2,y1,y2,r)){\n                    temp++;\n                }\n\n            }\n\n            ans.push_back(temp);\n\n        }\n        return ans;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool Manhattan(int x1,int x2,int y1,int y2,int r){\\n        int dist= pow((x2-x1),2) + pow((y2-y1),2);\\n\\n        if(dist<=r*r) return true;\\n        return false;\\n    }\\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\\n\\n        vector<int> ans;\\n\\n        for( auto c: queries){\\n            int x1=c[0];\\n            int y1=c[1];\\n            int r=c[2];\\n            int temp=0;\\n            \\n            for(auto i:points){\\n                int x2=i[0];\\n                int y2=i[1];\\n\\n                if(Manhattan(x1,x2,y1,y2,r)){\\n                    temp++;\\n                }\\n\\n            }\\n\\n            ans.push_back(temp);\\n\\n        }\\n        return ans;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-duplicate-number",
        "tags": "cpp",
        "release_time": 1666435696,
        "code": "class Solution {\npublic:\n    \n    int findDuplicate(vector<int>& nums) \n    {\n        \n        int n=nums.size();\n        int fast=nums[0];\n        int slow=nums[0];\n        \n        do{\n            \n            fast=nums[nums[fast]];\n            slow=nums[slow];\n            \n        }while(fast!=slow);\n        \n        fast=nums[0];\n        \n        while(fast!=slow)\n        {\n            fast=nums[fast];\n            slow=nums[slow];\n        }\n        \n        return fast;\n    }\n};",
        "content": "There are 3 key ideas here :\\n\\nOne used here is\\n\\n**==>Entry point to the cycle is the duplicate number. **\\n\\n**We use the second key so we can detect the duplicate number in an array**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findDuplicate(vector<int>& nums) \\n    {\\n        \\n        int n=nums.size();\\n        int fast=nums[0];\\n        int slow=nums[0];\\n        \\n        do{\\n            \\n            fast=nums[nums[fast]];\\n            slow=nums[slow];\\n            \\n        }while(fast!=slow);\\n        \\n        fast=nums[0];\\n        \\n        while(fast!=slow)\\n        {\\n            fast=nums[fast];\\n            slow=nums[slow];\\n        }\\n        \\n        return fast;\\n    }\\n};\\n```"
    },
    {
        "slug": "climbing-stairs",
        "tags": "cpp",
        "release_time": 1676965804,
        "code": "class Solution {\npublic:\n    int solve(int n,vector<int> &dp){\n        //base case\n        if(n<=2)\n          return n;\n        \n        if(dp[n]!=-1) \n          return dp[n]; \n        \n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\n        return dp[n];\n    }\n    int climbStairs(int n) {\n        if(n<=2)\n         return n;\n        vector<int> dp(n+1);\n        for(int i=0;i<=n;i++)\n         dp[i]=-1;\n        \n        return solve(n,dp);\n    }\n};",
        "content": "# Intuition\\nUsing Top - Down Approach -> Recursion + Memorization.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are visiting all values of n atleast 1 time.\\n\\n- Space complexity:\\nO(n) + O(n)  - > (Recursive calls + Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int n,vector<int> &dp){\\n        //base case\\n        if(n<=2)\\n          return n;\\n        \\n        if(dp[n]!=-1) \\n          return dp[n]; \\n        \\n        dp[n]=solve(n-1,dp)+solve(n-2,dp);\\n        return dp[n];\\n    }\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        for(int i=0;i<=n;i++)\\n         dp[i]=-1;\\n        \\n        return solve(n,dp);\\n    }\\n};\\n```\\n\\n# Intuition\\nUsing Bottom - up Approach -> Tabulation.\\n\\n# Approach\\nStoring the values of overlapping sub - problems in a vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(n) - > (Array of size n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int climbStairs(int n) {\\n        if(n<=2)\\n         return n;\\n        vector<int> dp(n+1);\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=2;\\n        for(int i=3;i<=n;i++)\\n         dp[i]=dp[i-1]+dp[i-2];\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n\\n# Python Code :\\nContributed by : Aarya_R\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> As we are traversing the vector atleast 1 time.\\n\\n- Space complexity:\\nO(1) \\n```\\ndef climbStairs(self, n):\\n        prev = 1\\n        prev2 = 0\\n        for i in range(1, n+1):\\n            curi = prev + prev2\\n            prev2 = prev\\n            prev = curi\\n        return prev \\n```\\n![upvote.jfif](https://assets.leetcode.com/users/images/995d917b-6ea2-4b6b-8baa-6ce7bc6441fd_1676965776.537627.jpeg)\\n\\n"
    },
    {
        "slug": "finding-3-digit-even-numbers",
        "tags": "cpp",
        "release_time": 1692040057,
        "code": "class Solution {\npublic:\n    vector<int> findEvenNumbers(vector<int>& digits) {\n        \n        int freq[10] = {0};\n\n        int di = digits.size();\n        for(int i=0; i<di; i++){\n            freq[digits[i]]++;\n        }\n\n        vector<int> ans;\n        for(int i=1; i<10; i++){\n            if(freq[i]){\n                for(int j=0; j<10; j++){\n                    if(freq[j] > (i==j)){\n                        for(int k=0; k<10; k+=2){\n                            if(freq[k] > ((i==k) + (j==k))){\n                                ans.push_back(i*100 + j*10 + k);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findEvenNumbers(vector<int>& digits) {\\n        \\n        int freq[10] = {0};\\n\\n        int di = digits.size();\\n        for(int i=0; i<di; i++){\\n            freq[digits[i]]++;\\n        }\\n\\n        vector<int> ans;\\n        for(int i=1; i<10; i++){\\n            if(freq[i]){\\n                for(int j=0; j<10; j++){\\n                    if(freq[j] > (i==j)){\\n                        for(int k=0; k<10; k+=2){\\n                            if(freq[k] > ((i==k) + (j==k))){\\n                                ans.push_back(i*100 + j*10 + k);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "grumpy-bookstore-owner",
        "tags": "cpp",
        "release_time": 1688134713,
        "code": "class Solution {\npublic:\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\n       int count = 0; \n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \n       int max = 0, temp = 0; \n       for(int i=0; i<minutes; i++) temp += customers[i]; \n       if(max < temp) max = temp; \n       for(int i=minutes; i<customers.size(); i++) {\n           temp -= customers[i - minutes]; temp += customers[i]; \n           if(max < temp) max = temp; \n       }\n\n       return count + max; \n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever the shopowner is not grumpy, the customers are added irrespective of when the minutes are, so add the customers to ans whenever he is not grumpy. Now change customers to 0 whenever the shop owner is not grumpy. \\nNow the question is changed to the maximum sum of subarray with window size minutes. (standard sliding window problem)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {\\n       int count = 0; \\n       for(int i=0; i<customers.size(); i++) if(grumpy[i] == 0) count+= customers[i]; \\n       for(int i=0; i<customers.size(); i++) customers[i] *= grumpy[i]; \\n       int max = 0, temp = 0; \\n       for(int i=0; i<minutes; i++) temp += customers[i]; \\n       if(max < temp) max = temp; \\n       for(int i=minutes; i<customers.size(); i++) {\\n           temp -= customers[i - minutes]; temp += customers[i]; \\n           if(max < temp) max = temp; \\n       }\\n\\n       return count + max; \\n\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-punishment-number-of-an-integer",
        "tags": "cpp",
        "release_time": 1684675860,
        "code": "class Solution {\npublic:\n    \n    bool valid(int n, string s,int sum){\n        // empty string indicates we have completed one partition\n        if(s==\"\") if(sum==n) return true;\n\n        // We use backtracking to check for all partitions if it is possible to generate required sum \n        // and if we find sum we immediately return true immediately\n        for(int i=1;i<=s.size();i++){\n            int x  = stoi(s.substr(0,i));\n            if(valid(n, s.substr(i), sum+x)) return true;\n        }\n        \n        //If no partition could add up to required sum n\n        return false;\n    }\n    int punishmentNumber(int n) {\n        int ans = 0;\n\n        //generate all possible squares and check them if they satisfy the given statement\n        for(int i=1;i<=n;i++){\n            int sq = i*i;\n            string x = to_string(sq);\n            if(valid(i,x,0)) ans += i*i;\n        }\n        \n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\nThe main idea of this problem is to generate all non empty partitions of a string using Backtracking.\\n\\nFor example let\\'s  say i = 36, it\\'s square = 36*36 = 1296\\nTo check if some partition of 1296 satisfy given statement, we make all partitions e.g\\n[1,2,9,6], [1,29,6], [1,296], [12,9,6] , [12,96], [129,6]\\n\\nAmong these only [1,29,6] satisfies the constraint.\\n\\nWe only need one of these set to satisfy the statement, hence we break immediately if we find any valid set.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n* Generate all possible squares and check if they satisfy the given statement\\n* To check if a square satisfies the given constraint or not generate all possible partitions using backtracking.\\n* If any single partition satisfy the statement then this square will be added to solution\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity :  O(n*(2^6)), here 6 is the maxm square length that is len(1000*1000) = 6\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool valid(int n, string s,int sum){\\n        // empty string indicates we have completed one partition\\n        if(s==\"\") if(sum==n) return true;\\n\\n        // We use backtracking to check for all partitions if it is possible to generate required sum \\n        // and if we find sum we immediately return true immediately\\n        for(int i=1;i<=s.size();i++){\\n            int x  = stoi(s.substr(0,i));\\n            if(valid(n, s.substr(i), sum+x)) return true;\\n        }\\n        \\n        //If no partition could add up to required sum n\\n        return false;\\n    }\\n    int punishmentNumber(int n) {\\n        int ans = 0;\\n\\n        //generate all possible squares and check them if they satisfy the given statement\\n        for(int i=1;i<=n;i++){\\n            int sq = i*i;\\n            string x = to_string(sq);\\n            if(valid(i,x,0)) ans += i*i;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "balanced-binary-tree",
        "tags": "cpp",
        "release_time": 1688021040,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        int height=0;\n        return dfs(root,height);\n    }\nprivate:\n    bool dfs(TreeNode* root, int & height){\n        if(root==NULL){\n            height=-1;\n            return true;\n        }\n        int left=0;\n        int right=0;\n        if(!(dfs(root->left,left)) || !(dfs(root->right,right))){\n            return false;\n        }\n        if(abs(left-right)>1){\n            return false;\n        }\n        height= 1+ max(left,right);\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code determines whether a binary tree is height-balanced or not. A binary tree is height-balanced if the heights of its left and right subtrees differ by at most 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code defines a helper function dfs() that takes a TreeNode pointer root and a reference to an integer height as arguments. Within this function, it performs the following steps:\\n\\nIf the root is NULL (i.e., there are no nodes), it sets the height to -1 and returns true to indicate that the subtree is height-balanced.\\nIt recursively calls the dfs() function on the left subtree of the current node (root->left) and stores the height of the left subtree in the variable left.\\nIt recursively calls the dfs() function on the right subtree of the current node (root->right) and stores the height of the right subtree in the variable right.\\nIf either the left subtree or the right subtree is not height-balanced (i.e., the dfs() function returns false), it returns false to indicate that the current subtree is not height-balanced.\\nIf the absolute difference between the heights of the left and right subtrees is greater than 1, it returns false to indicate that the current subtree is not height-balanced.\\nOtherwise, it calculates the height of the current subtree as 1 plus the maximum of the heights of the left and right subtrees and stores it in the height variable.\\nFinally, it returns true to indicate that the current subtree is height-balanced.\\nThe isBalanced() function initializes a variable height to store the height of the binary tree. It calls the dfs() function with the root of the binary tree and the height variable as arguments. If the dfs() function returns true, it means the binary tree is height-balanced, so it returns true. Otherwise, it returns false.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code visits each node exactly once, so the time complexity is O(n), where n is the number of nodes in the binary tree.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n), where n is the height of the binary tree. This is because the recursive calls consume space on the call stack, and in the worst case, the height of the tree is equal to the number of nodes in the tree, resulting in O(n) space complexity.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isBalanced(TreeNode* root) {\\n        int height=0;\\n        return dfs(root,height);\\n    }\\nprivate:\\n    bool dfs(TreeNode* root, int & height){\\n        if(root==NULL){\\n            height=-1;\\n            return true;\\n        }\\n        int left=0;\\n        int right=0;\\n        if(!(dfs(root->left,left)) || !(dfs(root->right,right))){\\n            return false;\\n        }\\n        if(abs(left-right)>1){\\n            return false;\\n        }\\n        height= 1+ max(left,right);\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "tags": "cpp",
        "release_time": 1667535325,
        "code": "class Solution {\npublic:\n     int containZero(int n){\n        int count = 0;\n        while(n > 0){\n            if(n % 10 == 0) count++;\n            n /= 10;\n        }\n        return count;\n    }\n    \n    vector<int> getNoZeroIntegers(int n) {\n        for(int i = 1; i <= n/2; i++){\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\n        }\n        return {};\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int containZero(int n){\\n        int count = 0;\\n        while(n > 0){\\n            if(n % 10 == 0) count++;\\n            n /= 10;\\n        }\\n        return count;\\n    }\\n    \\n    vector<int> getNoZeroIntegers(int n) {\\n        for(int i = 1; i <= n/2; i++){\\n            if((containZero(i) == 0) && (containZero(n-i) == 0)) return {i, n-i};\\n        }\\n        return {};\\n    }\\n};\\n```"
    },
    {
        "slug": "separate-the-digits-in-an-array",
        "tags": "cpp",
        "release_time": 1675535857,
        "code": "class Solution \n{\npublic:\n    vector<int> separateDigits(vector<int>& nums) \n    {\n        vector<int> v;\n        for(int x=0; x<nums.size(); x++)\n        {\n            int n=nums[x];\n            int count=0;\n            while(n!=0)\n            {\n                count++;\n                n/=10;\n            }\n            n=nums[x];\n            int m=pow(10,count-1);\n            while(m!=0)\n            {\n                v.push_back(nums[x]/m);\n                nums[x]=nums[x]%m;\n                m/=10;\n            }\n        }\n        return v;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> separateDigits(vector<int>& nums) \\n    {\\n        vector<int> v;\\n        for(int x=0; x<nums.size(); x++)\\n        {\\n            int n=nums[x];\\n            int count=0;\\n            while(n!=0)\\n            {\\n                count++;\\n                n/=10;\\n            }\\n            n=nums[x];\\n            int m=pow(10,count-1);\\n            while(m!=0)\\n            {\\n                v.push_back(nums[x]/m);\\n                nums[x]=nums[x]%m;\\n                m/=10;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-non-overlapping-palindrome-substrings",
        "tags": "cpp",
        "release_time": 1668312093,
        "code": "class Solution {\npublic:\n    \n    vector<vector<bool>> isPalindrome(string& s){\n        int n = s.size();\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\n        \n        for(int i=0; i<n; i++){\n            dp[i][i] = true;\n        }\n        \n        for(int i=0; i<n-1; i++){\n            if(s[i] == s[i+1]){\n                dp[i][i+1] = true;\n            }\n        }\n        \n        int k = 2;\n        \n        while(k < n){\n            int i=0;\n            int j=k;\n            \n            while(j<n){\n                if(s[i] == s[j] and dp[i+1][j-1]){\n                    dp[i][j] = true;\n                }\n                \n                i++;\n                j++;\n            }\n            \n            k++;\n        }\n        \n        return dp;\n    }\n    \n    int maxPalindromes(string s, int k) {\n        // get the dp table for palindrome\n        vector<vector<bool>> isPalin = isPalindrome(s);\n        vector<int> memo(s.size()+1, -1);\n        \n        function<int(int)> solve = [&](int i) {\n            // base cases\n            if(i >= s.size()) return 0;\n            if(memo[i] != -1) return memo[i];\n            \n            // skip the current index\n            int result = solve(i+1);\n            \n            // consider segments having length greater than or equal to k\n            for(int j=i+k; j<=s.size(); j++) {\n                if(isPalin[i][j-1]) result = max(result, solve(j)+1);\n            }\n            \n            return memo[i] = result;\n        };\n        \n        return solve(0);\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<bool>> isPalindrome(string& s){\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        \\n        for(int i=0; i<n; i++){\\n            dp[i][i] = true;\\n        }\\n        \\n        for(int i=0; i<n-1; i++){\\n            if(s[i] == s[i+1]){\\n                dp[i][i+1] = true;\\n            }\\n        }\\n        \\n        int k = 2;\\n        \\n        while(k < n){\\n            int i=0;\\n            int j=k;\\n            \\n            while(j<n){\\n                if(s[i] == s[j] and dp[i+1][j-1]){\\n                    dp[i][j] = true;\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n            \\n            k++;\\n        }\\n        \\n        return dp;\\n    }\\n    \\n    int maxPalindromes(string s, int k) {\\n        // get the dp table for palindrome\\n        vector<vector<bool>> isPalin = isPalindrome(s);\\n        vector<int> memo(s.size()+1, -1);\\n        \\n        function<int(int)> solve = [&](int i) {\\n            // base cases\\n            if(i >= s.size()) return 0;\\n            if(memo[i] != -1) return memo[i];\\n            \\n            // skip the current index\\n            int result = solve(i+1);\\n            \\n            // consider segments having length greater than or equal to k\\n            for(int j=i+k; j<=s.size(); j++) {\\n                if(isPalin[i][j-1]) result = max(result, solve(j)+1);\\n            }\\n            \\n            return memo[i] = result;\\n        };\\n        \\n        return solve(0);\\n    }\\n};\\n```"
    },
    {
        "slug": "cherry-pickup-ii",
        "tags": "cpp",
        "release_time": 1688886315,
        "code": "class Solution {\npublic:\n    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)\n    {\n        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;\n        if(i==r-1)\n        {\n            if(j1==j2) return grid[i][j1];\n            else return grid[i][j1]+grid[i][j2];\n        }\n        \n        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];\n        \n        int maxi=-1e8;\n        for(int dj1=-1; dj1<=1; dj1++)\n        {\n            for(int dj2=-1; dj2<=1; dj2++)\n            {\n                int value=0;\n                if(j1==j2) value=grid[i][j1];\n                else value=grid[i][j1]+grid[i][j2];\n                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);\n                maxi=max(maxi, value);\n            }\n        }\n        return dp[i][j1][j2]=maxi;\n    }\n    \n    int cherryPickup(vector<vector<int>>& grid) {\n        int r=grid.size();\n        int c=grid[0].size();\n        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));\n        return f(0, 0, c-1, r, c, grid, dp);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int f(int i, int j1, int j2, int r, int c, vector<vector<int>>& grid, vector<vector<vector<int>>>& dp)\\n    {\\n        if(j1<0 || j2<0 || j1>=c || j2>=c) return -1e8;\\n        if(i==r-1)\\n        {\\n            if(j1==j2) return grid[i][j1];\\n            else return grid[i][j1]+grid[i][j2];\\n        }\\n        \\n        if(dp[i][j1][j2]!=-1) return dp[i][j1][j2];\\n        \\n        int maxi=-1e8;\\n        for(int dj1=-1; dj1<=1; dj1++)\\n        {\\n            for(int dj2=-1; dj2<=1; dj2++)\\n            {\\n                int value=0;\\n                if(j1==j2) value=grid[i][j1];\\n                else value=grid[i][j1]+grid[i][j2];\\n                value+=f(i+1, j1+dj1, j2+dj2, r, c, grid, dp);\\n                maxi=max(maxi, value);\\n            }\\n        }\\n        return dp[i][j1][j2]=maxi;\\n    }\\n    \\n    int cherryPickup(vector<vector<int>>& grid) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        vector<vector<vector<int>>> dp(r, vector<vector<int>>(c, vector<int>(c, -1)));\\n        return f(0, 0, c-1, r, c, grid, dp);\\n    }\\n};\\n```"
    },
    {
        "slug": "count-the-number-of-beautiful-subarrays",
        "tags": "cpp",
        "release_time": 1678725180,
        "code": "class Solution {\npublic:\n    long long beautifulSubarrays(vector<int>& nums) {\n        long long int ans = 0,x=0;\n        unordered_map<long long int,long long int> mp;\n        mp[0]++;\n        for(auto &i: nums){\n            x ^= i;\n            if(mp.count(x)){\n                ans += mp[x];\n            }\n            mp[x]++;\n        }\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    long long beautifulSubarrays(vector<int>& nums) {\\n        long long int ans = 0,x=0;\\n        unordered_map<long long int,long long int> mp;\\n        mp[0]++;\\n        for(auto &i: nums){\\n            x ^= i;\\n            if(mp.count(x)){\\n                ans += mp[x];\\n            }\\n            mp[x]++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "convert-binary-number-in-a-linked-list-to-integer",
        "tags": "cpp",
        "release_time": 1691329902,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n ListNode* reverseList(ListNode* head) {\n        if(head==nullptr || head->next==nullptr)\n        return head;\n        ListNode* n=new ListNode(head->val);\n        head=head->next;\n        while(head!=nullptr)\n        {\n            ListNode* newnode=new ListNode(head->val,n);\n            n=newnode;\n            head=head->next;\n        }\n        return n;\n    }\n    int getDecimalValue(ListNode* head) {\n        head=reverseList(head);\n        int p=0;\n        int n=0;\n        while(head!=nullptr)\n        {\n            if(head->val==1)\n            {\n                n+=(1<<p);\n            }\n            p++;\n            head=head->next;\n        }\n        return n;\n    }\n};",
        "content": "# Intuition\\nFirst thought the general approach of traversing the list and counting the elements and then calculating the value bu for efficient code thought of reversing the list and then doing the same\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMade a function to reverse the list the used the left shift operator to find the power of 2 for tha particular position. 1<<x = 2^x\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **$$O(N log N)$$** or **$$O(N)$$** depending upon tthe compexity of power of 2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **$$O(N)$$**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n ListNode* reverseList(ListNode* head) {\\n        if(head==nullptr || head->next==nullptr)\\n        return head;\\n        ListNode* n=new ListNode(head->val);\\n        head=head->next;\\n        while(head!=nullptr)\\n        {\\n            ListNode* newnode=new ListNode(head->val,n);\\n            n=newnode;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n    int getDecimalValue(ListNode* head) {\\n        head=reverseList(head);\\n        int p=0;\\n        int n=0;\\n        while(head!=nullptr)\\n        {\\n            if(head->val==1)\\n            {\\n                n+=(1<<p);\\n            }\\n            p++;\\n            head=head->next;\\n        }\\n        return n;\\n    }\\n};\\n```"
    },
    {
        "slug": "perfect-rectangle",
        "tags": "cpp",
        "release_time": 1672756201,
        "code": "class Solution {\npublic:\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\n        map<pair<int,int>,int>m;\n        for(auto it:rectangles){\n            m[{it[0],it[1]}]++;\n            m[{it[2],it[3]}]++;\n            m[{it[0],it[3]}]--;\n            m[{it[2],it[1]}]--;\n        }\n        int cnt=0;\n        for( auto it=m.begin();it!=m.end();it++){\n            if(abs(it->second)==1){\n                cnt++;\n            }\n            else if(abs(it->second)!=1&&it->second!=0){\n                return false;\n            }\n        }\n        return cnt==4;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust used map to keep the count of edges.\\nIncreasing the count of bottom left and top right vertices.\\nDecreasing the count of bottom right and top left vertices.\\nAt Last We sum all the values of map.\\nIf the value is 4 then return true as four vertices are there, else return false. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a map with key as pair of int and int(pair<int,int>);\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N);\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isRectangleCover(vector<vector<int>>& rectangles) {\\n        map<pair<int,int>,int>m;\\n        for(auto it:rectangles){\\n            m[{it[0],it[1]}]++;\\n            m[{it[2],it[3]}]++;\\n            m[{it[0],it[3]}]--;\\n            m[{it[2],it[1]}]--;\\n        }\\n        int cnt=0;\\n        for( auto it=m.begin();it!=m.end();it++){\\n            if(abs(it->second)==1){\\n                cnt++;\\n            }\\n            else if(abs(it->second)!=1&&it->second!=0){\\n                return false;\\n            }\\n        }\\n        return cnt==4;\\n    }\\n};\\n```"
    },
    {
        "slug": "merge-two-binary-trees",
        "tags": "cpp",
        "release_time": 1673784101,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\n        if ( t1 && t2 ) {\n            TreeNode * root = new TreeNode(t1->val + t2->val);\n            root->left = mergeTrees(t1->left, t2->left);\n            root->right = mergeTrees(t1->right, t2->right);\n            return root;\n        } else {\n            return t1 ? t1 : t2;\n        }\n    }\n};",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {\\n        if ( t1 && t2 ) {\\n            TreeNode * root = new TreeNode(t1->val + t2->val);\\n            root->left = mergeTrees(t1->left, t2->left);\\n            root->right = mergeTrees(t1->right, t2->right);\\n            return root;\\n        } else {\\n            return t1 ? t1 : t2;\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!"
    },
    {
        "slug": "minimum-cost-for-tickets",
        "tags": "cpp",
        "release_time": 1680003063,
        "code": "class Solution {\npublic:\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\n        if(ind<0){return 0;}\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\n        indweek--;\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\n        indmonth--;\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\n    }\n\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int n=days.size();\n        vector<int>dp(366,-1);\n        return helper(costs,days,n-1,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> apply dp on 365 days..similar to striver soln\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```"
    },
    {
        "slug": "loud-and-rich",
        "tags": "cpp",
        "release_time": 1691183684,
        "code": "class Solution {\npublic:\n    vector<int>dp;\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\n        if(dp[node]!=-1) return dp[node];\n\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\n        // then the node is the quitiest person he knows who is as rich \n        // as him \n        int miniNode = node;\n        // stores the node with the properties\n\n        for(auto it:adj[node]){\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\n            // adjNode\n            if(quiet[miniIndex] < miniVal){\n                miniVal = quiet[miniIndex];\n                miniNode = miniIndex;\n            } \n\n        }\n\n        return dp[node] = miniNode;        \n    }\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\n        int n = quiet.size();\n        dp.resize(n,-1);\n        vector<vector<int>>adj(n);\n        vector<int>ans;\n        for(auto it: richer){\n            adj[it[1]].push_back(it[0]);\n        }\n\n        for(int i =0;i<n;i++){\n            int res = dfs(i,adj,quiet);\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires finding the quietest person each person knows within a social network represented as a directed graph. To find the quietest person a particular person p knows, we can traverse the social network starting from p and recursively find the quietest person among p\\'s neighbors. We will use depth-first search (DFS) to achieve this.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We can implement a recursive DFS function dfs(node, adj, quiet) that takes a person node, the adjacency list adj representing the social network, and the quiet vector representing the quietness levels of all people.\\n2. Within the dfs function, we will check if the quietest person for node has already been calculated and stored in the dp array (dynamic programming memoization). If it has, we return that value.\\n3. If the quietest person for node has not been calculated yet, we initialize miniVal to the quietness level of the current person node and miniNode to node. We then loop through all the neighbors of node (i.e., the people node knows) using the adjacency list adj.\\n4. For each neighbor, we recursively call the dfs function to find the quietest person that the neighbor knows. We update miniVal and miniNode if the quietness level of the neighbor is smaller than the current miniVal.\\n5. Finally, we return miniNode as the quietest person that node knows and store this value in the dp array for future use.\\n6. In the loudAndRich function, we initialize the dp array to store the results of the DFS to avoid redundant computations. We also create the adjacency list adj using the richer vector. For each person i in the network, we call the dfs function to find the quietest person that i knows and store the result in the ans\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe DFS function dfs is called once for each person in the network, and within each call, we may visit each neighbor once. Hence, the time complexity is O(N + E), where N is the number of people and E is the number of edges in the social network (richer relationships).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n We use additional space for the dp array, the adjacency list adj, and the ans vector. The space complexity is O(N + E) for the adjacency list and O(N) for the dp array and ans vector, resulting in a total space complexity of O(N + E).\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dp;\\n    int dfs(int node, vector<vector<int>>&adj, vector<int>& quiet){\\n        if(dp[node]!=-1) return dp[node];\\n\\n        int miniVal  = quiet[node]; // if there is no outgoing edge from the node\\n        // then the node is the quitiest person he knows who is as rich \\n        // as him \\n        int miniNode = node;\\n        // stores the node with the properties\\n\\n        for(auto it:adj[node]){\\n            int miniIndex = dfs(it,adj,quiet);// do a dfs traversal for all the\\n            // adjNode\\n            if(quiet[miniIndex] < miniVal){\\n                miniVal = quiet[miniIndex];\\n                miniNode = miniIndex;\\n            } \\n\\n        }\\n\\n        return dp[node] = miniNode;        \\n    }\\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n = quiet.size();\\n        dp.resize(n,-1);\\n        vector<vector<int>>adj(n);\\n        vector<int>ans;\\n        for(auto it: richer){\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        for(int i =0;i<n;i++){\\n            int res = dfs(i,adj,quiet);\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "car-pooling",
        "tags": "cpp",
        "release_time": 1685821263,
        "code": "class Solution {\nprivate:\n    static bool comp(vector<int>& it1, vector<int>& it2){\n        if(it1[1] < it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;\n        return false;\n    }\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        sort(trips.begin(),trips.end(),comp);\n        int n = trips.size();\n        int current_capacity = 0;\n        priority_queue<pair<int,int>>pq;\n        for(int i=0; i<n; i++){\n            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){\n                current_capacity -= pq.top().second;\n                pq.pop();\n            }\n            current_capacity += trips[i][0];\n            if(current_capacity > capacity) return false;\n            pq.push({-trips[i][2],trips[i][0]});\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    static bool comp(vector<int>& it1, vector<int>& it2){\\n        if(it1[1] < it2[1] || (it1[1] == it2[1] && it1[2] < it2[2])) return true;\\n        return false;\\n    }\\npublic:\\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\\n        sort(trips.begin(),trips.end(),comp);\\n        int n = trips.size();\\n        int current_capacity = 0;\\n        priority_queue<pair<int,int>>pq;\\n        for(int i=0; i<n; i++){\\n            while(!pq.empty() && -1 * pq.top().first <= trips[i][1]){\\n                current_capacity -= pq.top().second;\\n                pq.pop();\\n            }\\n            current_capacity += trips[i][0];\\n            if(current_capacity > capacity) return false;\\n            pq.push({-trips[i][2],trips[i][0]});\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "number-of-subarrays-with-gcd-equal-to-k",
        "tags": "cpp",
        "release_time": 1687965603,
        "code": "class Solution {\npublic:\n    int subarrayGCD(vector<int>& nums, int k) {\n        int count = 0;\n        for(int i=0; i<nums.size();i++){\n            int ans = 0;\n            for(int j=i; j<nums.size();j++){\n                ans = __gcd(ans,nums[j]);\n\n                if(ans == k){\n                    count ++;\n                }\n            }\n        }\n\n        return count;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.size();i++){\\n            int ans = 0;\\n            for(int j=i; j<nums.size();j++){\\n                ans = __gcd(ans,nums[j]);\\n\\n                if(ans == k){\\n                    count ++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n};\\n```"
    },
    {
        "slug": "tallest-billboard",
        "tags": "cpp",
        "release_time": 1687588495,
        "code": "class Solution {\npublic:\n\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\n    {\n        if(i>=rods.size() && balance==0)\n            return 0;\n        if(i>=rods.size() && balance!=0)\n            return INT_MIN;\n\n        if(memo[i][balance+5000]!=-1)\n            return memo[i][balance+5000];\n        int left= build_board(rods,balance+rods[i],i+1,memo);\n        int right= build_board(rods,balance-rods[i],i+1,memo);\n\n        int ans= rods[i]+max(left,right);\n\n        int skip= build_board(rods,balance,i+1,memo);\n\n        ans= max(ans,skip);\n\n        memo[i][balance+5000]=ans;\n        return ans;\n\n    }\n\n    int tallestBillboard(vector<int>& rods) {\n        \n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\n        int ans= build_board(rods,0,0,memo);\n\n        if(ans<=0)\n            return 0;\n        else\n            return ans/2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust as any dp problem where we have to select the item or leave it, same idea is being used here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor any given rod we have 3 optins to add it to the right leg or left leg or leave the rod. Now for the states of the dp one has to be the i that will iterate through the rods array. And if we maintain two additional states for left and the right leg then a total of 3 states was giving a memory limit exceed(in my case).\\n\\nTo reduce the a state, I used a balance state that will denote the difference between the legs\\' height. If we add the ith rod in the right leg then we increase the balance by rod[i] and if we add it to the left leg then we decerase the balance by rod[i], remains unchanged if we choose to skip the rod. \\n\\n**Balance ==0 will denote both legs are of same height, balance>0 means right leg is longer ans balance<0 means left is longer.**\\n\\n**Now, sum(rods[i])<=5000 (as given). Then our balance could range from -5000 to 5000. So in the memo table I am shifting the balance by 5000 to handle the negative indixes.**\\n\\n  \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int build_board(vector<int> &rods, int balance,int i,vector<vector<int>> &memo)\\n    {\\n        if(i>=rods.size() && balance==0)\\n            return 0;\\n        if(i>=rods.size() && balance!=0)\\n            return INT_MIN;\\n\\n        if(memo[i][balance+5000]!=-1)\\n            return memo[i][balance+5000];\\n        int left= build_board(rods,balance+rods[i],i+1,memo);\\n        int right= build_board(rods,balance-rods[i],i+1,memo);\\n\\n        int ans= rods[i]+max(left,right);\\n\\n        int skip= build_board(rods,balance,i+1,memo);\\n\\n        ans= max(ans,skip);\\n\\n        memo[i][balance+5000]=ans;\\n        return ans;\\n\\n    }\\n\\n    int tallestBillboard(vector<int>& rods) {\\n        \\n        vector<vector<int>> memo(rods.size(),vector<int>(10001,-1));\\n        int ans= build_board(rods,0,0,memo);\\n\\n        if(ans<=0)\\n            return 0;\\n        else\\n            return ans/2;\\n    }\\n};\\n```"
    },
    {
        "slug": "evaluate-reverse-polish-notation",
        "tags": "cpp",
        "release_time": 1688227672,
        "code": "class Solution {\npublic:\n    int performOperation(string operation, int firstNumber, int secondNumber) {\n        if(operation == \"+\")\n            return secondNumber + firstNumber; \n        if(operation == \"-\")    \n            return secondNumber - firstNumber; \n        if(operation == \"*\")\n            return secondNumber * firstNumber; \n        return secondNumber / firstNumber; \n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> tokenStack;\n        set<string> operators = {\"+\", \"-\", \"*\", \"/\"};\n\n        for(int i = 0; i < tokens.size(); i++)\n        {\n            // if the token is an operator \n            if(operators.find(tokens[i]) != operators.end())\n            {\n                // pop the 2 numbers in the stack \n                int firstNumber = tokenStack.top();\n                tokenStack.pop();\n                int secondNumber = tokenStack.top(); \n                tokenStack.pop();\n\n                // do the operation on the two numbers\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \n\n                // push the result of the operation in the stack \n                tokenStack.push(operationResult); \n            }\n            else\n            {\n                // if the token is a number, push it to the stack\n                tokenStack.push(stoi(tokens[i])); \n            }\n        }\n        return tokenStack.top();\n    }\n};",
        "content": "# Approach\\nWe traverse the tokens one by one\\n - If the token is a number, we push the number to to the stack. \\n - If the token is an operator, we get the two latest pushed numbers, do the operation on them then push the result to the stack. \\n\\nAt the end of the process, the result will be the last number in the stack.\\n\\n# Visualization of the problem\\n![IMG_0020.jpg](https://assets.leetcode.com/users/images/cb6078c3-36fe-4ddf-aa96-9ec3989469d5_1688227585.5480292.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int performOperation(string operation, int firstNumber, int secondNumber) {\\n        if(operation == \"+\")\\n            return secondNumber + firstNumber; \\n        if(operation == \"-\")    \\n            return secondNumber - firstNumber; \\n        if(operation == \"*\")\\n            return secondNumber * firstNumber; \\n        return secondNumber / firstNumber; \\n    }\\n    int evalRPN(vector<string>& tokens) {\\n        stack<int> tokenStack;\\n        set<string> operators = {\"+\", \"-\", \"*\", \"/\"};\\n\\n        for(int i = 0; i < tokens.size(); i++)\\n        {\\n            // if the token is an operator \\n            if(operators.find(tokens[i]) != operators.end())\\n            {\\n                // pop the 2 numbers in the stack \\n                int firstNumber = tokenStack.top();\\n                tokenStack.pop();\\n                int secondNumber = tokenStack.top(); \\n                tokenStack.pop();\\n\\n                // do the operation on the two numbers\\n                int operationResult = performOperation(tokens[i], firstNumber, secondNumber); \\n\\n                // push the result of the operation in the stack \\n                tokenStack.push(operationResult); \\n            }\\n            else\\n            {\\n                // if the token is a number, push it to the stack\\n                tokenStack.push(stoi(tokens[i])); \\n            }\\n        }\\n        return tokenStack.top();\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "tags": "cpp",
        "release_time": 1671945764,
        "code": "class Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n         int ind= find(words.begin(),words.end(),target)-words.begin();\n        int n= words.size();\n        if (ind==n)return -1;\n        if (words[startIndex]==target) return 0;\n        int i= startIndex-1;\n        int j= startIndex+1;\n        int cnt1=0; int cnt2=0;\n        while (true){\n            cnt1++; cnt2++;\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\n                return cnt1;\n            }\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\n                return cnt2;\n            }\n            i--; j++;\n        }\n        \n        return -1;\n    }\n};",
        "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int closetTarget(vector<string>& words, string target, int startIndex) {\\n         int ind= find(words.begin(),words.end(),target)-words.begin();\\n        int n= words.size();\\n        if (ind==n)return -1;\\n        if (words[startIndex]==target) return 0;\\n        int i= startIndex-1;\\n        int j= startIndex+1;\\n        int cnt1=0; int cnt2=0;\\n        while (true){\\n            cnt1++; cnt2++;\\n            if ((i>=0 && words[i%n]==target) || words[(n+i)%n]==target){\\n                return cnt1;\\n            }\\n            if ((j<n && words[j%n]==target) || words[(n+j)%n]==target){\\n                return cnt2;\\n            }\\n            i--; j++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n"
    },
    {
        "slug": "form-smallest-number-from-two-digit-arrays",
        "tags": "cpp",
        "release_time": 1680365144,
        "code": "class Solution {\npublic:\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\n        map<int,int>mp;\n        for(auto x: nums1) mp[x]++;\n        for(auto x: nums2) mp[x]++;\n        int mn1=*min_element(nums1.begin(),nums1.end());\n        int mn2=*min_element(nums2.begin(),nums2.end());\n        for(auto x: mp){\n            if(x.second>1) return x.first;\n        }\n        string s;\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\n        else s=to_string(mn2)+ to_string(mn1);\n        return stoi(s);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumber(vector<int>& nums1, vector<int>& nums2) {\\n        map<int,int>mp;\\n        for(auto x: nums1) mp[x]++;\\n        for(auto x: nums2) mp[x]++;\\n        int mn1=*min_element(nums1.begin(),nums1.end());\\n        int mn2=*min_element(nums2.begin(),nums2.end());\\n        for(auto x: mp){\\n            if(x.second>1) return x.first;\\n        }\\n        string s;\\n        if(mn1<mn2) s=to_string(mn1)+ to_string(mn2);\\n        else s=to_string(mn2)+ to_string(mn1);\\n        return stoi(s);\\n    }\\n};\\n```"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "tags": "cpp",
        "release_time": 1671863372,
        "code": "class Solution {\npublic:\n    int numTilings(int n) {\n        long long f[1009],MOD=1e9+7;\n        f[0]=1;\n        f[1]=1;\n        f[2]=2;\n        f[3]=5;\n        for(int i=4;i<=n;i++){\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\n        }\n        return f[n];\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numTilings(int n) {\\n        long long f[1009],MOD=1e9+7;\\n        f[0]=1;\\n        f[1]=1;\\n        f[2]=2;\\n        f[3]=5;\\n        for(int i=4;i<=n;i++){\\n            f[i]=(f[i-1]+f[i-2]*2+f[i-3]+f[i-4])%MOD;\\n        }\\n        return f[n];\\n    }\\n};\\n```"
    },
    {
        "slug": "kth-largest-element-in-a-stream",
        "tags": "cpp",
        "release_time": 1684824347,
        "code": "class KthLargest {\npublic:\n    priority_queue<int,vector<int>,greater<int>> pq;\n    int position;\n    KthLargest(int k, vector<int>& nums) {\n        position=k;\n        for(int i=0; i<nums.size(); i++){\n            if(pq.size()<k){\n                pq.push(nums[i]);\n            }\n            else if(pq.top()<nums[i]){\n                pq.pop();\n                pq.push(nums[i]);\n            }\n        }\n    }\n    \n    int add(int val) {\n        if(pq.size()<position){\n            pq.push(val);\n        }\n        else if(pq.top()<val){\n            pq.pop();\n            pq.push(val);\n        }\n        return pq.top();\n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass KthLargest {\\npublic:\\n    priority_queue<int,vector<int>,greater<int>> pq;\\n    int position;\\n    KthLargest(int k, vector<int>& nums) {\\n        position=k;\\n        for(int i=0; i<nums.size(); i++){\\n            if(pq.size()<k){\\n                pq.push(nums[i]);\\n            }\\n            else if(pq.top()<nums[i]){\\n                pq.pop();\\n                pq.push(nums[i]);\\n            }\\n        }\\n    }\\n    \\n    int add(int val) {\\n        if(pq.size()<position){\\n            pq.push(val);\\n        }\\n        else if(pq.top()<val){\\n            pq.pop();\\n            pq.push(val);\\n        }\\n        return pq.top();\\n    }\\n};\\n\\n/**\\n * Your KthLargest object will be instantiated and called as such:\\n * KthLargest* obj = new KthLargest(k, nums);\\n * int param_1 = obj->add(val);\\n */\\n```"
    },
    {
        "slug": "least-operators-to-express-number",
        "tags": "cpp",
        "release_time": 1676728776,
        "code": "class Solution {\npublic:\n    long long leastOpsExpressTarget(long long x, long long target,long long Less =1 ,long long  Operations =0) {\n        while(Less*x<target)\n        Less*=x , Operations++;\n        return min({Less!=1?Operations + leastOpsExpressTarget(x,target-Less):INT_MAX,(Less*x<2*target)? Operations + leastOpsExpressTarget(x,Less*x-target) + 1 :INT_MAX,2*target-1});\n    }\n};",
        "content": "# *3 Line short solution*\\n```\\nclass Solution {\\npublic:\\n    long long leastOpsExpressTarget(long long x, long long target,long long Less =1 ,long long  Operations =0) {\\n        while(Less*x<target)\\n        Less*=x , Operations++;\\n        return min({Less!=1?Operations + leastOpsExpressTarget(x,target-Less):INT_MAX,(Less*x<2*target)? Operations + leastOpsExpressTarget(x,Less*x-target) + 1 :INT_MAX,2*target-1});\\n    }\\n};\\n```"
    },
    {
        "slug": "check-knight-tour-configuration",
        "tags": "cpp",
        "release_time": 1685738927,
        "code": "class Solution {\nprivate:\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\n        int n = grid.size();\n        if(num == n*n) return true;\n        int i = row-2;\n        int j = col+1;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row-2;\n        j = col-1;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col - 1;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 2;\n        j = col + 1;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col + 2;\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col + 2;\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row - 1;\n        j = col - 2;\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        i = row + 1;\n        j = col - 2;\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\n\n        return false;\n    }\npublic:\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        ios::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);\n        if(grid[0][0] != 0) return false;\n        return helper(grid,0,0,1);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool helper(vector<vector<int>>& grid, int row, int col, int num){\\n        int n = grid.size();\\n        if(num == n*n) return true;\\n        int i = row-2;\\n        int j = col+1;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row-2;\\n        j = col-1;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col - 1;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 2;\\n        j = col + 1;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col + 2;\\n        if(i<n && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col + 2;\\n        if(i>=0 && j<n && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row - 1;\\n        j = col - 2;\\n        if(i>=0 && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        i = row + 1;\\n        j = col - 2;\\n        if(i<n && j>=0 && grid[i][j] == num) return helper(grid,i,j,num+1);\\n\\n        return false;\\n    }\\npublic:\\n    bool checkValidGrid(vector<vector<int>>& grid) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        if(grid[0][0] != 0) return false;\\n        return helper(grid,0,0,1);\\n    }\\n};\\n```"
    },
    {
        "slug": "greatest-english-letter-in-upper-and-lower-case",
        "tags": "cpp",
        "release_time": 1676005009,
        "code": "class Solution {\npublic:\n    string greatestLetter(string s) {\n     vector<int>v1(26,0); //creating 2 auxilary vectors\n     vector<int>v2(26,0);\n     for(int i=0;i<s.size();i++){\n            if(s[i]-'a'>=0 &&  s[i]-'a'<=25){\n                v2[s[i]-'a']++;   //storing by comparing integers values to vectors. \n            }\n            else if(s[i]-'A'>=0 &&  s[i]-'A'<=25){\n                v1[s[i]-'A']++;\n            }\n        }\n        string k;\n        for(int i=25;i>=0;i--){\n            if(v1[i]>0 && v2[i]>0){\n                k.push_back(i+'A'); //pushing the character that is in both case.\n                break;\n            }\n        }\n        return k;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreating two auxilary Arrays and putting integers values of character by comparing.\\nThen pushing stored values in string and returning back the character from string.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string greatestLetter(string s) {\\n     vector<int>v1(26,0); //creating 2 auxilary vectors\\n     vector<int>v2(26,0);\\n     for(int i=0;i<s.size();i++){\\n            if(s[i]-\\'a\\'>=0 &&  s[i]-\\'a\\'<=25){\\n                v2[s[i]-\\'a\\']++;   //storing by comparing integers values to vectors. \\n            }\\n            else if(s[i]-\\'A\\'>=0 &&  s[i]-\\'A\\'<=25){\\n                v1[s[i]-\\'A\\']++;\\n            }\\n        }\\n        string k;\\n        for(int i=25;i>=0;i--){\\n            if(v1[i]>0 && v2[i]>0){\\n                k.push_back(i+\\'A\\'); //pushing the character that is in both case.\\n                break;\\n            }\\n        }\\n        return k;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-number-of-integers-to-choose-from-a-range-i",
        "tags": "cpp",
        "release_time": 1675529167,
        "code": "class Solution {\npublic:\n    int maxCount(vector<int>& banned, int n, int maxSum) {\n        vector<int> nums;\n        long long sum=0;\n        int count=0;\n\n        for(int i=1;i<=n;i++){\n            nums.push_back(i);//storing the numbers from [1,n]\n        }\n        unordered_set<int> ban(banned.begin(),banned.end());//storing banned numbers in set\n        for(int i=0;i<nums.size();i++){\n            if(ban.find(nums[i])!=ban.end())continue;//if the number is banned\n\n            if(sum+nums[i]<=maxSum){//If we can add the number to sum and still it will be less than or equal to maxSum\n                sum+=nums[i];\n                count++;//Increment count as the number is used\n            }\n            else break;//If the sum exceeds max sum at any stage\n        }\n        return count;\n    }\n};",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Store the numbers from 1 to n in a vector nums.\\n- Store all the banned numbers in a set.\\n- Initialise sum and with 0.\\n- Check if the number is not banned.\\n- If it is not banned, check if(Sum + number <= Maximum Sum)\\nAdd the number if the above case is true and increment count, otherwise break. Return count at the end of the loop. \\n- Logic behind this break is that nums is sorted array.\\nExample: (78+15>90), Then (78+16) will also be greater than 90.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(vector<int>& banned, int n, int maxSum) {\\n        vector<int> nums;\\n        long long sum=0;\\n        int count=0;\\n\\n        for(int i=1;i<=n;i++){\\n            nums.push_back(i);//storing the numbers from [1,n]\\n        }\\n        unordered_set<int> ban(banned.begin(),banned.end());//storing banned numbers in set\\n        for(int i=0;i<nums.size();i++){\\n            if(ban.find(nums[i])!=ban.end())continue;//if the number is banned\\n\\n            if(sum+nums[i]<=maxSum){//If we can add the number to sum and still it will be less than or equal to maxSum\\n                sum+=nums[i];\\n                count++;//Increment count as the number is used\\n            }\\n            else break;//If the sum exceeds max sum at any stage\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "tags": "cpp",
        "release_time": 1679835912,
        "code": "class Solution {\npublic:\n    int mx=-1;\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)\n    {\n        if(pvis[i])\n        {\n            mx = max(mx , j - pvis[i]);\n            return;\n        }\n        if(!vis[i])\n        {\n            pvis[i] =j; j++; vis[i]=1;\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\n        }\n        pvis[i] = 0;\n        return;\n    }\n    int longestCycle(vector<int>& ed)\n     {\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\n        mx = -1;\n        for(int i=0;i<ed.size();i++)\n        {\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\n        }\n        return mx;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mx=-1;\\n    void dfs(vector<int> &ed , vector<int> &pvis , vector<int> &vis , int i , int j)\\n    {\\n        if(pvis[i])\\n        {\\n            mx = max(mx , j - pvis[i]);\\n            return;\\n        }\\n        if(!vis[i])\\n        {\\n            pvis[i] =j; j++; vis[i]=1;\\n            if(ed[i]!=-1) dfs(ed , pvis , vis , ed[i],j);\\n        }\\n        pvis[i] = 0;\\n        return;\\n    }\\n    int longestCycle(vector<int>& ed)\\n     {\\n        vector<int> vis(ed.size(),0) , pvis(ed.size(),0);\\n        mx = -1;\\n        for(int i=0;i<ed.size();i++)\\n        {\\n            if(!vis[i]) dfs(ed,pvis,vis,i,1);\\n        }\\n        return mx;\\n    }\\n};\\n```"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "tags": "cpp",
        "release_time": 1678827516,
        "code": "class Solution {\npublic:\n    bool isPossibleDivide(vector<int>& nums, int k) {\n        unordered_map<int,int> mpp;\n        sort(nums.begin(), nums.end());\n        if(nums.size()%k!=0){\n            return false;\n        }\n\n\n        for(int i=0; i<nums.size(); i++){\n            mpp[nums[i]]++;\n        }\n        for(int i=0; i<nums.size(); i++){\n            if(mpp[nums[i]]<=0){\n                continue;\n            }\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\n                if(mpp[j]<=0){\n                    return false;\n                }\n                \n                    mpp[j]--;\n                \n            }\n        }\n        return true;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        unordered_map<int,int> mpp;\\n        sort(nums.begin(), nums.end());\\n        if(nums.size()%k!=0){\\n            return false;\\n        }\\n\\n\\n        for(int i=0; i<nums.size(); i++){\\n            mpp[nums[i]]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            if(mpp[nums[i]]<=0){\\n                continue;\\n            }\\n            for(int j=nums[i] ; j<nums[i]+ k; j++){\\n                if(mpp[j]<=0){\\n                    return false;\\n                }\\n                \\n                    mpp[j]--;\\n                \\n            }\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-of-smaller-numbers-after-self",
        "tags": "cpp",
        "release_time": 1592051411,
        "code": "class Solution {\npublic:\n    void merge(vector<int> &count, vector<pair<int, int> > &v, int left, int mid, int right) {\n        vector<pair<int, int> > tmp(right-left+1);\n        int i = left;\n        int j = mid+1;\n        int k = 0;\n\n        while (i <= mid && j <= right) {\n            // mind that we're sorting in descending order\n            if (v[i].first <= v[j].first) { \n                tmp[k++] = v[j++];\n            }\n            else {\n                // only line responsible to update count, related to problem constraint, \n                // remaining part is just regular mergeSort \n                count[v[i].second] += right - j + 1;\n                tmp[k++] = v[i++];\n            }\n        }\n        while (i <= mid) {\n            tmp[k++] = v[i++];\n        }\n        while (j <= right) {\n            tmp[k++] = v[j++];\n        }\n        for (int i = left; i <= right; i++)\n            v[i] = tmp[i-left];\n    }        \n\n    void mergeSort(vector<int> &count, vector<pair<int, int> > &v, int left, int right) {\n        if (left >= right) \n            return;\n\n        int mid = left + (right-left)/2;\n        mergeSort(count, v, left, mid);\n        mergeSort(count, v, mid+1, right);\n        merge(count, v, left, mid, right);\n    }\n\n    vector<int> countSmaller(vector<int>& nums) {\n        int N = nums.size();\n\n        vector<pair<int, int> > v(N);\n        for (int i = 0; i < N; i++)   \n            v[i] = make_pair(nums[i], i);\n\n        vector<int> count(N, 0);\n        // sorting in descending order\n        mergeSort(count, v, 0, N-1);\n\n        return count;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void merge(vector<int> &count, vector<pair<int, int> > &v, int left, int mid, int right) {\\n        vector<pair<int, int> > tmp(right-left+1);\\n        int i = left;\\n        int j = mid+1;\\n        int k = 0;\\n\\n        while (i <= mid && j <= right) {\\n            // mind that we\\'re sorting in descending order\\n            if (v[i].first <= v[j].first) { \\n                tmp[k++] = v[j++];\\n            }\\n            else {\\n                // only line responsible to update count, related to problem constraint, \\n                // remaining part is just regular mergeSort \\n                count[v[i].second] += right - j + 1;\\n                tmp[k++] = v[i++];\\n            }\\n        }\\n        while (i <= mid) {\\n            tmp[k++] = v[i++];\\n        }\\n        while (j <= right) {\\n            tmp[k++] = v[j++];\\n        }\\n        for (int i = left; i <= right; i++)\\n            v[i] = tmp[i-left];\\n    }        \\n\\n    void mergeSort(vector<int> &count, vector<pair<int, int> > &v, int left, int right) {\\n        if (left >= right) \\n            return;\\n\\n        int mid = left + (right-left)/2;\\n        mergeSort(count, v, left, mid);\\n        mergeSort(count, v, mid+1, right);\\n        merge(count, v, left, mid, right);\\n    }\\n\\n    vector<int> countSmaller(vector<int>& nums) {\\n        int N = nums.size();\\n\\n        vector<pair<int, int> > v(N);\\n        for (int i = 0; i < N; i++)   \\n            v[i] = make_pair(nums[i], i);\\n\\n        vector<int> count(N, 0);\\n        // sorting in descending order\\n        mergeSort(count, v, 0, N-1);\\n\\n        return count;\\n    }\\n};\\n```\\n\\nUpvote if this helped!"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "tags": "cpp",
        "release_time": 1687509988,
        "code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n       if(root==NULL) \n       return NULL;\n       if(root->val==val)\n       {\n           return root;\n       }\n       if(root->val>val){\n          return  searchBST(root->left,val);\n       }\n        return searchBST(root->right,val);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n       if(root==NULL) \\n       return NULL;\\n       if(root->val==val)\\n       {\\n           return root;\\n       }\\n       if(root->val>val){\\n          return  searchBST(root->left,val);\\n       }\\n        return searchBST(root->right,val);\\n    }\\n};\\n```"
    },
    {
        "slug": "print-words-vertically",
        "tags": "cpp",
        "release_time": 1665332375,
        "code": "class Solution {\npublic:\n    vector<string> printVertically(string s) \n    {\n         int idx=0;\n         int len=0;\n\n         vector<string>words;\n\n         while(idx<s.length())\n         {\n             if(idx<s.length() and s[idx]>='A' and s[idx]<='Z')\n             {\n                string word=\"\";\n                while(idx<s.length() and s[idx]>='A' and s[idx]<='Z')\n                {\n                    word.push_back(s[idx]);\n                    idx++;\n                }\t\n                if(word.length() > 0)\n                {\n                   words.push_back(word); \n                   if(word.length()>len)\n                   {\n                       len=word.length();\n                   }\n                }\n             }\t\n         \n             while(idx<s.length() and s[idx]==' ')\n             {\n                idx++;\n             }\n\n         }      \n        \n         vector<string>ans(len,\"\");\n         \n         for(int i=0;i<words.size();i++)\n         {\n              string currword=words[i];\n              for(int j=0;j<len;j++)\n              {\n                  if(j<=currword.length()-1)\n                  {\n                     ans[j].push_back(currword[j]);             \n                  }\n                  else if(j>currword.length()-1)\n                  {\n                      ans[j].push_back(' ');\n                  }\n              }\n         }\n         vector<string>result;\n         for(int i=0;i<ans.size();i++)\n         {\n             string currword = ans[i];\n             int idx=-1;\n             int j;\n             for(j=0;j<currword.length();j++)\n             {\n                 if(currword[j]>='A' and currword[j]<='Z')\n                 {\n                     idx=j;\n                 }\n             }\n             result.push_back(currword.substr(0,idx+1));\n         }\n         return result;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    vector<string> printVertically(string s) \\n    {\\n         int idx=0;\\n         int len=0;\\n\\n         vector<string>words;\\n\\n         while(idx<s.length())\\n         {\\n             if(idx<s.length() and s[idx]>=\\'A\\' and s[idx]<=\\'Z\\')\\n             {\\n                string word=\"\";\\n                while(idx<s.length() and s[idx]>=\\'A\\' and s[idx]<=\\'Z\\')\\n                {\\n                    word.push_back(s[idx]);\\n                    idx++;\\n                }\\t\\n                if(word.length() > 0)\\n                {\\n                   words.push_back(word); \\n                   if(word.length()>len)\\n                   {\\n                       len=word.length();\\n                   }\\n                }\\n             }\\t\\n         \\n             while(idx<s.length() and s[idx]==\\' \\')\\n             {\\n                idx++;\\n             }\\n\\n         }      \\n        \\n         vector<string>ans(len,\"\");\\n         \\n         for(int i=0;i<words.size();i++)\\n         {\\n              string currword=words[i];\\n              for(int j=0;j<len;j++)\\n              {\\n                  if(j<=currword.length()-1)\\n                  {\\n                     ans[j].push_back(currword[j]);             \\n                  }\\n                  else if(j>currword.length()-1)\\n                  {\\n                      ans[j].push_back(\\' \\');\\n                  }\\n              }\\n         }\\n         vector<string>result;\\n         for(int i=0;i<ans.size();i++)\\n         {\\n             string currword = ans[i];\\n             int idx=-1;\\n             int j;\\n             for(j=0;j<currword.length();j++)\\n             {\\n                 if(currword[j]>=\\'A\\' and currword[j]<=\\'Z\\')\\n                 {\\n                     idx=j;\\n                 }\\n             }\\n             result.push_back(currword.substr(0,idx+1));\\n         }\\n         return result;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-stepping-numbers-in-range",
        "tags": "cpp",
        "release_time": 1692204094,
        "code": "class Solution {\npublic:\n    #define mod 1000000007\n    long long dp[102][10][2][2];\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\n        if(n==0) return 1;\n        \n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\n        long long up = tight ? (r[r.size()-n]-'0'):9,ans=0;\n        \n        if(leadingZero){\n            for(int i=0;i<=up;i++){\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \n            }\n        } else {\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\n        }\n        \n        \n        return dp[n][pre][leadingZero][tight]=ans;\n    }\n    int countSteppingNumbers(string low, string high) {\n        int n=high.size();\n        memset(dp,-1,sizeof(dp));\n        long long r= f(high,high.size(),0,1,1);\n        memset(dp,-1,sizeof(dp));\n        for(int i=low.size()-1;i>=0;i--){\n            if((low[i]-'0')>0){\n                low[i]--;break;\n            } else {\n                low[i]='9';\n            }\n        }\n        \n        // cout<<low<<endl;\n        long long l= f(low,low.size(),0,1,1);\n        cout<<l<<\" \"<<r<<endl;\n        return (r-l+mod)%mod;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define mod 1000000007\\n    long long dp[102][10][2][2];\\n    long long f(string &r,int n,int pre,int leadingZero,int tight){\\n        if(n==0) return 1;\\n        \\n        if(dp[n][pre][leadingZero][tight]!=-1) return dp[n][pre][leadingZero][tight];\\n        long long up = tight ? (r[r.size()-n]-\\'0\\'):9,ans=0;\\n        \\n        if(leadingZero){\\n            for(int i=0;i<=up;i++){\\n                ans = (ans + f(r,n-1,i,(i==0),tight&(i==up)))%mod; \\n            }\\n        } else {\\n            if(pre-1>=0 && pre-1<=up) ans = (ans + f(r,n-1,pre-1,0,tight&(pre-1==up)))%mod;\\n            if(pre+1<=up) ans = (ans + f(r,n-1,pre+1,0,tight&(pre+1==up)))%mod;\\n        }\\n        \\n        \\n        return dp[n][pre][leadingZero][tight]=ans;\\n    }\\n    int countSteppingNumbers(string low, string high) {\\n        int n=high.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long r= f(high,high.size(),0,1,1);\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=low.size()-1;i>=0;i--){\\n            if((low[i]-\\'0\\')>0){\\n                low[i]--;break;\\n            } else {\\n                low[i]=\\'9\\';\\n            }\\n        }\\n        \\n        // cout<<low<<endl;\\n        long long l= f(low,low.size(),0,1,1);\\n        cout<<l<<\" \"<<r<<endl;\\n        return (r-l+mod)%mod;\\n    }\\n};\\n```"
    },
    {
        "slug": "fruit-into-baskets",
        "tags": "cpp",
        "release_time": 1688730888,
        "code": "class Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        map<int,int> mp;\n        int i=0,j=0,ans=0;\n        while(j<fruits.size()){\n            mp[fruits[j]]++;\n            while(mp.size()>2){\n                if(mp[fruits[i]]==1){\n                    mp.erase(fruits[i]);\n                }else mp[fruits[i]]--;\n\n                i++;\n            }\n            ans=max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://www.youtube.com/watch?v=g2teoWNXspI\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int totalFruit(vector<int>& fruits) {\\n        map<int,int> mp;\\n        int i=0,j=0,ans=0;\\n        while(j<fruits.size()){\\n            mp[fruits[j]]++;\\n            while(mp.size()>2){\\n                if(mp[fruits[i]]==1){\\n                    mp.erase(fruits[i]);\\n                }else mp[fruits[i]]--;\\n\\n                i++;\\n            }\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-common-subsequence",
        "tags": "cpp",
        "release_time": 1690268208,
        "code": "class Solution {\npublic:\n\nint tabulation(string t1, string t2)\n{\n    vector<int>curr(t2.length()+19,0);\n    vector<int>next(t2.length()+19,0);\n \n    for(int i = t1.length()-1;i>=0;i--)\n    {\n        for(int j =t2.length()-1;j>=0;j--)\n        {\n            int ans =0;\n            if(t1[i]==t2[j])\n            {\n                ans=1+next[j+1];\n            }\n            else\n            {\n                ans=max(next[j],curr[j+1]);\n            }\n            curr[j]=ans;\n        } \n        next=curr;\n    }\n    return curr[0];\n}\n\n\n    int longestCommonSubsequence(string text1, string text2)\n    {\n        return tabulation(text1,text2);\n    }\n};",
        "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION \\n\\n# SPACE OPTIMIZED SOLUTION\\n\\n# Approach\\nCreate two 1D DP arrays:\\n\\nThe function tabulation initializes two 1D vectors, curr and next, of size (t2.length() + 19) and fills them with zeros. These arrays will be used to store the LCS lengths for substrings of t2.\\nFilling up the DP arrays:\\n\\nThe outer loop iterates through the characters of t1 in reverse order, starting from the last character and going backwards (i loop).\\nThe inner loop iterates through the characters of t2 in reverse order, starting from the last character and going backwards (j loop).\\nDetermine the LCS length for each pair of characters:\\n\\nFor each pair of characters t1[i] and t2[j], it checks if they are equal.\\nIf they are equal, it means we have found a common character in both strings. So, the LCS length is 1 plus the LCS length for the substring starting from the next position j+1 in t2.\\nIf they are not equal, it means the characters do not match. In this case, we need to find the maximum LCS length from either considering the current substring t2[j:] or the substring t2[j+1:].\\nUpdate the curr array:\\n\\nAfter determining the LCS length for the current pair of characters, it updates the curr[j] entry with the computed LCS length.\\nUpdate the next array:\\n\\nAfter completing the inner loop for a particular i, the curr array is copied to the next array. This step is essential because we are using the next array to compute the LCS lengths for the next i.\\nReturn the LCS length:\\n\\nAfter completing the loop iterations, the function returns the LCS length stored at curr[0]. This corresponds to the LCS of the entire strings t1 and t2.\\nThe tabulation approach fills the DP arrays iteratively, starting from the base cases (i.e., when one of the strings is empty) and then building up to the LCS length of the entire strings. By the end of the process, curr[0] will contain the length of the LCS between text1 and text2.\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(text1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint tabulation(string t1, string t2)\\n{\\n    vector<int>curr(t2.length()+19,0);\\n    vector<int>next(t2.length()+19,0);\\n \\n    for(int i = t1.length()-1;i>=0;i--)\\n    {\\n        for(int j =t2.length()-1;j>=0;j--)\\n        {\\n            int ans =0;\\n            if(t1[i]==t2[j])\\n            {\\n                ans=1+next[j+1];\\n            }\\n            else\\n            {\\n                ans=max(next[j],curr[j+1]);\\n            }\\n            curr[j]=ans;\\n        } \\n        next=curr;\\n    }\\n    return curr[0];\\n}\\n\\n\\n    int longestCommonSubsequence(string text1, string text2)\\n    {\\n        return tabulation(text1,text2);\\n    }\\n};\\n```\\n# Approach\\nCreate a 2D DP table:\\n\\nThe function tabulation initializes a 2D vector dp of size (t1.length() + 19) x (t2.length() + 19) and fills it with zeros.\\nFilling up the DP table:\\n\\nThe outer loop iterates through the characters of t1 in reverse order, starting from the last character and going backwards (i loop).\\nThe inner loop iterates through the characters of t2 in reverse order, starting from the last character and going backwards (j loop).\\nDetermine the LCS length for each pair of characters:\\n\\nFor each pair of characters t1[i] and t2[j], it checks if they are equal.\\nIf they are equal, it means we have found a common character in both strings. So, the LCS length is 1 plus the LCS length of the substrings starting from the next positions i+1 and j+1.\\nIf they are not equal, it means the characters do not match. In this case, we need to find the maximum LCS length from either considering the substring t1[i+1:] or t2[j+1:].\\nUpdate the DP table:\\n\\nAfter determining the LCS length for the current pair of characters, it updates the dp[i][j] entry with the computed LCS length.\\nReturn the LCS length:\\n\\nAfter completing the loop iterations, the function returns the LCS length stored at dp[0][0]. This corresponds to the LCS of the entire strings t1 and t2.\\nThe tabulation approach fills the DP table iteratively, starting from the base cases (i.e., when one of the strings is empty) and then building up to the LCS length of the entire strings. By the end of the process, dp[0][0] will contain the length of the LCS between text1 and text2.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(text1*text1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint tabulation(string t1, string t2)\\n{\\n    vector<vector<int>>dp(t1.length()+19,vector<int>(t2.length()+19,0));\\n    for(int i = t1.length()-1;i>=0;i--)\\n    {\\n        for(int j =t2.length()-1;j>=0;j--)\\n        {\\n            int ans =0;\\n            if(t1[i]==t2[j])\\n            {\\n                ans=1+dp[i+1][j+1];\\n            }\\n            else\\n            {\\n                ans=max(dp[i+1][j],dp[i][j+1]);\\n            }\\n            dp[i][j]=ans;\\n        } \\n    }\\n    return dp[0][0];\\n}\\n\\n\\n    int longestCommonSubsequence(string text1, string text2)\\n    {\\n        return tabulation(text1,text2);\\n    }\\n};\\n```"
    },
    {
        "slug": "magical-string",
        "tags": "cpp",
        "release_time": 1673536160,
        "code": "class Solution {\npublic:\n    int magicalString(int n) {\n        string s=\"\";\n        s+=\"122\";\n        int i=2,c=1;\n        while(i<n && s.size()<n)\n        {\n            if(s[i]=='1')\n            {\n                c++;\n                if(s[s.size()-1]=='2')\n                s+='1';\n                else\n                {\n                    s+='2';\n                }\n            }\n            else\n            {\n                if(s[s.size()-1]=='2')\n                s+=\"11\";\n                else\n                {\n                    s+=\"22\";\n                }\n            }\n            i++;\n        }\n        while(i<n)\n        {\n            if(s[i]=='1')\n            c++;\n            i++;\n        }\n        return c;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution was to find the repeating part first, then i saw the pattern carefully and tried to make it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can make the string using first three digits only \"122\",my intution is to make whole string upto length n,and count ones side by side. Also to count the remaining 1\\'s after while loop breaks\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int magicalString(int n) {\\n        string s=\"\";\\n        s+=\"122\";\\n        int i=2,c=1;\\n        while(i<n && s.size()<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            {\\n                c++;\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\\'1\\';\\n                else\\n                {\\n                    s+=\\'2\\';\\n                }\\n            }\\n            else\\n            {\\n                if(s[s.size()-1]==\\'2\\')\\n                s+=\"11\";\\n                else\\n                {\\n                    s+=\"22\";\\n                }\\n            }\\n            i++;\\n        }\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\')\\n            c++;\\n            i++;\\n        }\\n        return c;\\n    }\\n};\\n```"
    },
    {
        "slug": "finding-3-digit-even-numbers",
        "tags": "cpp",
        "release_time": 1666940781,
        "code": "class Solution {\npublic:\n    vector<int> findEvenNumbers(vector<int>& arr) \n{\n\tvector<int>ans;\n\tvector<int>check(10,0);\n\tfor(int i=0;i<arr.size();i++)\n\t{\n\t\tcheck[arr[i]]++;\n\t}\n\tfor(int i=100;i<=999;i++)\n\t{\n\t\tif((i%2)!=0) continue;\n\t\t\n\t\tvector<int>v(10,0);\n\t\tint num = i;\n\t    string str = to_string(num);\n\t    \n\t    for(int j=0;j<str.length();j++)\n\t    {\n\t    \tint digit = str[j] - '0';\n\t    \tv[digit]++;\n\t\t}\n\t\tbool flag=true;\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t   if(v[i] > check[i])\n\t\t   {\n\t\t     flag=false;\n\t\t\t break;\t\n\t       }\t\n\t\t}\n\t\tif(flag==true)\n\t\t{\n\t\t\tans.push_back(i);\n\t\t}\n\t}\n\treturn ans;\n}\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findEvenNumbers(vector<int>& arr) \\n{\\n\\tvector<int>ans;\\n\\tvector<int>check(10,0);\\n\\tfor(int i=0;i<arr.size();i++)\\n\\t{\\n\\t\\tcheck[arr[i]]++;\\n\\t}\\n\\tfor(int i=100;i<=999;i++)\\n\\t{\\n\\t\\tif((i%2)!=0) continue;\\n\\t\\t\\n\\t\\tvector<int>v(10,0);\\n\\t\\tint num = i;\\n\\t    string str = to_string(num);\\n\\t    \\n\\t    for(int j=0;j<str.length();j++)\\n\\t    {\\n\\t    \\tint digit = str[j] - \\'0\\';\\n\\t    \\tv[digit]++;\\n\\t\\t}\\n\\t\\tbool flag=true;\\n\\t\\tfor(int i=0;i<10;i++)\\n\\t\\t{\\n\\t\\t   if(v[i] > check[i])\\n\\t\\t   {\\n\\t\\t     flag=false;\\n\\t\\t\\t break;\\t\\n\\t       }\\t\\n\\t\\t}\\n\\t\\tif(flag==true)\\n\\t\\t{\\n\\t\\t\\tans.push_back(i);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n};\\n```"
    },
    {
        "slug": "greatest-sum-divisible-by-three",
        "tags": "cpp",
        "release_time": 1677684821,
        "code": "class Solution {\npublic:\nint ans=0;\n\n    int maxSumDivThree(vector<int>& nums) {\n        vector<int>dp(3);\n        for(auto a:nums){\n            for(int i:vector<int>(dp)){\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\n            }\n        }\n       return dp[0];\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n\\n    int maxSumDivThree(vector<int>& nums) {\\n        vector<int>dp(3);\\n        for(auto a:nums){\\n            for(int i:vector<int>(dp)){\\n                dp[(i+a)%3]=max(dp[(i+a)%3],i+a);\\n            }\\n        }\\n       return dp[0];\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "knight-probability-in-chessboard",
        "tags": "cpp",
        "release_time": 1690007879,
        "code": "class Solution {\npublic:\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\n        if(k==0) return 1.0;\n\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\n        double ans = 0.0;\n        for(int t=0;t<8;t++){\n            int nx=i+dx[t],ny=j+dy[t];\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\n                ans += f(nx,ny,k-1,n,dp);\n            }\n        }\n\n        return dp[i][j][k]=ans;\n    }\n    double knightProbability(int n, int k, int row, int column) {\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\n        double ct=f(row,column,k,n,dp);\n        for(int i=0;i<k;i++){\n            ct = ct/8;\n        }\n\n        return ct;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n*k)\\n\\n- Space complexity: O(n*n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double f(int i,int j,int k,int n,vector<vector<vector<double>>> &dp){\\n        if(k==0) return 1.0;\\n\\n        if(dp[i][j][k]!=-1.0) return dp[i][j][k];\\n        int dx[]={-2,-2,-1,1,2,2,1,-1},dy[]={-1,1,2,2,1,-1,-2,-2};\\n        double ans = 0.0;\\n        for(int t=0;t<8;t++){\\n            int nx=i+dx[t],ny=j+dy[t];\\n            if(nx>=0 && nx<n && ny>=0 && ny<n){\\n                ans += f(nx,ny,k-1,n,dp);\\n            }\\n        }\\n\\n        return dp[i][j][k]=ans;\\n    }\\n    double knightProbability(int n, int k, int row, int column) {\\n        vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1.0)));\\n        double ct=f(row,column,k,n,dp);\\n        for(int i=0;i<k;i++){\\n            ct = ct/8;\\n        }\\n\\n        return ct;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-impossible-or",
        "tags": "cpp",
        "release_time": 1676738066,
        "code": "class Solution {\npublic:\n    int minImpossibleOR(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(),nums.end());\n        int temp=1;\n        for(int i=1;i<32;i++){\n            if(s.find(temp)==s.end()) return temp;\n            temp=temp*2;\n        }\n        return temp; \n    }\n};",
        "content": "\\n\\n<!-- Describe your approach to solving the problem. -->\\nIf 1 and 2 are present in the array then all the number from 1 to 3 are expressible.\\n\\nIf 1, 2 and 4 are present in the array then all the number from 1 to 7 are expressible.\\n\\nIf 1, 2, 4 and 8 are present in the array then all the numbers from 1 to 15 are expressible.\\n\\nIf 1, 2, 4, 8 and 16 are present in the array then all the numbers from 1 to 31 are expressible.\\n\\nTherefore we need to find the smallest integer which can be expressed as power of 2 and which is not present in the array.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minImpossibleOR(vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(),nums.end());\\n        int temp=1;\\n        for(int i=1;i<32;i++){\\n            if(s.find(temp)==s.end()) return temp;\\n            temp=temp*2;\\n        }\\n        return temp; \\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-enemy-forts-that-can-be-captured",
        "tags": "cpp",
        "release_time": 1671901275,
        "code": "class Solution {\npublic:\n    int captureForts(vector<int>& forts) {\n        int ans=0;\n        int n=forts.size();\n        for (int i=0; i<n; i++){\n            if (forts[i]==1){\n                i++;\n                int curr=0;\n                while (i<n && forts[i]==0){\n                    curr++;\n                    i++;\n                }\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\n                i--;\n            }\n            if (forts[i]==-1){\n                i++;\n                int curr=0;\n                while (i<n && forts[i]==0){\n                    curr++;\n                    i++;\n                }\n                if (i<n && forts[i]==1)ans= max(ans,curr);\n                i--;\n            }\n            \n        }\n        return ans;\n    }\n};",
        "content": "## Code\\n```\\nclass Solution {\\npublic:\\n    int captureForts(vector<int>& forts) {\\n        int ans=0;\\n        int n=forts.size();\\n        for (int i=0; i<n; i++){\\n            if (forts[i]==1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==-1)ans= max(ans,curr);\\n                i--;\\n            }\\n            if (forts[i]==-1){\\n                i++;\\n                int curr=0;\\n                while (i<n && forts[i]==0){\\n                    curr++;\\n                    i++;\\n                }\\n                if (i<n && forts[i]==1)ans= max(ans,curr);\\n                i--;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "tags": "cpp",
        "release_time": 1687118835,
        "code": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int xoor = 0;\n        for (auto i: derived) xoor ^= i;\n        return !xoor;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int xoor = 0;\\n        for (auto i: derived) xoor ^= i;\\n        return !xoor;\\n    }\\n};\\n```"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
        "tags": "cpp",
        "release_time": 1687422999,
        "code": "class Solution {\npublic:\n    int maxProfit(vector<int>& prices, int fee) {\n        int n = prices.size();\n        if (n <= 1) return 0;\n        int buy = -prices[0];\n        int sell = 0;\n        for (int i = 1; i < n; i++) {\n            int prevBuy = buy;\n            buy = max(buy, sell - prices[i]);\n            sell = max(sell, prevBuy + prices[i] - fee);\n        }\n        return sell;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem, we can use a dynamic programming approach. \\n\\n# Approach\\nThe idea is to maintain two variables, buy and sell, which represent the maximum profit you can achieve if you have bought or sold the stock, respectively. Initially, buy is set to the negative of the first price, assuming we buy the stock on the first day. sell is set to zero because we haven\\'t sold any stock yet.\\n\\nThen, for each day starting from the second day, we update buy and sell as follows:\\n\\n- Update buy by taking the maximum value between the previous buy and the difference between sell and the current price (representing the profit we would make if we bought the stock on this day).\\n- Update sell by taking the maximum value between the previous sell and the sum of the previous buy and the current price minus the transaction fee (representing the profit we would make if we sold the stock on this day).\\n\\nFinally, the maximum profit we can achieve is stored in the sell variable, so we return its value.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int n = prices.size();\\n        if (n <= 1) return 0;\\n        int buy = -prices[0];\\n        int sell = 0;\\n        for (int i = 1; i < n; i++) {\\n            int prevBuy = buy;\\n            buy = max(buy, sell - prices[i]);\\n            sell = max(sell, prevBuy + prices[i] - fee);\\n        }\\n        return sell;\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "tags": "cpp",
        "release_time": 1675303092,
        "code": "class Solution {\npublic:\n    unordered_map<char,int>mp;\n    bool check(string &a,string& b){\n        int aa=a.size(),bb=b.size();\n        int n=min(aa,bb);\n        for(int i=0;i<n;i++){\n            if(mp[a[i]]>mp[b[i]])return false;\n            if(mp[a[i]]<mp[b[i]])return true;\n        }\n        if(aa>bb)return false;\n        return true;\n    }\n    bool isAlienSorted(vector<string>& words, string order) {\n        for(int i=0;i<order.size();i++) mp[order[i]]=i;\n        for(int i=1;i<words.size();i++){\n            bool ch=check(words[i-1],words[i]);\n            if(ch==false) return false;\n        }\n        return true;\n        \n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<char,int>mp;\\n    bool check(string &a,string& b){\\n        int aa=a.size(),bb=b.size();\\n        int n=min(aa,bb);\\n        for(int i=0;i<n;i++){\\n            if(mp[a[i]]>mp[b[i]])return false;\\n            if(mp[a[i]]<mp[b[i]])return true;\\n        }\\n        if(aa>bb)return false;\\n        return true;\\n    }\\n    bool isAlienSorted(vector<string>& words, string order) {\\n        for(int i=0;i<order.size();i++) mp[order[i]]=i;\\n        for(int i=1;i<words.size();i++){\\n            bool ch=check(words[i-1],words[i]);\\n            if(ch==false) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "detect-cycles-in-2d-grid",
        "tags": "cpp",
        "release_time": 1665809409,
        "code": "class Solution {\npublic:\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\n    {\n        visited[i][j] = true;\n        for(int d = 0; d < 4; ++d)\n        {\n            int a = i+dir[d];\n            int b = j+dir[d+1];\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\n                    return true;\n        }\n        return false;\n    }\n    bool containsCycle(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < m; ++j)\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\n                    return true;\n        return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<int> dir = { 0, 1, 0, -1, 0 }; \\n    bool isCyclic(vector<vector<char>>& grid, vector<vector<bool>>& visited, int i, int j, int x, int y)\\n    {\\n        visited[i][j] = true;\\n        for(int d = 0; d < 4; ++d)\\n        {\\n            int a = i+dir[d];\\n            int b = j+dir[d+1];\\n            if(a >= 0 && a < grid.size() && b >= 0 && b < grid[0].size() && grid[a][b] == grid[i][j] && !(x == a && y == b))\\n                if(visited[a][b] || isCyclic(grid, visited, a,b,i,j))\\n                    return true;\\n        }\\n        return false;\\n    }\\n    bool containsCycle(vector<vector<char>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<vector<bool>> visited(n, vector<bool>(m, false));\\n        for(int i = 0; i < n; ++i)\\n            for(int j = 0; j < m; ++j)\\n                if(!visited[i][j] && isCyclic(grid, visited, i, j, -1, -1))\\n                    return true;\\n        return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
        "tags": "cpp",
        "release_time": 1621139536,
        "code": "class Solution {\n    \n    int minFillPos(string& s, char ch, int current = 0) {\n        int count = 0;\n        for(int i=0; i<s.size(); i+=2) {\n            if(s[i] != ch) count++;\n        }\n        return count;\n    }\n    \npublic:\n    int minSwaps(string s) {\n        int oneCount = count(s.begin(), s.end(), '1');\n        int zeroCount = count(s.begin(), s.end(), '0');\n        if(abs(oneCount-zeroCount) > 1) return -1;\n        if(oneCount > zeroCount) return minFillPos(s,'1');\n        if(zeroCount > oneCount) return minFillPos(s,'0');\n        return min(minFillPos(s,'0'), minFillPos(s,'1'));\n    }\n};",
        "content": "```\\nclass Solution {\\n    \\n    int minFillPos(string& s, char ch, int current = 0) {\\n        int count = 0;\\n        for(int i=0; i<s.size(); i+=2) {\\n            if(s[i] != ch) count++;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    int minSwaps(string s) {\\n        int oneCount = count(s.begin(), s.end(), \\'1\\');\\n        int zeroCount = count(s.begin(), s.end(), \\'0\\');\\n        if(abs(oneCount-zeroCount) > 1) return -1;\\n        if(oneCount > zeroCount) return minFillPos(s,\\'1\\');\\n        if(zeroCount > oneCount) return minFillPos(s,\\'0\\');\\n        return min(minFillPos(s,\\'0\\'), minFillPos(s,\\'1\\'));\\n    }\\n};\\n```"
    },
    {
        "slug": "most-beautiful-item-for-each-query",
        "tags": "cpp",
        "release_time": 1664512625,
        "code": "class Solution {\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\n        int ans = 0, s = 0, e = items.size() - 1;\n        while(s <= e) {\n            int m = (s + e) / 2;\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\n            else e = m - 1;\n        }\n        return ans;\n    }\n\npublic:\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\n        sort(items.begin(), items.end());\n        vector<int> ans, beauty(items.size(), items[0][1]);\n\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\n\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\n        return ans;\n    }\n};",
        "content": "\\n# C++\\n```\\nclass Solution {\\n    int bs(vector<vector<int>>& items, int t, vector<int> &beauty) {\\n        int ans = 0, s = 0, e = items.size() - 1;\\n        while(s <= e) {\\n            int m = (s + e) / 2;\\n            if(items[m][0] <= t) ans = beauty[m], s = m + 1;\\n            else e = m - 1;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    vector<int> maximumBeauty(vector<vector<int>>& items, vector<int>& queries) {\\n        sort(items.begin(), items.end());\\n        vector<int> ans, beauty(items.size(), items[0][1]);\\n\\n        for(int i=1; i<items.size(); i++) beauty[i] = max(beauty[i - 1], items[i][1]);\\n\\n        for(int i : queries) ans.push_back(bs(items, i, beauty));\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def maximumBeauty(self, items, queries):\\n        items.sort()\\n        ans, beauty = [], [items[0][1]] * len(items)\\n        for i in range(1, len(items)): beauty[i] = max(beauty[i - 1], items[i][1])\\n\\n        def bs(t):\\n            ans, s, e = 0, 0, len(items) - 1\\n            while s <= e:\\n                m = (s + e) // 2\\n                if items[m][0] <= t:\\n                    ans = beauty[m]\\n                    s = m + 1\\n                else: e = m - 1\\n            return ans\\n\\n        for i in queries: ans.append(bs(i))\\n        return ans\\n```\\n"
    },
    {
        "slug": "perfect-squares",
        "tags": "cpp",
        "release_time": 1669088721,
        "code": "class Solution {\npublic:\n\n    // declare a dp\n\n    int dp[105][10005];\n\n    int helper(vector<int>& arr, int i, int n, int sum)\n    {\n        // base case\n\n        if(sum == 0)\n        {\n            return 0;\n        }\n\n        if(i >= n || sum < 0)\n        {\n            return INT_MAX - 1000;\n        }\n\n        // if already calculated\n\n        if(dp[i][sum] != -1)\n        {\n            return dp[i][sum];\n        }\n\n        // at each ith element we have two options either include or exclude\n\n        int mini = INT_MAX;\n\n        // inclusion part\n\n        if(arr[i] <= sum)\n        {\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\n        }\n\n        // exclusion part\n\n        mini = min(mini, helper(arr, i + 1, n, sum));\n\n        // store the res in dp\n\n        return dp[i][sum] = mini;\n    }\n\n    int numSquares(int n) {\n\n        vector<int> arr;\n\n        // find all the squares between 1 to n\n\n        for(int i = 1; i * i <= n; i++)\n        {\n            arr.push_back(i * i);\n        }\n\n        // initialize dp with -1\n\n        memset(dp, -1, sizeof(dp));\n\n        return helper(arr, 0, arr.size(), n);\n    }\n};",
        "content": "* ***Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N * sqrt(N))***\\n\\n* ***Space Complexity :- O(N * sqrt(N))***\\n\\n* ***There are sqrt(N), squares between 1 to N***\\n\\n```\\nclass Solution {\\npublic:\\n\\n    // declare a dp\\n\\n    int dp[105][10005];\\n\\n    int helper(vector<int>& arr, int i, int n, int sum)\\n    {\\n        // base case\\n\\n        if(sum == 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(i >= n || sum < 0)\\n        {\\n            return INT_MAX - 1000;\\n        }\\n\\n        // if already calculated\\n\\n        if(dp[i][sum] != -1)\\n        {\\n            return dp[i][sum];\\n        }\\n\\n        // at each ith element we have two options either include or exclude\\n\\n        int mini = INT_MAX;\\n\\n        // inclusion part\\n\\n        if(arr[i] <= sum)\\n        {\\n            mini = min(mini, 1 + helper(arr, i, n, sum - arr[i]));\\n        }\\n\\n        // exclusion part\\n\\n        mini = min(mini, helper(arr, i + 1, n, sum));\\n\\n        // store the res in dp\\n\\n        return dp[i][sum] = mini;\\n    }\\n\\n    int numSquares(int n) {\\n\\n        vector<int> arr;\\n\\n        // find all the squares between 1 to n\\n\\n        for(int i = 1; i * i <= n; i++)\\n        {\\n            arr.push_back(i * i);\\n        }\\n\\n        // initialize dp with -1\\n\\n        memset(dp, -1, sizeof(dp));\\n\\n        return helper(arr, 0, arr.size(), n);\\n    }\\n};\\n```"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "tags": "cpp",
        "release_time": 1672545923,
        "code": "class Solution {\npublic:\n    int minimumPartition(string s, int k) {\n        int ans = 0;\n        long long t = 0;\n        for(auto c: s){\n            long long r = t*10 + c-'0';\n            if(r <= k) t = r;\n            else{\n                ans++;\n                t = 0;\n                r = c - '0';\n                if(r <= k) t = r;\n                else return -1;\n            }\n        }\n        if(t <= k) ans++;\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    int minimumPartition(string s, int k) {\\n        int ans = 0;\\n        long long t = 0;\\n        for(auto c: s){\\n            long long r = t*10 + c-\\'0\\';\\n            if(r <= k) t = r;\\n            else{\\n                ans++;\\n                t = 0;\\n                r = c - \\'0\\';\\n                if(r <= k) t = r;\\n                else return -1;\\n            }\\n        }\\n        if(t <= k) ans++;\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "special-binary-string",
        "tags": "cpp",
        "release_time": 1672388328,
        "code": "class Solution {\npublic:\n    string makeLargestSpecial(string s) {\n        \n        if(s.length()==0)\n            return \"\"; //return null string if size is zero\n\n        vector<string> ans; //list to store all current special substrings\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \n                         //\"count\" to keep the track of special substring is over or not\n\n        for(int j=0;j<s.size();j++){\n            if(s[j] == '1')\n                count++;\n            else\n                count--;\n            \n            if(count==0){\n                //call recursively using mid special substring\n\n                ans.push_back('1' + makeLargestSpecial(s.substr(i+1,j-i-1)) + '0');\n                i = j+1;\n            }\n        }\n        //sort current substring stored list to fulfill the question demand\n\n        sort(ans.begin(),ans.end(),greater<string>());\n        string finalString = \"\";\n        for(i=0;i<ans.size();i++){\n            finalString += ans[i];\n        }\n        return finalString;\n    }\n};",
        "content": "Reminder: Special substring can not start with 0 as the 2nd condition states there should be atleast as many no of ones as zeroes, \\neg: \"01001\" prefix of this string is \"0\" but it does\\'nt contain any 1s with itself\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string makeLargestSpecial(string s) {\\n        \\n        if(s.length()==0)\\n            return \"\"; //return null string if size is zero\\n\\n        vector<string> ans; //list to store all current special substrings\\n        int count=0,i=0; //keep track of special substring starting index using \"i\" and \\n                         //\"count\" to keep the track of special substring is over or not\\n\\n        for(int j=0;j<s.size();j++){\\n            if(s[j] == \\'1\\')\\n                count++;\\n            else\\n                count--;\\n            \\n            if(count==0){\\n                //call recursively using mid special substring\\n\\n                ans.push_back(\\'1\\' + makeLargestSpecial(s.substr(i+1,j-i-1)) + \\'0\\');\\n                i = j+1;\\n            }\\n        }\\n        //sort current substring stored list to fulfill the question demand\\n\\n        sort(ans.begin(),ans.end(),greater<string>());\\n        string finalString = \"\";\\n        for(i=0;i<ans.size();i++){\\n            finalString += ans[i];\\n        }\\n        return finalString;\\n    }\\n};\\n```"
    },
    {
        "slug": "kids-with-the-greatest-number-of-candies",
        "tags": "cpp",
        "release_time": 1681936761,
        "code": "class Solution {\npublic:\n       vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n        vector<bool> out;\n        int max=*max_element(candies.begin(),candies.end());\n       for(auto i : candies){\n           if(i+extraCandies>=max)\n           out.push_back(true);\n           else \n           out.push_back(false);\n       }\n        return out;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n       vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\\n        vector<bool> out;\\n        int max=*max_element(candies.begin(),candies.end());\\n       for(auto i : candies){\\n           if(i+extraCandies>=max)\\n           out.push_back(true);\\n           else \\n           out.push_back(false);\\n       }\\n        return out;\\n    }\\n};\\n```"
    },
    {
        "slug": "fibonacci-number",
        "tags": "cpp",
        "release_time": 1685093345,
        "code": "class Solution {\n    int dp[33];\npublic:\n    int fibon(int n) {\n        cout<<n<<endl;\n        if(n==1)return 1;\n        if(n<=0)return 0;\n\n        int& ans = dp[n];\n        if(ans!=-1)return ans;\n\n        return ans = fibon(n-1) + fibon(n-2);\n    }\n\n    int fib(int n){\n        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;\n        int ans = fibon(n);\n        cout<<ans<<endl;\n        return ans;\n    }\n};",
        "content": "# Approach\\nAs we know that many of the states are repeated in fibonacci series while using recursion, so we have to use DP for storing the states and using these precalculated states, so to use these states if encountered again.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, as one state is exexuted only once.\\n\\n- Space complexity:\\n$$O(n)$$, as we are using array for storing states\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[33];\\npublic:\\n    int fibon(int n) {\\n        cout<<n<<endl;\\n        if(n==1)return 1;\\n        if(n<=0)return 0;\\n\\n        int& ans = dp[n];\\n        if(ans!=-1)return ans;\\n\\n        return ans = fibon(n-1) + fibon(n-2);\\n    }\\n\\n    int fib(int n){\\n        for(int i = 0 ; i < 33 ; i++)dp[i]=-1;\\n        int ans = fibon(n);\\n        cout<<ans<<endl;\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-cost-for-tickets",
        "tags": "cpp",
        "release_time": 1679973411,
        "code": "class Solution {\npublic:\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int lastDay = *max_element(days.begin(), days.end());\n        vector<int> dp(lastDay + 2, -1);\n        // needed a + 1 so that the ticket can also cover the last day\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\n\n        for (auto day : days) dp[day] = 0;\n\n        for (int i = lastDay; i >= 0; i--) {\n            // no trips that day, take the price of next day\n            if (dp[i] == -1) dp[i] = dp[i + 1];\n            else {\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\n            }\n        }\n\n        return dp[0];\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake the minimum cost of tickets for each day, bottom up approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate backwards from the last day.\\n- Set days of no travel as -1, we can calculate the price of these days as the same as the next day.\\n- For days of travel, we take the minimum price of a 1 day ticket, 7 day ticket, and 30 day ticket.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = *max_element(days.begin(), days.end());\\n        vector<int> dp(lastDay + 2, -1);\\n        // needed a + 1 so that the ticket can also cover the last day\\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\\n\\n        for (auto day : days) dp[day] = 0;\\n\\n        for (int i = lastDay; i >= 0; i--) {\\n            // no trips that day, take the price of next day\\n            if (dp[i] == -1) dp[i] = dp[i + 1];\\n            else {\\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n![Screenshot 2023-03-27 231946.png](https://assets.leetcode.com/users/images/1408ec23-7284-4d56-90c9-ed048a9f2714_1679973630.1438503.png)\\n"
    },
    {
        "slug": "destination-city",
        "tags": "cpp",
        "release_time": 1691676957,
        "code": "class Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> st;\n        for (auto row : paths)st.insert(row[1]);\n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\n        return *st.begin();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string destCity(vector<vector<string>>& paths) {\\n        unordered_set<string> st;\\n        for (auto row : paths)st.insert(row[1]);\\n        for (auto row : paths)if(st.count(row[0]) > 0) st.erase(row[0]);\\n        return *st.begin();\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "capitalize-the-title",
        "tags": "cpp",
        "release_time": 1672683061,
        "code": "class Solution {\npublic:\n    string capitalizeTitle(string s) {\n        int i=0;\n        int n=s.size();\n        int j=0;\n        while(i<n){\n            j=i;\n            int l=0;\n            while(i<n and s[i]!=' ')s[i]=tolower(s[i]),i++,l++;\n            if(i>0)\n            i++;\n            if(l>2){\n                s[j]=toupper(s[j]);\n            }\n            \n        }\n        return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust a tarverse and jsut look at at the code for more clearity \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string capitalizeTitle(string s) {\\n        int i=0;\\n        int n=s.size();\\n        int j=0;\\n        while(i<n){\\n            j=i;\\n            int l=0;\\n            while(i<n and s[i]!=\\' \\')s[i]=tolower(s[i]),i++,l++;\\n            if(i>0)\\n            i++;\\n            if(l>2){\\n                s[j]=toupper(s[j]);\\n            }\\n            \\n        }\\n        return s;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-operations-to-halve-array-sum",
        "tags": "cpp",
        "release_time": 1672207925,
        "code": "class Solution {\npublic:\n    int halveArray(vector<int>& nums) {\n        //priority queue \n        double sum = accumulate(nums.begin() , nums.end() , 0LL) ; \n        double required_sum = sum/2.0 ;\n        int operation=0;\n//this declares a priority queue and pushes all elements from nums in it\n        priority_queue<double>pq(nums.begin() , nums.end()) ; \n\n        /*\n        while(!pq.empty()) {\n         cout<<pq.top()<<\" \";\n         pq.pop();\n        }\n        */\n\n        while(sum>required_sum){\n            double max_sum = pq.top()/2.0 ;\n            pq.pop();\n            pq.push(max_sum);\n            sum-=max_sum;\n            operation++;\n        }\n        return operation;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int halveArray(vector<int>& nums) {\\n        //priority queue \\n        double sum = accumulate(nums.begin() , nums.end() , 0LL) ; \\n        double required_sum = sum/2.0 ;\\n        int operation=0;\\n//this declares a priority queue and pushes all elements from nums in it\\n        priority_queue<double>pq(nums.begin() , nums.end()) ; \\n\\n        /*\\n        while(!pq.empty()) {\\n         cout<<pq.top()<<\" \";\\n         pq.pop();\\n        }\\n        */\\n\\n        while(sum>required_sum){\\n            double max_sum = pq.top()/2.0 ;\\n            pq.pop();\\n            pq.push(max_sum);\\n            sum-=max_sum;\\n            operation++;\\n        }\\n        return operation;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```"
    },
    {
        "slug": "reverse-only-letters",
        "tags": "cpp",
        "release_time": 1679204854,
        "code": "class Solution {\npublic:\n    string reverseOnlyLetters(string s) \n    {\n      int i=0,j=s.length()-1;\n      while(i<=j)\n      {\n        if(isalpha(s[i])&&isalpha(s[j]))\n        {\n            swap(s[i],s[j]);\n            i++;\n            j--;\n        }\n        else\n        {\n            if(!isalpha(s[i]))\n            {\n                i++;\n            }\n            if(!isalpha(s[j]))\n            {\n                j--;\n            }\n        }\n      }\n      return s;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string reverseOnlyLetters(string s) \\n    {\\n      int i=0,j=s.length()-1;\\n      while(i<=j)\\n      {\\n        if(isalpha(s[i])&&isalpha(s[j]))\\n        {\\n            swap(s[i],s[j]);\\n            i++;\\n            j--;\\n        }\\n        else\\n        {\\n            if(!isalpha(s[i]))\\n            {\\n                i++;\\n            }\\n            if(!isalpha(s[j]))\\n            {\\n                j--;\\n            }\\n        }\\n      }\\n      return s;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-score-of-all-prefixes-of-an-array",
        "tags": "cpp",
        "release_time": 1690909996,
        "code": "class Solution {\npublic:\n    vector<long long> findPrefixScore(vector<int>& nums) {\n         int n=nums.size();\n        vector<long long>ans(n);\n        ans[0]=2*nums[0];\n       long long maxi=nums[0];\n        for(int i=1;i<n;i++)\n        {\n            if(nums[i]>maxi)\n            maxi=nums[i];\n            ans[i]=ans[i-1]+nums[i]+maxi;\n        }\n        return ans;;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> findPrefixScore(vector<int>& nums) {\\n         int n=nums.size();\\n        vector<long long>ans(n);\\n        ans[0]=2*nums[0];\\n       long long maxi=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            if(nums[i]>maxi)\\n            maxi=nums[i];\\n            ans[i]=ans[i-1]+nums[i]+maxi;\\n        }\\n        return ans;;\\n    }\\n};\\n```"
    },
    {
        "slug": "sort-colors",
        "tags": "cpp",
        "release_time": 1691861907,
        "code": "class Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        // sort(nums.begin(), nums.end());\n        int temp = 0;\n        for(int i=0; i<nums.size(); i++){\n            for(int j=i+1; j<nums.size(); j++){\n                if(nums[i]>nums[j]){\n                    temp = nums[j];\n                    nums[j] = nums[i];\n                    nums[i] = temp;\n                }\n            }\n        }\n    }\n};",
        "content": "# Intuition\\nBasically you have to traverse in the array \"nums\" twice, once for the very first element and second for the next element. Once you find that the first element is greater than that of second element swap them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst traverse in the \"nums\" with i=0 so it will start from 0th element, then the second pointer set to i+1 i.e. \"j=i+1\" so it will start from second element. Now compare and put the greater element in the temporary variable and the smaller one to greater one.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortColors(vector<int>& nums) {\\n        // sort(nums.begin(), nums.end());\\n        int temp = 0;\\n        for(int i=0; i<nums.size(); i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                if(nums[i]>nums[j]){\\n                    temp = nums[j];\\n                    nums[j] = nums[i];\\n                    nums[i] = temp;\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "tags": "cpp",
        "release_time": 1670731544,
        "code": "class Solution {\npublic:\n    static bool cmp(int a , int b){\n        return a>b;\n    }\n    int deleteGreatestValue(vector<vector<int>>& grid) {\n        int ans = 0;\n        \n        vector<vector<int>> mat = grid;\n        \n        \n        for(int i=0 ; i<grid.size() ; i++){\n            sort(mat[i].begin() , mat[i].end() , cmp);\n        }\n        \n        for(int j=0 ; j<mat[0].size() ; j++){\n            vector<int> tmp(mat.size());\n            for(int i=0 ; i<mat.size() ; i++){\n               \n                tmp.push_back(mat[i][j]);\n            }\n           \n            sort(tmp.begin() , tmp.end() , cmp);\n            \n            ans = ans + tmp[0];\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(int a , int b){\\n        return a>b;\\n    }\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        vector<vector<int>> mat = grid;\\n        \\n        \\n        for(int i=0 ; i<grid.size() ; i++){\\n            sort(mat[i].begin() , mat[i].end() , cmp);\\n        }\\n        \\n        for(int j=0 ; j<mat[0].size() ; j++){\\n            vector<int> tmp(mat.size());\\n            for(int i=0 ; i<mat.size() ; i++){\\n               \\n                tmp.push_back(mat[i][j]);\\n            }\\n           \\n            sort(tmp.begin() , tmp.end() , cmp);\\n            \\n            ans = ans + tmp[0];\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-all-numbers-disappeared-in-an-array",
        "tags": "cpp",
        "release_time": 1687767620,
        "code": "class Solution {\npublic:\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\n        int n = nums.size();\n        int i = 0;\n        while (i<n) {\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\n                swap(nums[i], nums[nums[i]-1]);\n            else i++;\n        }\n        \n        vector<int> res;\n        for (int i=0; i<n; i++) {\n            if (nums[i] != i+1) res.push_back(i+1);\n        }\n\n        return res;\n    }\n};",
        "content": "**Swap Sort** can be used in various problems where we have to find the **missing or duplicates values** in array and the array must contain **values in range [1..n]**.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDisappearedNumbers(vector<int>& nums) {\\n        int n = nums.size();\\n        int i = 0;\\n        while (i<n) {\\n            if (nums[i] != nums[nums[i]-1] && i != nums[i]-1)\\n                swap(nums[i], nums[nums[i]-1]);\\n            else i++;\\n        }\\n        \\n        vector<int> res;\\n        for (int i=0; i<n; i++) {\\n            if (nums[i] != i+1) res.push_back(i+1);\\n        }\\n\\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "sum-of-digits-of-string-after-convert",
        "tags": "cpp",
        "release_time": 1690867082,
        "code": "class Solution {\npublic:\n    int sumDigits(int num) {\n        int sum = 0;\n        while(num) {\n            sum += num%10;\n            num /= 10;\n        }\n        return sum;\n    }\n    \n    int getLucky(string s, int k) {\n        int sum = 0 ; \n        for(auto it: s){\n            int value = it - 'a' + 1;\n            if(value>=10){\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\n            }else\n                sum = sum + value; \n        }\n\n        k--;//since I did the sum once;\n        while(k-- && sum>=10){//furthur trasformations starts here\n            sum = sumDigits(sum);\n        } \n        return sum;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. apne ko firstly har ek char se iterate karke unki value nikalni hogi\\n2. value agar double digits me aaya to usko bhi single me tod ke sum me add kar deinge\\n3. since yehi chiz upto k=0 tak karni paregi to ek function bana ke kar leinge aur sum return kara deinge\\nNote: As hamne ek baar wo sum nikal liya hai therefore k--;\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumDigits(int num) {\\n        int sum = 0;\\n        while(num) {\\n            sum += num%10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    \\n    int getLucky(string s, int k) {\\n        int sum = 0 ; \\n        for(auto it: s){\\n            int value = it - \\'a\\' + 1;\\n            if(value>=10){\\n                sum+= value%10 + value/10; //since digit is two place only and we need all the digits(_ _)\\n            }else\\n                sum = sum + value; \\n        }\\n\\n        k--;//since I did the sum once;\\n        while(k-- && sum>=10){//furthur trasformations starts here\\n            sum = sumDigits(sum);\\n        } \\n        return sum;\\n    }\\n};\\n```\\n\\n\\n![upvote.jpg](https://assets.leetcode.com/users/images/0593cc08-ec64-46b3-bb36-81ecef0ce934_1690867154.0542114.jpeg)\\n"
    },
    {
        "slug": "smallest-index-with-equal-value",
        "tags": "cpp",
        "release_time": 1675700110,
        "code": "class Solution {\npublic:\n    int smallestEqual(vector<int>& nums) {\n        for (int i = 0 ; i < nums.size() ; i ++)\n        {\n            if ( (i % 10) == nums[i] )\n            {\n                return i ;\n            }\n        }\n        return -1; \n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestEqual(vector<int>& nums) {\\n        for (int i = 0 ; i < nums.size() ; i ++)\\n        {\\n            if ( (i % 10) == nums[i] )\\n            {\\n                return i ;\\n            }\\n        }\\n        return -1; \\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/4ad7c7e8-ac3b-44a3-9c07-4fd7fdbfa301_1675700088.7748973.png)\\n"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "tags": "cpp",
        "release_time": 1673964644,
        "code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        vector<int> v;\n        for (int i=1; i<=n; i++)v.push_back(i);\n        int i=0;\n        while (v.size() != 1){\n            i= (i+k-1)%(v.size());\n            //cout<<v[i]<<endl;\n            v.erase(v.begin()+i);\n        }\n        return v[0];\n    }\n};",
        "content": "## Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        vector<int> v;\\n        for (int i=1; i<=n; i++)v.push_back(i);\\n        int i=0;\\n        while (v.size() != 1){\\n            i= (i+k-1)%(v.size());\\n            //cout<<v[i]<<endl;\\n            v.erase(v.begin()+i);\\n        }\\n        return v[0];\\n    }\\n};\\n```"
    },
    {
        "slug": "partition-labels",
        "tags": "cpp",
        "release_time": 1688226776,
        "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        int n = intervals.size();\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> output;\n        for(auto interval : intervals){\n            if(output.empty() || output.back()[1] < interval[0]){\n                output.push_back(interval);\n            }\n            else{\n                output.back()[1] = max(output.back()[1], interval[1]);\n            }\n        }\n        return output;\n    }\n    vector<int> partitionLabels(string p) {\n        vector<vector<int>> t(26,vector<int>(1+1,-1));\n        for(int i=0;i<p.size();i++)\n        {\n            if(t[p[i]-'a'][0]==-1) \n            {\n                t[p[i]-'a'][0]=i;\n                t[p[i]-'a'][1]=i;\n            }\n            else \n            {\n                t[p[i]-'a'][1]=i;\n            }\n        }\n        \n        t=merge(t);\n        vector<int>an(t.size());\n        int q=0;\n        for(int i=0;i<t.size();i++)\n        {\n            if(t[i][0]==-1) q=1;\n            cout<<t[i][0]<<\",\"<<t[i][1]<<\" \";\n           an[i]=t[i][1]-t[i][0]+1;\n        }\n        if(q==1)\n        an.erase(an.begin());\n        return an;\n    }\n};",
        "content": "\\n# Approach\\nCreated intervals for each character and then merged the intervals. \\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        int n = intervals.size();\\n        sort(intervals.begin(), intervals.end());\\n        vector<vector<int>> output;\\n        for(auto interval : intervals){\\n            if(output.empty() || output.back()[1] < interval[0]){\\n                output.push_back(interval);\\n            }\\n            else{\\n                output.back()[1] = max(output.back()[1], interval[1]);\\n            }\\n        }\\n        return output;\\n    }\\n    vector<int> partitionLabels(string p) {\\n        vector<vector<int>> t(26,vector<int>(1+1,-1));\\n        for(int i=0;i<p.size();i++)\\n        {\\n            if(t[p[i]-\\'a\\'][0]==-1) \\n            {\\n                t[p[i]-\\'a\\'][0]=i;\\n                t[p[i]-\\'a\\'][1]=i;\\n            }\\n            else \\n            {\\n                t[p[i]-\\'a\\'][1]=i;\\n            }\\n        }\\n        \\n        t=merge(t);\\n        vector<int>an(t.size());\\n        int q=0;\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(t[i][0]==-1) q=1;\\n            cout<<t[i][0]<<\",\"<<t[i][1]<<\" \";\\n           an[i]=t[i][1]-t[i][0]+1;\\n        }\\n        if(q==1)\\n        an.erase(an.begin());\\n        return an;\\n    }\\n};\\n```"
    },
    {
        "slug": "transpose-matrix",
        "tags": "cpp",
        "release_time": 1683737574,
        "code": "class Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size(); \n        vector<vector<int>> transposed(n, vector<int>(m));\n    \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                transposed[j][i] = matrix[i][j];\n            }\n        }\n        \n        return transposed;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        int n = matrix[0].size(); \\n        vector<vector<int>> transposed(n, vector<int>(m));\\n    \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                transposed[j][i] = matrix[i][j];\\n            }\\n        }\\n        \\n        return transposed;\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "tags": "cpp",
        "release_time": 1683882134,
        "code": "class Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        int n = nums.size();\n        sort(nums.begin(),nums.end(),greater<int>());\n        for(int i=1;i<=n;i++){\n            int cnt=0;\n            for(int j=0;j<n;j++){\n                if(nums[j]>=i){\n                    cnt++;\n                }\n            }\n            if(cnt==i){\n                return i;\n            }\n        }\n        return -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can iterate over all possible values of x and check if there are exactly x numbers in nums that are greater than or equal to x. If we find such a value of x, we can return it as the answer. If we have checked all possible values of x and none of them satisfy the condition, we can return -1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the array in descending order.\\n- Iterate over all possible values of x from 1 to n (the length of the array).\\n- For each value of x, count the number of elements in the array that are greater than or equal to x. If the count is exactly x, return x as the answer.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Brute force Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        for(int i=1;i<=n;i++){\\n            int cnt=0;\\n            for(int j=0;j<n;j++){\\n                if(nums[j]>=i){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt==i){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Please Upvote if it was helpful\\u2B06\\uFE0F\\n# Optimized Approach (Using Binary Search)\\n# Intuition\\n\\nwe can optimize the time complexity of the solution from O(n^2) to O(n log n) by using binary search instead of iterating over all possible values of x.\\n# Approach\\n- Sort the array in non-increasing order.\\n- Set the left pointer to 1 and the right pointer to n (the length of the array).\\n- While the left pointer is less than or equal to the right pointer:\\n  - Set the mid pointer to the average of the left and right pointers.\\n  -  Count the number of elements in the array that are greater than or equal to mid. If the count is less than mid, set the right pointer to mid-1. If the count is greater than or equal to mid, set the left pointer to mid+1.\\n- If we have checked all possible values of x and none of them satisfy the condition, return -1. Otherwise, return the value of mid.\\n\\n\\nThe key idea behind this algorithm is that the number of elements in the array that are greater than or equal to x is a monotonic function of x. Therefore, we can use binary search to find the smallest value of x such that there are exactly x elements in the array that are greater than or equal to x.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int specialArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int left=1,right=n;\\n        \\n        while(left<=right){\\n            int mid=(left+right)/2;\\n            int cnt=0;\\n            for(int i=0;i<n;i++){\\n                if(nums[i]>=mid){\\n                    cnt++;\\n                }else{\\n                    break;\\n                }\\n            }\\n            if(cnt<mid){\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        if(right<1 || nums[right-1]<right){\\n            return -1;\\n        }\\n        int cal=0;\\n        for(int i=0;i<n;i++){\\n            if(nums[i]>=right){\\n                cal++;\\n            }\\n        }\\n        if(cal==right){\\n            return right;\\n        }else{\\n            return -1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n# Time Complexity \\n$$O(nlogn)$$\\n# Space Complexity\\n$$O(1)$$\\n\\n# One Upvote can be really encouraging\\u2B06\\uFE0F"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "tags": "cpp",
        "release_time": 1686461405,
        "code": "class Solution {\npublic:\n    string smallestString(string s) {\n        int temp = -1;\n        int cnt = 0;\n        for(int i = 0; i < s.size(); i++)\n        {\n            if(s[i] == 'a')\n            {\n                cnt++;\n            }\n        }\n        if(cnt == s.size())\n        {\n            s[s.size() - 1] = 'z';\n            return s;\n        }\n        else\n        {\n            for(int i = 0; i < s.size(); i++)\n            {\n                if(s[i] == 'a')\n                {\n                    temp = i;\n                    break;\n                }\n            }\n\n            if(temp == 0)\n            {\n                int temp1 = 1, temp2 = 1;\n                for(int i = 1 ; i < s.size(); i++)\n                {\n                    if(s[i] != 'a')\n                    {\n                        temp1 = i;\n                        break;\n                    }\n                }\n                for(int i = temp1; i < s.size(); i++)\n                {\n                    if(s[i] == 'a')\n                    {\n                        temp2 = i;\n                        break;\n                    }\n                }\n\n                if(temp2 > 1)\n                {\n                    for(int i = temp1; i < temp2; i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n                else if(temp2 == 1)\n                {\n                    for(int i = temp1; i < s.size(); i++)\n                    {\n                        s[i] = s[i] - 1;\n                    }\n                }\n\n                return s;\n            }\n            else if(temp == -1)\n            {\n                for(int i = 0; i < s.size(); i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n            else\n            {\n                for(int i = 0; i < temp; i++)\n                {\n                    s[i] = s[i] - 1;\n                }\n                return s;\n            }\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck for the first occurence of \\'a\\'.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check for the index where \\'a\\' has occured the very first time.\\n2. If it is index 0, then check for the very first index at which s[i] != \\'a\\', store this index in temp1 variable, then from temp1 check for the nearest occurence of \\'a\\' and store in temp2 variable, and from temp1 till temp2 - 1, replace all the letters with their previous one (alphabetically).\\n3. If index of first occurence of \\'a\\' is greater than 0 and store it in temp variable, then simply starting from 0 and ranging to temp - 1, replace all the letters with their previous one (alphabetically).\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn worst case, we need to traverse the whole string.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string smallestString(string s) {\\n        int temp = -1;\\n        int cnt = 0;\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            if(s[i] == \\'a\\')\\n            {\\n                cnt++;\\n            }\\n        }\\n        if(cnt == s.size())\\n        {\\n            s[s.size() - 1] = \\'z\\';\\n            return s;\\n        }\\n        else\\n        {\\n            for(int i = 0; i < s.size(); i++)\\n            {\\n                if(s[i] == \\'a\\')\\n                {\\n                    temp = i;\\n                    break;\\n                }\\n            }\\n\\n            if(temp == 0)\\n            {\\n                int temp1 = 1, temp2 = 1;\\n                for(int i = 1 ; i < s.size(); i++)\\n                {\\n                    if(s[i] != \\'a\\')\\n                    {\\n                        temp1 = i;\\n                        break;\\n                    }\\n                }\\n                for(int i = temp1; i < s.size(); i++)\\n                {\\n                    if(s[i] == \\'a\\')\\n                    {\\n                        temp2 = i;\\n                        break;\\n                    }\\n                }\\n\\n                if(temp2 > 1)\\n                {\\n                    for(int i = temp1; i < temp2; i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n                else if(temp2 == 1)\\n                {\\n                    for(int i = temp1; i < s.size(); i++)\\n                    {\\n                        s[i] = s[i] - 1;\\n                    }\\n                }\\n\\n                return s;\\n            }\\n            else if(temp == -1)\\n            {\\n                for(int i = 0; i < s.size(); i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n            else\\n            {\\n                for(int i = 0; i < temp; i++)\\n                {\\n                    s[i] = s[i] - 1;\\n                }\\n                return s;\\n            }\\n        }\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "tags": "cpp",
        "release_time": 1687530268,
        "code": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n       int count = 0; \n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\n\n       return count; \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<int>& nums) {\\n       int count = 0; \\n       for(int i=1; i<nums.size(); i++) if(nums[i] <= nums[i-1]) { count += nums[i-1]+1-nums[i]; nums[i] = nums[i-1]+1; }\\n\\n       return count; \\n    }\\n};\\n```"
    },
    {
        "slug": "minimize-malware-spread",
        "tags": "cpp",
        "release_time": 1690747715,
        "code": "class Solution {\npublic:\n    #define ll long long int\n    vector<ll> par;\n    vector<ll> sz;\n    int find(int x)\n    {\n        if(par[x]==x)\n        {\n            return x;\n        }\n        return find(par[x]);\n    }\n    void merge(int x,int y)\n    {\n        if(sz[x]<sz[y])\n        {\n            int t=x;\n            x=y;\n            y=t;\n        }\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    int minMalwareSpread(vector<vector<int>>& ga, vector<int>& a) {\n        int n=ga.size();\n        sort(a.begin(),a.end());\n        sz.resize(n,1);\n        par.resize(n);\n        for(int i=0;i<n;i++)\n        {\n            par[i]=i;\n        }\n        for(int i=0;i<n;i++)\n        {\n            for(int j=0;j<n;j++)\n            {\n                if(ga[i][j]==1)\n                {\n                    int xx=find(i);\n                    int yy=find(j);\n                    if(xx!=yy)\n                    {\n                        merge(xx,yy);\n                    }\n                }\n            }\n        }\n        vector<int> cn(n,0);\n        for(auto i:a)\n        {\n            cn[find(i)]++;\n        }\n        ll ans=a[0],ma=0;\n        for(int i=0;i<a.size();i++)\n        {\n            int xx=find(a[i]);\n            if(cn[xx]==1&&ma<sz[xx])\n            {\n                ma=sz[xx];\n                ans=a[i];\n            }\n        }\n        return ans;\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    vector<ll> par;\\n    vector<ll> sz;\\n    int find(int x)\\n    {\\n        if(par[x]==x)\\n        {\\n            return x;\\n        }\\n        return find(par[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        if(sz[x]<sz[y])\\n        {\\n            int t=x;\\n            x=y;\\n            y=t;\\n        }\\n        sz[x]+=sz[y];\\n        par[y]=x;\\n    }\\n    int minMalwareSpread(vector<vector<int>>& ga, vector<int>& a) {\\n        int n=ga.size();\\n        sort(a.begin(),a.end());\\n        sz.resize(n,1);\\n        par.resize(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            par[i]=i;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(ga[i][j]==1)\\n                {\\n                    int xx=find(i);\\n                    int yy=find(j);\\n                    if(xx!=yy)\\n                    {\\n                        merge(xx,yy);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> cn(n,0);\\n        for(auto i:a)\\n        {\\n            cn[find(i)]++;\\n        }\\n        ll ans=a[0],ma=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int xx=find(a[i]);\\n            if(cn[xx]==1&&ma<sz[xx])\\n            {\\n                ma=sz[xx];\\n                ans=a[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "sum-of-scores-of-built-strings",
        "tags": "cpp",
        "release_time": 1691516314,
        "code": "#define ll long long\n#define sz(x) ((ll)(x).size())\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\n\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\nstruct Hashing{\n    string s;\n    int n;\n    int primes;\n    vector<ll> hashPrimes = {1000000009, 100000007};\n    const ll base = 31;\n    vector<vector<ll>> hashValues;\n    vector<vector<ll>> powersOfBase;\n    Hashing(string a){\n        primes = sz(hashPrimes);\n        hashValues.resize(primes);\n        powersOfBase.resize(primes);\n        s = a;\n        n = s.length(); \n        for(int i = 0; i < sz(hashPrimes); i++) {\n            powersOfBase[i].resize(n + 1);\n            powersOfBase[i][0] = 1;\n            for(int j = 1; j <= n; j++){\n                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];\n            }\n        }\n        for(int i = 0; i < sz(hashPrimes); i++) {\n            hashValues[i].resize(n);\n            for(int j = 0; j < n; j++){\n                hashValues[i][j] = ((s[j] - 'a' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];\n                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];\n            }\n        }\n    }\n    vector<ll> substringHash(int l, int r){ // extra O(log) factor\n        vector<ll> hash(primes);\n        for(int i = 0; i < primes; i++){\n            ll val1 = hashValues[i][r];\n            ll val2 = l > 0 ? hashValues[i][l - 1] : 0LL;\n            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), mminvprime(powersOfBase[i][l], hashPrimes[i]), hashPrimes[i]);\n        }\n        return hash;\n    }\n    bool compareSubstrings(int l1, int r1, int l2, int r2){ // use this for comparing strings faster\n        if(l1 > l2){\n            swap(l1, l2);\n            swap(r1, r2);\n        }\n        for(int i = 0; i < primes; i++){\n            ll val1 = mod_sub(hashValues[i][r1], (l1 > 0 ? hashValues[i][l1 - 1] : 0LL), hashPrimes[i]);\n            ll val2 = mod_sub(hashValues[i][r2], (l2 > 0 ? hashValues[i][l2 - 1] : 0LL), hashPrimes[i]);\n            if(mod_mul(val1, powersOfBase[i][l2 - l1], hashPrimes[i]) != val2)\n                return false;\n        }   \n        return true;\n    }\n};\nclass Solution {\npublic:\n    long long sumScores(string s) {\n        ll n=s.size();\n        Hashing s1(s);\n        ll ans=0;\n        for(int i=n-1;i>=0;i--){\n            int l=i;\n            int r=n-1;\n            ll res=0;\n            while(l<=r){\n                int mid=r-(r-l)/2;\n                int len=mid-i+1;\n                if(s1.compareSubstrings(i,mid,0,len-1)){\n                    res=len;\n                    l=mid+1;\n                }\n                else{\n                    r=mid-1;\n                }\n            }\n            ans+=res;\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\n#define ll long long\\n#define sz(x) ((ll)(x).size())\\nll expo(ll a, ll b, ll mod) {ll res = 1; while (b > 0) {if (b & 1)res = (res * a) % mod; a = (a * a) % mod; b = b >> 1;} return res;}\\n\\nll mminvprime(ll a, ll b) {return expo(a, b - 2, b);}\\nll mod_add(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a + b) % m) + m) % m;}\\nll mod_mul(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a * b) % m) + m) % m;}\\nll mod_sub(ll a, ll b, ll m) {a = a % m; b = b % m; return (((a - b) % m) + m) % m;}\\nll mod_div(ll a, ll b, ll m) {a = a % m; b = b % m; return (mod_mul(a, mminvprime(b, m), m) + m) % m;}  //only for prime m\\nstruct Hashing{\\n    string s;\\n    int n;\\n    int primes;\\n    vector<ll> hashPrimes = {1000000009, 100000007};\\n    const ll base = 31;\\n    vector<vector<ll>> hashValues;\\n    vector<vector<ll>> powersOfBase;\\n    Hashing(string a){\\n        primes = sz(hashPrimes);\\n        hashValues.resize(primes);\\n        powersOfBase.resize(primes);\\n        s = a;\\n        n = s.length(); \\n        for(int i = 0; i < sz(hashPrimes); i++) {\\n            powersOfBase[i].resize(n + 1);\\n            powersOfBase[i][0] = 1;\\n            for(int j = 1; j <= n; j++){\\n                powersOfBase[i][j] = (base * powersOfBase[i][j - 1]) % hashPrimes[i];\\n            }\\n        }\\n        for(int i = 0; i < sz(hashPrimes); i++) {\\n            hashValues[i].resize(n);\\n            for(int j = 0; j < n; j++){\\n                hashValues[i][j] = ((s[j] - \\'a\\' + 1LL) * powersOfBase[i][j]) % hashPrimes[i];\\n                hashValues[i][j] = (hashValues[i][j] + (j > 0 ? hashValues[i][j - 1] : 0LL)) % hashPrimes[i];\\n            }\\n        }\\n    }\\n    vector<ll> substringHash(int l, int r){ // extra O(log) factor\\n        vector<ll> hash(primes);\\n        for(int i = 0; i < primes; i++){\\n            ll val1 = hashValues[i][r];\\n            ll val2 = l > 0 ? hashValues[i][l - 1] : 0LL;\\n            hash[i] = mod_mul(mod_sub(val1, val2, hashPrimes[i]), mminvprime(powersOfBase[i][l], hashPrimes[i]), hashPrimes[i]);\\n        }\\n        return hash;\\n    }\\n    bool compareSubstrings(int l1, int r1, int l2, int r2){ // use this for comparing strings faster\\n        if(l1 > l2){\\n            swap(l1, l2);\\n            swap(r1, r2);\\n        }\\n        for(int i = 0; i < primes; i++){\\n            ll val1 = mod_sub(hashValues[i][r1], (l1 > 0 ? hashValues[i][l1 - 1] : 0LL), hashPrimes[i]);\\n            ll val2 = mod_sub(hashValues[i][r2], (l2 > 0 ? hashValues[i][l2 - 1] : 0LL), hashPrimes[i]);\\n            if(mod_mul(val1, powersOfBase[i][l2 - l1], hashPrimes[i]) != val2)\\n                return false;\\n        }   \\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    long long sumScores(string s) {\\n        ll n=s.size();\\n        Hashing s1(s);\\n        ll ans=0;\\n        for(int i=n-1;i>=0;i--){\\n            int l=i;\\n            int r=n-1;\\n            ll res=0;\\n            while(l<=r){\\n                int mid=r-(r-l)/2;\\n                int len=mid-i+1;\\n                if(s1.compareSubstrings(i,mid,0,len-1)){\\n                    res=len;\\n                    l=mid+1;\\n                }\\n                else{\\n                    r=mid-1;\\n                }\\n            }\\n            ans+=res;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "valid-number",
        "tags": "cpp",
        "release_time": 1682081742,
        "code": "class Solution {\npublic:\n    bool isNumber(string s) {\n        int n = s.length();\n        int i = 0;\n\n        // Skip leading white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // Check optional sign\n        if (i < n && (s[i] == '+' || s[i] == '-')) {\n            i++;\n        }\n\n        // Check digits before decimal point\n        bool hasDigits = false;\n        while (i < n && isdigit(s[i])) {\n            i++;\n            hasDigits = true;\n        }\n\n        // Check optional decimal point and digits after it\n        if (i < n && s[i] == '.') {\n            i++;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasDigits = true;\n            }\n        }\n\n        // Check optional exponent part\n        if (hasDigits && i < n && (s[i] == 'e' || s[i] == 'E')) {\n            i++;\n\n            // Check optional sign in exponent\n            if (i < n && (s[i] == '+' || s[i] == '-')) {\n                i++;\n            }\n\n            bool hasExponentDigits = false;\n            while (i < n && isdigit(s[i])) {\n                i++;\n                hasExponentDigits = true;\n            }\n\n            // The exponent must have at least one digit\n            if (!hasExponentDigits) {\n                return false;\n            }\n        }\n\n        // Check trailing white space\n        while (i < n && isspace(s[i])) {\n            i++;\n        }\n\n        // The number is valid if we consumed the entire string and found at least one digit\n        return i == n && hasDigits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isNumber(string s) {\\n        int n = s.length();\\n        int i = 0;\\n\\n        // Skip leading white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // Check optional sign\\n        if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n            i++;\\n        }\\n\\n        // Check digits before decimal point\\n        bool hasDigits = false;\\n        while (i < n && isdigit(s[i])) {\\n            i++;\\n            hasDigits = true;\\n        }\\n\\n        // Check optional decimal point and digits after it\\n        if (i < n && s[i] == \\'.\\') {\\n            i++;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasDigits = true;\\n            }\\n        }\\n\\n        // Check optional exponent part\\n        if (hasDigits && i < n && (s[i] == \\'e\\' || s[i] == \\'E\\')) {\\n            i++;\\n\\n            // Check optional sign in exponent\\n            if (i < n && (s[i] == \\'+\\' || s[i] == \\'-\\')) {\\n                i++;\\n            }\\n\\n            bool hasExponentDigits = false;\\n            while (i < n && isdigit(s[i])) {\\n                i++;\\n                hasExponentDigits = true;\\n            }\\n\\n            // The exponent must have at least one digit\\n            if (!hasExponentDigits) {\\n                return false;\\n            }\\n        }\\n\\n        // Check trailing white space\\n        while (i < n && isspace(s[i])) {\\n            i++;\\n        }\\n\\n        // The number is valid if we consumed the entire string and found at least one digit\\n        return i == n && hasDigits;\\n    }\\n};\\n```"
    },
    {
        "slug": "coin-change-ii",
        "tags": "cpp",
        "release_time": 1691774051,
        "code": "class Solution\n{\npublic:\n    int change(int amount, vector<int> &coins)\n    {\n        ios_base::sync_with_stdio(0);\n        int st = 0;\n        sort(coins.begin(), coins.end());\n        int ways_to_do[5001] = {0};\n        // If there is a coin of value 1\n        // There will be always a way to make every amount\n        // From [1, amount]\n        // Hence all the values should be initialised at 1\n        if (coins[0] == 1)\n        {\n            for (int i = 1; i <= amount; i++)\n                ways_to_do[i] = 1;\n            st = 1;\n        }\n        // There is always 1 way to make a zero amount \n        ways_to_do[0] = 1;\n        // For every coin_value\n        // Add the number of ways to make current_amount - coin_value \n        // To the number of ways to make the current AMOUNT\n        for (int i = st; i < coins.size(); i++)\n            for (int j = coins[i]; j <= amount; j++)\n                ways_to_do[j] += ways_to_do[j - coins[i]];\n        return ways_to_do[amount];\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNumber of ways a particular `amount` can be generated with a `coin_value` is equal to the current number of ways to generate the `current_amount` + number of ways to generate `current_amount - coin_value`\\n\\n\\n# Complexity\\n- Time complexity: $$O(N * Amount)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(Amount)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int change(int amount, vector<int> &coins)\\n    {\\n        ios_base::sync_with_stdio(0);\\n        int st = 0;\\n        sort(coins.begin(), coins.end());\\n        int ways_to_do[5001] = {0};\\n        // If there is a coin of value 1\\n        // There will be always a way to make every amount\\n        // From [1, amount]\\n        // Hence all the values should be initialised at 1\\n        if (coins[0] == 1)\\n        {\\n            for (int i = 1; i <= amount; i++)\\n                ways_to_do[i] = 1;\\n            st = 1;\\n        }\\n        // There is always 1 way to make a zero amount \\n        ways_to_do[0] = 1;\\n        // For every coin_value\\n        // Add the number of ways to make current_amount - coin_value \\n        // To the number of ways to make the current AMOUNT\\n        for (int i = st; i < coins.size(); i++)\\n            for (int j = coins[i]; j <= amount; j++)\\n                ways_to_do[j] += ways_to_do[j - coins[i]];\\n        return ways_to_do[amount];\\n    }\\n};\\n```"
    },
    {
        "slug": "shuffle-string",
        "tags": "cpp",
        "release_time": 1690699398,
        "code": "class Solution {\npublic:\n    string restoreString(string s, vector<int>& ind) {\n        int n = s.size();\n        string ans(n, '.');\n        for (int i = 0; i < n; i++) {\n            ans[ind[i]] = s[i];\n        } \n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string restoreString(string s, vector<int>& ind) {\\n        int n = s.size();\\n        string ans(n, \\'.\\');\\n        for (int i = 0; i < n; i++) {\\n            ans[ind[i]] = s[i];\\n        } \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-good-numbers",
        "tags": "cpp",
        "release_time": 1690970857,
        "code": "class Solution {\npublic:\n    int mod=1e9+7;\n    int binExpo(long long x,long long n){\n        int ans=1;\n        while(n){\n            if(n&1){\n                ans=(ans*x)%mod;\n            }\n            x=(x*x)%mod;\n            n>>=1;\n        }\n        return ans;\n    }\n    int countGoodNumbers(long long n) {\n        long long even=n/2+n%2,odd=n/2;\n        int even_val=binExpo(5,even);\n        int odd_val=binExpo(4,odd);\n        return (1ll*even_val*odd_val)%mod;\n\n        \n    }\n};",
        "content": "Here we can use the concept of binary exponentiation.\\nAs 2^7==2^(0111) in binary.\\nso 2^7=(2^4)*(2^2)*(2^1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    int binExpo(long long x,long long n){\\n        int ans=1;\\n        while(n){\\n            if(n&1){\\n                ans=(ans*x)%mod;\\n            }\\n            x=(x*x)%mod;\\n            n>>=1;\\n        }\\n        return ans;\\n    }\\n    int countGoodNumbers(long long n) {\\n        long long even=n/2+n%2,odd=n/2;\\n        int even_val=binExpo(5,even);\\n        int odd_val=binExpo(4,odd);\\n        return (1ll*even_val*odd_val)%mod;\\n\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "decode-xored-array",
        "tags": "cpp",
        "release_time": 1687811435,
        "code": "class Solution {\npublic:\n    vector<int> decode(vector<int>& encoded, int first) {\n        vector<int>v;\n        v.push_back(first);\n        for(int i=0;i<encoded.size();i++)\n        {\n        v.push_back(encoded[i]^v[i]);\n        }\n        return v;\n    }\n};",
        "content": "# Hint\\nv[i+1]=encoded[i]^v[i]\\n# Approach\\n- Create a new vector v;\\n- push_back(first);\\n- make a loop till end of encoded vector\\n- keep pushing encoded[i]^v[i]\\n- outside the loop return v;\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> decode(vector<int>& encoded, int first) {\\n        vector<int>v;\\n        v.push_back(first);\\n        for(int i=0;i<encoded.size();i++)\\n        {\\n        v.push_back(encoded[i]^v[i]);\\n        }\\n        return v;\\n    }\\n};\\n```\\n# Please upvote if you understand!!"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "tags": "cpp",
        "release_time": 1671217374,
        "code": "#define pii pair<int, int>\n#define maxn 10005\n#define inf 1000000000\n\nclass Solution {\npublic:\n    vector<pii>g[maxn];\n    int dis[maxn];\n    int n, m;\n    bool valid(int x, int y) {\n        if(x >= 0 and x < n and y >= 0 and y < m) return true;\n        else return false;\n    }\n    void bfs(int s) {\n        deque<int> q;\n        for(int i=0; i<maxn; i++) dis[i] = inf;\n        dis[s] = 0;\n        q.push_front(s);\n        while(!q.empty()){\n            int u = q.front();\n            q.pop_front();\n            for(int i=0; i<g[u].size(); i++){\n                int v = g[u][i].first;\n                int w = g[u][i].second;\n                if(dis[u] + w < dis[v]){\n                    dis[v] = dis[u] + w;\n                    if(w == 1) q.push_back(v);\n                    else q.push_front(v);\n                }\n            }\n        }\n    }\n    int minCost(vector<vector<int>>& grid) {\n        n = grid.size(), m = grid[0].size();\n        for(int i=0; i<n; i++) {\n            for(int j=0; j<m; j++) {\n                int u = i * m + j;\n                if(valid(i+1, j)) {\n                    int v = (i+1) * m + j;\n                    int w;\n                    if(grid[i][j] == 3) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                }\n                if(valid(i-1, j)) {\n                    int v = (i-1) * m + j;\n                    int w;\n                    if(grid[i][j] == 4) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j+1)) {\n                    int v = i * m + (j+1);\n                    int w;\n                    if(grid[i][j] == 1) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n                if(valid(i, j-1)) {\n                    int v = i * m + (j-1);\n                    int w;\n                    if(grid[i][j] == 2) w = 0;\n                    else w = 1;\n                    g[u].push_back({v, w});\n                } \n            }\n        }\n        bfs(0);\n        int node = (n * m) - 1;\n        int ans = dis[node];\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS 2D\\n\\n# Code\\n```\\n#define pii pair<int, int>\\n#define maxn 10005\\n#define inf 1000000000\\n\\nclass Solution {\\npublic:\\n    vector<pii>g[maxn];\\n    int dis[maxn];\\n    int n, m;\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x < n and y >= 0 and y < m) return true;\\n        else return false;\\n    }\\n    void bfs(int s) {\\n        deque<int> q;\\n        for(int i=0; i<maxn; i++) dis[i] = inf;\\n        dis[s] = 0;\\n        q.push_front(s);\\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop_front();\\n            for(int i=0; i<g[u].size(); i++){\\n                int v = g[u][i].first;\\n                int w = g[u][i].second;\\n                if(dis[u] + w < dis[v]){\\n                    dis[v] = dis[u] + w;\\n                    if(w == 1) q.push_back(v);\\n                    else q.push_front(v);\\n                }\\n            }\\n        }\\n    }\\n    int minCost(vector<vector<int>>& grid) {\\n        n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                int u = i * m + j;\\n                if(valid(i+1, j)) {\\n                    int v = (i+1) * m + j;\\n                    int w;\\n                    if(grid[i][j] == 3) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                }\\n                if(valid(i-1, j)) {\\n                    int v = (i-1) * m + j;\\n                    int w;\\n                    if(grid[i][j] == 4) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n                if(valid(i, j+1)) {\\n                    int v = i * m + (j+1);\\n                    int w;\\n                    if(grid[i][j] == 1) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n                if(valid(i, j-1)) {\\n                    int v = i * m + (j-1);\\n                    int w;\\n                    if(grid[i][j] == 2) w = 0;\\n                    else w = 1;\\n                    g[u].push_back({v, w});\\n                } \\n            }\\n        }\\n        bfs(0);\\n        int node = (n * m) - 1;\\n        int ans = dis[node];\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "divide-array-in-sets-of-k-consecutive-numbers",
        "tags": "cpp",
        "release_time": 1682176291,
        "code": "class Solution {\npublic:\n     bool isPossibleDivide(vector<int>& nums, int k) {\n         map<int,int> map;\n         for(int num : nums){\n             map[num]++;\n         }\n         while(map.size()!=0){\n             int first = map.begin()->first;\n             for(int i=first; i<first+k; i++){\n                 if(!map.count(i)){\n                     return false;\n                 }\n                 map[i]--;\n                 if(map[i]==0){\n                     map.erase(i);\n                 }\n             }\n         }\n         return true;\n     }\n };",
        "content": "# Intuition:\\nBoth approaches are solving the same problem of determining whether a given array can be divided into groups of k consecutive elements or not. Approach 1 uses a map to keep track of the frequency of each element, and then iterates over the elements while maintaining the current group of k consecutive elements. If the current group cannot be formed, it returns false. Approach 2 also uses a map to keep track of the frequency of each element but sorts the array first and then iterates over it. For each element, it checks if it can form a group of k consecutive elements by checking the frequency of the next k-1 elements.\\n\\n# Approach 1:\\n\\n1. Initialize a map to keep track of the frequency of each element.\\n2. Iterate over the array and update the map with the frequency of each element.\\n3. While the map is not empty, get the first element of the map.\\n4. Iterate over the next k consecutive elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n5. Update the frequency of each element in the group and remove any element from the map whose frequency becomes 0.\\n6. Return true if all groups of k consecutive elements can be formed.\\n# Approach 2:\\n\\n1. Check if the length of the array is divisible by k. If not, return false.\\n2. Initialize an unordered map to keep track of the frequency of each element.\\n3. Iterate over the array and update the map with the frequency of each element.\\n4. Sort the array in ascending order.\\n5. For each element in the sorted array, check if its frequency is greater than 0.\\n6. If yes, iterate over the next k-1 elements and check if they exist in the map and have a frequency greater than 0. If any element is missing or has a frequency of 0, return false.\\n7. Update the frequency of each element in the group.\\n8. Repeat steps 5-7 until all groups of k consecutive elements have been formed.\\n9. Return true if all groups of k consecutive elements can be formed.\\n# Complexity:\\n\\n- Time complexity:\\n    - Approach 1: The time complexity of this approach is O(n log n) due to the use of a map and the worst-case scenario is when all elements are distinct, then it takes nlogn time for inserting into map, and n times we need to check for each group of k elements.\\n    - Approach 2: The time complexity of this approach is O(n log n) due to the use of sorting and iterating over the sorted array. Sorting takes O(n log n) time, and iterating over the array takes O(n) time.\\n\\n- Space complexity:\\n    - Approach 1: The space complexity of this approach is O(n) due to the use of a map to store the frequency of each element.\\n    - Approach 2: The space complexity of this approach is also O(n) due to the use of an unordered map to store the frequency of each element.\\n# C++\\n## Approach 1\\n```\\nclass Solution {\\npublic:\\n     bool isPossibleDivide(vector<int>& nums, int k) {\\n         map<int,int> map;\\n         for(int num : nums){\\n             map[num]++;\\n         }\\n         while(map.size()!=0){\\n             int first = map.begin()->first;\\n             for(int i=first; i<first+k; i++){\\n                 if(!map.count(i)){\\n                     return false;\\n                 }\\n                 map[i]--;\\n                 if(map[i]==0){\\n                     map.erase(i);\\n                 }\\n             }\\n         }\\n         return true;\\n     }\\n };\\n```\\n## Approach 2\\n```\\nclass Solution {\\npublic:\\n    bool isPossibleDivide(vector<int>& nums, int k) {\\n        if (nums.size() % k != 0) {\\n            return false;\\n        }\\n        \\n        unordered_map<int,int> map;\\n        for (int num : nums) {\\n            map[num]++;\\n        }\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for (int num : nums) {\\n            if (map[num] > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map[i] == 0) {\\n                        return false;\\n                    }\\n                    map[i]--;\\n                }\\n                map[num]--;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n\\n```\\n# Java\\n ## Approach 1\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n        while (!map.isEmpty()) {\\n            int first = Collections.min(map.keySet());\\n            for (int i = first; i < first + k; i++) {\\n                if (!map.containsKey(i)) {\\n                    return false;\\n                }\\n                map.put(i, map.get(i) - 1);\\n                if (map.get(i) == 0) {\\n                    map.remove(i);\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\\n```\\n## Approach 2\\n```\\nclass Solution {\\n    public boolean isPossibleDivide(int[] nums, int k) {\\n        if (nums.length % k != 0) {\\n            return false;\\n        }\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums) {\\n            map.put(num, map.getOrDefault(num, 0) + 1);\\n        }\\n\\n        Arrays.sort(nums);\\n\\n        for (int num : nums) {\\n            if (map.get(num) > 0) {\\n                for (int i = num + 1; i < num + k; i++) {\\n                    if (map.getOrDefault(i, 0) == 0) {\\n                        return false;\\n                    }\\n                    map.put(i, map.get(i) - 1);\\n                }\\n                map.put(num, map.get(num) - 1);\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```\\n# Python\\n ## Approach 1\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: bool\\n        \"\"\"\\n        num_map = {}\\n        for num in nums:\\n            num_map[num] = num_map.get(num, 0) + 1\\n        while num_map:\\n            first = min(num_map)\\n            for i in range(first, first+k):\\n                if i not in num_map:\\n                    return False\\n                num_map[i] -= 1\\n                if num_map[i] == 0:\\n                    del num_map[i]\\n        return True\\n\\n```\\n ## Approach 2\\n```\\nclass Solution(object):\\n    def isPossibleDivide(self, nums, k):\\n        if len(nums) % k != 0:\\n            return False\\n        \\n        map = {}\\n        for num in nums:\\n            map[num] = map.get(num, 0) + 1\\n        \\n        nums.sort()\\n        \\n        for num in nums:\\n            if map[num] > 0:\\n                for i in range(num+1, num+k):\\n                    if map.get(i, 0) == 0:\\n                        return False\\n                    map[i] -= 1\\n                map[num] -= 1\\n        \\n        return True\\n\\n```\\n# JavaScript\\n ## Approach 1\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n  while (map.size !== 0) {\\n    const first = Array.from(map.keys()).sort((a, b) => a - b)[0];\\n    for (let i = first; i < first + k; i++) {\\n      if (!map.has(i)) {\\n        return false;\\n      }\\n      map.set(i, map.get(i) - 1);\\n      if (map.get(i) === 0) {\\n        map.delete(i);\\n      }\\n    }\\n  }\\n  return true;\\n}\\n```\\n ## Approach 2\\n```\\nvar isPossibleDivide = function(nums, k) {\\n  if (nums.length % k !== 0) {\\n    return false;\\n  }\\n\\n  const map = new Map();\\n  for (const num of nums) {\\n    map.set(num, (map.get(num) || 0) + 1);\\n  }\\n\\n  nums.sort((a, b) => a - b);\\n\\n  for (const num of nums) {\\n    if (map.get(num) > 0) {\\n      for (let i = num + 1; i < num + k; i++) {\\n        if (map.get(i) === 0) {\\n          return false;\\n        }\\n        map.set(i, map.get(i) - 1);\\n      }\\n      map.set(num, map.get(num) - 1);\\n    }\\n  }\\n\\n  return true;\\n}\\n\\n```\\n# Similar Question: \\nhttps://leetcode.com/problems/hand-of-straights/solutions/3444424/c-very-easy-fully-explained-using-map/"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "tags": "cpp",
        "release_time": 1686750328,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\n    private:\n    int cnt=0;\n    int func(TreeNode *root) {\n        if(!root) return 0;\n\n        int l = func(root->left);\n        int r = func(root->right);\n\n        int temp = root->val -1 +l+r;\n        cnt += abs(temp);\n\n        return temp;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        func(root);\n        return cnt;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    // bs ye dhyan rkho leaf node se backtrack kro and return kro iss node ko kitne coins ki \\n    // jarurat hai.. if -2 means 2 coins ki jarurat hai and 0 means no coins need\\n    // 2 means 2 coins extra hai...iss node + iske neeche saare nodes ke bharne ke baad\\n    // to kisi nodes ko kitne coins chahiye :- root->value ,-1 for this node coin\\n    // +l for left side se jo ans aaya if -ve ans aaya to subtract wrna add nd same for right\\n    // so, curr-1+l+r iss node ki requirement hai and iska parent itna coins isko lautaega if\\n    // this is -ve or ye itna coin parent ko lauta rha hai if it is +ve so \\n    // in final cnt ... add its abs(...) since dono case mein coin parent to child ya child to parent move karega\\n    private:\\n    int cnt=0;\\n    int func(TreeNode *root) {\\n        if(!root) return 0;\\n\\n        int l = func(root->left);\\n        int r = func(root->right);\\n\\n        int temp = root->val -1 +l+r;\\n        cnt += abs(temp);\\n\\n        return temp;\\n    }\\npublic:\\n    int distributeCoins(TreeNode* root) {\\n        func(root);\\n        return cnt;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-star-sum-of-a-graph",
        "tags": "cpp",
        "release_time": 1670688277,
        "code": "class Solution {\npublic:\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \n    {\n        int n = vals.size();\n        vector<vector<pair<int, int>>>adj(n);\n        for (vector<int>edge : edges)\n        {\n            int startNode = edge[0], startNodeVal = vals[startNode];\n            int endNode = edge[1], endNodeVal = vals[endNode];\n            adj[startNode].push_back({endNodeVal, endNode});\n            adj[endNode].push_back({startNodeVal, startNode});\n        }\n        //========================================================\n        int mxSum = INT_MIN;\n        for (int node = 0; node < n; node++)\n        {\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\n            int neighborSize = adj[node].size();\n            int sum = vals[node];\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\n            {\n                int val = adj[node][i].first;\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \n\t\t\t\t                     //as the neighbors left to it would also have negative values\n                sum += val;\n            }\n            mxSum = max(mxSum, sum);\n        }\n        //=============================================================\n        return mxSum;\n        \n    }\n};",
        "content": "So a star graph is a graph having **one node [center node] which is connected to all other nodes directly** \\n\\nSo why not try all nodes \"as the center of star graph\"\\nFor each node,\\n  **star graph = node itself(center node)  + all it\\'s direct neighbors**\\n  \\n  Thus for each node treat it is as center node and **find sum of k highest value neighbors**\\n  [Take care of negative values =>  exclude negative values as they would decrease overall sum]\\n  \\n  \\n  \\n```\\nclass Solution {\\npublic:\\n    int maxStarSum(vector<int>& vals, vector<vector<int>>& edges, int k) \\n    {\\n        int n = vals.size();\\n        vector<vector<pair<int, int>>>adj(n);\\n        for (vector<int>edge : edges)\\n        {\\n            int startNode = edge[0], startNodeVal = vals[startNode];\\n            int endNode = edge[1], endNodeVal = vals[endNode];\\n            adj[startNode].push_back({endNodeVal, endNode});\\n            adj[endNode].push_back({startNodeVal, startNode});\\n        }\\n        //========================================================\\n        int mxSum = INT_MIN;\\n        for (int node = 0; node < n; node++)\\n        {\\n            sort(adj[node].begin(), adj[node].end()); //sort the neighbors based on increasing \"values\"\\n            int neighborSize = adj[node].size();\\n            int sum = vals[node];\\n            for (int i = neighborSize - 1; i >= 0 && i >= (neighborSize - k); i--) //take k neighbors [start from largest vals]\\n            {\\n                int val = adj[node][i].first;\\n                if (val < 0) break; //if value of neighbor is < 0, it would decrease sum so \"break\", \\n\\t\\t\\t\\t                     //as the neighbors left to it would also have negative values\\n                sum += val;\\n            }\\n            mxSum = max(mxSum, sum);\\n        }\\n        //=============================================================\\n        return mxSum;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "closest-subsequence-sum",
        "tags": "cpp",
        "release_time": 1623566277,
        "code": "class Solution {\npublic:\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\n        if(i==e){\n            sumv.push_back(sum);\n            return;\n        }\n        find(v,i+1,e,sum+v[i],sumv);\n        find(v,i+1,e,sum,sumv);\n    }\n        \n    \n    int minAbsDifference(vector<int>& nums, int goal) {\n        int n=nums.size();\n        \n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\n        \n        vector<int>A,B;\n        for(int i=0;i<n/2;i++)\n            A.push_back(nums[i]);\n        for(int i=n/2;i<n;i++)\n            B.push_back(nums[i]);\n        \n        //Step 2: Find all possible subset sums of A and B\n        \n        vector<int>sumA,sumB;\n        find(A,0,A.size(),0,sumA);\n        find(B,0,B.size(),0,sumB);\n        \n        sort(sumA.begin(),sumA.end());\n        sort(sumB.begin(),sumB.end());\n        \n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\n        \n        int ans=INT_MAX;\n        \n        for(int i=0;i<sumA.size();i++){\n            int s=sumA[i];\n            int l=0;\n            int r=sumB.size()-1;\n            while(l<=r){\n                int mid=l+(r-l)/2;\n                int sum=s+sumB[mid];\n                if(sum==goal)\n                    return 0;\n                ans=min(ans,abs(sum-goal));\n                if(sum>goal){\n                    r=mid-1;\n                }\n                else{\n                    l=mid+1;\n                }    \n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    void find(vector<int>&v, int i, int e, int sum, vector<int>&sumv){\\n        if(i==e){\\n            sumv.push_back(sum);\\n            return;\\n        }\\n        find(v,i+1,e,sum+v[i],sumv);\\n        find(v,i+1,e,sum,sumv);\\n    }\\n        \\n    \\n    int minAbsDifference(vector<int>& nums, int goal) {\\n        int n=nums.size();\\n        \\n        //Step 1: Divide nums into 2 subarrays of size n/2 and n-n/2\\n        \\n        vector<int>A,B;\\n        for(int i=0;i<n/2;i++)\\n            A.push_back(nums[i]);\\n        for(int i=n/2;i<n;i++)\\n            B.push_back(nums[i]);\\n        \\n        //Step 2: Find all possible subset sums of A and B\\n        \\n        vector<int>sumA,sumB;\\n        find(A,0,A.size(),0,sumA);\\n        find(B,0,B.size(),0,sumB);\\n        \\n        sort(sumA.begin(),sumA.end());\\n        sort(sumB.begin(),sumB.end());\\n        \\n        //Step 3: Find combinations from sumA & sumB such that abs(sum-goal) is minimized\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<sumA.size();i++){\\n            int s=sumA[i];\\n            int l=0;\\n            int r=sumB.size()-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                int sum=s+sumB[mid];\\n                if(sum==goal)\\n                    return 0;\\n                ans=min(ans,abs(sum-goal));\\n                if(sum>goal){\\n                    r=mid-1;\\n                }\\n                else{\\n                    l=mid+1;\\n                }    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you find it useful!**"
    },
    {
        "slug": "add-strings",
        "tags": "cpp",
        "release_time": 1688037697,
        "code": "class Solution {\npublic:\n    string addStrings(string a, string b) {\n        string ret = \"\" ;\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\n        while( i >= 0 || j >= 0 ){\n            int x = i >= 0 ? a[i--] - '0' : 0 ;\n            int y = j >= 0 ? b[j--] - '0' : 0 ;\n\n            int sm = x + y + carry ;\n            ret.push_back( '0' + (sm % 10) ) ;\n            carry = sm/10;\n        }\n        if(carry)\n            ret.push_back('0' + carry ) ;\n        \n        reverse( ret.begin(), ret.end() ) ;\n\n        return ret ;\n    }\n};",
        "content": "# Intuition\\nSimple solution will be to do the basice math, and simulate the digits from the back\\n\\n# Approach\\n- We\\'ll start with the ends of both strings, and in each iteration (till we\\'ve iterated all the strings), we\\'ll fetch the last digit from the $$nums1$$, $$nums2$$ if not available we\\'ll default to 0.\\n\\n- Then we\\'ll sum the digits and also add the carry from the last iteration,\\n\\n- Then we\\'ll push the sum modulo 10 to the answer string.\\n\\n- Also dont forget to update the carry variable.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string addStrings(string a, string b) {\\n        string ret = \"\" ;\\n        int carry = 0, i = a.size() - 1, j = b.size() - 1;\\n        while( i >= 0 || j >= 0 ){\\n            int x = i >= 0 ? a[i--] - \\'0\\' : 0 ;\\n            int y = j >= 0 ? b[j--] - \\'0\\' : 0 ;\\n\\n            int sm = x + y + carry ;\\n            ret.push_back( \\'0\\' + (sm % 10) ) ;\\n            carry = sm/10;\\n        }\\n        if(carry)\\n            ret.push_back(\\'0\\' + carry ) ;\\n        \\n        reverse( ret.begin(), ret.end() ) ;\\n\\n        return ret ;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximize-grid-happiness",
        "tags": "cpp",
        "release_time": 1669119358,
        "code": "//from votrubac\nclass Solution {\npublic:\n   int dp[25][7][7][64][64] = {};\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\n    int diff = 0, up = (1 << (n - 1));\n    if (j > 0 && (mask_in & 1))\n        diff += d - 30;\n    if (i > 0 && (mask_in & up))\n        diff += d - 30;\n    if (j > 0 && (mask_ex & 1))\n        diff += d + 20;\n    if (i > 0 && (mask_ex & up))\n        diff += d + 20;\n    return diff;\n}\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\n    int i = p / n, j = p % n;\n    if (i >= m)\n        return 0;\n    if (dp[p][in][ex][mask_in][mask_ex])\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\n    if (in > 0) {\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\n        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));\n    }\n    if (ex > 0) {\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\n    }\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\n    return res;\n}\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\n}\n};",
        "content": "\\n\\n# Code\\n```\\n//from votrubac\\nclass Solution {\\npublic:\\n   int dp[25][7][7][64][64] = {};\\nint nCost(int m, int n, int i, int j, int mask_in, int mask_ex, int d) {\\n    int diff = 0, up = (1 << (n - 1));\\n    if (j > 0 && (mask_in & 1))\\n        diff += d - 30;\\n    if (i > 0 && (mask_in & up))\\n        diff += d - 30;\\n    if (j > 0 && (mask_ex & 1))\\n        diff += d + 20;\\n    if (i > 0 && (mask_ex & up))\\n        diff += d + 20;\\n    return diff;\\n}\\nint dfs(int m, int n, int p, int in, int ex, int mask_in, int mask_ex) {\\n    int i = p / n, j = p % n;\\n    if (i >= m)\\n        return 0;\\n    if (dp[p][in][ex][mask_in][mask_ex])\\n        return dp[p][in][ex][mask_in][mask_ex] - 1;\\n    int n_mask_in = (mask_in << 1) & 63, n_mask_ex = (mask_ex << 1) & 63;\\n    int res = dfs(m, n, p + 1, in, ex, n_mask_in, n_mask_ex);\\n    if (in > 0) {\\n        int diff = 120 + nCost(m, n, i, j, mask_in, mask_ex, -30);\\n        res = max(res, diff + dfs(m, n, p + 1, in - 1, ex, n_mask_in + 1, n_mask_ex));\\n    }\\n    if (ex > 0) {\\n        int diff = 40 + nCost(m, n, i, j, mask_in, mask_ex, 20);\\n        res = max(res, diff + dfs(m, n, p + 1, in, ex - 1, n_mask_in, n_mask_ex + 1));\\n    }\\n    dp[p][in][ex][mask_in][mask_ex] = res + 1;\\n    return res;\\n}\\nint getMaxGridHappiness(int m, int n, int introvertsCount, int extrovertsCount) {\\n    return dfs(m, n, 0, introvertsCount, extrovertsCount, 0, 0);\\n}\\n};\\n```"
    },
    {
        "slug": "sentence-similarity-iii",
        "tags": "cpp",
        "release_time": 1617468664,
        "code": "class Solution {\npublic:\n    bool areSentencesSimilar(string sentence1, string sentence2) {\n        // two vectors to store words of both sentence\n        vector<string>s1;\n        vector<string>s2;\n        string word;\n        stringstream iss(sentence1);//storing each word of sentence 1\n            while(iss>>word)\n               s1.push_back(word);\n        string word1;\n        stringstream iss1(sentence2);//storing each word of sentence 2\n            while(iss1>>word1)\n                 s2.push_back(word1);\n        int start1=0,start2=0,end1=s1.size()-1,end2=s2.size()-1;\n        while(start1<=end1&&start2<=end2)\n        {\n            if(s1[start1]==s2[start2]) // if start of both vectors are equal\n            {\n                start1++; start2++;\n            }\n            else if(s1[end1]==s2[end2]) //if end of both vectors are equal\n            {\n                end1--; end2--;\n            }\n            else  return false;\n        }\n        return true;\n    }\n        \n};",
        "content": "**Logic--\\nIf first words matches increase the start pointers else If last words matches decrease the end pointers else return false**\\n\\n```\\nclass Solution {\\npublic:\\n    bool areSentencesSimilar(string sentence1, string sentence2) {\\n        // two vectors to store words of both sentence\\n        vector<string>s1;\\n        vector<string>s2;\\n        string word;\\n        stringstream iss(sentence1);//storing each word of sentence 1\\n            while(iss>>word)\\n               s1.push_back(word);\\n        string word1;\\n        stringstream iss1(sentence2);//storing each word of sentence 2\\n            while(iss1>>word1)\\n                 s2.push_back(word1);\\n        int start1=0,start2=0,end1=s1.size()-1,end2=s2.size()-1;\\n        while(start1<=end1&&start2<=end2)\\n        {\\n            if(s1[start1]==s2[start2]) // if start of both vectors are equal\\n            {\\n                start1++; start2++;\\n            }\\n            else if(s1[end1]==s2[end2]) //if end of both vectors are equal\\n            {\\n                end1--; end2--;\\n            }\\n            else  return false;\\n        }\\n        return true;\\n    }\\n        \\n};\\n```"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "tags": "cpp",
        "release_time": 1680722545,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        ios_base::sync_with_stdio(false);\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\n     return {-1,-1};\n }\n        ListNode* temp2=head->next;\n        ListNode* temp3=head->next->next;\n      vector<int>v;\n      int i=2;\n      while(temp3){\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\n              v.push_back(i);\n          }\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\n              v.push_back(i);\n          }\n          i++;\n          head=head->next;\n          temp2=temp2->next;\n          temp3=temp3->next;\n      }\n      if(v.size()<2){\n           return {-1,-1};\n      }\n      int mini=INT_MAX;\n      for(int i=1;i<v.size();i++){\n          mini=min(mini,(v[i]-v[i-1]));\n      }\n        return {mini,(v[v.size()-1]-v[0])};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen faced with a problem involving linked lists, the first intuition should be to think about how to traverse the list efficiently to extract the required information.\\n\\nIn the case of this problem, the required information is the minimum and maximum distance between any two critical points in the list. A critical point is defined as a node where the value is either the maximum or minimum among its adjacent nodes.\\n\\nTo solve this problem, we need to traverse the list and identify the critical points. Once we have the critical points, we can calculate the distances between them and find the minimum and maximum distances.\\n\\nTherefore, the first intuition for this problem should be to think about how to traverse the list and identify critical points efficiently. We can then use this information to calculate the minimum and maximum distances between critical points.\\n\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code first checks if the list has at least three nodes, as it is not possible to have a critical point with less than two adjacent nodes. If the list does not meet this condition, the function returns {-1,-1}.\\n\\nThen, the code initializes three pointers, head, temp2, and temp3. The head pointer is used to traverse the list, while temp2 and temp3 are used to check if the current node is a critical point. The i variable is also initialized to 2, as the first two nodes are not considered critical points.\\n\\nNext, the code enters a loop that traverses the list using the temp3 pointer. For each node, the code checks if it is a critical point by comparing its value to the values of its adjacent nodes. If it is a critical point, the current value of i is pushed to a vector v.\\n\\nAfter the loop finishes, the code checks if there are at least two critical points in the list. If there are less than two, the function returns {-1,-1}.\\n\\nIf there are at least two critical points, the code calculates the minimum and maximum distances between adjacent critical points. The minimum distance is the minimum difference between the indices of adjacent critical points in the v vector, and the maximum distance is the difference between the indices of the first and last elements in the v vector.\\n\\nFinally, the function returns a vector containing the minimum and maximum distances as its two elements.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is O(n), where n is the length of the input singly-linked list. This is because the code only traverses the list once in the while loop, and performs constant time operations (comparisons, pointer assignments, and vector operations) for each node. The vector operations inside the loop take constant time on average, as the vector is not resized during the loop. Therefore, the overall time complexity of the code is O(n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is O(1) if we ignore the space used by the input linked list. The code only uses a constant amount of extra space to store three pointers (head, temp2, temp3) and a vector v to store the indices of critical points. The size of v is proportional to the number of critical points in the list, which is at most n-2 (where n is the length of the list), as there can be at most one critical point per node except for the first and last nodes. Therefore, the size of v is bounded by O(n), but since the space used by v is not a function of the input size, we consider it as a constant space usage. Therefore, the overall space complexity of the code is O(1).\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n if(head==NULL || head->next==NULL ||head->next->next==NULL){\\n     return {-1,-1};\\n }\\n        ListNode* temp2=head->next;\\n        ListNode* temp3=head->next->next;\\n      vector<int>v;\\n      int i=2;\\n      while(temp3){\\n          if((head->val<temp2->val)&&(temp3->val<temp2->val)){\\n              v.push_back(i);\\n          }\\n          else if((head->val>temp2->val)&&(temp3->val>temp2->val)){\\n              v.push_back(i);\\n          }\\n          i++;\\n          head=head->next;\\n          temp2=temp2->next;\\n          temp3=temp3->next;\\n      }\\n      if(v.size()<2){\\n           return {-1,-1};\\n      }\\n      int mini=INT_MAX;\\n      for(int i=1;i<v.size();i++){\\n          mini=min(mini,(v[i]-v[i-1]));\\n      }\\n        return {mini,(v[v.size()-1]-v[0])};\\n    }\\n};\\n```"
    },
    {
        "slug": "kth-ancestor-of-a-tree-node",
        "tags": "cpp",
        "release_time": 1667792667,
        "code": "class TreeAncestor {\npublic:\n    vector<vector<int>>v;\n    TreeAncestor(int n, vector<int>& parent) {\n        vector<vector<int>> par(n, vector<int>(20));\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\n        for (int j = 1; j < 20; j++) {\n            for (int i = 0; i < n; i++) {\n                if (par[i][j - 1] == -1) par[i][j] = -1;\n                else par[i][j] = par[par[i][j - 1]][j - 1];\n            }\n        }\n        swap(v, par);\n    }\n    int getKthAncestor(int node, int k) {\n        for (int i = 0; i < 20; i++) {\n            if ((k >> i) & 1) {\n                node = v[node][i];\n                if (node == -1) return -1;\n            }\n        }\n        return node;\n    }\n};\n\n/**\n * Your TreeAncestor object will be instantiated and called as such:\n * TreeAncestor* obj = new TreeAncestor(n, parent);\n * int param_1 = obj->getKthAncestor(node,k);\n */",
        "content": "\\n\\n# Code\\n```\\nclass TreeAncestor {\\npublic:\\n    vector<vector<int>>v;\\n    TreeAncestor(int n, vector<int>& parent) {\\n        vector<vector<int>> par(n, vector<int>(20));\\n        for (int i = 0; i < n; i++) par[i][0] = parent[i];\\n        for (int j = 1; j < 20; j++) {\\n            for (int i = 0; i < n; i++) {\\n                if (par[i][j - 1] == -1) par[i][j] = -1;\\n                else par[i][j] = par[par[i][j - 1]][j - 1];\\n            }\\n        }\\n        swap(v, par);\\n    }\\n    int getKthAncestor(int node, int k) {\\n        for (int i = 0; i < 20; i++) {\\n            if ((k >> i) & 1) {\\n                node = v[node][i];\\n                if (node == -1) return -1;\\n            }\\n        }\\n        return node;\\n    }\\n};\\n\\n/**\\n * Your TreeAncestor object will be instantiated and called as such:\\n * TreeAncestor* obj = new TreeAncestor(n, parent);\\n * int param_1 = obj->getKthAncestor(node,k);\\n */\\n```"
    },
    {
        "slug": "minimum-sideway-jumps",
        "tags": "cpp",
        "release_time": 1671628807,
        "code": "class Solution {\npublic:\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\n        if(i==obstacles.size()-2){\n            if(obstacles[i+1]==l)return 1;\n            return 0;\n        }\n\n        if(dp[i][l]!=-1)return dp[i][l];\n\n        if(obstacles[i+1]!=l){\n            return dp[i][l] = func(i+1,l,obstacles,dp);\n        }\n\n    \n        int b=INT_MAX;\n        for(int j=1;j<=3;j++){\n            if(l==j)continue;\n            if(obstacles[i]==j)continue;\n            b=min(b,1+func(i,j,obstacles,dp));\n        }\n    \n\n        return dp[i][l] = b;\n    }\n\n    int minSideJumps(vector<int>& obstacles) {\n        int n=obstacles.size();\n        vector<vector<int>>dp(n,vector<int>(4,-1));\n        return func(0,2,obstacles,dp);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*4) = O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n*4)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(int i,int l,vector<int>&obstacles,vector<vector<int>>&dp){\\n        if(i==obstacles.size()-2){\\n            if(obstacles[i+1]==l)return 1;\\n            return 0;\\n        }\\n\\n        if(dp[i][l]!=-1)return dp[i][l];\\n\\n        if(obstacles[i+1]!=l){\\n            return dp[i][l] = func(i+1,l,obstacles,dp);\\n        }\\n\\n    \\n        int b=INT_MAX;\\n        for(int j=1;j<=3;j++){\\n            if(l==j)continue;\\n            if(obstacles[i]==j)continue;\\n            b=min(b,1+func(i,j,obstacles,dp));\\n        }\\n    \\n\\n        return dp[i][l] = b;\\n    }\\n\\n    int minSideJumps(vector<int>& obstacles) {\\n        int n=obstacles.size();\\n        vector<vector<int>>dp(n,vector<int>(4,-1));\\n        return func(0,2,obstacles,dp);\\n    }\\n};\\n```"
    },
    {
        "slug": "find-elements-in-a-contaminated-binary-tree",
        "tags": "cpp",
        "release_time": 1666144088,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass FindElements {\n  unordered_set<int> set;\npublic:\n    void recover(TreeNode* root, int x) {\n        if (!root) return;\n        root->val = x;\n        set.emplace(x);\n        recover(root->left, 2 * x + 1);\n        recover(root->right, 2 * x + 2);\n    }\n    \n    FindElements(TreeNode* root) {\n        recover(root, 0);\n    }\n    \n    bool find(int target) {\n        return set.count(target);\n    }\n};\n\n/**\n * Your FindElements object will be instantiated and called as such:\n * FindElements* obj = new FindElements(root);\n * bool param_1 = obj->find(target);\n */",
        "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass FindElements {\\n  unordered_set<int> set;\\npublic:\\n    void recover(TreeNode* root, int x) {\\n        if (!root) return;\\n        root->val = x;\\n        set.emplace(x);\\n        recover(root->left, 2 * x + 1);\\n        recover(root->right, 2 * x + 2);\\n    }\\n    \\n    FindElements(TreeNode* root) {\\n        recover(root, 0);\\n    }\\n    \\n    bool find(int target) {\\n        return set.count(target);\\n    }\\n};\\n\\n/**\\n * Your FindElements object will be instantiated and called as such:\\n * FindElements* obj = new FindElements(root);\\n * bool param_1 = obj->find(target);\\n */\\n```"
    },
    {
        "slug": "find-the-difference-of-two-arrays",
        "tags": "cpp",
        "release_time": 1683091309,
        "code": "class Solution {\npublic:\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> set1(nums1.begin(), nums1.end());\n        unordered_set<int> set2(nums2.begin(), nums2.end());\n        \n        vector<int> distinct_nums1, distinct_nums2;\n        for (int num : set1) {\n            if (set2.count(num) == 0) {\n                distinct_nums1.push_back(num);\n            }\n        }\n\n        for (int num : set2) {\n            if (set1.count(num) == 0) {\n                distinct_nums2.push_back(num);\n            }\n        }\n\n        return {distinct_nums1, distinct_nums2};\n    }\n};",
        "content": "# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Intuition\\n- ##### To solve this problem, we can create two sets: set1 and set2. We can then iterate through nums1 and add each integer to set1. Similarly, we can iterate through nums2 and add each integer to set2.\\n\\n- ##### Next, we can take the set difference between set1 and set2 to obtain the distinct integers in nums1 that are not present in nums2. Similarly, we can take the set difference between set2 and set1 to obtain the distinct integers in nums2 that are not present in nums1.\\n\\n- ##### Finally, we can return the results in the form of a Vector of size 2, where the first element is the vector of distinct integers in nums1 that are not present in nums2, and the second element is the vector of distinct integers in nums2 that are not present in nums1.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- ### Time complexity: O(M+N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- ### Space complexity: O(M+N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# **PLEASE UPVOTE \\uD83D\\uDC4D**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_set<int> set1(nums1.begin(), nums1.end());\\n        unordered_set<int> set2(nums2.begin(), nums2.end());\\n        \\n        vector<int> distinct_nums1, distinct_nums2;\\n        for (int num : set1) {\\n            if (set2.count(num) == 0) {\\n                distinct_nums1.push_back(num);\\n            }\\n        }\\n\\n        for (int num : set2) {\\n            if (set1.count(num) == 0) {\\n                distinct_nums2.push_back(num);\\n            }\\n        }\\n\\n        return {distinct_nums1, distinct_nums2};\\n    }\\n};\\n\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/e5cc6438-63d7-47fb-84d1-e4e36cf43c6e_1683003574.1370602.png)\\n"
    },
    {
        "slug": "reduction-operations-to-make-the-array-elements-equal",
        "tags": "cpp",
        "release_time": 1675938581,
        "code": "class Solution {\npublic:\n    int reductionOperations(vector<int>& nums) {\n        int ans = 0;\n        map<int,int> mp;\n        for(auto &i: nums){\n            mp[i]++;\n        }\n        auto it = mp.end();\n        while(mp.begin() != --it){\n            // cout<<it->first<<\" \"<<it->second<<endl;\n            auto x = it;\n            --x;\n            ans += it->second;\n            x->second += it->second;\n        }\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int reductionOperations(vector<int>& nums) {\\n        int ans = 0;\\n        map<int,int> mp;\\n        for(auto &i: nums){\\n            mp[i]++;\\n        }\\n        auto it = mp.end();\\n        while(mp.begin() != --it){\\n            // cout<<it->first<<\" \"<<it->second<<endl;\\n            auto x = it;\\n            --x;\\n            ans += it->second;\\n            x->second += it->second;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "min-cost-climbing-stairs",
        "tags": "cpp",
        "release_time": 1690306963,
        "code": "class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        int n = cost.size();\n\n        for(int i=2; i<n; i++){\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\n        }\n\n        return min(cost[n-1],cost[n-2]);\n    }\n};",
        "content": "\\n# Approach\\nDynamic Programming without using any extra memory. Modifying the given array itself.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCostClimbingStairs(vector<int>& cost) {\\n        int n = cost.size();\\n\\n        for(int i=2; i<n; i++){\\n            cost[i] = min(cost[i-1],cost[i-2]) + cost[i];\\n        }\\n\\n        return min(cost[n-1],cost[n-2]);\\n    }\\n};\\n```"
    },
    {
        "slug": "the-number-of-good-subsets",
        "tags": "cpp",
        "release_time": 1673615811,
        "code": "class Solution {\npublic:\n    int mod=1e9+7;\n    vector<int>prime;\n    int mp[45];\n    long long dp[31][1<<12];\n    int find(int n)\n    {\n        for(int i=2;i<=sqrt(n);i++)\n        {\n            if(n%i==0)\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    long long find(int value,int mask)\n    {\n        if(value>30)\n        {\n            return (mask>0);\n        }\n        if(dp[value][mask]!=-1)\n        {\n            return dp[value][mask]%mod;\n        }\n        int new_mask=0;\n        long long product=1;\n        for(int i=0;i<prime.size();i++)\n        {\n            if((value%prime[i])==0)\n            {\n                product*=prime[i];\n                new_mask|=(1<<i);\n            }\n        }\n        long long ans=find(value+1,mask);\n        if(product==value&&mp[value]&&((mask&new_mask)==0))\n        {\n            ans+=(find(value+1,mask|new_mask)*mp[value]);\n        }\n        return dp[value][mask]=ans%mod;\n    }\n    int numberOfGoodSubsets(vector<int>& nums) \n    {\n        memset(dp,-1,sizeof(dp));\n        for(int i=2;i<=30;i++)\n        {\n            if(find(i))\n            {\n                prime.push_back(i);\n            }\n        }\n        for(auto it:nums)\n        {\n            mp[it]++;\n        }\n        long long val=find(2,0)%mod;\n        long one=1;\n        for(int i=0;i<mp[1];i++)\n        {\n            one=(one*2)%mod;\n        }\n        val=(val*one)%mod;\n        return val;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    vector<int>prime;\\n    int mp[45];\\n    long long dp[31][1<<12];\\n    int find(int n)\\n    {\\n        for(int i=2;i<=sqrt(n);i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    long long find(int value,int mask)\\n    {\\n        if(value>30)\\n        {\\n            return (mask>0);\\n        }\\n        if(dp[value][mask]!=-1)\\n        {\\n            return dp[value][mask]%mod;\\n        }\\n        int new_mask=0;\\n        long long product=1;\\n        for(int i=0;i<prime.size();i++)\\n        {\\n            if((value%prime[i])==0)\\n            {\\n                product*=prime[i];\\n                new_mask|=(1<<i);\\n            }\\n        }\\n        long long ans=find(value+1,mask);\\n        if(product==value&&mp[value]&&((mask&new_mask)==0))\\n        {\\n            ans+=(find(value+1,mask|new_mask)*mp[value]);\\n        }\\n        return dp[value][mask]=ans%mod;\\n    }\\n    int numberOfGoodSubsets(vector<int>& nums) \\n    {\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=2;i<=30;i++)\\n        {\\n            if(find(i))\\n            {\\n                prime.push_back(i);\\n            }\\n        }\\n        for(auto it:nums)\\n        {\\n            mp[it]++;\\n        }\\n        long long val=find(2,0)%mod;\\n        long one=1;\\n        for(int i=0;i<mp[1];i++)\\n        {\\n            one=(one*2)%mod;\\n        }\\n        val=(val*one)%mod;\\n        return val;\\n    }\\n};\\n```"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "tags": "cpp",
        "release_time": 1671733344,
        "code": "class Solution {\n    int dfs(TreeNode* root, int &ans) {\n        if(!root) return 0;\n        int l = dfs(root -> left, ans);\n        int r = dfs(root -> right, ans);\n\n        ans += abs(l) + abs(r);\n        return root -> val - 1 + l + r;\n    }\npublic:\n    int distributeCoins(TreeNode* root) {\n        int ans = 0;\n        dfs(root, ans);\n\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\n    int dfs(TreeNode* root, int &ans) {\\n        if(!root) return 0;\\n        int l = dfs(root -> left, ans);\\n        int r = dfs(root -> right, ans);\\n\\n        ans += abs(l) + abs(r);\\n        return root -> val - 1 + l + r;\\n    }\\npublic:\\n    int distributeCoins(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "tags": "cpp",
        "release_time": 1686170411,
        "code": "class Solution {\npublic:\n    int minSwaps(string s) {\n        int size=0;\n        for(char &ch:s){\n          if(ch=='[')  size++;\n          else if(size) size--;\n        }\n        return (size+1)/2;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSwaps(string s) {\\n        int size=0;\\n        for(char &ch:s){\\n          if(ch==\\'[\\')  size++;\\n          else if(size) size--;\\n        }\\n        return (size+1)/2;\\n    }\\n};\\n```"
    },
    {
        "slug": "construct-the-longest-new-string",
        "tags": "cpp",
        "release_time": 1687622575,
        "code": "class Solution {\npublic:\n    int longestString(int x, int y, int z) {\n        if(z > 0) {\n            if(y > x) return 4 * (x + 1) + 2 * z - 2;\n            return 4 * y + 2 * z + (x - y > 0 ? 2 : 0);\n        }\n        return 4*(min(x,y) + 1) - 2 - (x == y ? 2 : 0);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        if(z > 0) {\\n            if(y > x) return 4 * (x + 1) + 2 * z - 2;\\n            return 4 * y + 2 * z + (x - y > 0 ? 2 : 0);\\n        }\\n        return 4*(min(x,y) + 1) - 2 - (x == y ? 2 : 0);\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-path-to-get-all-keys",
        "tags": "cpp",
        "release_time": 1688009151,
        "code": "class Solution {\npublic:\n    using int2 = pair<int, int>;\n\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size();\n        int m = grid[0].size();\n\n        int2 start;\n        // Scan the start and KeyMask\n        int KeyMask = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                char c = grid[i][j];\n                int2 pos = {i, j};\n                if (c == '@')\n                    start = pos;  // Store the position of the starting point\n                if ('a' <= c && c <= 'z')\n                    KeyMask |= (1 << (c - 'a'));  // Set the corresponding bit in KeyMask for each key found\n            }\n        }\n        // Record the visiting status for every key status\n        vector<vector<vector<bool>>> \n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\n\n        // [i, j, key state, distance]\n        queue<tuple<int, int, int, int>> q;\n        auto [i0, j0] = start;\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\n\n        while (!q.empty()) {\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\n            q.pop();\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\n            for (auto [a, b] : adj) {\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == '#')\n                    continue;  // Skip if the next position is out of bounds or a wall ('#')\n                char c = grid[a][b];\n                // c is a key\n                if ('a' <= c && c <= 'z') {\n                    int keyIdx = c - 'a';  // Calculate the index of the key\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\n                }\n                // c is a lock\n                else if ('A' <= c && c <= 'F') {\n                    int lockIdx = c - 'A';  // Calculate the index of the lock\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n                }\n                // c is ',' or '@'\n                else if (visit[a][b][keyState])\n                    continue;  // Skip if this key state has been visited before at this position\n\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\n            }\n        }\n\n        return -1;  // If all keys cannot be collected, return -1\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ code solves the problem of finding the shortest path to collect all keys in a grid. It uses a BFS approach to explore the grid. It initializes the start position and a bitmask to track collected keys. \\n \\nIt checks if the position contains a key or a lock and updates the key state accordingly. It also keeps track of visited positions with different key states to avoid revisiting them. If all keys are collected, it returns the shortest distance. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are at most $2^6=64$ key states, not a large amount. In this case, using the boolean array is faster than using the hash tables.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(m\\u22C5n\\u22C52^k)$\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    using int2 = pair<int, int>;\\n\\n    int shortestPathAllKeys(vector<string>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        int2 start;\\n        // Scan the start and KeyMask\\n        int KeyMask = 0;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                char c = grid[i][j];\\n                int2 pos = {i, j};\\n                if (c == \\'@\\')\\n                    start = pos;  // Store the position of the starting point\\n                if (\\'a\\' <= c && c <= \\'z\\')\\n                    KeyMask |= (1 << (c - \\'a\\'));  // Set the corresponding bit in KeyMask for each key found\\n            }\\n        }\\n        // Record the visiting status for every key status\\n        vector<vector<vector<bool>>> \\n        visit(n, vector<vector<bool>>(m, vector<bool>(KeyMask+1, 0)));\\n\\n        // [i, j, key state, distance]\\n        queue<tuple<int, int, int, int>> q;\\n        auto [i0, j0] = start;\\n        q.push({i0, j0, 0, 0});  // Push the starting point with initial key state and distance 0\\n\\n        while (!q.empty()) {\\n            auto [i, j, keyState, distance] = q.front();  // Extract current position, key state, and distance from the front of the queue\\n            q.pop();\\n            vector<int2> adj = {{i + 1, j}, {i, j + 1}, {i - 1, j}, {i, j - 1}};\\n            for (auto [a, b] : adj) {\\n                if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == \\'#\\')\\n                    continue;  // Skip if the next position is out of bounds or a wall (\\'#\\')\\n                char c = grid[a][b];\\n                // c is a key\\n                if (\\'a\\' <= c && c <= \\'z\\') {\\n                    int keyIdx = c - \\'a\\';  // Calculate the index of the key\\n                    int newState = keyState | (1 << keyIdx);  // Update the key state by setting the corresponding bit\\n                    if (visit[a][b][newState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][newState] = 1;  // Mark the current key state as visited at this position\\n                    if (newState == KeyMask) return distance + 1;  // If all keys are collected, return the distance\\n                    q.push({a, b, newState, distance + 1});  // Push the next position with updated key state and increased distance\\n                }\\n                // c is a lock\\n                else if (\\'A\\' <= c && c <= \\'F\\') {\\n                    int lockIdx = c - \\'A\\';  // Calculate the index of the lock\\n                    if ((keyState & (1 << lockIdx)) == 0) continue;  // Skip if the corresponding key for the lock is missing\\n                    if (visit[a][b][keyState]) continue;  // Skip if this key state has been visited before at this position\\n                    visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                    q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n                }\\n                // c is \\',\\' or \\'@\\'\\n                else if (visit[a][b][keyState])\\n                    continue;  // Skip if this key state has been visited before at this position\\n\\n                visit[a][b][keyState] = 1;  // Mark the current key state as visited at this position\\n                q.push({a, b, keyState, distance + 1});  // Push the next position with the same key state and increased distance\\n            }\\n        }\\n\\n        return -1;  // If all keys cannot be collected, return -1\\n    }\\n};\\n\\n\\n```"
    },
    {
        "slug": "lru-cache",
        "tags": "cpp",
        "release_time": 1689644680,
        "code": "class LRUCache {\npublic:\nclass node\n{\n  public:\n  int key;\n  int val;\n  node* next;\n  node* prev;\n  node(int _key,int _val)\n  {\n    key = _key;\n    val = _val;\n  }\n};\nnode* head = new node(-1,-1);\nnode* tail = new node(-1,-1);\n\nint size;\nunordered_map<int,node*>mpp;\n    LRUCache(int capacity) {\n       size = capacity; \n       head->next = tail;\n       tail->prev = head;  \n    }\n\n    void addNode(node* newNode){\n       \n       node* temp = head->next;\n       newNode->next = temp;\n       newNode->prev = head;\n       head->next = newNode;\n       temp->prev = newNode;\n    }\n\n    void deleteNode(node* delNode){\n         \n       node* delprev = delNode->prev;\n       node* delnext = delNode->next;\n       delprev->next = delnext;\n       delnext->prev = delprev;\n    }\n    \n    int get(int _key) {\n        \n        if(mpp.count(_key))\n        {\n          node* nde = mpp[_key];\n          int curr = nde->val;\n          mpp.erase(_key);\n          deleteNode(nde);\n          addNode(nde);\n          mpp[_key] = head->next;\n          return curr;\n        }\n        return -1;\n    }\n    \n    void put(int _key, int value) {\n        \n        if(mpp.count(_key))\n        {\n           node* nde = mpp[_key];\n           mpp.erase(_key);\n           deleteNode(nde);\n        }\n        if(mpp.size()==size)\n        {\n           mpp.erase(tail->prev->key);\n           deleteNode(tail->prev);\n        }\n        addNode(new node(_key,value));\n        mpp[_key] = head->next;\n    }\n};",
        "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n## INTUITION\\nTo Implement LRU(Least recently used), we need to have a track of the usage of the keys, in the order of there usage, as we have a limited capacity we cant extend our capacity beyond \"capacity\", so we always we will take out those values which has\\'nt been acccess in the recent time.So, we have to think of something that can kind of sort our keys according to usage on the go, the best Data Structure for this purpose is Doubly linked List.\\n                             A Doubly linked list will have a Head node as well as a tail node, and whenever a key is used we will place it just next to the head node,in this fashions, the one\\'s which are closer to head are the most recently used ones, and as we go closer to the tail node, those are the less recently used ones while the node just previous to tail is the \"LEAST RECENTLY USED\". \\nSo whenever we add a key or use a key(get()), we will move it right after the head node, and whenever we call the (put() function), if size if greater we have to delete the LRU node, if key is not present, (if present then too we will delete that node so as to update the value and still move it right after head node), and place new node right after head node.                        \\n\\n\\n**Ask Furthur Doubts in the Comment Section**\\n# Code\\n```\\nclass LRUCache {\\npublic:\\nclass node\\n{\\n  public:\\n  int key;\\n  int val;\\n  node* next;\\n  node* prev;\\n  node(int _key,int _val)\\n  {\\n    key = _key;\\n    val = _val;\\n  }\\n};\\nnode* head = new node(-1,-1);\\nnode* tail = new node(-1,-1);\\n\\nint size;\\nunordered_map<int,node*>mpp;\\n    LRUCache(int capacity) {\\n       size = capacity; \\n       head->next = tail;\\n       tail->prev = head;  \\n    }\\n\\n    void addNode(node* newNode){\\n       \\n       node* temp = head->next;\\n       newNode->next = temp;\\n       newNode->prev = head;\\n       head->next = newNode;\\n       temp->prev = newNode;\\n    }\\n\\n    void deleteNode(node* delNode){\\n         \\n       node* delprev = delNode->prev;\\n       node* delnext = delNode->next;\\n       delprev->next = delnext;\\n       delnext->prev = delprev;\\n    }\\n    \\n    int get(int _key) {\\n        \\n        if(mpp.count(_key))\\n        {\\n          node* nde = mpp[_key];\\n          int curr = nde->val;\\n          mpp.erase(_key);\\n          deleteNode(nde);\\n          addNode(nde);\\n          mpp[_key] = head->next;\\n          return curr;\\n        }\\n        return -1;\\n    }\\n    \\n    void put(int _key, int value) {\\n        \\n        if(mpp.count(_key))\\n        {\\n           node* nde = mpp[_key];\\n           mpp.erase(_key);\\n           deleteNode(nde);\\n        }\\n        if(mpp.size()==size)\\n        {\\n           mpp.erase(tail->prev->key);\\n           deleteNode(tail->prev);\\n        }\\n        addNode(new node(_key,value));\\n        mpp[_key] = head->next;\\n    }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)"
    },
    {
        "slug": "determine-color-of-a-chessboard-square",
        "tags": "cpp",
        "release_time": 1687862385,
        "code": "class Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\n        else return false;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool squareIsWhite(string coordinates) {\\n        if(coordinates[0]%2==0 && coordinates[1]%2!=0) return true;\\n        else if(coordinates[0]%2!=0 && coordinates[1]%2==0) return true;\\n        else return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "tags": "cpp",
        "release_time": 1687966294,
        "code": "class Solution {\npublic:\n    bool doesValidArrayExist(vector<int>& derived) {\n        int ans = 0;\n        for(int i=0; i<derived.size(); i++)\n            ans ^= derived[i];\n        return ans==0;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets consider the first example:\\nSay `original = [a, b, c]` and given is `derived = [1, 1, 0]`\\nNow, it is given that `derived[i] = original[i]^original[i+1]` for all and `dervied[n-1] = original[n-1]^original[0] `\\nWe can see that `a^b = 1` Similarly `b^c = 1 and c^a = 0`\\nNow, if we perform XOR of all these equations then it must result in 0. \\n\\n## **Proof** \\n`(a^b) ^ (b^c) ^ (c^a) = (a^a) ^ (b^b) ^ (c^c) = 0`\\nNow, if you observe,` a^b = 1, b^c = 1 and c^a = 0` are the elements of derived array and hence must give **XOR of all elements equal to zero.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool doesValidArrayExist(vector<int>& derived) {\\n        int ans = 0;\\n        for(int i=0; i<derived.size(); i++)\\n            ans ^= derived[i];\\n        return ans==0;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-pairs-with-xor-in-a-range",
        "tags": "cpp",
        "release_time": 1682942883,
        "code": "class Solution {\npublic:\nstruct Node{\n    Node* links[2];\n    int cnt=0;\n    void put(int ind,Node* node)\n    {\n        links[ind]=node;\n    }\n    bool isContains(int ind)\n    {\n        return links[ind]!=NULL;\n    }\n    Node* get(int ind)\n    {\n        return links[ind];\n    }\n    void incCount()\n    {\n        cnt++;\n    }\n    int count()\n    {\n        return cnt;\n    }\n};\nclass Trie\n{\n    public:\n    Node * root;\n      Trie()\n      {\n       root=new Node();\n      }\n      void insert(int num)\n      {\n          Node* node=root;\n          for (int i=14;i>=0;i--)\n          {\n              int bit=((num>>i)&1);\n              if (!node->isContains(bit))\n              {\n                 node->put(bit,new Node());\n              }\n              node=node->get(bit);\n              node->incCount();\n          }\n      }\n      int getCount(Node* root)\n      {\n          if (root==NULL) return 0;\n          return root->count();\n      }\n      int rec(Node* root,int index,int high,int val)\n      {\n          if (root==NULL) return 0;\n           if (index<0) return root->count();\n          int valBit=((val>>index)&1);\n          int highBit=((high>>index)&1);\n          if(valBit==1)\n          {\n            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));\n            else return rec(root->get(1),index-1,high,val);\n          }\n          else\n          {\n             if (highBit==1) return rec(root->get(1),index-1,high,val)+getCount(root->get(0));\n             else return rec(root->get(0),index-1,high,val);\n          }\n      }\n\n};\n    int countPairs(vector<int>& nums, int low, int high) {\n        int ans=0;\n        Trie * trie=new Trie();\n        for (auto & it:nums)\n        {\n           ans+=trie->rec(trie->root,14,high,it);\n           ans-=trie->rec(trie->root,14,low-1,it);\n           trie->insert(it);\n        } \n        return ans;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nstruct Node{\\n    Node* links[2];\\n    int cnt=0;\\n    void put(int ind,Node* node)\\n    {\\n        links[ind]=node;\\n    }\\n    bool isContains(int ind)\\n    {\\n        return links[ind]!=NULL;\\n    }\\n    Node* get(int ind)\\n    {\\n        return links[ind];\\n    }\\n    void incCount()\\n    {\\n        cnt++;\\n    }\\n    int count()\\n    {\\n        return cnt;\\n    }\\n};\\nclass Trie\\n{\\n    public:\\n    Node * root;\\n      Trie()\\n      {\\n       root=new Node();\\n      }\\n      void insert(int num)\\n      {\\n          Node* node=root;\\n          for (int i=14;i>=0;i--)\\n          {\\n              int bit=((num>>i)&1);\\n              if (!node->isContains(bit))\\n              {\\n                 node->put(bit,new Node());\\n              }\\n              node=node->get(bit);\\n              node->incCount();\\n          }\\n      }\\n      int getCount(Node* root)\\n      {\\n          if (root==NULL) return 0;\\n          return root->count();\\n      }\\n      int rec(Node* root,int index,int high,int val)\\n      {\\n          if (root==NULL) return 0;\\n           if (index<0) return root->count();\\n          int valBit=((val>>index)&1);\\n          int highBit=((high>>index)&1);\\n          if(valBit==1)\\n          {\\n            if (highBit==1) return rec(root->get(0),index-1,high,val) + getCount(root->get(1));\\n            else return rec(root->get(1),index-1,high,val);\\n          }\\n          else\\n          {\\n             if (highBit==1) return rec(root->get(1),index-1,high,val)+getCount(root->get(0));\\n             else return rec(root->get(0),index-1,high,val);\\n          }\\n      }\\n\\n};\\n    int countPairs(vector<int>& nums, int low, int high) {\\n        int ans=0;\\n        Trie * trie=new Trie();\\n        for (auto & it:nums)\\n        {\\n           ans+=trie->rec(trie->root,14,high,it);\\n           ans-=trie->rec(trie->root,14,low-1,it);\\n           trie->insert(it);\\n        } \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "most-frequent-even-element",
        "tags": "cpp",
        "release_time": 1673020570,
        "code": "class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        int n = nums.size(),i;\n        map<int , int> freq;\n        for(auto x:nums){\n            freq[x]++;\n        }\n        int evefreq=0,ans=-1;\n        for(auto y:freq){\n            if(y.first%2==0 && y.second> evefreq){\n                ans=y.first;\n                evefreq=y.second;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "valid-anagram",
        "tags": "cpp",
        "release_time": 1679637788,
        "code": "class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.length()!=t.length())\n            return false;\n        vector<int> freq(26, 0);\n        for(int i =0; i<s.length(); i++){\n            freq[s[i]-'a']++;\n            freq[t[i]-'a']--;\n        }\n        for(int i =0; i<freq.size(); i++){\n            if(freq[i]!=0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "# Intuition\\nTo solve this problem we will count occurence of each character in both strings and if they are same then both strings are anagram of each other.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can use vector of length 26 to track the occurences of character. \\nIf the size of both string is different then they can\\'t be anagram of each other, so we are checking this first.We loop through each character in both strings and increment the frequency of the corresponding letter in s and decrement the frequency of the corresponding letter in t.\\nThen we loop through freq array if all the elements are 0, if all the elements are 0 this means the two strings are anagram and if not then these things are not anagram of each othe.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), n is the size of s or t string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t) {\\n        if(s.length()!=t.length())\\n            return false;\\n        vector<int> freq(26, 0);\\n        for(int i =0; i<s.length(); i++){\\n            freq[s[i]-\\'a\\']++;\\n            freq[t[i]-\\'a\\']--;\\n        }\\n        for(int i =0; i<freq.size(); i++){\\n            if(freq[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "mean-of-array-after-removing-some-elements",
        "tags": "cpp",
        "release_time": 1680188219,
        "code": "class Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int i, k;\n        double mean;\n        sort(arr.begin(), arr.end());\n        k = 0.05*arr.size();\n        for(i=0 ; i<k ; i++)\n        {\n            arr.erase(arr.begin()+0);\n            arr.erase(arr.begin()+arr.size()-1);\n        }\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\n        return mean;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double trimMean(vector<int>& arr) {\\n        int i, k;\\n        double mean;\\n        sort(arr.begin(), arr.end());\\n        k = 0.05*arr.size();\\n        for(i=0 ; i<k ; i++)\\n        {\\n            arr.erase(arr.begin()+0);\\n            arr.erase(arr.begin()+arr.size()-1);\\n        }\\n        mean = (double)accumulate(arr.begin(), arr.end(), 0)/arr.size();\\n        return mean;\\n    }\\n};\\n```"
    },
    {
        "slug": "a-number-after-a-double-reversal",
        "tags": "cpp",
        "release_time": 1673071723,
        "code": "class Solution {\npublic:\n    bool isSameAfterReversals(int num) {\n        string ans=to_string(num);\n        reverse(ans.begin(), ans.end());\n        int ab=stoi(ans);\n        string ans2=to_string(ab);\n        reverse(ans2.begin(), ans2.end());\n        int ba=stoi(ans2);\n        if(ba==num) return true;\n        return false;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSameAfterReversals(int num) {\\n        string ans=to_string(num);\\n        reverse(ans.begin(), ans.end());\\n        int ab=stoi(ans);\\n        string ans2=to_string(ab);\\n        reverse(ans2.begin(), ans2.end());\\n        int ba=stoi(ans2);\\n        if(ba==num) return true;\\n        return false;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-nice-pairs-in-an-array",
        "tags": "cpp",
        "release_time": 1677082453,
        "code": "class Solution {\n    int rev(int n) {\n        int a = 0;\n        while(n) a = a * 10 + (n % 10), n /= 10;\n        return a;\n    }\npublic:\n    int countNicePairs(vector<int>& nums) {\n        unordered_map<long long, long long> m;\n        long long ans = 0, mod = 1e9 + 7;\n        for(int i : nums) m[i - rev(i)]++;\n        for(auto i : m) ans = (ans + (i.second * (i.second - 1)) / 2) % mod;\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\n    int rev(int n) {\\n        int a = 0;\\n        while(n) a = a * 10 + (n % 10), n /= 10;\\n        return a;\\n    }\\npublic:\\n    int countNicePairs(vector<int>& nums) {\\n        unordered_map<long long, long long> m;\\n        long long ans = 0, mod = 1e9 + 7;\\n        for(int i : nums) m[i - rev(i)]++;\\n        for(auto i : m) ans = (ans + (i.second * (i.second - 1)) / 2) % mod;\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-minimum-and-maximum-number-of-nodes-between-critical-points",
        "tags": "cpp",
        "release_time": 1692541932,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n      int count=2;\n      vector<int>v;\n      ListNode * temp=head->next;\n      ListNode * prev=head;\n      while(temp->next)\n      {\n          if(temp->val > prev->val && temp->val > temp->next->val)\n          {\n              v.push_back(count);\n          }\n          if(temp->val < prev->val && temp->val < temp->next->val)\n          {\n              v.push_back(count);\n          }\n          count++;\n          prev=temp;\n          temp=temp->next;\n      }\n      if(v.size()<2)\n      {\n          return {-1,-1};\n      }\n    sort(v.begin(), v.end()); // Sort the vector\n\n    int maxDifference = v[v.size() - 1] - v[0];\n    int minDifference = INT_MAX;\n\n    for (int i = 1; i < v.size(); ++i) {\n        int diff = v[i] - v[i - 1];\n        minDifference = min(minDifference, diff);\n    }\n    return {minDifference,maxDifference};\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\\n      int count=2;\\n      vector<int>v;\\n      ListNode * temp=head->next;\\n      ListNode * prev=head;\\n      while(temp->next)\\n      {\\n          if(temp->val > prev->val && temp->val > temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          if(temp->val < prev->val && temp->val < temp->next->val)\\n          {\\n              v.push_back(count);\\n          }\\n          count++;\\n          prev=temp;\\n          temp=temp->next;\\n      }\\n      if(v.size()<2)\\n      {\\n          return {-1,-1};\\n      }\\n    sort(v.begin(), v.end()); // Sort the vector\\n\\n    int maxDifference = v[v.size() - 1] - v[0];\\n    int minDifference = INT_MAX;\\n\\n    for (int i = 1; i < v.size(); ++i) {\\n        int diff = v[i] - v[i - 1];\\n        minDifference = min(minDifference, diff);\\n    }\\n    return {minDifference,maxDifference};\\n    }\\n};\\n```"
    },
    {
        "slug": "count-elements-with-strictly-smaller-and-greater-elements",
        "tags": "cpp",
        "release_time": 1686274970,
        "code": "class Solution {\npublic:\n    int countElements(vector<int>& nums) {\n\n        if(nums.size() == 1 || nums.size() == 2) return 0;\n        int ma = *max_element(nums.begin(),nums.end());\n        int countma = count(nums.begin(),nums.end(),ma);\n        int mi = *min_element(nums.begin(),nums.end());\n        int countmi = count(nums.begin(),nums.end(),mi);\n        int ans = nums.size() - (countma+countmi);\n        if(ans <= 0) return 0;\n        return nums.size() - (countma+countmi);\n        \n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countElements(vector<int>& nums) {\\n\\n        if(nums.size() == 1 || nums.size() == 2) return 0;\\n        int ma = *max_element(nums.begin(),nums.end());\\n        int countma = count(nums.begin(),nums.end(),ma);\\n        int mi = *min_element(nums.begin(),nums.end());\\n        int countmi = count(nums.begin(),nums.end(),mi);\\n        int ans = nums.size() - (countma+countmi);\\n        if(ans <= 0) return 0;\\n        return nums.size() - (countma+countmi);\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "single-number",
        "tags": "cpp",
        "release_time": 1691549090,
        "code": "class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        unordered_map<int,int> mp;\n        for(int i=0;i<nums.size();i++){\n            mp[nums[i]]++;\n        }\n        for(auto m:mp){\n            if(m.second==1){\n                return m.first;\n            }\n        }\n        return -1;\n    }\n};",
        "content": "# Using Map\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        for(auto m:mp){\\n            if(m.second==1){\\n                return m.first;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Using XOR\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++){\\n            res^=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```\\n# Another solutions\\nIf it was given that array is sorted\\n# Iterating over array\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int i=0;\\n        while(i<arr.size()){\\n            if(arr[i]==arr[i+1])i+=2;\\n            else return arr[i];\\n        }\\n    }\\n};\\n```\\n# Binary Search\\nNow we know to optimize from O(N) we can think for O(logN) and first algo comes in mind is Binary Search. But how? and Why?\\n```\\nclass Solution {\\npublic:\\n    int singleNumber(vector<int>& nums) {\\n        int n=arr.size();\\n        // Checking for edge cases\\n        if(n==1 || arr[0]!=arr[1]){\\n            return arr[0];\\n        }\\n        if(arr[n-1]!=arr[n-2]){\\n            return arr[n-1];\\n        }\\n        // Going for Binary search approach\\n        int low=1,high=n-2;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(arr[mid]!=arr[mid-1] && arr[mid]!=arr[mid+1]){\\n                return arr[mid];\\n            }\\n            if((mid%2==1 && arr[mid]==arr[mid-1]) || (mid%2==0 && arr[mid]==arr[mid+1])){// In left half\\n                low=mid+1;\\n            }\\n            else{// In Right half\\n                high=mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "tags": "cpp",
        "release_time": 1687357774,
        "code": "class Solution {\npublic:\n    int fillCups(vector<int>& amount) {\n        priority_queue<int> pq;\n        for(int i=0; i<3; i++){\n            pq.push(amount[i]);\n        }\n        int time=0;\n        while(pq.top() != 0){\n            time += 1;\n            int temp = pq.top()-1;\n            pq.pop();\n            int temp2 = pq.top()-1;\n            pq.pop();\n            pq.push(temp);\n            pq.push(temp2);\n        }\n        return time;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& amount) {\\n        priority_queue<int> pq;\\n        for(int i=0; i<3; i++){\\n            pq.push(amount[i]);\\n        }\\n        int time=0;\\n        while(pq.top() != 0){\\n            time += 1;\\n            int temp = pq.top()-1;\\n            pq.pop();\\n            int temp2 = pq.top()-1;\\n            pq.pop();\\n            pq.push(temp);\\n            pq.push(temp2);\\n        }\\n        return time;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "tags": "cpp",
        "release_time": 1690663903,
        "code": "class Solution {\npublic:\n    int fillCups(vector<int>& am) \n    {\n        priority_queue<int> pq;\n        for(auto i :am)\n        {\n            pq.push(i);\n        }\n        int count=0;\n        while(pq.top()!=0)\n        {\n            int a=pq.top();\n            pq.pop();\n            int b=pq.top();\n            pq.pop();\n            a--;\n            b--;\n            pq.push(a);\n            pq.push(b);\n            count++;\n        }\n        return count;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fillCups(vector<int>& am) \\n    {\\n        priority_queue<int> pq;\\n        for(auto i :am)\\n        {\\n            pq.push(i);\\n        }\\n        int count=0;\\n        while(pq.top()!=0)\\n        {\\n            int a=pq.top();\\n            pq.pop();\\n            int b=pq.top();\\n            pq.pop();\\n            a--;\\n            b--;\\n            pq.push(a);\\n            pq.push(b);\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```"
    },
    {
        "slug": "frequency-tracker",
        "tags": "cpp",
        "release_time": 1683432600,
        "code": "class FrequencyTracker {\npublic:\n    unordered_map<int,int> x,y;\n    void add(int number) {\n        x[number]++;\n        if(x[number]!=1) y[x[number]-1]--;\n        y[x[number]]++;\n    }\n    void deleteOne(int number) {\n        if(x[number]!=0){\n            x[number]--;\n            y[x[number]+1]--;\n            y[x[number]]++;\n        }\n    }\n    bool hasFrequency(int frequency) {\n        if(y[frequency]!=0) return true;\n        return false;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FrequencyTracker {\\npublic:\\n    unordered_map<int,int> x,y;\\n    void add(int number) {\\n        x[number]++;\\n        if(x[number]!=1) y[x[number]-1]--;\\n        y[x[number]]++;\\n    }\\n    void deleteOne(int number) {\\n        if(x[number]!=0){\\n            x[number]--;\\n            y[x[number]+1]--;\\n            y[x[number]]++;\\n        }\\n    }\\n    bool hasFrequency(int frequency) {\\n        if(y[frequency]!=0) return true;\\n        return false;\\n    }\\n};"
    },
    {
        "slug": "closest-prime-numbers-in-range",
        "tags": "cpp",
        "release_time": 1690620210,
        "code": "class Solution {\npublic:\n    vector<int> closestPrimes(int left, int right) {\n        if(left==1)left++;\n        vector<bool> v(right+1,true);\n        for(int i = 2; i <= sqrt(right); i++){\n            if(v[i]){\n                for(int j = i*i; j <= right; j += i){\n                    v[j] = false;\n                }\n            }\n        }\n        int i = left;\n        int j;\n        int a = -1, b = -1, k = INT_MAX;\n        while(i<= right){\n            if(v[i])break;\n            i++;\n        }\n        j = i+1;\n        while(j<=right){\n            if(v[j]){\n                if(j-i<k){\n                    k = j-i;\n                    a = i,b = j;\n                }\n                    i = j;\n            }\n            j++;\n        }\n        return {a,b};\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> closestPrimes(int left, int right) {\\n        if(left==1)left++;\\n        vector<bool> v(right+1,true);\\n        for(int i = 2; i <= sqrt(right); i++){\\n            if(v[i]){\\n                for(int j = i*i; j <= right; j += i){\\n                    v[j] = false;\\n                }\\n            }\\n        }\\n        int i = left;\\n        int j;\\n        int a = -1, b = -1, k = INT_MAX;\\n        while(i<= right){\\n            if(v[i])break;\\n            i++;\\n        }\\n        j = i+1;\\n        while(j<=right){\\n            if(v[j]){\\n                if(j-i<k){\\n                    k = j-i;\\n                    a = i,b = j;\\n                }\\n                    i = j;\\n            }\\n            j++;\\n        }\\n        return {a,b};\\n    }\\n};\\n```"
    },
    {
        "slug": "implement-stack-using-queues",
        "tags": "cpp",
        "release_time": 1691589248,
        "code": "class MyStack {\npublic:\n queue<int> q;\n    MyStack() {\n\n    }\n    \n    void push(int x) {\n        q.push(x);\n        for(int i=0; i<q.size()-1; i++){\n            q.push(q.front());\n            q.pop();\n        }\n    }\n    \n    int pop() {\n       int a= q.front();\n       q.pop();\n       return a;\n           }\n    \n    int top() {\n      return q.front();\n    }\n    \n    bool empty() {\n        return q.empty();\n    }\n};",
        "content": "\\n# Code\\n```\\nclass MyStack {\\npublic:\\n queue<int> q;\\n    MyStack() {\\n\\n    }\\n    \\n    void push(int x) {\\n        q.push(x);\\n        for(int i=0; i<q.size()-1; i++){\\n            q.push(q.front());\\n            q.pop();\\n        }\\n    }\\n    \\n    int pop() {\\n       int a= q.front();\\n       q.pop();\\n       return a;\\n           }\\n    \\n    int top() {\\n      return q.front();\\n    }\\n    \\n    bool empty() {\\n        return q.empty();\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "loud-and-rich",
        "tags": "cpp",
        "release_time": 1662566148,
        "code": "class Solution {\npublic:\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\n        \n        vis[i]=1;\n        for(auto ele:edge[i]){\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\n        }\n        \n        if(i!=parent)\n            ansc[i].push_back(parent);\n    }\n    \n    \n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\n        int n=quiet.size();\n        vector<vector<int>>ansc(n),edge(n);\n        \n        for(auto ele:richer){\n            edge[ele[0]].push_back(ele[1]);\n        }\n        \n        for(int i=0;i<n;i++){\n            vector<int>vis(n);\n            dfs(i,i,edge,vis,ansc);\n        }\n        \n        vector<int>ans(n);\n        for(int i=0;i<n;i++){\n            int mini=quiet[i],a=i;\n            \n            for(auto ele:ansc[i]){\n                if(mini>=quiet[ele]){\n                    a=ele;\n                    mini=quiet[ele];\n                }\n            }\n            \n            ans[i]=a;\n        }\n        \n        return ans;\n    }\n};",
        "content": "**Finding all ansector of given node and than had a check for most quietest anscestor that the current node**\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int parent,vector<vector<int>>&edge,vector<int>&vis,vector<vector<int>>&ansc){\\n        \\n        vis[i]=1;\\n        for(auto ele:edge[i]){\\n            if(!vis[ele])dfs(ele,parent,edge,vis,ansc);\\n        }\\n        \\n        if(i!=parent)\\n            ansc[i].push_back(parent);\\n    }\\n    \\n    \\n    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {\\n        int n=quiet.size();\\n        vector<vector<int>>ansc(n),edge(n);\\n        \\n        for(auto ele:richer){\\n            edge[ele[0]].push_back(ele[1]);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            vector<int>vis(n);\\n            dfs(i,i,edge,vis,ansc);\\n        }\\n        \\n        vector<int>ans(n);\\n        for(int i=0;i<n;i++){\\n            int mini=quiet[i],a=i;\\n            \\n            for(auto ele:ansc[i]){\\n                if(mini>=quiet[ele]){\\n                    a=ele;\\n                    mini=quiet[ele];\\n                }\\n            }\\n            \\n            ans[i]=a;\\n        }\\n        \\n        return ans;\\n    }\\n};"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "tags": "cpp",
        "release_time": 1669626414,
        "code": "class Solution {\npublic:\n    map<int,int>mp1;\n    map<int,int>mp2;\n    vector<vector<int>> findWinners(vector<vector<int>>& matches) {\n        for(int i=0;i<matches.size();i++)\n        {\n            mp1[matches[i][0]]++;\n            mp2[matches[i][1]]++;\n        }\n        vector<vector<int>>ans;\n        vector<int>temp1;\n        for(auto it: mp1)\n        {\n            if(mp2.find(it.first)==mp2.end()) \n            {\n                temp1.push_back(it.first);\n            }\n//if find function finds the value then it return iterator refering to end of map so if it = returns mp2.end() then our value doesn't exist in mp2 and we add it in list 1(temp1).\n        }\n        ans.push_back(temp1);\n        vector<int>temp2;\n        for(auto it: mp2)\n        {\n// players with only single loss\n            if(it.second==1)\n            {\n                temp2.push_back(it.first);\n            }\n        }\n        ans.push_back(temp2);\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to Output the list of Players who lost  0 matches or 1 matches and should\\'ve played atleast 1 match.\\nSo we can use Map to find the number of matches won by particular player and another Map to store the number of matches lost by a player.\\nAnd then iterating through map we can find the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can create 1 map to store the Winners and the number of the matches they won(frequency) and 2 map for players and the matches they lost.\\nFor finding the players who lost 0 matches we can select players from 1st list and look if they are present in the map2 (where losers are stored) then that player can\\'t be included in the list 1 else we include them in the list 1.\\nFor finding the players who lost 1 match we can just look in 2nd Map for players whose frequency is 1(they lost only 1 match) and include that players in list 2.\\nLastly we combine and return both lists.\\nHope you Understand!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O((log(n))^2)**\\n <!--  -->\\nFor iterating in map1 and using find() function both having log(n) complexity.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int>mp1;\\n    map<int,int>mp2;\\n    vector<vector<int>> findWinners(vector<vector<int>>& matches) {\\n        for(int i=0;i<matches.size();i++)\\n        {\\n            mp1[matches[i][0]]++;\\n            mp2[matches[i][1]]++;\\n        }\\n        vector<vector<int>>ans;\\n        vector<int>temp1;\\n        for(auto it: mp1)\\n        {\\n            if(mp2.find(it.first)==mp2.end()) \\n            {\\n                temp1.push_back(it.first);\\n            }\\n//if find function finds the value then it return iterator refering to end of map so if it = returns mp2.end() then our value doesn\\'t exist in mp2 and we add it in list 1(temp1).\\n        }\\n        ans.push_back(temp1);\\n        vector<int>temp2;\\n        for(auto it: mp2)\\n        {\\n// players with only single loss\\n            if(it.second==1)\\n            {\\n                temp2.push_back(it.first);\\n            }\\n        }\\n        ans.push_back(temp2);\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "01-matrix",
        "tags": "cpp",
        "release_time": 1692260053,
        "code": "class Solution {\npublic:\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\n        int n=mat.size();\n        int m=mat[0].size();\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\n        //normal case so will go for top and left only\n        for (int i=0;i<n;i++){\n            for (int j=0;j<m;j++){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\n                }\n            }\n        }\n\n        //reverse \n             for (int i=n-1;i>=0;i--){\n            for (int j=m-1;j>=0;j--){\n                if (mat[i][j]==0) dp[i][j]=0;\n                else {\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\n                }\n            }\n        }\n        return dp;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a 2D vector `dp` of the same size as the input matrix `mat`, where each cell initially has a value of `INT_MAX - 2`.\\n2. Traverse the matrix from top-left to bottom-right:\\n   - If the current cell contains 0, set `dp[i][j]` to 0.\\n   - Otherwise, update `dp[i][j]` with the minimum of its current value and the values from its top and left neighbors, incremented by 1.\\n3. Traverse the matrix in reverse, from bottom-right to top-left:\\n   - Update `dp[i][j]` with the minimum of its current value and the values from its bottom and right neighbors, incremented by 1.\\n4. Return the updated `dp` matrix.\\n\\n**Additional Point:**\\n- The reason for using `INT_MAX - 2` is to avoid integer overflow when adding 1 to `INT_MAX`. By subtracting 2, we ensure that the addition won\\'t exceed the maximum value representable by an `int`. This is a common technique to handle situations where adding a small number to `INT_MAX` might cause unexpected behavior due to overflow.\\n![image.png](https://assets.leetcode.com/users/images/768d89e8-9abb-4604-8189-48ab7753f33f_1692259793.882623.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n * m) \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> updateMatrix(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<vector<int>>dp(n,vector<int>(m,INT_MAX-2));\\n        //normal case so will go for top and left only\\n        for (int i=0;i<n;i++){\\n            for (int j=0;j<m;j++){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i>0) dp[i][j]= min (dp[i][j], dp[i-1][j]+1); //top\\n                    if (j>0) dp[i][j]=min (dp[i][j],dp[i][j-1]+1); //left\\n                }\\n            }\\n        }\\n\\n        //reverse \\n             for (int i=n-1;i>=0;i--){\\n            for (int j=m-1;j>=0;j--){\\n                if (mat[i][j]==0) dp[i][j]=0;\\n                else {\\n                    if (i<n-1) dp[i][j]= min (dp[i][j], dp[i+1][j]+1); //bottom\\n                    if (j<m-1) dp[i][j]=min (dp[i][j],dp[i][j+1]+1); //right\\n                }\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```\\n\\nupvote plz \\uD83D\\uDE4F\\uD83C\\uDFFE\\u2B06\\uFE0F\\n"
    },
    {
        "slug": "smallest-even-multiple",
        "tags": "cpp",
        "release_time": 1671525279,
        "code": "class Solution {\npublic:\n    int smallestEvenMultiple(int n) {       \n        if(n%2==0) //If n is even return as it is\n          return n;\n        else\n        return n*2;//If n is odd return n * 2\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int smallestEvenMultiple(int n) {       \\n        if(n%2==0) //If n is even return as it is\\n          return n;\\n        else\\n        return n*2;//If n is odd return n * 2\\n    }\\n};\\n```"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "tags": "cpp",
        "release_time": 1686192488,
        "code": "class Solution {\npublic:\n    int binaryS(vector<int>& v, int sz) {\n        int l=0, r=sz, mid;\n        while(l<r){\n            mid=l+(r-l)/2;\n            if(v[mid]<0) r=mid;\n            else l=mid+1;\n        }\n        return r;  // Returns the index\n        // The binaryS function is used to find the index where \n        // negative numbers start in a sorted vector.\n        // It performs a binary search to locate the first \n        // occurrence of a negative number.\n        //////////////////////////////////////\n        // C++ STL upper_bound\n        //  return upper_bound(v.begin(),v.end(),0,greater<int>())\n        //    -v.begin(); \n    }\n\n    int countNegatives(vector<vector<int>>& grid) {\n        int n=grid.size();\n        int m=grid[0].size();\n        int sum=0;\n\n        // Using binaryS to find the number i_max\n        vector<int> col0(n);\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\n        int i_max=binaryS(col0, n);\n        // The binaryS function is called to find the number of\n        // negative numbers in the first column of the grid.\n        // It returns the index where the negative numbers start,\n        // which represents the number of negative numbers in \n        // that column.\n\n        for (int i=0; i<i_max; i++){\n            sum+= m-binaryS(grid[i], m);\n        }\n        // Iterate through the rows up to i_max.\n        // For each row, binaryS is called to find the number of\n        // negative numbers in that row.\n        // Subtracting this count from m gives the number of\n        // non-negative numbers in the row.\n        // The result is added to the sum.\n\n        sum+=(n-i_max)*m;\n        // Add the number of non-negative numbers in the remaining\n        // rows (n-i_max) to the sum.\n        // Since all elements in these rows are non-negative, the \n        //count is simply m (the number of columns).\n\n        return sum;  // Return the total count of negative numbers\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nC++ solution using binary search to find  the least upper bound i_max for the column vector grid[i][0] first.\\n\\nThen using a for-loop to sum up the values for m-binarS(grid[i]) where i<i_max\\n\\nFinally,  add the number (n-i_max)*m to the desired variable sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binaryS(vector<int>& v, int sz) {\\n        int l=0, r=sz, mid;\\n        while(l<r){\\n            mid=l+(r-l)/2;\\n            if(v[mid]<0) r=mid;\\n            else l=mid+1;\\n        }\\n        return r;  // Returns the index\\n        // The binaryS function is used to find the index where \\n        // negative numbers start in a sorted vector.\\n        // It performs a binary search to locate the first \\n        // occurrence of a negative number.\\n        //////////////////////////////////////\\n        // C++ STL upper_bound\\n        //  return upper_bound(v.begin(),v.end(),0,greater<int>())\\n        //    -v.begin(); \\n    }\\n\\n    int countNegatives(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int sum=0;\\n\\n        // Using binaryS to find the number i_max\\n        vector<int> col0(n);\\n        for(int i=0; i<n; i++) col0[i]=grid[i][0];\\n        int i_max=binaryS(col0, n);\\n        // The binaryS function is called to find the number of\\n        // negative numbers in the first column of the grid.\\n        // It returns the index where the negative numbers start,\\n        // which represents the number of negative numbers in \\n        // that column.\\n\\n        for (int i=0; i<i_max; i++){\\n            sum+= m-binaryS(grid[i], m);\\n        }\\n        // Iterate through the rows up to i_max.\\n        // For each row, binaryS is called to find the number of\\n        // negative numbers in that row.\\n        // Subtracting this count from m gives the number of\\n        // non-negative numbers in the row.\\n        // The result is added to the sum.\\n\\n        sum+=(n-i_max)*m;\\n        // Add the number of non-negative numbers in the remaining\\n        // rows (n-i_max) to the sum.\\n        // Since all elements in these rows are non-negative, the \\n        //count is simply m (the number of columns).\\n\\n        return sum;  // Return the total count of negative numbers\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "tags": "cpp",
        "release_time": 1685857914,
        "code": "class Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        queue<int> q;\n        for(int i=1;i<=n;i++){\n            q.push(i);\n        }\n        while(q.size()!=1){\n            int temp=k-1;\n            while(temp>0){\n                int t=q.front();\n                q.pop();\n                q.push(t);\n                temp--;\n            }\n            q.pop();\n        }\n        return q.front();\n    }\n};",
        "content": "# Intuition\\nEliminate a person after every k turns until a single person is left.\\nn and k have really small values. Simply simulate the process.\\n\\n# Approach\\n- Create a queue which initially contains numbers from 1 to n.\\n- For k-1 times, shift the first element of the queue to the end of the queue and pop the element from queue at the kth turn.\\n- Do above step until queue have only 1 element left which is the required answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findTheWinner(int n, int k) {\\n        queue<int> q;\\n        for(int i=1;i<=n;i++){\\n            q.push(i);\\n        }\\n        while(q.size()!=1){\\n            int temp=k-1;\\n            while(temp>0){\\n                int t=q.front();\\n                q.pop();\\n                q.push(t);\\n                temp--;\\n            }\\n            q.pop();\\n        }\\n        return q.front();\\n    }\\n};\\n```\\n**Please upvote if it helped. Happy Coding!**"
    },
    {
        "slug": "find-the-student-that-will-replace-the-chalk",
        "tags": "cpp",
        "release_time": 1688143072,
        "code": "class Solution {\npublic:\n    int chalkReplacer(vector<int>& chalk, int k) {\n       long long sum =0;\n       for(int i=0; i<chalk.size();i++){\n           sum+=chalk[i];\n       }\n\n       \n\n       if(k%sum !=0){\n           int x = k%sum;\n           for(int i=0; i<chalk.size();i++){\n               x-=chalk[i];\n               if(x<0){\n                   return i;\n                   break;\n               }\n           }\n       }\n\n       return 0;\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int chalkReplacer(vector<int>& chalk, int k) {\\n       long long sum =0;\\n       for(int i=0; i<chalk.size();i++){\\n           sum+=chalk[i];\\n       }\\n\\n       \\n\\n       if(k%sum !=0){\\n           int x = k%sum;\\n           for(int i=0; i<chalk.size();i++){\\n               x-=chalk[i];\\n               if(x<0){\\n                   return i;\\n                   break;\\n               }\\n           }\\n       }\\n\\n       return 0;\\n    }\\n};\\n```"
    },
    {
        "slug": "gray-code",
        "tags": "cpp",
        "release_time": 1688835462,
        "code": "class Solution {\npublic:\n    vector<int> grayCode(int n) {\n        vector<int> res;\n        res.push_back( 0 );\n        for( int k = 0; k<n; k++ ) {\n            int i = res.size(), t = (1<<k) ;\n            while( i ) {\n                int temp = res[--i] | t;\n                res.push_back( temp );\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> grayCode(int n) {\\n        vector<int> res;\\n        res.push_back( 0 );\\n        for( int k = 0; k<n; k++ ) {\\n            int i = res.size(), t = (1<<k) ;\\n            while( i ) {\\n                int temp = res[--i] | t;\\n                res.push_back( temp );\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-ideal-subsequence",
        "tags": "cpp",
        "release_time": 1665172616,
        "code": "class Solution {\n\n\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\n   {\n       if(index == s.length())\n       return 0;\n\n       if(dp[index][prev] != -1)\n       return dp[index][prev];\n\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\n\n       int op2 = 0 ;\n\n       if(prev == 26)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n       else if(abs(s[index]-'a' - prev) <= k)\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-'a' , dp);\n\n       return dp[index][prev] = max(op1 , op2);\n   }\n\n   int SolveByTab(string &s , int &k )\n   {\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + dp[index+1][prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + dp[index+1][s[index]-'a'];\n\n               dp[index][prev] = max(op1 , op2);\n            }\n        }\n\n       return max(dp[0][s[0]-'a'] , dp[0][26]);\n   }\n\n   int SolveByTabSpaceOptimised(string &s , int &k )\n   {\n        vector<int> next(27, 0) ;\n        vector<int> curr(27, 0);\n       \n        for(int index = s.length()-1 ; index>=0 ; index--)\n        {\n            for(int prev = 0 ; prev<= 26 ; prev++)\n            {\n                int op1 = 0 + next[prev];\n                int op2 = 0 ;\n\n               if(prev == 26)\n               op2 = 1 + next[s[index]-'a'];\n               else if(abs(s[index]-'a' - prev) <= k)\n               op2 = 1 + next[s[index]-'a'];\n\n               curr[prev] = max(op1 , op2);\n            }\n            next = curr;\n        }\n\n       return max(curr[s[0]-'a'] , curr[26]);\n   }\n\npublic:\n    int longestIdealString(string s, int k) {\n        \n        // 1. Recursion + Memoization || Top Down Approach\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\n        // return SolveByMemo(s, k , 0 , 26, dp);\n\n        // 2. Tabulation Method || Bottom Up Approach\n        // return SolveByTab(s, k);\n\n        // 3. Space Optimisation using Tabulation\n        return SolveByTabSpaceOptimised(s , k);\n    }\n};",
        "content": "\\n# Approach\\nWe Have Use Three Different Approaches :\\n1. Recursion + Memoization \\n    TC : O(n^2) , SC : O(n)\\n2. Tabulation Method \\n    TC : O(n^2) , SC : O(n)\\n3.  Tabulatuon With SOace Optimised\\n    TC : O(n^2) , SC : O(1) \\n\\n\\n#Note\\nSC In first two methods is On) and not O(n^2) as size is fixed to 27 for each index hence it is Linear Space ,Similarly for 3rd Method we have optimised to constant space as at any instant we onlt need memory of next 27 blocks  only.\\n\\n#Hope You Liekd It and Upvote are appreciated \\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n   int SolveByMemo(string &s , int &k , int index , int prev , vector<vector<int>> &dp)\\n   {\\n       if(index == s.length())\\n       return 0;\\n\\n       if(dp[index][prev] != -1)\\n       return dp[index][prev];\\n\\n       int op1 = 0 + SolveByMemo(s, k , index+1 , prev , dp);\\n\\n       int op2 = 0 ;\\n\\n       if(prev == 26)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n       else if(abs(s[index]-\\'a\\' - prev) <= k)\\n       op2 = 1 + SolveByMemo(s, k , index+1 , s[index]-\\'a\\' , dp);\\n\\n       return dp[index][prev] = max(op1 , op2);\\n   }\\n\\n   int SolveByTab(string &s , int &k )\\n   {\\n        vector<vector<int>> dp(s.length()+1 , vector<int> (27, 0));\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + dp[index+1][prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + dp[index+1][s[index]-\\'a\\'];\\n\\n               dp[index][prev] = max(op1 , op2);\\n            }\\n        }\\n\\n       return max(dp[0][s[0]-\\'a\\'] , dp[0][26]);\\n   }\\n\\n   int SolveByTabSpaceOptimised(string &s , int &k )\\n   {\\n        vector<int> next(27, 0) ;\\n        vector<int> curr(27, 0);\\n       \\n        for(int index = s.length()-1 ; index>=0 ; index--)\\n        {\\n            for(int prev = 0 ; prev<= 26 ; prev++)\\n            {\\n                int op1 = 0 + next[prev];\\n                int op2 = 0 ;\\n\\n               if(prev == 26)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n               else if(abs(s[index]-\\'a\\' - prev) <= k)\\n               op2 = 1 + next[s[index]-\\'a\\'];\\n\\n               curr[prev] = max(op1 , op2);\\n            }\\n            next = curr;\\n        }\\n\\n       return max(curr[s[0]-\\'a\\'] , curr[26]);\\n   }\\n\\npublic:\\n    int longestIdealString(string s, int k) {\\n        \\n        // 1. Recursion + Memoization || Top Down Approach\\n        // vector<vector<int>> dp(s.length() , vector<int> (27, -1));\\n        // return SolveByMemo(s, k , 0 , 26, dp);\\n\\n        // 2. Tabulation Method || Bottom Up Approach\\n        // return SolveByTab(s, k);\\n\\n        // 3. Space Optimisation using Tabulation\\n        return SolveByTabSpaceOptimised(s , k);\\n    }\\n};\\n```"
    },
    {
        "slug": "search-in-a-binary-search-tree",
        "tags": "cpp",
        "release_time": 1687002048,
        "code": "class Solution {\npublic:\n    TreeNode* searchBST(TreeNode* root, int val) {\n        while(root!=NULL && root->val!=val){\n            if(val<root->val) root=root->left;\n            else root=root->right;\n        }\n        return root;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        while(root!=NULL && root->val!=val){\\n            if(val<root->val) root=root->left;\\n            else root=root->right;\\n        }\\n        return root;\\n    }\\n};\\n```"
    },
    {
        "slug": "factorial-trailing-zeroes",
        "tags": "cpp",
        "release_time": 1682961619,
        "code": "class Solution {\npublic:\n    unordered_map<long long int,long long int>mp;\n    int trailingZeroes(int n) {\n        for(int i=n;i>=1;i--)\n         fun(i);\n         \n\t\t return min(mp[2],mp[5]); \n    }\n     void fun(int n)\n    {\n         for(int i=2;i*i<=n;i++)\n         {\n         \twhile((n%i) == 0)\n         \t{\n         \t    mp[i]++;\n\t\t\t\tn = n / i;\t\n\t\t\t}\n\t\t }\n\t\t if(n > 1)\n\t\t mp[n]++;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<long long int,long long int>mp;\\n    int trailingZeroes(int n) {\\n        for(int i=n;i>=1;i--)\\n         fun(i);\\n         \\n\\t\\t return min(mp[2],mp[5]); \\n    }\\n     void fun(int n)\\n    {\\n         for(int i=2;i*i<=n;i++)\\n         {\\n         \\twhile((n%i) == 0)\\n         \\t{\\n         \\t    mp[i]++;\\n\\t\\t\\t\\tn = n / i;\\t\\n\\t\\t\\t}\\n\\t\\t }\\n\\t\\t if(n > 1)\\n\\t\\t mp[n]++;\\n    }\\n};\\n```"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-iv",
        "tags": "cpp",
        "release_time": 1690201964,
        "code": "class Solution {\npublic:\n\nint solvetab(vector<int>& prices,int k )\n{\n    int n = prices.size();\n    vector<int>curr(2*k+1);\n    vector<int>next(2*k+1);\n\n\n    for(int index=n-1;index>=0;index--)\n    {\n        for(int op=0;op<2*k;op++)\n        {\n            int profit=0;\n            if(op%2==0)\n            {\n                profit=max(-prices[index]+next[op+1] , 0 + next[op]); \n            }\n            else\n            {\n                profit=max(prices[index]+ next[op+1], 0 + next[op]); \n            }\n            curr[op]=profit;\n            }\n            next=curr;\n        \n\n    }\n    return next[0];\n}\n\n    int maxProfit(int k, vector<int>& prices) {\n        return solvetab(prices,k);\n    }\n};",
        "content": "# **PLS UPVOTE IF YOU LIKE MY SOLUTION AND FEEL FREE TO COMMENT YOUR PROBLEM IN COMMENTS**\\n\\n# SPACE OPTIMIZED SOLUTION \\n# Approach\\nThe function solvetab takes the prices vector and an integer k (maximum allowed transactions) as input.\\n\\nInitialize two 1D vectors curr and next, each with a size of 2*k+1. These vectors will be used to store the maximum profit for different scenarios. curr[op] represents the maximum profit at the current day with op indicating the number of operations (buy and sell transactions) performed so far.\\n\\nThe outer loop runs from n-1 to 0, iterating backward through the prices array. This helps us build the curr and next vectors from the last day to the first day.\\n\\nWithin the outer loop, there is a nested loop that runs from 0 to 2*k-1. This loop handles all possible scenarios for the number of operations performed at each day (both buying and selling).\\n\\nFor each index (current day) and op (number of operations), calculate the maximum profit for the current day and operation scenario:\\n\\nIf op is even, it means a buying operation is allowed, so we consider two options:\\na. Perform the buying operation on the current day and move to the next operation (op+1), considering the profit obtained by subtracting the stock price from the result of the next day\\'s calculation with the same number of allowed transactions (next[op+1]).\\nb. Skip the buying operation and move to the next operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions (next[op]).\\nIf op is odd, it means a selling operation is allowed, so we consider two options:\\na. Perform the selling operation on the current day and move to the next operation (op+1), considering the profit obtained by adding the stock price to the result of the next day\\'s calculation with the same number of allowed transactions (next[op+1]).\\nb. Skip the selling operation and move to the next operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions (next[op]).\\nUpdate the curr[op] value with the calculated maximum profit for the current index and op.\\n\\nAfter filling the curr vector for the current day, copy its values to the next vector. This is done to update the values for the next day in the next iteration.\\n\\nOnce the loops are completed, the answer will be stored in next[0], which represents the maximum profit achievable with at most k transactions on the given array of stock prices.\\n\\nReturn next[0] as the maximum profit.\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<int>curr(2*k+1);\\n    vector<int>next(2*k+1);\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int op=0;op<2*k;op++)\\n        {\\n            int profit=0;\\n            if(op%2==0)\\n            {\\n                profit=max(-prices[index]+next[op+1] , 0 + next[op]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[op+1], 0 + next[op]); \\n            }\\n            curr[op]=profit;\\n            }\\n            next=curr;\\n        \\n\\n    }\\n    return next[0];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# TOP DOWN APPROACH\\n# Approach\\nThe function solve is a recursive function that takes the prices vector, the maximum allowed transactions k, the current index representing the current day, the number of operations (op) performed so far, and the memoization table dp as inputs.\\n\\nThe function handles two base cases:\\n\\nIf the current index goes beyond the size of the prices array or the number of operations op exceeds 2 * k, we return 0, as we cannot perform any more transactions.\\nIf the result for the current index and op is already present in the dp table, we return the precomputed value to avoid redundant calculations.\\nWithin the function, we calculate the maximum profit for the current day and operation scenario.\\n\\nIf op is even, it means a buying operation is allowed, so we consider two options:\\na. Perform the buying operation on the current day and move to the next day with the next operation (op+1), considering the profit obtained by subtracting the stock price from the result of the next day\\'s calculation with the same number of allowed transactions.\\nb. Skip the buying operation and move to the next day with the same operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions.\\nIf op is odd, it means a selling operation is allowed, so we consider two options:\\na. Perform the selling operation on the current day and move to the next day with the next operation (op+1), considering the profit obtained by adding the stock price to the result of the next day\\'s calculation with the same number of allowed transactions.\\nb. Skip the selling operation and move to the next day with the same operation (op), considering the profit obtained from the next day\\'s calculation with the same number of allowed transactions.\\nUpdate the dp table with the calculated maximum profit for the current index and op.\\n\\nReturn the calculated maximum profit for the current index and op.\\n\\nIn the maxProfit function, we initialize the memoization table dp of size n+1 (where n is the size of the prices vector) and 2 * k + 1 (to account for 2 * k possible operations, both buying and selling).\\n\\nCall the solve function with the starting parameters: prices, k, index=0, op=0, and the dp table.\\n\\nReturn the result obtained from the solve function as the maximum profit that can be obtained with at most k transactions on the given array of stock prices.\\n\\n\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solve(vector<int>& prices,int k ,int index,int op,vector<vector<int>>&dp)\\n{\\n    if(index>=prices.size())\\n    return 0;\\n\\n    if(op==k*2)\\n    return 0;\\n    \\n    int profit=0;\\n    \\n    if(dp[index][op]!=-1)\\n    return dp[index][op];\\n    \\n    if(op%2==0)\\n    // BUY ALLOWED\\n    {\\n        profit = max(-prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n    }\\n    else\\n    {\\n        profit = max(prices[index] + solve(prices, k, index + 1,op+1,dp ), 0 + solve(prices, k, index + 1, op,dp));\\n\\n    }\\n    return dp[index][op]=profit;\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        int n= prices.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(2*k,-1));\\n        return solve(prices,k,0,0,dp);\\n    }\\n};\\n```\\n# BOTTOM UP APPROACH\\n# Approach\\nThe function solvetab takes the prices vector and an integer k as input, representing the maximum number of allowed transactions.\\n\\nInitialize two 2D vectors curr and next, each with dimensions [2][k+1]. These vectors will be used to store the maximum profit for different scenarios. curr[buy][limit] represents the maximum profit at the current day with buy indicating whether the stock is bought (0 for not bought, 1 for bought), and limit representing the remaining transactions allowed (ranging from 0 to k).\\n\\nThe outer loop runs from n-1 to 0, iterating backward through the prices array. This helps us build the curr and next vectors from the last day to the first day.\\n\\nWithin the outer loop, there are two nested loops for buy and limit, each ranging from 0 to 1 and 1 to k, respectively. These loops handle all possible scenarios for buying or not buying the stock on each day and the number of remaining transactions.\\n\\nFor each combination of index, buy, and limit, calculate the maximum profit:\\n\\nIf buy is 1 (meaning the stock is bought on the current day), the profit is the maximum of two possibilities:\\na. The profit obtained by buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: -prices[index] + next[0][limit].\\nb. The profit obtained by not buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: 0 + next[1][limit].\\nIf buy is 0 (meaning the stock is not bought on the current day), the profit is the maximum of two possibilities:\\na. The profit obtained by not buying the stock on the current day and adding the profit from the next day with limit+1 transactions remaining: prices[index] + next[1][limit - 1].\\nb. The profit obtained by not buying the stock on the current day and adding the profit from the next day with the same number of remaining transactions: 0 + next[0][limit].\\nUpdate the curr[buy][limit] value with the calculated maximum profit.\\n\\nAfter filling the curr vector for the current day, copy its values to the next vector. This is done to update the values for the next day in the next iteration.\\n\\nOnce the loops are completed, the answer will be stored in next[1][k], where 1 indicates the stock is bought, and k represents the remaining transactions allowed.\\n\\nReturn next[1][k] as the maximum profit achievable with at most k transactions on the given array of stock prices.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint solvetab(vector<int>& prices,int k )\\n{\\n    int n = prices.size();\\n    vector<vector<int>>curr(2,vector<int>(k+1,0));\\n    vector<vector<int>>next(2,vector<int>(k+1,0));\\n\\n\\n    for(int index=n-1;index>=0;index--)\\n    {\\n        for(int buy=0;buy<=1;buy++)\\n        {\\n            for(int limit=1;limit<=k;limit++)\\n            {\\n                int profit=0;\\n            if(buy==1)\\n            {\\n                profit=max(-prices[index]+next[0][limit] , 0 + next[1][limit]); \\n            }\\n            else\\n            {\\n                profit=max(prices[index]+ next[1][limit-1], 0 + next[0][limit]); \\n            }\\n            curr[buy][limit]=profit;\\n            }\\n            next=curr;\\n        }\\n\\n    }\\n    return next[1][k];\\n}\\n\\n    int maxProfit(int k, vector<int>& prices) {\\n        return solvetab(prices,k);\\n    }\\n};\\n```"
    },
    {
        "slug": "number-of-provinces",
        "tags": "cpp",
        "release_time": 1685863266,
        "code": "class Solution {\n    int res,c = 0,n,vis[201]={0};\n    void dfs(vector<vector<int>>& isConnected,int start)\n    {\n        vis[start] = true;c++;\n        for(int connection = 0;connection<n;connection++)\n        {\n            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);\n        }\n    }\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected)\n     {\n        n = isConnected.size();\n        for(int i = 0;i<n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;\n        return res;   \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int res,c = 0,n,vis[201]={0};\\n    void dfs(vector<vector<int>>& isConnected,int start)\\n    {\\n        vis[start] = true;c++;\\n        for(int connection = 0;connection<n;connection++)\\n        {\\n            if(!vis[connection] and isConnected[start][connection]) dfs(isConnected,connection);\\n        }\\n    }\\npublic:\\n    int findCircleNum(vector<vector<int>>& isConnected)\\n     {\\n        n = isConnected.size();\\n        for(int i = 0;i<n;i++) if(!vis[i]) c=0,dfs(isConnected,i),res++;;\\n        return res;   \\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "tags": "cpp",
        "release_time": 1674370423,
        "code": "class Solution {\npublic:\n    int minCost(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> dp(n,INT_MAX);\n        dp[0]=k;\n        unordered_map<int,int> freq;\n\n        for(int i=1;i<n;i++)\n        {\n            int val=0;\n            freq.clear();\n            for(int j=i;j>=0;j--)\n            {\n                freq[nums[j]]++;\n                if(freq[nums[j]]==2)\n                val+=2;\n                else if(freq[nums[j]]>2) \n                val++;\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\n            }\n        }\n        return dp[n-1];\n    }\n};",
        "content": "# Intuition and Approach\\nhttps://youtu.be/RkgKv39A0zk\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minCost(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> dp(n,INT_MAX);\\n        dp[0]=k;\\n        unordered_map<int,int> freq;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int val=0;\\n            freq.clear();\\n            for(int j=i;j>=0;j--)\\n            {\\n                freq[nums[j]]++;\\n                if(freq[nums[j]]==2)\\n                val+=2;\\n                else if(freq[nums[j]]>2) \\n                val++;\\n                dp[i]=min(dp[i],(j>0?dp[j-1]:0)+k+val);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```"
    },
    {
        "slug": "rotate-array",
        "tags": "cpp",
        "release_time": 1681732437,
        "code": "class Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        int n=nums.size();\n        vector<int> temp(nums.size());\n        for(int i=0;i<n;i++){\n            temp[(i+k)%n]=nums[i];\n        }\n        nums=temp;\n    }\n};",
        "content": "# Approach\\nhere i is of loop which starts form (0,1,2...) k is the value how many times you want to rotate and n is the size of first vector ,and after that new indexes will be generated in our temp vector and we have to put values of nums vector at new indexes . . . \\nlike for first  arr[1,2,3,4,5,6,7]  and k=3     so ,\\ntemp[0 + 3 % 7]=nums[i]\\ntemp[3 % 7]=nums[i]\\ntemp[3] = nums[i]\\n[_ , _ , _ , 1 , _ ,_ , _ ]\\nfor next ,\\ntemp[1 + 3 % 7]=nums[i]\\ntemp[4 % 7]=nums[i]\\ntemp[4] = nums[i]\\n[_ , _ , _ , 1 , 2 ,_ , _ ]   and so on \\ni hope you understand ..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void rotate(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int> temp(nums.size());\\n        for(int i=0;i<n;i++){\\n            temp[(i+k)%n]=nums[i];\\n        }\\n        nums=temp;\\n    }\\n};\\n```\\n![upvote 1.jpeg](https://assets.leetcode.com/users/images/565d5fa5-1370-44d9-a6b6-0cf06d575aae_1681731352.2608747.jpeg)\\n"
    },
    {
        "slug": "brace-expansion-ii",
        "tags": "cpp",
        "release_time": 1677655008,
        "code": "class Solution {\npublic:\n    \n    vector<string> multiply(vector<string>& a, vector<string>& b){\n        if(a.empty()) return b;\n        if(b.empty()) return a;\n        vector<string> ans;\n        for(auto&i:a){\n            for(auto&j:b) ans.push_back(i+j);\n        }\n        return ans;\n    }\n    \n    vector<string> braceExpansionII(string expression) {\n        vector<string>  res, curr;\n        stack<vector<string>> st;\n        for(auto&x:expression){\n            if(x >= 'a' and x <= 'z'){\n                if(curr.size()) for(auto&i:curr) i += x;\n                else curr.push_back(string(1, x));\n            }\n            else if(x == '{'){\n                st.push(res); st.push(curr);\n                res.clear(), curr.clear();\n            }\n            else if(x == '}'){\n                vector<string> preCurr = st.top(); st.pop();\n                vector<string> preRes = st.top(); st.pop();\n                for(auto&i:curr) res.push_back(i);\n                curr = multiply(preCurr, res);\n                res = preRes;\n            }\n            else if(x == ','){\n                for(auto&i:curr) res.push_back(i);\n                curr.clear();\n            }\n        }\n        for(auto&i:curr) res.push_back(i);\n        sort(res.begin(), res.end());\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\n    }\n};",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse stack to keep track of previous two lists\\n<!-- Describe your approach to solving the problem. -->\\n<!-- \\n# Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> multiply(vector<string>& a, vector<string>& b){\\n        if(a.empty()) return b;\\n        if(b.empty()) return a;\\n        vector<string> ans;\\n        for(auto&i:a){\\n            for(auto&j:b) ans.push_back(i+j);\\n        }\\n        return ans;\\n    }\\n    \\n    vector<string> braceExpansionII(string expression) {\\n        vector<string>  res, curr;\\n        stack<vector<string>> st;\\n        for(auto&x:expression){\\n            if(x >= \\'a\\' and x <= \\'z\\'){\\n                if(curr.size()) for(auto&i:curr) i += x;\\n                else curr.push_back(string(1, x));\\n            }\\n            else if(x == \\'{\\'){\\n                st.push(res); st.push(curr);\\n                res.clear(), curr.clear();\\n            }\\n            else if(x == \\'}\\'){\\n                vector<string> preCurr = st.top(); st.pop();\\n                vector<string> preRes = st.top(); st.pop();\\n                for(auto&i:curr) res.push_back(i);\\n                curr = multiply(preCurr, res);\\n                res = preRes;\\n            }\\n            else if(x == \\',\\'){\\n                for(auto&i:curr) res.push_back(i);\\n                curr.clear();\\n            }\\n        }\\n        for(auto&i:curr) res.push_back(i);\\n        sort(res.begin(), res.end());\\n        return vector<string>(res.begin(), unique(res.begin(), res.end()));\\n    }\\n};\\n```"
    },
    {
        "slug": "array-partition",
        "tags": "cpp",
        "release_time": 1683568397,
        "code": "class Solution {\npublic:\n    int arrayPairSum(vector<int>& nums) {\n        sort(nums.begin(),nums.end());\n        int sum=0;\n        for(int i=0;i<nums.size();i+=2)\n            sum+=nums[i];\n        return sum;\n    }\n};",
        "content": "# Intuition\\n  To maximise sum, ***try to group larger number together***-the only way   to do so is by sorting.\\n# Approach\\n 1. Sort the given vector.\\n\\n 2. Sum first number i.e min from a pair - to do so *increment counter by 2*, by doing so you will always lend into smallest number of a pair \\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrayPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        for(int i=0;i<nums.size();i+=2)\\n            sum+=nums[i];\\n        return sum;\\n    }\\n};\\n```"
    },
    {
        "slug": "search-insert-position",
        "tags": "cpp",
        "release_time": 1676910439,
        "code": "class Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        int l=0;\n        int r=nums.size()-1;\n        int m;\n        while(l<=r){\n            m=(l+r)/2;\n            if(nums[m]==target){\n                return m;\n            }else if(nums[m]>target){\n                r=m-1;\n            }\n            else{\n                l=m+1;\n            }\n        }\n        return l;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(log(n)) -> Binary Search\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int searchInsert(vector<int>& nums, int target) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        int m;\\n        while(l<=r){\\n            m=(l+r)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }else if(nums[m]>target){\\n                r=m-1;\\n            }\\n            else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```"
    },
    {
        "slug": "middle-of-the-linked-list",
        "tags": "cpp",
        "release_time": 1687519093,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* temp = head;\n        ListNode* mid = head;\n        while(temp != NULL && temp -> next != NULL){\n            mid = mid -> next;\n            temp = temp->next-> next;\n        }\n        return mid;\n    }\n};",
        "content": "## INITIALIZE BOTH POINTS FROM HEAD AND THEN TRAVERSE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# FIRST POINT SHOULD TRAVERSE AT A NORMAL PACE\\n# BUT THE OTHER POINTER (ie. FAST) SHOULD SKIP ONE NODE AND THUS YOU WILL REACH THE SOLUTION IN O(n) TIME COMPLEXITY.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* middleNode(ListNode* head) {\\n        ListNode* temp = head;\\n        ListNode* mid = head;\\n        while(temp != NULL && temp -> next != NULL){\\n            mid = mid -> next;\\n            temp = temp->next-> next;\\n        }\\n        return mid;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-absolute-difference-between-elements-with-constraint",
        "tags": "cpp",
        "release_time": 1691900240,
        "code": "int func(vector<int> &v,int x)\n{\n    int n = v.size(); int ans = 1e9+10;\n    map<int,set<int>> m; // val , index\n    multiset<int> s;\n    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }\n    for(int i=0;i<n-x;i++)\n    {\n        auto it = s.lower_bound(v[i]);\n        int key = *it;\n        ans = min(ans , abs(key - v[i]) );  // checking absolute\n\n        int del = v[i+x];\n        it = s.find(del);\n        s.erase(it);\n        m[del].erase(i+x);\n        if( m[del].size()==0 ) m.erase(del);\n    }\n\n    return ans;\n}\n\nclass Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& v, int x) \n    {\n        int ans = 1e9+10;\n        ans = min( ans , func(v,x) );\n        reverse(v.begin(),v.end());\n        ans = min( ans , func(v,x) );\n        return ans;\n    }\n};",
        "content": "# Intuition\\nFor any index i , You just have to check for minimum absolute difference in the subarray starting from index $$(i+x)$$ to $$n-1$$   \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.) Created a Map & Multiset for storing the elements in  $$(n-x)$$ sized window from the end , with keeping track of $$ < values : indices >$$  in map and values in a multiset \\n\\n2.) kept updating the answer while iterating from the 0th index to $$x$$th index by finding the lower_bound in the multiset as lower_bound will be the most closest next element to the current value.\\n> Note\\nSince lower_bound will only consider the elements $$ i,j $$ with $$v[i] <= v[j]$$ . We need to call the same function on reverse of this array also to consider the indices $$ i,j $$ with $$v[i] > v[j]$$ .\\n\\n3.) In order to shrink the window size at every iteration step , just remove index of the first element of window i.e. $$(i+k)$$ from the map where key is $$v[i+x]$$ and delete it from the multiset as well\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(nlog(n))$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint func(vector<int> &v,int x)\\n{\\n    int n = v.size(); int ans = 1e9+10;\\n    map<int,set<int>> m; // val , index\\n    multiset<int> s;\\n    for(int i=n-1;i>=x;i--) { m[v[i]].insert(i); s.insert(v[i]); }\\n    for(int i=0;i<n-x;i++)\\n    {\\n        auto it = s.lower_bound(v[i]);\\n        int key = *it;\\n        ans = min(ans , abs(key - v[i]) );  // checking absolute\\n\\n        int del = v[i+x];\\n        it = s.find(del);\\n        s.erase(it);\\n        m[del].erase(i+x);\\n        if( m[del].size()==0 ) m.erase(del);\\n    }\\n\\n    return ans;\\n}\\n\\nclass Solution {\\npublic:\\n    int minAbsoluteDifference(vector<int>& v, int x) \\n    {\\n        int ans = 1e9+10;\\n        ans = min( ans , func(v,x) );\\n        reverse(v.begin(),v.end());\\n        ans = min( ans , func(v,x) );\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "first-letter-to-appear-twice",
        "tags": "cpp",
        "release_time": 1690691593,
        "code": "class Solution {\npublic:\n    char repeatedCharacter(string s) {\n        unordered_map<char, int> ump;\n        for(int i = 0; i<s.size(); i++ ){\n            ump[s[i]]++;\n            if( ump[s[i]] == 2 ) {\n                return s[i];\n            }\n        }\n\n        return 'a';\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    char repeatedCharacter(string s) {\\n        unordered_map<char, int> ump;\\n        for(int i = 0; i<s.size(); i++ ){\\n            ump[s[i]]++;\\n            if( ump[s[i]] == 2 ) {\\n                return s[i];\\n            }\\n        }\\n\\n        return \\'a\\';\\n    }\\n};\\n```"
    },
    {
        "slug": "average-salary-excluding-the-minimum-and-maximum-salary",
        "tags": "cpp",
        "release_time": 1682952594,
        "code": "class Solution {\npublic:\n    double average(vector<int>& salary) {\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\n        for(int i:salary){\n            Max = Max < i ? i : Max ;\n            Min = Min > i ? i : Min ;\n            sum += i;\n        }\n        sum -= (Min + Max);\n        return sum/(n-2.0);\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double average(vector<int>& salary) {\\n        int n=salary.size(),sum=0,Min=INT_MAX,Max=INT_MIN;\\n        for(int i:salary){\\n            Max = Max < i ? i : Max ;\\n            Min = Min > i ? i : Min ;\\n            sum += i;\\n        }\\n        sum -= (Min + Max);\\n        return sum/(n-2.0);\\n    }\\n};\\n```"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "tags": "cpp",
        "release_time": 1685601860,
        "code": "class Solution {\npublic:\n    bool canThreePartsEqualSum(vector<int>& arr) {\n        if(arr.size()<3) return false;\n        else\n        {\n            int sum=0;\n            for(int i=0; i<arr.size(); i++)\n            {\n                sum+=arr[i];\n            }\n            if(sum%3==0)\n            {\n                int cnt=0, sum1=0;\n                for(int i=0; i<arr.size(); i++)\n                {\n                    sum1+=arr[i];\n                    if(sum1==sum/3)\n                    {\n                        cnt++;\n                        sum1=0;\n                    }\n                }\n                if(cnt>=3) return true;\n                else return false;\n            }\n            else return false;\n        }\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDivisiblilty by 3.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Just check if the sum of all elements of the array is divisible by 3.\\n2. If yes, then check whether there are three separate partitions which are having the sum of (sum/3).\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. The initial loop that calculates the sum of all elements in the array has a time complexity of O(n), where n is the size of the input array.\\n2. The subsequent loop that checks for parts with a sum equal to sum/3 also has a time complexity of O(n), as it iterates through the array once.\\n\\nTherefore, the overall time complexity of the code is O(n), where n is the size of the input array.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. The code uses a constant amount of additional space for variables such as \"sum,\" \"cnt,\" and \"sum1.\" These variables require a constant amount of memory, so the space complexity can be considered O(1).\\n2. The input vector \"arr\" is passed by reference and does not result in any additional space usage.\\n\\nTherefore, the space complexity of the code is O(1), as it uses only a constant amount of additional space.\\n\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canThreePartsEqualSum(vector<int>& arr) {\\n        if(arr.size()<3) return false;\\n        else\\n        {\\n            int sum=0;\\n            for(int i=0; i<arr.size(); i++)\\n            {\\n                sum+=arr[i];\\n            }\\n            if(sum%3==0)\\n            {\\n                int cnt=0, sum1=0;\\n                for(int i=0; i<arr.size(); i++)\\n                {\\n                    sum1+=arr[i];\\n                    if(sum1==sum/3)\\n                    {\\n                        cnt++;\\n                        sum1=0;\\n                    }\\n                }\\n                if(cnt>=3) return true;\\n                else return false;\\n            }\\n            else return false;\\n        }\\n    }\\n};\\n```"
    },
    {
        "slug": "reach-a-number",
        "tags": "cpp",
        "release_time": 1671643345,
        "code": "class Solution {\npublic:\n    int reachNumber(int target) {\n        target = abs(target);\n        int sum=0, steps = 0;\n        while(sum<target){\n            sum+=steps;\n            steps++;\n        }\n        while((sum-target)%2!=0){\n            sum += steps;\n            steps++;\n        }\n        return steps-1;\n    }\n};",
        "content": "# Intuition\\nFrom observation, it can be find out that moving in the negative direction will give the even difference from target to final position.For example if target is equal to 8 and we keep moving in positive direction then we reach to 10 (in 4 steps) and the difference from final position (i.e. 10) to target (i.e 8) is 2 (i.e. divisible by 2).\\nIf we take any negative step (among 4 steps) then we can reach to our target (therefore answer remains 4). But if the difference in not divisble by 2 like when target is equal to 12 then we reach to final position (i.e. 15) in 5 steps and difference is 3 (i.e. not divisible by 2) then we keep on adding steps until the difference becomes divisble by 2. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int reachNumber(int target) {\\n        target = abs(target);\\n        int sum=0, steps = 0;\\n        while(sum<target){\\n            sum+=steps;\\n            steps++;\\n        }\\n        while((sum-target)%2!=0){\\n            sum += steps;\\n            steps++;\\n        }\\n        return steps-1;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit",
        "tags": "cpp",
        "release_time": 1691818682,
        "code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums, int limit) {\n        int ans=1,l=0,h=1,count=1;\n        map<int,int> mp;\n        mp[nums[l]]++;\n        \n        while(h<nums.size()){\n            mp[nums[h]]++;\n            count++; //counting the number of elements in map\n            \n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \n                ans=max(ans,count); // giving the size of subarray that may make our answer\n            }else{\n                // If diff is more than limit then we'll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\n                    else mp.erase(nums[l]);\n                    count--;\n                    l++;\n                }\n            }\n            h++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1-> We can use window sliding and keep all the values in map that can tell us min and max value in that window.\\n2-> If the range (i.e., max-min) is greater than limit then we need to delete element from the left of window that we can do using map in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 -> keep inserting the values in map and keep increasing the size of window, until we found max-min>limit and Keep updating the size of window as answer.\\n2-> If max-min>limit, then we can start deleting the values from map. This can be done by getting the left indexes of window and acces the value at that index and delete it from map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince we are using map here, so complexity for map is O(Nlog(N));\\nand we are traversing the array from 0-N then it\\'ll take O(N);\\n\\nSo overall, **Time complexity: O(Nlog(N))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using one extra map here, so **space complexity is O(N)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ans=1,l=0,h=1,count=1;\\n        map<int,int> mp;\\n        mp[nums[l]]++;\\n        \\n        while(h<nums.size()){\\n            mp[nums[h]]++;\\n            count++; //counting the number of elements in map\\n            \\n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \\n                ans=max(ans,count); // giving the size of subarray that may make our answer\\n            }else{\\n                // If diff is more than limit then we\\'ll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\\n                    else mp.erase(nums[l]);\\n                    count--;\\n                    l++;\\n                }\\n            }\\n            h++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "extra-characters-in-a-string",
        "tags": "cpp",
        "release_time": 1690885964,
        "code": "class Solution {\npublic:\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\n    {\n        if (ind==s.size()) return 0;\n        if (dp[ind]!=-1) return dp[ind];\n        int ans=s.size()-ind;\n        for (int i=ind;i<s.size();i++)\n        {\n           string temp=s.substr(ind,i-ind+1);\n           if (st.find(temp)!=st.end())\n           {\n              ans=min(ans,rec(i+1,s,st,dp));\n           }\n        }\n        ans=min(ans,1+rec(ind+1,s,st,dp));\n        return dp[ind]=ans;\n    }\n    int minExtraChar(string s, vector<string>& dictionary) \n    {\n        set<string>st;\n        int n=s.size();\n        vector<int>dp(n,-1);\n        for (auto it:dictionary)\n        {\n            st.insert(it);\n        }\n        return rec(0,s,st,dp);\n    }\n};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int ind,string &s,set<string>&st,vector<int>&dp)\\n    {\\n        if (ind==s.size()) return 0;\\n        if (dp[ind]!=-1) return dp[ind];\\n        int ans=s.size()-ind;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n           string temp=s.substr(ind,i-ind+1);\\n           if (st.find(temp)!=st.end())\\n           {\\n              ans=min(ans,rec(i+1,s,st,dp));\\n           }\\n        }\\n        ans=min(ans,1+rec(ind+1,s,st,dp));\\n        return dp[ind]=ans;\\n    }\\n    int minExtraChar(string s, vector<string>& dictionary) \\n    {\\n        set<string>st;\\n        int n=s.size();\\n        vector<int>dp(n,-1);\\n        for (auto it:dictionary)\\n        {\\n            st.insert(it);\\n        }\\n        return rec(0,s,st,dp);\\n    }\\n};\\n```"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "tags": "cpp",
        "release_time": 1671865863,
        "code": "class Solution {\npublic:\n    int mod=1e9+7;\n    long helper(int n, vector<long>& dp){\n        if(n==1) return 1;\n        if(n==2) return 2;\n        if(n==3) return 5;\n\n        if(dp[n]!=-1) return dp[n]%mod;\n\n        long smallAns1=0, smallAns2=0;\n        smallAns1=helper(n-1,dp)%mod;\n        smallAns2=helper(n-3,dp)%mod;\n\n        dp[n]=(smallAns1*2+smallAns2)%mod;\n        return dp[n]%mod;\n    }\n    \n    int numTilings(int n) {\n        vector<long> dp(n+1,-1);\n        long ans=helper(n,dp)%mod;\n        return (int)ans;        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfor n , we want answer for n-1 and n-3\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) + Recurisve Stack Space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mod=1e9+7;\\n    long helper(int n, vector<long>& dp){\\n        if(n==1) return 1;\\n        if(n==2) return 2;\\n        if(n==3) return 5;\\n\\n        if(dp[n]!=-1) return dp[n]%mod;\\n\\n        long smallAns1=0, smallAns2=0;\\n        smallAns1=helper(n-1,dp)%mod;\\n        smallAns2=helper(n-3,dp)%mod;\\n\\n        dp[n]=(smallAns1*2+smallAns2)%mod;\\n        return dp[n]%mod;\\n    }\\n    \\n    int numTilings(int n) {\\n        vector<long> dp(n+1,-1);\\n        long ans=helper(n,dp)%mod;\\n        return (int)ans;        \\n    }\\n};\\n```"
    },
    {
        "slug": "merge-similar-items",
        "tags": "cpp",
        "release_time": 1680036708,
        "code": "class Solution {\npublic:\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\n\n    map<int, int> m;\n    int n1=items1.size();\n    for (auto i = 0; i < n1; i++)\n        m[items1[i][0]] = items1[i][1];\n\n    int n2=items2.size();\n    for (int j = 0; j < n2; j++)\n        m[items2[j][0]] += items2[j][1];\n\n    vector<vector<int>> ans;\n    for(auto e:m)\n        ans.push_back({e.first,e.second});\n    return ans;\n\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(NlogN)\\n  N: Total number of elements\\n  \\n- Space complexity: O(M)\\n  M: Number of distinct elements\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\\n\\n    map<int, int> m;\\n    int n1=items1.size();\\n    for (auto i = 0; i < n1; i++)\\n        m[items1[i][0]] = items1[i][1];\\n\\n    int n2=items2.size();\\n    for (int j = 0; j < n2; j++)\\n        m[items2[j][0]] += items2[j][1];\\n\\n    vector<vector<int>> ans;\\n    for(auto e:m)\\n        ans.push_back({e.first,e.second});\\n    return ans;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-losers-of-the-circular-game",
        "tags": "cpp",
        "release_time": 1684039583,
        "code": "class Solution {\npublic:\n    vector<int> circularGameLosers(int n, int k) {\n       vector<int>frq(n+1,0);\n        vector<int>ans;\n        int i = 0;\n        int round = 1;\n       while(true){\n           frq[i]++;\n           if(frq[i] >= 2) break;\n            i = (i + ( round++ * k))%n;\n       }\n        for(int  i = 0 ; i<n ; i++)\n            if( frq[i] == 0) ans.push_back(i+1);\n\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> circularGameLosers(int n, int k) {\\n       vector<int>frq(n+1,0);\\n        vector<int>ans;\\n        int i = 0;\\n        int round = 1;\\n       while(true){\\n           frq[i]++;\\n           if(frq[i] >= 2) break;\\n            i = (i + ( round++ * k))%n;\\n       }\\n        for(int  i = 0 ; i<n ; i++)\\n            if( frq[i] == 0) ans.push_back(i+1);\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "tags": "cpp",
        "release_time": 1674806782,
        "code": "class Solution {\npublic:\n    int minOperations(string s) {\n        int n=s.size(), ans=0;\n        for(int i=0;i<n;i++)\n        {\n            if(s[i]-'0' != i%2)\n            ans++;\n        }\n        return min(ans, n-ans);\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(string s) {\\n        int n=s.size(), ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]-\\'0\\' != i%2)\\n            ans++;\\n        }\\n        return min(ans, n-ans);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!"
    },
    {
        "slug": "making-file-names-unique",
        "tags": "cpp",
        "release_time": 1665634361,
        "code": "class Solution {\npublic:\n   vector<string> getFolderNames(vector<string>& names) {\n    unordered_map<string,int>m;\n    vector<string>ans;\n    for(int i=0;i<names.size();i++){\n      if(m.find(names[i])!=m.end())\n       {\n          int k = m[names[i]];\n           string str;\n          do{\n           str = names[i]+'(';\n          str += to_string(k);\n              str += ')';\n            m[names[i]]++;\n            k++;\n          }\n          while(m.find(str)!=m.end());\n          m[str]++ ;\n          ans.push_back(str);\n       }\n       else\n       {\n          m[names[i]]++;\n          ans.push_back(names[i]);\n       }\n    }\n    return ans;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   vector<string> getFolderNames(vector<string>& names) {\\n    unordered_map<string,int>m;\\n    vector<string>ans;\\n    for(int i=0;i<names.size();i++){\\n      if(m.find(names[i])!=m.end())\\n       {\\n          int k = m[names[i]];\\n           string str;\\n          do{\\n           str = names[i]+\\'(\\';\\n          str += to_string(k);\\n              str += \\')\\';\\n            m[names[i]]++;\\n            k++;\\n          }\\n          while(m.find(str)!=m.end());\\n          m[str]++ ;\\n          ans.push_back(str);\\n       }\\n       else\\n       {\\n          m[names[i]]++;\\n          ans.push_back(names[i]);\\n       }\\n    }\\n    return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "max-number-of-k-sum-pairs",
        "tags": "cpp",
        "release_time": 1690482956,
        "code": "class Solution {\npublic:\n    int maxOperations(vector<int>& nums, int k) {\n        sort(nums.begin(),nums.end());\n        // using two poiners approach;\n        int i=0;\n        int j=nums.size()-1;\n        int count=0;\n        while(j>i)\n        {\n            if(nums[i]+nums[j]==k)\n            {\n                i++;\n                j--;\n                count++;\n            }\n            else if(nums[i]+nums[j]<k)\n            {\n                i++;\n            }\n            else\n            {\n                j--;\n            }\n        }\n        return count;\n\n    }\n};",
        "content": "# Approach\\nTwo pointers\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxOperations(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        // using two poiners approach;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int count=0;\\n        while(j>i)\\n        {\\n            if(nums[i]+nums[j]==k)\\n            {\\n                i++;\\n                j--;\\n                count++;\\n            }\\n            else if(nums[i]+nums[j]<k)\\n            {\\n                i++;\\n            }\\n            else\\n            {\\n                j--;\\n            }\\n        }\\n        return count;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "knight-dialer",
        "tags": "cpp",
        "release_time": 1680161413,
        "code": "long long mod = 1e9+7;\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\nint dp[5][4][5002];\nclass Solution {\npublic:\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\n    {\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\n        if(n==0)return 1;\n        auto &t = dp[i][j][n];\n        if(t!=-1)return t;\n        int ans =0;\n        for(int k=0;k<8;k++)\n        {\n            int x = dx[k]+i;\n            int y = dy[k]+j;\n            ans= (ans+f(nums,x,y,n-1))%mod;\n        }\n        return t =  ans%mod;\n    }\n    \n    int knightDialer(int n) {\n        vector<vector<int>> nums(4,vector<int>(3,-1));\n        memset(dp,-1,sizeof(dp));\n        int x=1;\n         nums[3][1] = 0;\n        for(int i=0;i<3;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                nums[i][j] = x;\n                x++;\n            }\n        }\n      int ans=0;\n        for(int i=0;i<4;i++)\n        {\n            for(int j=0;j<3;j++)\n            {\n                if(nums[i][j]!=-1)\n                {\n                    ans=(ans+f(nums,i,j,n-1))%mod;\n                }\n            }\n        }\n        return ans%mod;\n    }\n};",
        "content": "```\\nlong long mod = 1e9+7;\\nint dx[] = {2,2,1,1,-2,-2,-1,-1};\\nint dy[] = {1,-1,2,-2,1,-1,2,-2};\\nint dp[5][4][5002];\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>& nums,int i ,int j,int n)\\n    {\\n       if(i<0 || j<0 || i>=nums.size() || j>=nums[0].size() || nums[i][j]==-1)return 0;\\n        if(n==0)return 1;\\n        auto &t = dp[i][j][n];\\n        if(t!=-1)return t;\\n        int ans =0;\\n        for(int k=0;k<8;k++)\\n        {\\n            int x = dx[k]+i;\\n            int y = dy[k]+j;\\n            ans= (ans+f(nums,x,y,n-1))%mod;\\n        }\\n        return t =  ans%mod;\\n    }\\n    \\n    int knightDialer(int n) {\\n        vector<vector<int>> nums(4,vector<int>(3,-1));\\n        memset(dp,-1,sizeof(dp));\\n        int x=1;\\n         nums[3][1] = 0;\\n        for(int i=0;i<3;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                nums[i][j] = x;\\n                x++;\\n            }\\n        }\\n      int ans=0;\\n        for(int i=0;i<4;i++)\\n        {\\n            for(int j=0;j<3;j++)\\n            {\\n                if(nums[i][j]!=-1)\\n                {\\n                    ans=(ans+f(nums,i,j,n-1))%mod;\\n                }\\n            }\\n        }\\n        return ans%mod;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-moves-to-reach-target-with-rotations",
        "tags": "cpp",
        "release_time": 1692341665,
        "code": "class Solution {\n    int n;\n    vector<vector<int>> hmemo, vmemo;\n    vector<vector<int>> *gridp;\n\n    int dfs(bool h, int r, int c) {\n        vector<vector<int>> & grid = *gridp;\n        if (h && r == n-1 && c == n-2)\n            return 0;\n        int res = INT_MAX-1;\n        if (h) {\n            if (hmemo[r][c] > 0) {\n                return hmemo[r][c];\n            }\n            hmemo[r][c] = INT_MAX-1;\n            if (c+2 < n && grid[r][c+2] == 0) {\n                // move right\n                res = min(res, 1+dfs(true, r, c+1));\n            }\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\n                // move down\n                res = min(res, 1+dfs(true, r+1, c));\n                // rotate clockwise\n                res = min(res, 1+dfs(false, r, c));\n            }\n            hmemo[r][c] = res;\n            return res;\n        } else {\n            if (vmemo[r][c] > 0) {\n                return vmemo[r][c];\n            }\n            vmemo[r][c] = INT_MAX-1;\n            if (r+2 < n && grid[r+2][c] == 0) {\n                // move down\n                res = min(res, 1+dfs(false, r+1, c));\n            }\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\n                // move right\n                res = min(res, 1+dfs(false, r, c+1));\n                // rotate counterclockwise\n                res = min(res, 1+dfs(true, r, c));\n            }\n            vmemo[r][c] = res;\n            return res;\n        }\n    }\n\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        this->gridp = &grid;\n        n = grid.size();\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\n        int res = dfs(true, 0, 0);\n        return res < INT_MAX-1 ? res : -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s *generally* better to use BFS for search problems like this. However, given the constraints for this problem, DFS+memo is more than adequate; in fact it is both simpler and faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS with two 2D arrays for memoization: `hmemo` for when we\\'re horizontal, and `vmemo` for when we\\'re vertical. While we\\'re running DFS on a point, we can set its memo to `INT_MAX-1` so the code will short-circuit if we attempt anything that could cause a cycle. I also return `INT_MAX-1` if the target is unreachable. (`INT_MAX-1` avoids overflow when doing `1+dfs(...)`).\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, 17ms beats 100% apparently!\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> hmemo, vmemo;\\n    vector<vector<int>> *gridp;\\n\\n    int dfs(bool h, int r, int c) {\\n        vector<vector<int>> & grid = *gridp;\\n        if (h && r == n-1 && c == n-2)\\n            return 0;\\n        int res = INT_MAX-1;\\n        if (h) {\\n            if (hmemo[r][c] > 0) {\\n                return hmemo[r][c];\\n            }\\n            hmemo[r][c] = INT_MAX-1;\\n            if (c+2 < n && grid[r][c+2] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(true, r, c+1));\\n            }\\n            if (r+1 < n && grid[r+1][c] == 0 && grid[r+1][c+1] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(true, r+1, c));\\n                // rotate clockwise\\n                res = min(res, 1+dfs(false, r, c));\\n            }\\n            hmemo[r][c] = res;\\n            return res;\\n        } else {\\n            if (vmemo[r][c] > 0) {\\n                return vmemo[r][c];\\n            }\\n            vmemo[r][c] = INT_MAX-1;\\n            if (r+2 < n && grid[r+2][c] == 0) {\\n                // move down\\n                res = min(res, 1+dfs(false, r+1, c));\\n            }\\n            if (c+1 < n && grid[r][c+1] == 0 && grid[r+1][c+1] == 0) {\\n                // move right\\n                res = min(res, 1+dfs(false, r, c+1));\\n                // rotate counterclockwise\\n                res = min(res, 1+dfs(true, r, c));\\n            }\\n            vmemo[r][c] = res;\\n            return res;\\n        }\\n    }\\n\\npublic:\\n    int minimumMoves(vector<vector<int>>& grid) {\\n        this->gridp = &grid;\\n        n = grid.size();\\n        hmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        vmemo = vector<vector<int>>(n, vector<int>(n, -1));\\n        int res = dfs(true, 0, 0);\\n        return res < INT_MAX-1 ? res : -1;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-subarray-of-1s-after-deleting-one-element",
        "tags": "cpp",
        "release_time": 1688536604,
        "code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        int n = nums.size();\n        int left = 0, right, zeros = 0, ans = 0;\n\n        for (right = 0; right < n; right++) {\n            if (nums[right] == 0){\n                zeros++;\n                }\n            if (zeros > 1 && nums[left++] == 0){\n                zeros--;\n                }\n            ans = max(ans, right - left);\n        }\n        return ans; \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums) {\\n        int n = nums.size();\\n        int left = 0, right, zeros = 0, ans = 0;\\n\\n        for (right = 0; right < n; right++) {\\n            if (nums[right] == 0){\\n                zeros++;\\n                }\\n            if (zeros > 1 && nums[left++] == 0){\\n                zeros--;\\n                }\\n            ans = max(ans, right - left);\\n        }\\n        return ans; \\n    }\\n};\\n```"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "tags": "cpp",
        "release_time": 1682433907,
        "code": "class Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        sort(stones.begin(), stones.end());\n\n        int N = stones.size(), low = N;\n        for (int i = 0, j = 0; j < N; ++j) {\n            while (stones[j] - stones[i] + 1 > N) {\n                ++i;\n            }\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\n                low = min(low, 2);\n            } else {\n                low = min(low, N - (j - i + 1));\n            }\n        }\n\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\n        return {low, high};\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> numMovesStonesII(vector<int>& stones) {\\n        sort(stones.begin(), stones.end());\\n\\n        int N = stones.size(), low = N;\\n        for (int i = 0, j = 0; j < N; ++j) {\\n            while (stones[j] - stones[i] + 1 > N) {\\n                ++i;\\n            }\\n            if (N - (j - i + 1) == 1 && N - (stones[j] - stones[i] + 1) == 1) {\\n                low = min(low, 2);\\n            } else {\\n                low = min(low, N - (j - i + 1));\\n            }\\n        }\\n\\n        int high = 1 + max((stones[N - 1] - stones[1] + 1) - N,  // Move to right most\\n                           (stones[N - 2] - stones[0] + 1) - N); // Move to left most\\n        return {low, high};\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-time-visiting-all-points",
        "tags": "cpp",
        "release_time": 1667545882,
        "code": "#include <cstdlib>\nclass Solution {\npublic:\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\n        int ans=0;\n        for(int i=1;i<points.size();i++)\n        {\n            int temp1=points[i][0]-points[i-1][0];\n            int temp2=points[i][1]-points[i-1][1];\n            temp1=abs(temp1);\n            temp2=abs(temp2);\n            int res = max(temp1,temp2);\n            cout<<res;\n            ans += res;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <cstdlib>\\nclass Solution {\\npublic:\\n    int minTimeToVisitAllPoints(vector<vector<int>>& points) {\\n        int ans=0;\\n        for(int i=1;i<points.size();i++)\\n        {\\n            int temp1=points[i][0]-points[i-1][0];\\n            int temp2=points[i][1]-points[i-1][1];\\n            temp1=abs(temp1);\\n            temp2=abs(temp2);\\n            int res = max(temp1,temp2);\\n            cout<<res;\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "flip-string-to-monotone-increasing",
        "tags": "cpp",
        "release_time": 1673915632,
        "code": "//Memoisation\nclass Solution {\npublic:\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\n        if(idx==s.size()){\n            return 0;\n        }\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\n        if(prev){\n            return dp[idx][prev]=(s[idx]=='0')+solve(idx+1,prev,s,dp);\n        }\n        else{\n            return dp[idx][prev]=min((s[idx]=='1')+solve(idx+1,0,s,dp),(s[idx]=='0')+solve(idx+1,1,s,dp));\n        }\n    }\n    int minFlipsMonoIncr(string s) {\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\n        return solve(0,0,s,dp);\n    }\n};",
        "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    int solve(int idx,int prev,string &s,vector<vector<int>>& dp){\\n        if(idx==s.size()){\\n            return 0;\\n        }\\n        if(dp[idx][prev]!=-1) return dp[idx][prev];\\n        if(prev){\\n            return dp[idx][prev]=(s[idx]==\\'0\\')+solve(idx+1,prev,s,dp);\\n        }\\n        else{\\n            return dp[idx][prev]=min((s[idx]==\\'1\\')+solve(idx+1,0,s,dp),(s[idx]==\\'0\\')+solve(idx+1,1,s,dp));\\n        }\\n    }\\n    int minFlipsMonoIncr(string s) {\\n        vector<vector<int>> dp(s.size(),vector<int>(2,-1));\\n        return solve(0,0,s,dp);\\n    }\\n};\\n\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n=s.size();\\n        vector<vector<int>> dp(n+1,vector<int>(2,0));\\n        for(int idx=n-1;idx>=0;idx--){\\n            for(int prev=1;prev>=0;prev--){\\n                if(prev){\\n                    dp[idx][prev]=(s[idx]==\\'0\\')+dp[idx+1][prev];\\n                }\\n                else{\\n                    dp[idx][prev]=min((s[idx]==\\'1\\')+dp[idx+1][0],(s[idx]==\\'0\\')+dp[idx+1][1]);\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```\\n```\\n//Space Optimization\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n=s.size();\\n        vector<int> dp(2,0);\\n        for(int idx=n-1;idx>=0;idx--){\\n            vector<int> curr(2,0);\\n            for(int prev=1;prev>=0;prev--){\\n                if(prev){\\n                    curr[prev]=(s[idx]==\\'0\\')+dp[prev];\\n                }\\n                else{\\n                    curr[prev]=min((s[idx]==\\'1\\')+dp[0],(s[idx]==\\'0\\')+dp[1]);\\n                }\\n            }\\n            dp=curr;\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
    },
    {
        "slug": "apply-operations-to-an-array",
        "tags": "cpp",
        "release_time": 1667707492,
        "code": "class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        for(int i =0 ;i<nums.size()-1;i++){\n            if(nums[i] == nums[i+1]){\n                nums[i] *=2;\n                nums[i+1] = 0;\n            }\n        };\n        vector<int> ans;\n        for(auto ele:nums){\n            if(ele!=0)ans.push_back(ele);\n        };\n        for(auto ele:nums){\n            if(ele == 0)ans.push_back(ele);\n        };\n        return ans;\n    }\n};",
        "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> applyOperations(vector<int>& nums) {\\n        for(int i =0 ;i<nums.size()-1;i++){\\n            if(nums[i] == nums[i+1]){\\n                nums[i] *=2;\\n                nums[i+1] = 0;\\n            }\\n        };\\n        vector<int> ans;\\n        for(auto ele:nums){\\n            if(ele!=0)ans.push_back(ele);\\n        };\\n        for(auto ele:nums){\\n            if(ele == 0)ans.push_back(ele);\\n        };\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-increasing-subsequence",
        "tags": "cpp",
        "release_time": 1686036144,
        "code": "class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        //array to store max length subsequence till that place\n        vector<int> dp(nums.size(),0);\n        int maxlength = 0;//to store maxlength of subsequence\n        dp[0] = 1;//length will be 1 at first index \n        for(int i = 0;i<nums.size();i++){\n            int currentMaxLen = 0; //to store maxlength at till this index\n            for(int j = 0;j<i;j++){\n                // only check when the subsequence is increasing\n                if(nums[i]>nums[j]){\n                    if(currentMaxLen<dp[j]){\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\n                    }\n                }\n            }\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\n            maxlength = max(maxlength,dp[i]); //update maxlength\n        }\n        \n        return maxlength;\n    }\n};",
        "content": "# Intuition\\nThe problem asks us to find the length of the longest strictly increasing subsequence in the given array. To solve this problem efficiently, we can use dynamic programming.\\n\\n# Approach\\n1. Create a vector dp of size nums.size(), where dp[i] will store the length of the longest increasing subsequence ending at index i.\\n2. Initialize a variable maxlength to store the maximum length of the subsequence.\\n3. Set dp[0] to 1, as the length of the subsequence ending at the first index is always 1.\\n4. Iterate through each element in nums using the outer loop. For each element at index i, iterate through all the previous elements using the inner loop (from 0 to i-1).\\n5. Check if nums[i] is greater than nums[j], indicating that we can extend the increasing subsequence.\\n    - If the condition is satisfied, update the currentMaxLen variable with the maximum length of the subsequence so far at index j.\\n6. After the inner loop, update dp[i] with currentMaxLen + 1, which represents the maximum length of the subsequence ending at index i.\\nUpdate maxlength by taking the maximum value between maxlength and dp[i].\\n7. After the loop, maxlength will contain the length of the longest increasing subsequence.\\n8. Return maxlength.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n^2), where n is the size of the input array nums. The outer loop runs for n iterations, and the inner loop also runs for a maximum of n iterations.\\n\\n- Space complexity:\\nThe space complexity is O(n) since we are using an additional vector dp of size n to store the lengths of subsequences.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int lengthOfLIS(vector<int>& nums) {\\n        //array to store max length subsequence till that place\\n        vector<int> dp(nums.size(),0);\\n        int maxlength = 0;//to store maxlength of subsequence\\n        dp[0] = 1;//length will be 1 at first index \\n        for(int i = 0;i<nums.size();i++){\\n            int currentMaxLen = 0; //to store maxlength at till this index\\n            for(int j = 0;j<i;j++){\\n                // only check when the subsequence is increasing\\n                if(nums[i]>nums[j]){\\n                    if(currentMaxLen<dp[j]){\\n                        currentMaxLen = dp[j]; //update currentMaxLen accordingly\\n                    }\\n                }\\n            }\\n            dp[i] = currentMaxLen + 1; //set the maxLength till ith index, which will be maxlenth so far + 1\\n            maxlength = max(maxlength,dp[i]); //update maxlength\\n        }\\n        \\n        return maxlength;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-number-of-possible-root-nodes",
        "tags": "cpp",
        "release_time": 1677967205,
        "code": "class Solution {\npublic:\n    map<pair<int,int>,int> mp;\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\n    {\n        for(auto& a:tree[cur])\n        {\n            if(possible[a]==-1)\n            {\n                int new_ans=ans;\n                bool a1=false,a2=false;\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\n                {\n                    mp[{a,cur}]=1;\n                    new_ans++;\n                    a1=true;\n                }\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\n                {\n                    mp[{cur,a}]=0;\n                    new_ans--;\n                    a2=true;\n                }\n                possible[a]=0;\n                if(new_ans>=k)\n                {\n                    possible[a]=1;\n                }\n                dfs(tree,possible,a,new_ans,k);\n                if(a1)\n                {\n                    mp[{a,cur}]=0;\n                }\n                if(a2)\n                {\n                    mp[{cur,a}]=1;\n                }\n            }\n        }\n\n    }\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\n        \n        for(auto&e : guesses)\n        {\n            mp[ {e[0],e[1]}]=0;\n        }\n        int n=edges.size()+1;\n        vector<vector<int>> tree(n);\n        for(auto& e:edges)\n        {\n            tree[e[0]].push_back(e[1]);\n            tree[e[1]].push_back(e[0]);\n        }\n        queue<int> q;\n        q.push(0);\n        vector<bool> visited(n,false);\n        visited[0]=true;\n        int ans=0;\n        while(q.size()>0)\n        {\n            int a=q.front();\n            q.pop();\n            for(int i=0;i<tree[a].size();i++)\n            {\n                if(visited[tree[a][i]])\n                    continue;\n                visited[tree[a][i]]=true;\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\n                {\n                    mp[{a,tree[a][i]}]=1;\n                    ans++;\n                }\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\n                {\n                    mp[{tree[a][i],a}]=0;\n                    ans--;\n                }\n                q.push(tree[a][i]);\n            }\n        }\n        vector<int> possible(n,-1);\n        possible[0]= (1?ans>=k:0);\n        dfs(tree,possible,0,ans,k);\n        int sum=accumulate(possible.begin(),possible.end(),0);\n        return sum;\n    }\n};",
        "content": "# Intuition\\nSuppose [a,b] is an edge and a is the root of the tree. Now suppose we want to evaluate b as the root of the tree. The only guess that were previously correct and now incorrect would be [a,b]. Similarly the only guess that was previously incorrect but now correct is [b,a].\\n\\n# Approach\\nCreate an adjacency list of the graph ->***tree***. Suppose 0 is the root of the tree. Apply bfs (I used bfs but dfs can be used as well) to evaluate all the guesses that are now correct ->***ans***. Create another array of size n -> ***possible*** that stores if the current node is capable of being the root of the tree. possible[0] = 1 if ans>=k, else possible[0]=0;\\n\\nNow try to evaluate the ans if one of the neighbours of 0 is the root. Suppose [0,b] is an edge in guesses. We will know that since b is now parent, [0,b] guess would now be false. So decrement ans by 1 in this case. Similarly suppose [b,0] was a guess. This guess is now correct. Increment ans by 1 in this case. Again see if ans>=k. If yes, possible[b]=1, else possible[b]=0;\\n\\nContinue this for all the edges in the tree in a dfs manner. Finally return the number of indexes where possible array entry is equal to 1. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    void dfs(vector<vector<int>>& tree,vector<int>& possible,int cur ,int ans,int k)\\n    {\\n        for(auto& a:tree[cur])\\n        {\\n            if(possible[a]==-1)\\n            {\\n                int new_ans=ans;\\n                bool a1=false,a2=false;\\n                if(mp.find({a,cur})!=mp.end() && mp[{a,cur}]==0  )\\n                {\\n                    mp[{a,cur}]=1;\\n                    new_ans++;\\n                    a1=true;\\n                }\\n                if(mp.find({cur,a })!=mp.end() && mp[{cur,a}]==1  )\\n                {\\n                    mp[{cur,a}]=0;\\n                    new_ans--;\\n                    a2=true;\\n                }\\n                possible[a]=0;\\n                if(new_ans>=k)\\n                {\\n                    possible[a]=1;\\n                }\\n                dfs(tree,possible,a,new_ans,k);\\n                if(a1)\\n                {\\n                    mp[{a,cur}]=0;\\n                }\\n                if(a2)\\n                {\\n                    mp[{cur,a}]=1;\\n                }\\n            }\\n        }\\n\\n    }\\n    int rootCount(vector<vector<int>>& edges, vector<vector<int>>& guesses, int k) {\\n        \\n        for(auto&e : guesses)\\n        {\\n            mp[ {e[0],e[1]}]=0;\\n        }\\n        int n=edges.size()+1;\\n        vector<vector<int>> tree(n);\\n        for(auto& e:edges)\\n        {\\n            tree[e[0]].push_back(e[1]);\\n            tree[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n,false);\\n        visited[0]=true;\\n        int ans=0;\\n        while(q.size()>0)\\n        {\\n            int a=q.front();\\n            q.pop();\\n            for(int i=0;i<tree[a].size();i++)\\n            {\\n                if(visited[tree[a][i]])\\n                    continue;\\n                visited[tree[a][i]]=true;\\n                if(mp.find({a,tree[a][i]})!=mp.end() && mp[{a,tree[a][i]}]==0  )\\n                {\\n                    mp[{a,tree[a][i]}]=1;\\n                    ans++;\\n                }\\n                if(mp.find({tree[a][i],a })!=mp.end() && mp[{tree[a][i],a}]==1  )\\n                {\\n                    mp[{tree[a][i],a}]=0;\\n                    ans--;\\n                }\\n                q.push(tree[a][i]);\\n            }\\n        }\\n        vector<int> possible(n,-1);\\n        possible[0]= (1?ans>=k:0);\\n        dfs(tree,possible,0,ans,k);\\n        int sum=accumulate(possible.begin(),possible.end(),0);\\n        return sum;\\n    }\\n};\\n```"
    },
    {
        "slug": "buddy-strings",
        "tags": "cpp",
        "release_time": 1688356386,
        "code": "class Solution {\npublic:\n    bool buddyStrings(string s, string p) {\n        int n=s.length(), m=p.length();\n        if(n!=m) return false;\n        \n        vector<int> freq(26,0);\n        \n        int first=-1, second=-1;\n        for(int i=0;i<n;i++){\n            if(s[i] != p[i]){\n                if(first==-1){\n                    first=i;\n                }else if(second==-1){\n                    second=i;\n                }else{\n                    return false; // more than 2 mismatching characters\n                }\n            }\n            freq[s[i]-'a']++;\n        }\n        \n\t\t// similar strings\n        if(first == -1 && second == -1){\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\n            return false; // all characters occur only once\n        }else if(second == -1){\n            return false; // exactly 1 mismatch\n        }\n        \n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    bool buddyStrings(string s, string p) {\\n        int n=s.length(), m=p.length();\\n        if(n!=m) return false;\\n        \\n        vector<int> freq(26,0);\\n        \\n        int first=-1, second=-1;\\n        for(int i=0;i<n;i++){\\n            if(s[i] != p[i]){\\n                if(first==-1){\\n                    first=i;\\n                }else if(second==-1){\\n                    second=i;\\n                }else{\\n                    return false; // more than 2 mismatching characters\\n                }\\n            }\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        \\n\\t\\t// similar strings\\n        if(first == -1 && second == -1){\\n            for(int i=0;i<26;i++) if(freq[i] > 1) return true; // can swap similar characters\\n            return false; // all characters occur only once\\n        }else if(second == -1){\\n            return false; // exactly 1 mismatch\\n        }\\n        \\n        return (s[first]==p[second] && s[second]==p[first]); // check similarity on 2 mismatched indexes\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-smallest-divisor-given-a-threshold",
        "tags": "cpp",
        "release_time": 1691733662,
        "code": "class Solution {\npublic:\n\n    int SumOfDivisor(vector<int>& nums, int Day){\n        int sum = 0;\n        for(int i = 0;i<nums.size();i++){\n            sum += ceil((double)nums[i]/(double)(Day));\n        }\n        return sum;\n    }\n    int smallestDivisor(vector<int>& nums, int threshold) {\n        int maxi = INT_MIN;\n        for(int i = 0;i<nums.size();i++){\n            maxi = max(maxi,nums[i]);\n        }\n        int low = 1,high = maxi,ans = -1;\n        while(low <= high){\n            int mid = (low + high)/2;\n            if(SumOfDivisor(nums,mid) <= threshold){\n                ans = mid;\n                high = mid - 1;\n            }\n            else{\n                low = mid + 1;\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int SumOfDivisor(vector<int>& nums, int Day){\\n        int sum = 0;\\n        for(int i = 0;i<nums.size();i++){\\n            sum += ceil((double)nums[i]/(double)(Day));\\n        }\\n        return sum;\\n    }\\n    int smallestDivisor(vector<int>& nums, int threshold) {\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<nums.size();i++){\\n            maxi = max(maxi,nums[i]);\\n        }\\n        int low = 1,high = maxi,ans = -1;\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            if(SumOfDivisor(nums,mid) <= threshold){\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "closest-prime-numbers-in-range",
        "tags": "cpp",
        "release_time": 1672771904,
        "code": "class Solution \n{\npublic:\n    vector<int> closestPrimes(int left, int right) \n    {\n        //marks all prime number from 2 to right using sieve algorithm\n        vector<int> nums(right+1, 1);\n        for(int i=2; i*i<=right; i++)\n        {\n            if(nums[i]==1)\n            {\n                for(int j=i*i; j<=right; j+=i)\n                    nums[j]=0;\n            }\n        }\n\n        //storing all prime number between left and right\n        vector<int> prime;\n        for(int i=max(2,left); i<=right; i++)\n        {\n            if(nums[i]==1) prime.push_back(i);\n        }\n\n        //finding pair of prime numbers having minimum difference\n        int n1=-1, n2=-1, mini=1e8, diff;\n        for(int i=1; i<prime.size(); i++)\n        {\n            diff = prime[i]-prime[i-1];\n            if(diff < mini)\n            {\n                mini = diff;\n                n1 = prime[i-1];\n                n2 = prime[i];\n            }\n        }\n        return {n1, n2};\n    }\n};",
        "content": "# Intuition\\nWe need to find all prime numbers between range(left, right) using minimum time complexity. \\n\\n# Approach\\nFor finding prime number between left and right range we use sieve algorithm. It takes O(nlog(logn)) time. Then, we find prime number pairs having minimum difference and return them.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(logn))\\n\\n- Space complexity:\\nO(n)\\n\\nwhere n=right value\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> closestPrimes(int left, int right) \\n    {\\n        //marks all prime number from 2 to right using sieve algorithm\\n        vector<int> nums(right+1, 1);\\n        for(int i=2; i*i<=right; i++)\\n        {\\n            if(nums[i]==1)\\n            {\\n                for(int j=i*i; j<=right; j+=i)\\n                    nums[j]=0;\\n            }\\n        }\\n\\n        //storing all prime number between left and right\\n        vector<int> prime;\\n        for(int i=max(2,left); i<=right; i++)\\n        {\\n            if(nums[i]==1) prime.push_back(i);\\n        }\\n\\n        //finding pair of prime numbers having minimum difference\\n        int n1=-1, n2=-1, mini=1e8, diff;\\n        for(int i=1; i<prime.size(); i++)\\n        {\\n            diff = prime[i]-prime[i-1];\\n            if(diff < mini)\\n            {\\n                mini = diff;\\n                n1 = prime[i-1];\\n                n2 = prime[i];\\n            }\\n        }\\n        return {n1, n2};\\n    }\\n};\\n```"
    },
    {
        "slug": "percentage-of-letter-in-string",
        "tags": "cpp",
        "release_time": 1672836042,
        "code": "class Solution {\npublic:\n    int percentageLetter(string s, char letter) {\n        int count = 0;\n        for(int i=0; i<s.length(); i++){\n            if(s[i] == letter){\n                count++;\n            }\n        }\n        int ans = ((count*100)/s.length()); \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int percentageLetter(string s, char letter) {\\n        int count = 0;\\n        for(int i=0; i<s.length(); i++){\\n            if(s[i] == letter){\\n                count++;\\n            }\\n        }\\n        int ans = ((count*100)/s.length()); \\n        return ans;\\n    }\\n}; \\n```"
    },
    {
        "slug": "closest-nodes-queries-in-a-binary-search-tree",
        "tags": "cpp",
        "release_time": 1668964996,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n \nclass Solution {\npublic:\n        void dfs(TreeNode* root, vector<int>& bv){\n            if (root==NULL)return;\n            if (root->left)dfs(root->left,bv);\n            bv.push_back(root->val);\n            if (root->right)dfs(root->right,bv);\n        }\n\t\t\n        int min1(vector<int>& bv, int val){\n            int ans= -1;\n            int i=0; int j= bv.size()-1;\n            while (i<=j){\n                int mid= i+ (j-i)/2;\n                if (val== bv[mid])return val;\n                if (val> bv[mid]){\n                    ans= bv[mid];\n                    i= mid+1;\n                }\n                else j= mid-1;\n            }\n            return ans;\n        }\n\t\t\n    int max1(vector<int>& bv,int val){\n        int ans= -1;\n        int i=0; int j= bv.size()-1;\n        while (i<=j){\n            int mid= i+ (j-i)/2;\n            if (val== bv[mid])return val;\n            if (val < bv[mid]){\n                ans= bv[mid];\n                j= mid-1;\n            }\n            else i= mid+1;\n        }\n        return ans;\n    }\n\t\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        vector<int> bv;\n        vector<vector<int>> ans;\n        //dfs se sorted list banate hai.\n        dfs(root,bv);\n        for (auto q: queries){\n            int lb= min1(bv,q);\n            int ub= max1(bv,q);\n            ans.push_back({lb,ub});\n        }\n        return ans;\n    }\n    \n};",
        "content": "Here is my C++ solution :-\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n        void dfs(TreeNode* root, vector<int>& bv){\\n            if (root==NULL)return;\\n            if (root->left)dfs(root->left,bv);\\n            bv.push_back(root->val);\\n            if (root->right)dfs(root->right,bv);\\n        }\\n\\t\\t\\n        int min1(vector<int>& bv, int val){\\n            int ans= -1;\\n            int i=0; int j= bv.size()-1;\\n            while (i<=j){\\n                int mid= i+ (j-i)/2;\\n                if (val== bv[mid])return val;\\n                if (val> bv[mid]){\\n                    ans= bv[mid];\\n                    i= mid+1;\\n                }\\n                else j= mid-1;\\n            }\\n            return ans;\\n        }\\n\\t\\t\\n    int max1(vector<int>& bv,int val){\\n        int ans= -1;\\n        int i=0; int j= bv.size()-1;\\n        while (i<=j){\\n            int mid= i+ (j-i)/2;\\n            if (val== bv[mid])return val;\\n            if (val < bv[mid]){\\n                ans= bv[mid];\\n                j= mid-1;\\n            }\\n            else i= mid+1;\\n        }\\n        return ans;\\n    }\\n\\t\\n        vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\\n        vector<int> bv;\\n        vector<vector<int>> ans;\\n        //dfs se sorted list banate hai.\\n        dfs(root,bv);\\n        for (auto q: queries){\\n            int lb= min1(bv,q);\\n            int ub= max1(bv,q);\\n            ans.push_back({lb,ub});\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```"
    },
    {
        "slug": "final-value-of-variable-after-performing-operations",
        "tags": "cpp",
        "release_time": 1690653502,
        "code": "class Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int x = 0;\n        for (auto& operation : operations) {\n            if (operation[1] == '+') x++;\n            else x--;\n        }\n        return x;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int finalValueAfterOperations(vector<string>& operations) {\\n        int x = 0;\\n        for (auto& operation : operations) {\\n            if (operation[1] == \\'+\\') x++;\\n            else x--;\\n        }\\n        return x;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-time-to-repair-cars",
        "tags": "cpp",
        "release_time": 1679155662,
        "code": "class Solution {\npublic:\n    long long repairCars(vector<int>& ranks, int cars) {\n        long long int mn = 1, mx = (1e14),mid,ans;\n        while(mn<=mx){\n            mid = (mx-mn)/2+mn;\n            long long int k = 0;\n            for(auto &i: ranks){\n                k += sqrt(mid/i);\n            }\n            if(k==cars){\n                ans = mid;\n                mx = mid-1;\n            }else if(k>cars){\n                ans = mid;\n                mx = mid-1;\n            }else{\n                mn = mid+1;\n            }\n            \n        }\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    long long repairCars(vector<int>& ranks, int cars) {\\n        long long int mn = 1, mx = (1e14),mid,ans;\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            long long int k = 0;\\n            for(auto &i: ranks){\\n                k += sqrt(mid/i);\\n            }\\n            if(k==cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else if(k>cars){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "path-with-maximum-probability",
        "tags": "cpp",
        "release_time": 1687928964,
        "code": "class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        unordered_map<int, vector<pair<int, int>>> graph;\n        \n        // Build the graph using an adjacency list representation\n        // Each edge is represented as a pair (neighbor node, edge index)\n        for (int i = 0; i < edges.size(); i++) {\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\n            graph[u].push_back({v, edgeIdx});\n            graph[v].push_back({u, edgeIdx});\n        }\n        \n        vector<double> probabilities(n, 0.0);\n        probabilities[start] = 1.0;\n        \n        priority_queue<pair<double, int>> nodesToExplore;\n        // Add the start node to the priority queue with probability 1.0\n        nodesToExplore.push({1.0, start});\n        \n        while (!nodesToExplore.empty()) {\n            auto [prob, u] = nodesToExplore.top();\n            nodesToExplore.pop();\n            \n            // If we've reached the end node, return the probability\n            if (u == end) \n                return prob;\n            // If we've already explored this node with a higher probability, skip it\n            if (probabilities[u] > prob) \n                continue;\n                \n            // Explore the neighbors of the current node\n            for (auto [v, edgeIdx] : graph[u]) {\n                double newProb = prob * succProb[edgeIdx];\n                \n                // Update the probability of the neighbor node if we've found a higher probability\n                if (newProb > probabilities[v]) {\n                    probabilities[v] = newProb;\n                    \n                    // Add the neighbor node to the priority queue with its new probability\n                    nodesToExplore.push({newProb, v});\n                }\n            }\n        }\n        \n        // If we've explored all nodes and haven't reached the end node, return 0.0\n        return 0.0;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\\n        unordered_map<int, vector<pair<int, int>>> graph;\\n        \\n        // Build the graph using an adjacency list representation\\n        // Each edge is represented as a pair (neighbor node, edge index)\\n        for (int i = 0; i < edges.size(); i++) {\\n            int u = edges[i][0], v = edges[i][1], edgeIdx = i;\\n            graph[u].push_back({v, edgeIdx});\\n            graph[v].push_back({u, edgeIdx});\\n        }\\n        \\n        vector<double> probabilities(n, 0.0);\\n        probabilities[start] = 1.0;\\n        \\n        priority_queue<pair<double, int>> nodesToExplore;\\n        // Add the start node to the priority queue with probability 1.0\\n        nodesToExplore.push({1.0, start});\\n        \\n        while (!nodesToExplore.empty()) {\\n            auto [prob, u] = nodesToExplore.top();\\n            nodesToExplore.pop();\\n            \\n            // If we\\'ve reached the end node, return the probability\\n            if (u == end) \\n                return prob;\\n            // If we\\'ve already explored this node with a higher probability, skip it\\n            if (probabilities[u] > prob) \\n                continue;\\n                \\n            // Explore the neighbors of the current node\\n            for (auto [v, edgeIdx] : graph[u]) {\\n                double newProb = prob * succProb[edgeIdx];\\n                \\n                // Update the probability of the neighbor node if we\\'ve found a higher probability\\n                if (newProb > probabilities[v]) {\\n                    probabilities[v] = newProb;\\n                    \\n                    // Add the neighbor node to the priority queue with its new probability\\n                    nodesToExplore.push({newProb, v});\\n                }\\n            }\\n        }\\n        \\n        // If we\\'ve explored all nodes and haven\\'t reached the end node, return 0.0\\n        return 0.0;\\n    }\\n};\\n```"
    },
    {
        "slug": "intervals-between-identical-elements",
        "tags": "cpp",
        "release_time": 1687245473,
        "code": "class Solution {\npublic:\n    vector<long long> getDistances(vector<int>& arr) {\n        \n        int n = arr.size();\n        vector<long long> ans(n);\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\n\n        for(int i = 0;i<n;i++)\n        {\n           sum[arr[i]]+=i;\n           freq[arr[i]]++;\n        }\n\n        for(int i = 0;i<n;i++)\n        {\n           currfreq[arr[i]]++;\n           currsum[arr[i]]+=i;\n\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\n        }\n        return ans;\n    }\n};",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Approach-1:** Brute Force Approach Using Hash Table Looks Easy but it is not efficient solution it gives TLE.\\n**Approach-2:** to optmize the brute force, Break Dawn the Brute Force into **Current (SUM & FREQUENCY)** and **Remaining (SUM & FREQUENCY**) \\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> getDistances(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        vector<long long> ans(n);\\n        unordered_map<long long,long long> sum,freq,currfreq,currsum;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           sum[arr[i]]+=i;\\n           freq[arr[i]]++;\\n        }\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           currfreq[arr[i]]++;\\n           currsum[arr[i]]+=i;\\n\\n           long long currfrq = currfreq[arr[i]]-1,remfreq = freq[arr[i]]-currfreq[arr[i]];\\n           long long currsumval = currsum[arr[i]],remsum = sum[arr[i]]-currsum[arr[i]];\\n           ans[i] =  abs(i*currfrq-(currsumval-i))+abs(i*remfreq-remsum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/ef1866bf-43d6-4c44-877f-d7106d457c67_1687245465.1707878.jpeg)\\n"
    },
    {
        "slug": "find-good-days-to-rob-the-bank",
        "tags": "cpp",
        "release_time": 1664208035,
        "code": "class Solution {\npublic:\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\n        \n        int n = arr.size();\n        \n        // left[i] will store the length of increasing subarray including arr[i] on left side\n        \n        vector<int> left(n, 1);\n        \n        // fill left array\n        \n        for(int i = 1; i < n; i++)\n        {\n            if(arr[i] <= arr[i - 1])\n            {\n                left[i] = left[i - 1] + 1;\n            }\n        }\n        \n        // right[i] will store the length of increasing subarray including arr[i] on right side\n        \n        vector<int> right(n, 1);\n        \n        // fill right array\n        \n        for(int i = n - 2; i >= 0; i--)\n        {\n            if(arr[i] <= arr[i + 1])\n            {\n                right[i] = right[i + 1] + 1;\n            }\n        }\n        \n        // push the possible index into res\n        \n        vector<int> res;\n        \n        for(int i = k; i <= n - k - 1; i++)\n        {\n            if(left[i] >= k + 1 && right[i] >= k + 1)\n            {\n                res.push_back(i);\n            }\n        }\n        \n        return res;\n    }\n};",
        "content": "* ***Precalculate***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> goodDaysToRobBank(vector<int>& arr, int k) {\\n        \\n        int n = arr.size();\\n        \\n        // left[i] will store the length of increasing subarray including arr[i] on left side\\n        \\n        vector<int> left(n, 1);\\n        \\n        // fill left array\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(arr[i] <= arr[i - 1])\\n            {\\n                left[i] = left[i - 1] + 1;\\n            }\\n        }\\n        \\n        // right[i] will store the length of increasing subarray including arr[i] on right side\\n        \\n        vector<int> right(n, 1);\\n        \\n        // fill right array\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            if(arr[i] <= arr[i + 1])\\n            {\\n                right[i] = right[i + 1] + 1;\\n            }\\n        }\\n        \\n        // push the possible index into res\\n        \\n        vector<int> res;\\n        \\n        for(int i = k; i <= n - k - 1; i++)\\n        {\\n            if(left[i] >= k + 1 && right[i] >= k + 1)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-subarray-to-be-removed-to-make-array-sorted",
        "tags": "cpp",
        "release_time": 1678913689,
        "code": "class Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n\n        int n =(int) arr.size();\n        int h = n-1 , l=0 ;\n        \n        \n        \n        for(int i=h;i>=1;i--)  \n        {\n            if(arr[i]>=arr[i-1] && h>0)\n            {\n                h--;\n            }\n            else break;\n        }\n\n        int res=h;\n\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\n       {\n             \n             while(h<n && arr[l]>arr[h])\n              {\n                 h++;\n              }\n\n\n           res = min(res,h-l-1);\n\n        \n           \n       }\n      return res;\n\n        \n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n\\n        int n =(int) arr.size();\\n        int h = n-1 , l=0 ;\\n        \\n        \\n        \\n        for(int i=h;i>=1;i--)  \\n        {\\n            if(arr[i]>=arr[i-1] && h>0)\\n            {\\n                h--;\\n            }\\n            else break;\\n        }\\n\\n        int res=h;\\n\\n       for( l=0 ; l<h && (l==0 || arr[l-1]<=arr[l])  ;l++)\\n       {\\n             \\n             while(h<n && arr[l]>arr[h])\\n              {\\n                 h++;\\n              }\\n\\n\\n           res = min(res,h-l-1);\\n\\n        \\n           \\n       }\\n      return res;\\n\\n        \\n        \\n    }\\n};\\n```\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n\\n    bool checker(vector<int> &arr,vector<int> &pref ,vector<int> &suff , int lo,int mid)\\n    {\\n        int n= (int)arr.size();\\n        bool ff =true;\\n        int hi = lo+mid-1;\\n        if(lo-1>=0 && pref[lo-1]==0) return false;\\n        if(hi+1<n && suff[hi+1]==0) return false;\\n        if(lo-1>=0 && hi+1<n && arr[lo-1]>arr[hi+1] ) return false;\\n        return true;\\n    }\\n    int findLengthOfShortestSubarray(vector<int>& arr) {\\n    \\n       int n = (int)arr.size();\\n       int ans=n;\\n       vector<int> pref(n,0),suff(n,0);\\n       pref[0]=1,suff[n-1]=1;\\n       for(int i=1;i<n;i++)\\n       {\\n           if(arr[i]>=arr[i-1] && pref[i-1]==1) pref[i]=1;\\n       }\\n\\n       for(int i=n-2;i>=0;i--)\\n       {\\n           if(arr[i]<=arr[i+1] && suff[i+1]==1) suff[i]=1;\\n       }\\n\\n       for(int i=0;i<n;i++)\\n       {\\n           int lo=0,hi=n;\\n           while(lo<=hi)\\n           {\\n               int mid = (lo+hi)/2;\\n               if(checker(arr,pref,suff,i,mid))\\n               {\\n                   ans = min(ans,mid);\\n                   hi =mid-1;\\n               }\\n               else lo = mid+1;\\n           }\\n       }\\n\\n       return ans;\\n    }\\n};\\n```\\n![4of9h0.jpg](https://assets.leetcode.com/users/images/d5a48e00-497f-4da5-b25d-ca6650410462_1678915207.8747983.jpeg)\\n\\n\\n```"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "tags": "cpp",
        "release_time": 1673405367,
        "code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int v[26];\n        memset(v,-1,sizeof v);\n        int ans=-1;\n        for(int i=0;i<s.size();i++){\n            if(v[s[i]-'a']==-1){\n                v[s[i]-'a']=i;\n            }\n            int res=i-v[s[i]-'a']-1;\n            ans=max(ans,res);\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxLengthBetweenEqualCharacters(string s) {\\n        int v[26];\\n        memset(v,-1,sizeof v);\\n        int ans=-1;\\n        for(int i=0;i<s.size();i++){\\n            if(v[s[i]-\\'a\\']==-1){\\n                v[s[i]-\\'a\\']=i;\\n            }\\n            int res=i-v[s[i]-\\'a\\']-1;\\n            ans=max(ans,res);\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-all-possible-routes",
        "tags": "cpp",
        "release_time": 1687678873,
        "code": "class Solution {\n    private:\n    int mod = 7+1e9;\npublic:\n    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\n        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));\n        return solve(locations, start, finish, fuel, dp);\n    }\n\n    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)\n    {\n        int ans = 0;\n        if(current == finish)\n        {\n            ans = 1;\n        }\n        if(currentfuel == 0)\n        {\n            return ans;\n        }\n        if(dp[current][currentfuel] != -1)\n        {\n            return dp[current][currentfuel];\n        }\n        for(int i = 0;i < locations.size(); i++)\n        {\n            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)\n            {\n                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;\n            }\n        }\n        return dp[current][currentfuel] = ans%mod;\n    }\n};",
        "content": "# Intuition\\nWe have to count all possible routes and from any city we can go to all other cities so intution is to apply dynamic programming.\\n\\n# Approach\\nWe\\'ll maintain two changing variable at any recursion call. One will be the current city we are in and another will be current fuel that we have. We\\'ll intialize a variable ans which will be 0 if the current city is not the finish city. However if the current city is finish city then we initialize the ans variable to 1 as that path should be added to answer. Then  we\\'ll run a loop from city 0 to city 1 and if the city i is not equal to current city and if current fuel is more than the fuel needed to travel between those two cities then we\\'ll make a recursion call and add that answer from recursion call to the ans variable. In the end we\\'ll return ans variable.\\n\\nHowever we\\'ll have to memoize this solution because it will lead to repetitive recursion calls. For example we\\'ll be able to reach a particular city with multiple paths and be left with same fuel. So this will lead to repetitive calls. COnsider this array [1,2,3,5] and fuel = 10 and start city as 0. SO we\\'ll be able to reach city 2 via city 0->1->2 and left with 8 unit fuel. We can also reach city 2 via 0->2 and left with fuel 8. THis will lead to repetitive calls.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    int mod = 7+1e9;\\npublic:\\n    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\\n        vector<vector<int>>dp(locations.size()+1, vector<int>(fuel+1, -1));\\n        return solve(locations, start, finish, fuel, dp);\\n    }\\n\\n    int solve(vector<int>& locations, int current, int& finish, int currentfuel, vector<vector<int>>& dp)\\n    {\\n        int ans = 0;\\n        if(current == finish)\\n        {\\n            ans = 1;\\n        }\\n        if(currentfuel == 0)\\n        {\\n            return ans;\\n        }\\n        if(dp[current][currentfuel] != -1)\\n        {\\n            return dp[current][currentfuel];\\n        }\\n        for(int i = 0;i < locations.size(); i++)\\n        {\\n            if(i != current && (currentfuel - abs(locations[current]-locations[i])) >= 0)\\n            {\\n                ans = (ans + (solve(locations, i, finish, currentfuel-abs(locations[current]-locations[i]), dp))%mod)%mod;\\n            }\\n        }\\n        return dp[current][currentfuel] = ans%mod;\\n    }\\n};\\n```\\n\\n**Do upvote if you understood it !\\uD83D\\uDE00**"
    },
    {
        "slug": "as-far-from-land-as-possible",
        "tags": "cpp",
        "release_time": 1676050875,
        "code": "class Solution {\npublic:\n    bool isallsame(vector<vector<int>>&grid)\n    {\n        int compare=grid[0][0];\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j]!=compare)\n                {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    int maxDistance(vector<vector<int>>&grid) \n    {\n        if(isallsame(grid))\n        {\n            return -1;\n        }\n        vector<bool>a(grid[0].size(),false);\n        vector<int>b(grid[0].size(),0);\n        vector<vector<bool>>pushedinqueue(grid.size(),a);\n        vector<vector<int>>distance(grid.size(),b);\n        //BFS\n        queue<pair<int,int>>visit;\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j])\n                {\n                    visit.push({i,j});\n                    pushedinqueue[i][j]=true;\n                }\n            }\n        }\n        int dist=0;\n        while(!visit.empty())\n        {\n            int n=visit.size();\n            for(int i=0;i<n;i++)\n            {\n                pair<int,int>x=visit.front();\n                visit.pop();\n                distance[x.first][x.second]=dist;\n                if(x.first>0 && !pushedinqueue[x.first-1][x.second])\n                {\n                    pushedinqueue[x.first-1][x.second]=true;\n                    visit.push({x.first-1,x.second});\n                }\n                if(x.first<(grid.size()-1) && !pushedinqueue[x.first+1][x.second])\n                {\n                    pushedinqueue[x.first+1][x.second]=true;\n                    visit.push({x.first+1,x.second});\n                }\n                if(x.second>0 && !pushedinqueue[x.first][x.second-1])\n                {\n                    pushedinqueue[x.first][x.second-1]=true;\n                    visit.push({x.first,x.second-1});\n                }\n                if(x.second<(grid[0].size()-1) && !pushedinqueue[x.first][x.second+1])\n                {\n                    pushedinqueue[x.first][x.second+1]=true;\n                    visit.push({x.first,x.second+1});\n                }\n            }\n            dist++;\n        }\n        int ans=INT_MIN;\n        for(int i=0;i<grid.size();i++)\n        {\n            for(int j=0;j<grid[0].size();j++)\n            {\n                if(grid[i][j]==0)\n                {\n                    ans=max(ans,distance[i][j]);\n                }\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isallsame(vector<vector<int>>&grid)\\n    {\\n        int compare=grid[0][0];\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]!=compare)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maxDistance(vector<vector<int>>&grid) \\n    {\\n        if(isallsame(grid))\\n        {\\n            return -1;\\n        }\\n        vector<bool>a(grid[0].size(),false);\\n        vector<int>b(grid[0].size(),0);\\n        vector<vector<bool>>pushedinqueue(grid.size(),a);\\n        vector<vector<int>>distance(grid.size(),b);\\n        //BFS\\n        queue<pair<int,int>>visit;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    visit.push({i,j});\\n                    pushedinqueue[i][j]=true;\\n                }\\n            }\\n        }\\n        int dist=0;\\n        while(!visit.empty())\\n        {\\n            int n=visit.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                pair<int,int>x=visit.front();\\n                visit.pop();\\n                distance[x.first][x.second]=dist;\\n                if(x.first>0 && !pushedinqueue[x.first-1][x.second])\\n                {\\n                    pushedinqueue[x.first-1][x.second]=true;\\n                    visit.push({x.first-1,x.second});\\n                }\\n                if(x.first<(grid.size()-1) && !pushedinqueue[x.first+1][x.second])\\n                {\\n                    pushedinqueue[x.first+1][x.second]=true;\\n                    visit.push({x.first+1,x.second});\\n                }\\n                if(x.second>0 && !pushedinqueue[x.first][x.second-1])\\n                {\\n                    pushedinqueue[x.first][x.second-1]=true;\\n                    visit.push({x.first,x.second-1});\\n                }\\n                if(x.second<(grid[0].size()-1) && !pushedinqueue[x.first][x.second+1])\\n                {\\n                    pushedinqueue[x.first][x.second+1]=true;\\n                    visit.push({x.first,x.second+1});\\n                }\\n            }\\n            dist++;\\n        }\\n        int ans=INT_MIN;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    ans=max(ans,distance[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "number-of-black-blocks",
        "tags": "cpp",
        "release_time": 1688884502,
        "code": "class Solution {\npublic:\nvector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {\n        vector<long long> ans(5,0);\n        int sz=cds.size();\n        set<pair<int,int>> s,black;\n        for(int i=0;i<sz;++i){\n            black.insert({cds[i][0],cds[i][1]});\n        }\n        for(int i=0;i<sz;++i){\n            int x=cds[i][0],y=cds[i][1];\n            // it can cover four squares\n            // case 1\n            if(x>0&&y>0){\n                bool flag=true;\n                int cnt=0;\n                for(int dx=-1;dx<=0;++dx){\n                    for(int dy=-1;dy<=0;++dy){\n                        if(s.find({x+dx,y+dy})==s.end()){\n                            if(black.find({x+dx,y+dy})!=black.end()){\n                                cnt++;\n                            } \n                        } else{\n                            flag=false;\n                            break;\n                        } \n                    }\n                }\n                if(flag){\n                    ans[cnt]++;\n                }\n            }\n            // case 2\n            if(x<m-1&&y>0){\n                bool flag=true;\n                int cnt=0;\n                for(int dx=0;dx<=1;++dx){\n                    for(int dy=-1;dy<=0;++dy){\n                        if(s.find({x+dx,y+dy})==s.end()){\n                            if(black.find({x+dx,y+dy})!=black.end()){\n                                cnt++;\n                            }\n                        } else{\n                            flag=false;\n                            break;\n                        } \n                    }\n                }\n                if(flag){\n                    ans[cnt]++;\n                }\n            }\n            // case 3\n            if(x>0&&y<n-1){\n                bool flag=true;\n                int cnt=0;\n                for(int dx=-1;dx<=0;++dx){\n                    for(int dy=0;dy<=1;++dy){\n                        if(s.find({x+dx,y+dy})==s.end()){\n                            if(black.find({x+dx,y+dy})!=black.end()){\n                                cnt++;\n                            } \n                        } else{\n                            flag=false;\n                            break;\n                        } \n                    }\n                }\n                if(flag){\n                    ans[cnt]++;\n                }\n            }\n            // case 4\n            if(x<m-1&&y<n-1){\n                bool flag=true;\n                int cnt=0;\n                for(int dx=0;dx<=1;++dx){\n                    for(int dy=0;dy<=1;++dy){\n                        if(s.find({x+dx,y+dy})==s.end()){\n                            if(black.find({x+dx,y+dy})!=black.end()){\n                                cnt++;\n                            }\n                        } else{\n                            flag=false;\n                            break;\n                        } \n                    }\n                }\n                if(flag){\n                    ans[cnt]++;\n                }\n            }\n            // put in set\n            s.insert({x,y});\n        }\n        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a Black colored coordinate it can cover at max 4 blocks only, so we will see 4 blocks for each coordinate element, while taking care that the block is not previously visited\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First Put All coordinates in a set named \"black\" and an empty set \"s\", then traverse coordinates\\n2) For each coordinate[x,y], check all 4 blocks(at max) if a block is not previously visited(we use set \"s\" for it) we count number of black coordinate(using set \"black\") in a block then update it in \"ans\"(answer vector)\\n3) For block with 0 black coordinate preset we update \"ans\" at the end. i.e ans[0]=(m-1)*(n-1)-(blocks with 1-4 black coordinate).\\n**As mxn grid has (m-1)*(n-1) => 2x2 blocks\\n\\nNote: We can also use unordered_set but you have to define Hash Function for itbecause by default, C++ doesn\\'t allow us to create an unordered set of pairs directly but one can pass a hash function to the unordered set container. \\n\\n# Complexity\\n- Time complexity:(coordinates.length*log(coordinates.length))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(coordinates.length)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> countBlackBlocks(int m, int n, vector<vector<int>>& cds) {\\n        vector<long long> ans(5,0);\\n        int sz=cds.size();\\n        set<pair<int,int>> s,black;\\n        for(int i=0;i<sz;++i){\\n            black.insert({cds[i][0],cds[i][1]});\\n        }\\n        for(int i=0;i<sz;++i){\\n            int x=cds[i][0],y=cds[i][1];\\n            // it can cover four squares\\n            // case 1\\n            if(x>0&&y>0){\\n                bool flag=true;\\n                int cnt=0;\\n                for(int dx=-1;dx<=0;++dx){\\n                    for(int dy=-1;dy<=0;++dy){\\n                        if(s.find({x+dx,y+dy})==s.end()){\\n                            if(black.find({x+dx,y+dy})!=black.end()){\\n                                cnt++;\\n                            } \\n                        } else{\\n                            flag=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    ans[cnt]++;\\n                }\\n            }\\n            // case 2\\n            if(x<m-1&&y>0){\\n                bool flag=true;\\n                int cnt=0;\\n                for(int dx=0;dx<=1;++dx){\\n                    for(int dy=-1;dy<=0;++dy){\\n                        if(s.find({x+dx,y+dy})==s.end()){\\n                            if(black.find({x+dx,y+dy})!=black.end()){\\n                                cnt++;\\n                            }\\n                        } else{\\n                            flag=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    ans[cnt]++;\\n                }\\n            }\\n            // case 3\\n            if(x>0&&y<n-1){\\n                bool flag=true;\\n                int cnt=0;\\n                for(int dx=-1;dx<=0;++dx){\\n                    for(int dy=0;dy<=1;++dy){\\n                        if(s.find({x+dx,y+dy})==s.end()){\\n                            if(black.find({x+dx,y+dy})!=black.end()){\\n                                cnt++;\\n                            } \\n                        } else{\\n                            flag=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    ans[cnt]++;\\n                }\\n            }\\n            // case 4\\n            if(x<m-1&&y<n-1){\\n                bool flag=true;\\n                int cnt=0;\\n                for(int dx=0;dx<=1;++dx){\\n                    for(int dy=0;dy<=1;++dy){\\n                        if(s.find({x+dx,y+dy})==s.end()){\\n                            if(black.find({x+dx,y+dy})!=black.end()){\\n                                cnt++;\\n                            }\\n                        } else{\\n                            flag=false;\\n                            break;\\n                        } \\n                    }\\n                }\\n                if(flag){\\n                    ans[cnt]++;\\n                }\\n            }\\n            // put in set\\n            s.insert({x,y});\\n        }\\n        ans[0]=(m-1)*1ll*(n-1)-ans[1]-ans[2]-ans[3]-ans[4];\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "tags": "cpp",
        "release_time": 1686902755,
        "code": "class Solution {\npublic:\n    unordered_map<int, int> m; int ml = -1; \n    void fun( vector<int> &nums, int val, int pos){\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\n        fun(nums, val, pos+1); \n       val  = val | nums[pos]; \n        fun(nums, val, pos+1); \n    }\n\n    int countMaxOrSubsets(vector<int>& nums) {\n        fun(nums,0, 0 ); \n\n        return m[ml]; \n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet every possible sub sequence calculate frequency of each sequence, return freq of max value \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntraverse through vector of int, at each position add and not add the number at position, when it reaches the end increase frequency of that value, and maintain a var to store max value. return the frequency of max value\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you like it \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> m; int ml = -1; \\n    void fun( vector<int> &nums, int val, int pos){\\n        if(nums.size() == pos) {if(ml < val) ml = val;   m[val]++; return; }\\n        fun(nums, val, pos+1); \\n       val  = val | nums[pos]; \\n        fun(nums, val, pos+1); \\n    }\\n\\n    int countMaxOrSubsets(vector<int>& nums) {\\n        fun(nums,0, 0 ); \\n\\n        return m[ml]; \\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-incompatibility",
        "tags": "cpp",
        "release_time": 1682291828,
        "code": "class Solution {\npublic:\n    const int inf = 0x3f3f3f3f;\n    int minimumIncompatibility(vector<int>& nums, int k) {\n      int n = nums.size();\n      int sz = n/k; // size of every group\n      //dp(mask, i) select mask, pre select i\n      //if (bit set of mask) == sz, select first available\n      //else select first after i available\n      sort(nums.begin(), nums.end());\n      int dp[1<<n][n];\n      memset(dp, inf, sizeof(dp));\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\n      for (int m = 0; m < (1<<n)-1; ++m) {\n        int cnt = __builtin_popcount(m);\n        for (int i = 0; i < n; ++i) {\n          if (dp[m][i] == inf) { continue; }\n          if (cnt%sz == 0) {\n            int j = __builtin_ffs(~m)-1;\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\n          } else {\n            for (int j = i+1; j < n; ++j) {\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\n            }\n          }\n        }\n      }\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int inf = 0x3f3f3f3f;\\n    int minimumIncompatibility(vector<int>& nums, int k) {\\n      int n = nums.size();\\n      int sz = n/k; // size of every group\\n      //dp(mask, i) select mask, pre select i\\n      //if (bit set of mask) == sz, select first available\\n      //else select first after i available\\n      sort(nums.begin(), nums.end());\\n      int dp[1<<n][n];\\n      memset(dp, inf, sizeof(dp));\\n      for (int i = 0; i < n; ++i) { dp[0][i] = 0; }\\n      for (int m = 0; m < (1<<n)-1; ++m) {\\n        int cnt = __builtin_popcount(m);\\n        for (int i = 0; i < n; ++i) {\\n          if (dp[m][i] == inf) { continue; }\\n          if (cnt%sz == 0) {\\n            int j = __builtin_ffs(~m)-1;\\n            dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]);\\n          } else {\\n            for (int j = i+1; j < n; ++j) {\\n              if (m&(1<<j) || nums[j] == nums[i]) { continue; }\\n              dp[m|(1<<j)][j] = min(dp[m|(1<<j)][j],dp[m][i]+nums[j]-nums[i]);\\n            }\\n          }\\n        }\\n      }\\n      return dp[(1<<n)-1][n-1] == inf? -1: dp[(1<<n)-1][n-1];\\n    }\\n};\\n```"
    },
    {
        "slug": "group-anagrams",
        "tags": "cpp",
        "release_time": 1690927060,
        "code": "class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string,int> m;\n        vector<vector<string>> ans;\n        for(int i=0; i<strs.size(); i++) {\n            string str = strs[i];\n            sort(str.begin(),str.end());\n\n            if(m.find(str) != m.end()) {\n                ans[m[str]].push_back(strs[i]);\n            }\n            else {\n                m[str] = ans.size(); \n                ans.push_back({strs[i]});\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\\n        unordered_map<string,int> m;\\n        vector<vector<string>> ans;\\n        for(int i=0; i<strs.size(); i++) {\\n            string str = strs[i];\\n            sort(str.begin(),str.end());\\n\\n            if(m.find(str) != m.end()) {\\n                ans[m[str]].push_back(strs[i]);\\n            }\\n            else {\\n                m[str] = ans.size(); \\n                ans.push_back({strs[i]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "trapping-rain-water",
        "tags": "cpp",
        "release_time": 1692193935,
        "code": "class Solution {\npublic:\n    \n    int trap(vector<int>& height) {\n        \n        // brute force\n        // int ans = 0;\n        // int size = height.size();\n        // for (int i = 1; i < size - 1; i++) {\n        //     int left_max = 0, right_max = 0;\n        //     for (int j = i; j >= 0; j--) { //Search the left part for max bar size\n        //         left_max = max(left_max, height[j]);\n        //     }\n        //     for (int j = i; j < size; j++) { //Search the right part for max bar size\n        //         right_max = max(right_max, height[j]);\n        //     }\n        //     ans += min(left_max, right_max) - height[i];\n        // }\n        // return ans;\n\n        // optimal \n\n        int n = height.size();\n        int left = 0,right = n-1;\n        int res = 0;\n        int left_max = 0,right_max = 0;\n\n        while(left <= right){\n            if(height[left] <= height[right]){\n                if(height[left] >= left_max){\n                    left_max = height[left];\n                }\n                else{\n                    res += left_max - height[left];\n                }\n                left++;\n            }\n            else{\n                if(height[right] >= right_max){\n                    right_max = height[right];\n                }\n                else{\n                    res += right_max - height[right];\n                }\n                right--;\n            }\n        }\n        return res;\n\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int trap(vector<int>& height) {\\n        \\n        // brute force\\n        // int ans = 0;\\n        // int size = height.size();\\n        // for (int i = 1; i < size - 1; i++) {\\n        //     int left_max = 0, right_max = 0;\\n        //     for (int j = i; j >= 0; j--) { //Search the left part for max bar size\\n        //         left_max = max(left_max, height[j]);\\n        //     }\\n        //     for (int j = i; j < size; j++) { //Search the right part for max bar size\\n        //         right_max = max(right_max, height[j]);\\n        //     }\\n        //     ans += min(left_max, right_max) - height[i];\\n        // }\\n        // return ans;\\n\\n        // optimal \\n\\n        int n = height.size();\\n        int left = 0,right = n-1;\\n        int res = 0;\\n        int left_max = 0,right_max = 0;\\n\\n        while(left <= right){\\n            if(height[left] <= height[right]){\\n                if(height[left] >= left_max){\\n                    left_max = height[left];\\n                }\\n                else{\\n                    res += left_max - height[left];\\n                }\\n                left++;\\n            }\\n            else{\\n                if(height[right] >= right_max){\\n                    right_max = height[right];\\n                }\\n                else{\\n                    res += right_max - height[right];\\n                }\\n                right--;\\n            }\\n        }\\n        return res;\\n\\n    }\\n};\\n```"
    },
    {
        "slug": "reverse-odd-levels-of-binary-tree",
        "tags": "cpp",
        "release_time": 1665040875,
        "code": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int x = 1,n,i,z;\n        vector<TreeNode*> tmp;\n        TreeNode* node;\n        while(!q.empty()){\n            tmp.clear();\n            n = q.size();\n            // cout<<n<<\" \";\n            while(n--){\n                node = q.front();q.pop();\n                // cout<<node->val<<\" \";\n                if(x==0){\n                    tmp.push_back(node);\n                }\n                if(node->left)\n                    q.push(node->left);\n                if(node->right){\n                    q.push(node->right);\n                }\n            }\n            n = tmp.size();\n            for(i = 0; i < n/2; i++){\n                z = tmp[i]->val;\n                tmp[i]->val = tmp[n-1-i]->val;\n                tmp[n-1-i]->val = z;\n            }\n            x ^= 1;\n            n = 0;\n        }\n        return root;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* reverseOddLevels(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int x = 1,n,i,z;\\n        vector<TreeNode*> tmp;\\n        TreeNode* node;\\n        while(!q.empty()){\\n            tmp.clear();\\n            n = q.size();\\n            // cout<<n<<\" \";\\n            while(n--){\\n                node = q.front();q.pop();\\n                // cout<<node->val<<\" \";\\n                if(x==0){\\n                    tmp.push_back(node);\\n                }\\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right){\\n                    q.push(node->right);\\n                }\\n            }\\n            n = tmp.size();\\n            for(i = 0; i < n/2; i++){\\n                z = tmp[i]->val;\\n                tmp[i]->val = tmp[n-1-i]->val;\\n                tmp[n-1-i]->val = z;\\n            }\\n            x ^= 1;\\n            n = 0;\\n        }\\n        return root;\\n    }\\n};\\n```"
    },
    {
        "slug": "is-graph-bipartite",
        "tags": "cpp",
        "release_time": 1684525813,
        "code": "class Solution {\npublic:\n    //graph coloring\n\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\n    bool flag = false;\n\n    //dfs traversal\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\n    {\n\n        //color the current node\n        color[ind]=currcolor;\n\n\n        for(auto it: graph[ind])\n        {\n\n            //if a neighbour node is not coloured yet then color it with opposite color \n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\n\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\n            else if(color[it] == currcolor)\n            {\n                flag=true;\n                return;\n            }\n        }\n    }\n    bool isBipartite(vector<vector<int>>& graph) {\n        \n        //no of nodes in graph\n        int n = graph.size();\n        \n        //coloring array\n        vector<int> color(n, 0);\n\n        for(int i=0; i<graph.size(); i++)\n        {\n            //if a uncolored node in encountered then color it and it's corresponding uncoloured neighbouring node\n            if(color[i]==0) dfs(i, graph, color, 1);\n\n            //if flag got turned on then making this graph bipartite is not possible\n            if(flag) return false;\n        }\n\n        return true;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor making a graph bipartite any two of it\\'s adjacent node should come under two different sections.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Denoting two different section as two different colors (here, 1 & -1).\\n- Implementing dfs and start coloring the graph.\\n- Coloring every adjacent node of current node with opposite color of current node.\\n- If two adjacent nodes are encountered with same colour then return false, because in this case making this graph bipartite is not possible.\\n- If whole graph is coloured, then this graph can be bipartite, so return true.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //graph coloring\\n\\n    //flag variable, to be turned on when an error of two neighbouring nodes having same colour is detected\\n    bool flag = false;\\n\\n    //dfs traversal\\n    void dfs(int ind, vector<vector<int>>& graph, vector<int>& color, int currcolor)\\n    {\\n\\n        //color the current node\\n        color[ind]=currcolor;\\n\\n\\n        for(auto it: graph[ind])\\n        {\\n\\n            //if a neighbour node is not coloured yet then color it with opposite color \\n            if(color[it] == 0) dfs(it, graph, color, currcolor*(-1));\\n\\n            //if a neighbour node is already coloured then it should have opposite colour what current node is having right now\\n            //else if a neighbour have same colour then making this graph a bipartite is not possible\\n            else if(color[it] == currcolor)\\n            {\\n                flag=true;\\n                return;\\n            }\\n        }\\n    }\\n    bool isBipartite(vector<vector<int>>& graph) {\\n        \\n        //no of nodes in graph\\n        int n = graph.size();\\n        \\n        //coloring array\\n        vector<int> color(n, 0);\\n\\n        for(int i=0; i<graph.size(); i++)\\n        {\\n            //if a uncolored node in encountered then color it and it\\'s corresponding uncoloured neighbouring node\\n            if(color[i]==0) dfs(i, graph, color, 1);\\n\\n            //if flag got turned on then making this graph bipartite is not possible\\n            if(flag) return false;\\n        }\\n\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram",
        "tags": "cpp",
        "release_time": 1678804304,
        "code": "class Solution {\npublic:\n\n    vector<int> mapping(string s)\n    {\n        vector<int> v(26, 0);\n        for (int i = 0; i < s.size(); i++)\n            v[s[i] - 'a']++;\n        return v;\n    }\n\n    int minSteps(string s, string t) {\n\n    vector<int> mapping1 = mapping(s);\n    vector<int> mapping2 = mapping(t);\n    int count = 0;\n    for (int i = 0; i < 26; i++)\n    {\n        int diff = 0;\n        if (mapping1[i] != 0)\n            if (mapping1[i] > mapping2[i])\n                diff = mapping1[i] - mapping2[i];\n        count += diff;\n    }\n    return count;\n        \n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> mapping(string s)\\n    {\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            v[s[i] - \\'a\\']++;\\n        return v;\\n    }\\n\\n    int minSteps(string s, string t) {\\n\\n    vector<int> mapping1 = mapping(s);\\n    vector<int> mapping2 = mapping(t);\\n    int count = 0;\\n    for (int i = 0; i < 26; i++)\\n    {\\n        int diff = 0;\\n        if (mapping1[i] != 0)\\n            if (mapping1[i] > mapping2[i])\\n                diff = mapping1[i] - mapping2[i];\\n        count += diff;\\n    }\\n    return count;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "flip-binary-tree-to-match-preorder-traversal",
        "tags": "cpp",
        "release_time": 1659184135,
        "code": "class Solution {\npublic:\n    \n    bool helper(int &ind, TreeNode *root, vector<int> &voyage, vector<int> &ans){\n        if(root == NULL || ind == voyage.size()){\n            ind--;\n            return true;\n        }\n        \n        // Not possible to create \n        if(root->val != voyage[ind]){\n            ans.clear();\n            ans.push_back(-1);\n            return false;\n        }\n        \n        // If voyage value not equal to its left child, then swap both childs and check\n        if(root->left && root->left->val != voyage[ind+1]){\n\t\t\tTreeNode *temp = root->left;\n\t\t\troot->left = root->right;\n\t\t\troot->right = temp;\n\t\t\t\n\t\t\t// Pusing root into ans\n\t\t\tans.push_back(root->val);\n        }\n        \n        return helper(++ind, root->left, voyage, ans) &&\n            helper(++ind, root->right, voyage, ans);\n    }\n    \n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\n        int ind = 0;\n        vector<int> ans;\n        helper(ind, root, voyage, ans);\n        return ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool helper(int &ind, TreeNode *root, vector<int> &voyage, vector<int> &ans){\\n        if(root == NULL || ind == voyage.size()){\\n            ind--;\\n            return true;\\n        }\\n        \\n        // Not possible to create \\n        if(root->val != voyage[ind]){\\n            ans.clear();\\n            ans.push_back(-1);\\n            return false;\\n        }\\n        \\n        // If voyage value not equal to its left child, then swap both childs and check\\n        if(root->left && root->left->val != voyage[ind+1]){\\n\\t\\t\\tTreeNode *temp = root->left;\\n\\t\\t\\troot->left = root->right;\\n\\t\\t\\troot->right = temp;\\n\\t\\t\\t\\n\\t\\t\\t// Pusing root into ans\\n\\t\\t\\tans.push_back(root->val);\\n        }\\n        \\n        return helper(++ind, root->left, voyage, ans) &&\\n            helper(++ind, root->right, voyage, ans);\\n    }\\n    \\n    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {\\n        int ind = 0;\\n        vector<int> ans;\\n        helper(ind, root, voyage, ans);\\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```"
    },
    {
        "slug": "plus-one",
        "tags": "cpp",
        "release_time": 1691775412,
        "code": "class Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        int n=digits.size();\n        digits[n-1]++;\n        for(int i=n-1;i>=1;i--)\n        {\n            if(digits[i]>9)\n            {\n                digits[i]%=10;\n                digits[i-1]++;\n            }\n        }\n        if(digits[0]>9)\n        {\n            digits.insert(digits.begin(),1);\n            digits[1]%=10;\n        }\n        return digits;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple iterative approach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterated all index from the end , then manually checked for 0th index and did the needful.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> plusOne(vector<int>& digits) {\\n        int n=digits.size();\\n        digits[n-1]++;\\n        for(int i=n-1;i>=1;i--)\\n        {\\n            if(digits[i]>9)\\n            {\\n                digits[i]%=10;\\n                digits[i-1]++;\\n            }\\n        }\\n        if(digits[0]>9)\\n        {\\n            digits.insert(digits.begin(),1);\\n            digits[1]%=10;\\n        }\\n        return digits;\\n    }\\n};\\n```"
    },
    {
        "slug": "arranging-coins",
        "tags": "cpp",
        "release_time": 1670925544,
        "code": "class Solution {\npublic:\n    int arrangeCoins(int n) {\n        int c=n;\n        long long i=1;\n        if(n==0) return 0;\n        else if(n==1) return 1;\n        while(c>0){\n            i++;\n            c-=i;\n\n        }\n    return i-1;}\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int arrangeCoins(int n) {\\n        int c=n;\\n        long long i=1;\\n        if(n==0) return 0;\\n        else if(n==1) return 1;\\n        while(c>0){\\n            i++;\\n            c-=i;\\n\\n        }\\n    return i-1;}\\n};\\n```"
    },
    {
        "slug": "delete-nodes-and-return-forest",
        "tags": "cpp",
        "release_time": 1680861010,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* del(TreeNode* root,queue<TreeNode*>&Rootnodes,vector<int>&to_delete){\n        if(!root){\n            return NULL;\n        }\n        if(find(to_delete.begin(),to_delete.end(),root->val)!=to_delete.end()){\n            if(root->left){\n                Rootnodes.push(root->left);\n            }\n            if(root->right){\n                Rootnodes.push(root->right);\n            }\n            return NULL;\n        }\n        root->left=del(root->left,Rootnodes,to_delete);\n        root->right=del(root->right,Rootnodes,to_delete);\n        return root;\n    }\n    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n        vector<TreeNode*>ans;\n        queue<TreeNode*>Rootnodes;\n        Rootnodes.push(root);\n        while(!Rootnodes.empty()){\n            TreeNode* treeroot=Rootnodes.front();\n            TreeNode* rootnode=del(treeroot,Rootnodes,to_delete);\n            if(rootnode){\n                ans.push_back(rootnode);\n            }\n            Rootnodes.pop();\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen you delete a node store its left and right (if any) and consider it as root of a binary tree \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConsider a <i><b>queue</b></i>  data structure --> to store all the valid Rootnodes which are not to be deleted \\n* First push root into queue and while loop exits when its empty(no nodes are left)\\n* del function as return type TreeNode* to link NULL to its parent\\n* Taverse from rootnode, If root->val is to be deleted store its left and right (if any) for further tranversal and retrun NULL\\n*  So for every recursion call it checks for delete node and returns root if no delete node is found\\n* rootnode is sorted in vector and queue is poped\\n* ans vector is returned when queue is empty\\n# Complexity\\n- Time complexity: O(N)\\nwe are traversing each node only once\\n- Space complexity: O(N)\\n Assuming worst case where every node is to be deleted\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* del(TreeNode* root,queue<TreeNode*>&Rootnodes,vector<int>&to_delete){\\n        if(!root){\\n            return NULL;\\n        }\\n        if(find(to_delete.begin(),to_delete.end(),root->val)!=to_delete.end()){\\n            if(root->left){\\n                Rootnodes.push(root->left);\\n            }\\n            if(root->right){\\n                Rootnodes.push(root->right);\\n            }\\n            return NULL;\\n        }\\n        root->left=del(root->left,Rootnodes,to_delete);\\n        root->right=del(root->right,Rootnodes,to_delete);\\n        return root;\\n    }\\n    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\\n        vector<TreeNode*>ans;\\n        queue<TreeNode*>Rootnodes;\\n        Rootnodes.push(root);\\n        while(!Rootnodes.empty()){\\n            TreeNode* treeroot=Rootnodes.front();\\n            TreeNode* rootnode=del(treeroot,Rootnodes,to_delete);\\n            if(rootnode){\\n                ans.push_back(rootnode);\\n            }\\n            Rootnodes.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThank You :D"
    },
    {
        "slug": "design-twitter",
        "tags": "cpp",
        "release_time": 1679157289,
        "code": "class Twitter {\n    int timer = INT_MAX;\n    map<int, map<int, bool>> friends;\n    // map user id with user friends map\n    map<int, pair<int, int>> tweets;\n    // time {userId, tweetId}\npublic:\n    Twitter() {\n    }\n    \n    void postTweet(int userId, int tweetId) {\n        tweets[timer--] = {userId, tweetId};\n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        vector<int> ans;\n        for(auto it: tweets){\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\n                ans.push_back(it.second.second);\n            if(ans.size() == 10) break;\n        }\n        return ans;\n    }\n    \n    void follow(int followerId, int followeeId) {\n        friends[followerId][followeeId] = true;\n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        friends[followerId].erase(followeeId);\n    }\n};\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter* obj = new Twitter();\n * obj->postTweet(userId,tweetId);\n * vector<int> param_2 = obj->getNewsFeed(userId);\n * obj->follow(followerId,followeeId);\n * obj->unfollow(followerId,followeeId);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs our normal map sort the data in asscending order, wo we will use the timer variable initially it will be INT_MAX so, the upcoming tweets will be at starting.\\n\\nWhen fetching the tweets we simply check is the tweet id belongs to the userId or any of its friend if yes add it to answer and do, it till we fetch the top 10 recent tweets by the user or its friend\\n# Code\\n```\\nclass Twitter {\\n    int timer = INT_MAX;\\n    map<int, map<int, bool>> friends;\\n    // map user id with user friends map\\n    map<int, pair<int, int>> tweets;\\n    // time {userId, tweetId}\\npublic:\\n    Twitter() {\\n    }\\n    \\n    void postTweet(int userId, int tweetId) {\\n        tweets[timer--] = {userId, tweetId};\\n    }\\n    \\n    vector<int> getNewsFeed(int userId) {\\n        vector<int> ans;\\n        for(auto it: tweets){\\n            if(it.second.first == userId || friends[userId].find(it.second.first)!=friends[userId].end())\\n                ans.push_back(it.second.second);\\n            if(ans.size() == 10) break;\\n        }\\n        return ans;\\n    }\\n    \\n    void follow(int followerId, int followeeId) {\\n        friends[followerId][followeeId] = true;\\n    }\\n    \\n    void unfollow(int followerId, int followeeId) {\\n        friends[followerId].erase(followeeId);\\n    }\\n};\\n\\n/**\\n * Your Twitter object will be instantiated and called as such:\\n * Twitter* obj = new Twitter();\\n * obj->postTweet(userId,tweetId);\\n * vector<int> param_2 = obj->getNewsFeed(userId);\\n * obj->follow(followerId,followeeId);\\n * obj->unfollow(followerId,followeeId);\\n */\\n```"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "tags": "cpp",
        "release_time": 1689480311,
        "code": "class Solution {\npublic:\n    int longestValidSubstring(string word, vector<string>& forbidden) {\n        vector<int> ends(word.size() , -1);\n        unordered_map<string, int> forbidden_word;\n        for(auto it : forbidden)forbidden_word[it] = 1;\n        int n = word.size();\n        for(int i = 0; i<n; i++){\n            string temp = \"\";\n            for(int j = i; j<i+10 && j<n; j++){\n                temp += word[j];\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\n                    ends[j] = i;\n                }\n            }\n        }\n        \n        int i = 0, j = 0;\n        int ans = INT_MIN;\n        while(j < n){\n            \n            if(ends[j] != -1){\n                int st = ends[j];\n                if(st < i){\n                    ans = max(ans, j-i+1);\n                }\n                else{\n                    i = st+1;\n                    ans = max(ans, j-i+1);\n                }\n            }\n            else ans = max(ans,j-i+1);\n            j++;\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nWe can use sliding window + Vector.\\n\\n# Approach\\n\\nWe will initialize a vector end of size word with -1.Than we know the forbidden[i].size() is <= 10, so we can find all the index of the forbidden[i] in word string. we just need to find the ending points of each forbidden[i] in the word string and store it in ends vector with value of the starting index.\\n\\nNow we will use Sliding Window.\\n- we check for each right pointer j in our vector that is, is it a end point? if yes than we need to find the starting point of the substring and let it be \"st\" using our vector of end points. than we check if st < i (our left pointer) if yes than it means our window is safe because it doesnt contain starting index of the particular forbidden word ending at j.\\n\\nif st >= i(our left pointer) that means the starting point of forbidden word ending with right pointer j is in our window so we have to remove it by movig left pointer i = st+1.\\n\\nif our right pointer j is not a end point than the window is valid and we can store the ans of it.\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestValidSubstring(string word, vector<string>& forbidden) {\\n        vector<int> ends(word.size() , -1);\\n        unordered_map<string, int> forbidden_word;\\n        for(auto it : forbidden)forbidden_word[it] = 1;\\n        int n = word.size();\\n        for(int i = 0; i<n; i++){\\n            string temp = \"\";\\n            for(int j = i; j<i+10 && j<n; j++){\\n                temp += word[j];\\n                if(forbidden_word.find(temp) != forbidden_word.end()) {\\n                    ends[j] = i;\\n                }\\n            }\\n        }\\n        \\n        int i = 0, j = 0;\\n        int ans = INT_MIN;\\n        while(j < n){\\n            \\n            if(ends[j] != -1){\\n                int st = ends[j];\\n                if(st < i){\\n                    ans = max(ans, j-i+1);\\n                }\\n                else{\\n                    i = st+1;\\n                    ans = max(ans, j-i+1);\\n                }\\n            }\\n            else ans = max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "longest-well-performing-interval",
        "tags": "cpp",
        "release_time": 1688530675,
        "code": "class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n    map<int,int> mp;\n    int k=0,ans=0;\n    for(int i=0;i<hours.size();i++)\n    {\n        if(hours[i]>8)  k++; else   k--;\n        if(k>0)\n        {\n        ans=max(ans,i+1);\n        } else{\n            if(mp.find(k-1)!=mp.end()){\n                ans=max(ans,i-mp[k-1]);\n            }\n             if(mp.find(k)==mp.end()){\n                mp[k]=i;\n            }\n        }\n       \n    }    \n    return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestWPI(vector<int>& hours) {\\n    map<int,int> mp;\\n    int k=0,ans=0;\\n    for(int i=0;i<hours.size();i++)\\n    {\\n        if(hours[i]>8)  k++; else   k--;\\n        if(k>0)\\n        {\\n        ans=max(ans,i+1);\\n        } else{\\n            if(mp.find(k-1)!=mp.end()){\\n                ans=max(ans,i-mp[k-1]);\\n            }\\n             if(mp.find(k)==mp.end()){\\n                mp[k]=i;\\n            }\\n        }\\n       \\n    }    \\n    return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "distance-between-bus-stops",
        "tags": "cpp",
        "release_time": 1682917175,
        "code": "class Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        int i, dis1=0, dis2=0, j, temp;\n\n        // Swapping the values of start and destination, if destination is smaller than start\n        if(start>destination)\n        {\n            temp = start;\n            start = destination;\n            destination = temp;\n        }\n\n        //Checking Forward distance\n        for(i=start ; i<destination ; i++)\n        {\n            dis1 += distance[i];\n        }\n\n        //Checking Backward distance\n        i = start-1;\n        j = distance.size()-destination+start;\n        while(j>0)\n        {\n            if(i<0)\n            {\n                dis2 += distance[distance.size()+i];\n            }\n            else\n                dis2 += distance[i];\n            i--;\n            j--;\n        }\n\n        // Result\n        if(dis1<dis2)\n            return dis1;\n        return dis2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\\n        int i, dis1=0, dis2=0, j, temp;\\n\\n        // Swapping the values of start and destination, if destination is smaller than start\\n        if(start>destination)\\n        {\\n            temp = start;\\n            start = destination;\\n            destination = temp;\\n        }\\n\\n        //Checking Forward distance\\n        for(i=start ; i<destination ; i++)\\n        {\\n            dis1 += distance[i];\\n        }\\n\\n        //Checking Backward distance\\n        i = start-1;\\n        j = distance.size()-destination+start;\\n        while(j>0)\\n        {\\n            if(i<0)\\n            {\\n                dis2 += distance[distance.size()+i];\\n            }\\n            else\\n                dis2 += distance[i];\\n            i--;\\n            j--;\\n        }\\n\\n        // Result\\n        if(dis1<dis2)\\n            return dis1;\\n        return dis2;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/07016b53-8ada-4070-aab3-3dbdab28415c_1682917170.9058347.jpeg)\\n"
    },
    {
        "slug": "battleships-in-a-board",
        "tags": "cpp",
        "release_time": 1674588612,
        "code": "class Solution {\npublic:\n    int countBattleships(vector<vector<char>>& board) {\n        vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\n        int count = 0;\n        for(int i = 0;i<board.size();i++)\n        {\n            for(int j = 0; j<board[0].size();j++)\n            {\n                if(board[i][j] == 'X' and vis[i][j]==0)\n                    {\n                        helper(board, i, j, vis, count);\n                        count++;\n                    }\n            }\n        }\n        return count;\n    }\n    void helper(vector<vector<char>>& board, int i, int j,vector<vector<int>> &vis, int &count)\n    {\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || vis[i][j]==1 || board[i][j] == '.')\n            return;\n        vis[i][j] = 1;\n        helper(board, i+1,j,vis, count);\n        helper(board, i-1,j,vis, count);\n        helper(board, i,j+1,vis, count);\n        helper(board, i,j-1,vis, count);\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countBattleships(vector<vector<char>>& board) {\\n        vector<vector<int>> vis(board.size(),vector<int>(board[0].size(),0));\\n        int count = 0;\\n        for(int i = 0;i<board.size();i++)\\n        {\\n            for(int j = 0; j<board[0].size();j++)\\n            {\\n                if(board[i][j] == \\'X\\' and vis[i][j]==0)\\n                    {\\n                        helper(board, i, j, vis, count);\\n                        count++;\\n                    }\\n            }\\n        }\\n        return count;\\n    }\\n    void helper(vector<vector<char>>& board, int i, int j,vector<vector<int>> &vis, int &count)\\n    {\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || vis[i][j]==1 || board[i][j] == \\'.\\')\\n            return;\\n        vis[i][j] = 1;\\n        helper(board, i+1,j,vis, count);\\n        helper(board, i-1,j,vis, count);\\n        helper(board, i,j+1,vis, count);\\n        helper(board, i,j-1,vis, count);\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "tags": "cpp",
        "release_time": 1684152754,
        "code": "class Solution {\npublic:\n    long long findTheArrayConcVal(vector<int>& nums) {\n        int i = 0,j=nums.size()-1,x,y;\n        long long int ans=0;\n        while(i<j){\n            x = nums[j];\n            y = 0;\n            while(x){\n                y++;\n                x /= 10;\n            }\n            ans += (nums[i]*1LL*pow(10,y)+nums[j]);\n            i++;\n            j--;\n        }\n        if(i==j){\n            ans += nums[i];\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long findTheArrayConcVal(vector<int>& nums) {\\n        int i = 0,j=nums.size()-1,x,y;\\n        long long int ans=0;\\n        while(i<j){\\n            x = nums[j];\\n            y = 0;\\n            while(x){\\n                y++;\\n                x /= 10;\\n            }\\n            ans += (nums[i]*1LL*pow(10,y)+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        if(i==j){\\n            ans += nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-peak-element",
        "tags": "cpp",
        "release_time": 1692100702,
        "code": "class Solution {\npublic:\n    int findPeakElement(vector<int>& nums) {\n    int n=nums.size();\n    if(n==1)\n    {\n      return 0;\n    } \n    if(nums[0]>nums[1])\n    {\n      return 0;\n    }\n    if(nums[n-1]>nums[n-2])\n    {\n      return n-1;\n    }\n    int left=1;\n    int right=n-2;\n    while(left<=right)\n    {\n      int mid=(left+right)/2;\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\n      {\n        return mid;\n      }\n      else if(nums[mid]>nums[mid-1])\n      {\n        left=mid+1;\n      }\n      else{\n        right=mid-1;\n      }\n    }\nreturn -1;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findPeakElement(vector<int>& nums) {\\n    int n=nums.size();\\n    if(n==1)\\n    {\\n      return 0;\\n    } \\n    if(nums[0]>nums[1])\\n    {\\n      return 0;\\n    }\\n    if(nums[n-1]>nums[n-2])\\n    {\\n      return n-1;\\n    }\\n    int left=1;\\n    int right=n-2;\\n    while(left<=right)\\n    {\\n      int mid=(left+right)/2;\\n      if(nums[mid]>nums[mid-1]&& nums[mid]>nums[mid+1])\\n      {\\n        return mid;\\n      }\\n      else if(nums[mid]>nums[mid-1])\\n      {\\n        left=mid+1;\\n      }\\n      else{\\n        right=mid-1;\\n      }\\n    }\\nreturn -1;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-if-path-exists-in-graph",
        "tags": "cpp",
        "release_time": 1671419605,
        "code": "class Solution {\npublic:\n\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        \n        unordered_map<int,vector<int>>mpp;\n        unordered_map<int,bool>vis;\n        \n        for(auto it : edges)\n        {\n             mpp[it[0]].push_back(it[1]);\n             mpp[it[1]].push_back(it[0]);\n             vis[it[0]] = false;\n             vis[it[1]] = false;\n        }\n\n        queue<int>q;\n        q.push(source);\n\n        vis[source] = true;\n\n        while(!q.empty())\n        {\n           int temp = q.front();\n           q.pop();\n\n           vector<int>vec = mpp[temp];\n\n           for(int i = 0;i<vec.size();++i)\n           {\n              if(vis[vec[i]]==true) continue;\n\n              else\n              {\n                 q.push(vec[i]);\n                 vis[vec[i]] = true;\n              }\n\n            }\n\n        }\n\n        return vis[destination];\n    }\n};",
        "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\\n        \\n        unordered_map<int,vector<int>>mpp;\\n        unordered_map<int,bool>vis;\\n        \\n        for(auto it : edges)\\n        {\\n             mpp[it[0]].push_back(it[1]);\\n             mpp[it[1]].push_back(it[0]);\\n             vis[it[0]] = false;\\n             vis[it[1]] = false;\\n        }\\n\\n        queue<int>q;\\n        q.push(source);\\n\\n        vis[source] = true;\\n\\n        while(!q.empty())\\n        {\\n           int temp = q.front();\\n           q.pop();\\n\\n           vector<int>vec = mpp[temp];\\n\\n           for(int i = 0;i<vec.size();++i)\\n           {\\n              if(vis[vec[i]]==true) continue;\\n\\n              else\\n              {\\n                 q.push(vec[i]);\\n                 vis[vec[i]] = true;\\n              }\\n\\n            }\\n\\n        }\\n\\n        return vis[destination];\\n    }\\n};\\n\\n\\n```"
    },
    {
        "slug": "minimum-operations-to-halve-array-sum",
        "tags": "cpp",
        "release_time": 1675094747,
        "code": "class Solution {\npublic:\n\n    int halveArray(vector<int>& nums) \n    {\n        // use priority Queue to store elements in assending order\n        // So Biggest element is always on top of Queue\n        priority_queue<double>Q;\n\n        double sum=0;   //Total sum of element\n\n        //store all elments in Queue\n        for(auto ele : nums)\n        {\n            sum+=ele;\n            Q.push(ele);\n            \n        }\n        \n        //half of total\n        double half=sum/2;\n\n        //count operations until sum is greater than half \n        int count=0;\n        while(sum>half)\n        { \n            double max=Q.top();     //maximum emement of Queue\n            Q.pop();                //remove it from Queue\n\n            max/=2;                 \n            Q.push(max);            //add half of that element\n            count++;                //count accurance of operation\n\n            sum-=max;               //substarct half of element from sum \n        }\n       \n        return count;\n        \n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int halveArray(vector<int>& nums) \\n    {\\n        // use priority Queue to store elements in assending order\\n        // So Biggest element is always on top of Queue\\n        priority_queue<double>Q;\\n\\n        double sum=0;   //Total sum of element\\n\\n        //store all elments in Queue\\n        for(auto ele : nums)\\n        {\\n            sum+=ele;\\n            Q.push(ele);\\n            \\n        }\\n        \\n        //half of total\\n        double half=sum/2;\\n\\n        //count operations until sum is greater than half \\n        int count=0;\\n        while(sum>half)\\n        { \\n            double max=Q.top();     //maximum emement of Queue\\n            Q.pop();                //remove it from Queue\\n\\n            max/=2;                 \\n            Q.push(max);            //add half of that element\\n            count++;                //count accurance of operation\\n\\n            sum-=max;               //substarct half of element from sum \\n        }\\n       \\n        return count;\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "check-if-all-the-integers-in-a-range-are-covered",
        "tags": "cpp",
        "release_time": 1661876981,
        "code": "class Solution {\npublic:\n    bool isCovered(vector<vector<int>>& ranges, int left, int right) {\n        vector<int> line(52,0);\n        for (auto &r : ranges) {\n            line[r[0]] += 1;\n            line[r[1] + 1] -= 1;\n        }\n        for(int i=0; i<51; i++) line[i+1]+=line[i];\n        for (int i = 1; i <= right; ++i) {\n            if (i >= left && line[i] == 0)\n                return false;\n        }\n        return true;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    bool isCovered(vector<vector<int>>& ranges, int left, int right) {\\n        vector<int> line(52,0);\\n        for (auto &r : ranges) {\\n            line[r[0]] += 1;\\n            line[r[1] + 1] -= 1;\\n        }\\n        for(int i=0; i<51; i++) line[i+1]+=line[i];\\n        for (int i = 1; i <= right; ++i) {\\n            if (i >= left && line[i] == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "remove-outermost-parentheses",
        "tags": "cpp",
        "release_time": 1687925926,
        "code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        stack<char> st;\n        string res=\"\";\n        for(int i=0;i<s.size();i++){\n            if(s[i]=='(' && st.empty()){\n                st.push(s[i]);\n            }\n            else if(s[i]=='('){\n                st.push(s[i]);\n                res+=s[i];\n            }\n            else{\n                st.pop();\n                if(st.size()){\n                    res+=s[i];\n                }\n            }\n        }\n        return res;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeOuterParentheses(string s) {\\n        stack<char> st;\\n        string res=\"\";\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'(\\' && st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==\\'(\\'){\\n                st.push(s[i]);\\n                res+=s[i];\\n            }\\n            else{\\n                st.pop();\\n                if(st.size()){\\n                    res+=s[i];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "tags": "cpp",
        "release_time": 1677320292,
        "code": "class Solution {\npublic:\n    int Rem(int a)\n    {\n        return (a * (a+1) )/2;\n    }\n    int totalMoney(int n) {\n        int ans = 0,dif=28;\n        int a = 0;\n\n        a = n/7;\n        \n        for(int i=0;i<a;i++)\n        {\n            ans+=dif;\n            dif+=7;\n        }\n\n        int b = n%7;\n        int ad = Rem(b);\n        ad+= a*b;\n\n        ans+=ad;\n\n\n        return ans;\n    }\n};",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBasically This Question Try to Test Pattern Finding Skill.\\nThis Problem has 2 things two Consider.\\n1) Firstly We Divide n by 7 ( as Week is of  Days ) So that We get Value Which Indicates that Total Number of Weeks need to Consider in Final Answer.\\n\\n2) Now We Do n%7 which gives answer between 0 to 6 which indicates Remaining Days after Step 1. So We need To calculate Sum of Savings for That n%7 days Separately.\\n\\nAs Sum of\\n \\nWeek 1 : 28\\nWeek 2 : 35\\nWeek 3 : 42\\nWeek 4 : 49\\nWeek 5 : 56\\nand so on...\\n Indicates Pattern that We only need How many Whole Week Need to Consider in answer and that We got in Step 1.\\nSo add 28+35+.. upto n/7 terms\\n\\n\\nNow , In Step 2 , We need to consider Saving For Remainig Days which is n%7.\\nSuppose Rem Day is B then B*(B+1)/2 Will be Saving at B day of Week 1.We know that we have n/7 week so n/7*b will be added to B*(B+1)/2\\n.This is Final answer of Step 2.\\n\\n3) Add Both answer of Step 1 and Step 2.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int Rem(int a)\\n    {\\n        return (a * (a+1) )/2;\\n    }\\n    int totalMoney(int n) {\\n        int ans = 0,dif=28;\\n        int a = 0;\\n\\n        a = n/7;\\n        \\n        for(int i=0;i<a;i++)\\n        {\\n            ans+=dif;\\n            dif+=7;\\n        }\\n\\n        int b = n%7;\\n        int ad = Rem(b);\\n        ad+= a*b;\\n\\n        ans+=ad;\\n\\n\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-path-visiting-all-nodes",
        "tags": "cpp",
        "release_time": 1684853737,
        "code": "class Solution {\npublic:\n    int shortestPathLength(vector<vector<int>>& graph) {\n        int n=graph.size();\n        if(n==1) return 0;\n        set<pair<int,int>>vis;\n        queue<pair<int,pair<int,int>>>q;\n        int all=(1<<n)-1;\n        for(int i=0;i<n;i++){\n            int mask=1<<i;\n            q.push({i,{0,mask}});\n            vis.insert({i,mask});\n        }\n        while(!q.empty()){\n            int node=q.front().first;\n            int dist=q.front().second.first;\n            int mask=q.front().second.second;\n            q.pop();\n            for(auto it:graph[node]){\n                int newMask=(mask|(1<<it));\n                if(newMask==all)\n                    return dist+1;\n                else if(vis.count({it,newMask}))\n                    continue;\n                q.push({it,{dist+1,newMask}});\n                vis.insert({it,newMask});\n            }\n        }\n        return 0;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int shortestPathLength(vector<vector<int>>& graph) {\\n        int n=graph.size();\\n        if(n==1) return 0;\\n        set<pair<int,int>>vis;\\n        queue<pair<int,pair<int,int>>>q;\\n        int all=(1<<n)-1;\\n        for(int i=0;i<n;i++){\\n            int mask=1<<i;\\n            q.push({i,{0,mask}});\\n            vis.insert({i,mask});\\n        }\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            int dist=q.front().second.first;\\n            int mask=q.front().second.second;\\n            q.pop();\\n            for(auto it:graph[node]){\\n                int newMask=(mask|(1<<it));\\n                if(newMask==all)\\n                    return dist+1;\\n                else if(vis.count({it,newMask}))\\n                    continue;\\n                q.push({it,{dist+1,newMask}});\\n                vis.insert({it,newMask});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```"
    },
    {
        "slug": "leaf-similar-trees",
        "tags": "cpp",
        "release_time": 1670464661,
        "code": "class Solution {\npublic:\n    void inorder(TreeNode* root, vector<int>& v){\n        if(!root) return;\n        if(root->left==NULL && root->right==NULL){\n            v.push_back(root->val);\n        }\n        \n        inorder(root->left,v);\n        inorder(root->right,v);\n    }\n\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> first,second;\n        inorder(root1,first);\n        inorder(root2,second);\n\n        if(first.size()!=second.size()) return false;\n        for(int i=0;i<first.size();i++){\n            if(first[i]!=second[i]) return false;\n        }\n        return true;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>& v){\\n        if(!root) return;\\n        if(root->left==NULL && root->right==NULL){\\n            v.push_back(root->val);\\n        }\\n        \\n        inorder(root->left,v);\\n        inorder(root->right,v);\\n    }\\n\\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\\n        vector<int> first,second;\\n        inorder(root1,first);\\n        inorder(root2,second);\\n\\n        if(first.size()!=second.size()) return false;\\n        for(int i=0;i<first.size();i++){\\n            if(first[i]!=second[i]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "tags": "cpp",
        "release_time": 1685246618,
        "code": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size();\n        vector<int> row_max(n), col_max(m);\n        \n        map<int, vector<pair<int, int>>, greater<int>> pos;\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < m; ++j) {\n                pos[mat[i][j]].push_back({i, j});\n            }\n        }\n        \n        int ans = 0;\n        for (auto& [num, cells]: pos) {\n            int k = cells.size();\n            vector<int> next(k);\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                next[i] = max(row_max[r], col_max[c]) + 1;\n                ans = max(ans, next[i]);\n            }\n            for (int i = 0; i < k; ++i) {\n                int r = cells[i].first, c = cells[i].second;\n                row_max[r] = max(row_max[r], next[i]);\n                col_max[c] = max(col_max[c], next[i]);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\nAt first I thought of a 2d dp. You can iterate through the matrix in order of decreasing cell value, storing the max number of cells reachable from each cell `mat[i][j]` in `dp[i][j]`. However, for each cell you have to look at all reachable cells (its entire row and column), so the time complexity would be $$O(n*m*(n+m))$$, which isn\\u2019t fast enough.\\n\\nThen I realized you don\\u2019t need to store the max for every cell. As you iterate through the matrix in order of decreasing cell value, you always take the maximum path already found starting in the same row or column. This means you can get away with just storing the max for each row and column.\\n\\n# Approach\\nCreate a map of cell values in decreasing order to (r, c) positions in the matrix with those values. Iterate through this map, updating the vectors row_max and col_max, which store the max number of cells reachable starting from somewhere in each row and column. Be careful to only update row_max and col_max after every cell with a given value has been processed.\\n\\n\\n# Complexity\\n- Time complexity\\n$$O(n*m*log(n*m))$$\\n\\n- Space complexity:\\n$$O(n*m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIncreasingCells(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        vector<int> row_max(n), col_max(m);\\n        \\n        map<int, vector<pair<int, int>>, greater<int>> pos;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                pos[mat[i][j]].push_back({i, j});\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (auto& [num, cells]: pos) {\\n            int k = cells.size();\\n            vector<int> next(k);\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                next[i] = max(row_max[r], col_max[c]) + 1;\\n                ans = max(ans, next[i]);\\n            }\\n            for (int i = 0; i < k; ++i) {\\n                int r = cells[i].first, c = cells[i].second;\\n                row_max[r] = max(row_max[r], next[i]);\\n                col_max[c] = max(col_max[c], next[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "minimum-operations-to-make-array-equal",
        "tags": "cpp",
        "release_time": 1685334505,
        "code": "class Solution {\npublic:\n    int minOperations(int n) {\n       int i,j,k=0,s=0;\n       i=n/2;\n       int max=n;\n       \n        for(j=0;j<i;j++){\n            s+=max-2*j-1;\n\n        }\n        return s;\n\n        \n    }\n};\n\n//1 3 5 7",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(int n) {\\n       int i,j,k=0,s=0;\\n       i=n/2;\\n       int max=n;\\n       \\n        for(j=0;j<i;j++){\\n            s+=max-2*j-1;\\n\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n\\n//1 3 5 7\\n```"
    },
    {
        "slug": "maximum-rows-covered-by-columns",
        "tags": "cpp",
        "release_time": 1662227882,
        "code": "class Solution {\npublic:\n    // Global Vector to all possible column combinations\n    vector<vector<int>>comb;\n\t\n    // Function to find the number of rows a particular column combination can capture\n    int find(vector<vector<int>>& mat1)\n    {\n        int c = 0;\n        for(int i = 0; i < mat1.size(); i++)\n        {\n            int flg = 0;\n            for(int j = 0; j < mat1[0].size(); j++)\n                if(mat1[i][j] == 1)\n                    flg = 1;\n            if(flg == 0)\n                c++;\n        }\n        return c;\n    }\n    \n\t// Function to Traverse for each Column Combination Present\n    int find_ans(vector<vector<int>>& mat)\n    {\n        int ans = 0;\n        for(int i = 0; i < comb.size(); i++)\n        {\n            vector<int>temp = comb[i];\n            vector<vector<int>> mat1 = mat;\n            for(int j = 0; j < temp.size(); j++)\n            {\n                int col_val = temp[j];\n                for(int k = 0; k < mat1.size(); k++)\n                    mat1[k][col_val] = 0;\n            }\n            ans = max(ans, find(mat1));\n        }\n        return ans;\n    }\n    // Function to Find all possible column combinations\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\n    {\n        int col = mat[0].size();\n        if(count == cols)\n        {\n            comb.push_back(tans);\n            return;\n        }\n        if(idx >= col)\n            return;\n        \n        helper(mat, cols, count, idx+1, tans);\n        tans.push_back(idx);\n        helper(mat, cols, count+1, idx+1, tans);\n    }\n    \n    int maximumRows(vector<vector<int>>& mat, int cols) {\n        \n        vector<int>tans;\n        helper(mat, cols, 0, 0, tans);\n        return find_ans(mat);\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    // Global Vector to all possible column combinations\\n    vector<vector<int>>comb;\\n\\t\\n    // Function to find the number of rows a particular column combination can capture\\n    int find(vector<vector<int>>& mat1)\\n    {\\n        int c = 0;\\n        for(int i = 0; i < mat1.size(); i++)\\n        {\\n            int flg = 0;\\n            for(int j = 0; j < mat1[0].size(); j++)\\n                if(mat1[i][j] == 1)\\n                    flg = 1;\\n            if(flg == 0)\\n                c++;\\n        }\\n        return c;\\n    }\\n    \\n\\t// Function to Traverse for each Column Combination Present\\n    int find_ans(vector<vector<int>>& mat)\\n    {\\n        int ans = 0;\\n        for(int i = 0; i < comb.size(); i++)\\n        {\\n            vector<int>temp = comb[i];\\n            vector<vector<int>> mat1 = mat;\\n            for(int j = 0; j < temp.size(); j++)\\n            {\\n                int col_val = temp[j];\\n                for(int k = 0; k < mat1.size(); k++)\\n                    mat1[k][col_val] = 0;\\n            }\\n            ans = max(ans, find(mat1));\\n        }\\n        return ans;\\n    }\\n    // Function to Find all possible column combinations\\n    void helper(vector<vector<int>>& mat, int cols, int count, int idx, vector<int>tans)\\n    {\\n        int col = mat[0].size();\\n        if(count == cols)\\n        {\\n            comb.push_back(tans);\\n            return;\\n        }\\n        if(idx >= col)\\n            return;\\n        \\n        helper(mat, cols, count, idx+1, tans);\\n        tans.push_back(idx);\\n        helper(mat, cols, count+1, idx+1, tans);\\n    }\\n    \\n    int maximumRows(vector<vector<int>>& mat, int cols) {\\n        \\n        vector<int>tans;\\n        helper(mat, cols, 0, 0, tans);\\n        return find_ans(mat);\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-frequency-stack",
        "tags": "cpp",
        "release_time": 1689270384,
        "code": "class FreqStack {\npublic:\n    \n    unordered_map<int,int> mp; // It will map x->val ,i.e val for every x\n// bcoz we will not push val into set,so we will get val from mp.\n    unordered_map<int,int> freq; // It will keep freq of the val\n    set<pair<int,int>> s; // {freq,x};\n    int x=0; // x is maintained for second condition i.e \n// if freq tie, then we need to return latest element pushed.\n    FreqStack() {\n        \n    }\n    \n    void push(int val) {\n        freq[val]++; // increase the freq of val.\n        mp[x]=val; // map x->val\n        s.insert({freq[val],x++}); // {freq,x}\n    }\n    \n    int pop() {\n        auto it2=s.rbegin(); // return the iterater to last element in set i.e\n// the one which is our ans with highest freq,if freq ties,\n//then latest pushed,i.e having higher value of x.\n        auto it=*(it2);// it gets the pair from the it2\n        s.erase(it); // remove this pair from set\n        int f=it.first;// freq\n        int cur_x=it.second; // x\n        int val=mp[cur_x]; // val i.e ans\n        freq[val]--; // reduce the freq of val\n        return val;\n    }\n};",
        "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass FreqStack {\\npublic:\\n    \\n    unordered_map<int,int> mp; // It will map x->val ,i.e val for every x\\n// bcoz we will not push val into set,so we will get val from mp.\\n    unordered_map<int,int> freq; // It will keep freq of the val\\n    set<pair<int,int>> s; // {freq,x};\\n    int x=0; // x is maintained for second condition i.e \\n// if freq tie, then we need to return latest element pushed.\\n    FreqStack() {\\n        \\n    }\\n    \\n    void push(int val) {\\n        freq[val]++; // increase the freq of val.\\n        mp[x]=val; // map x->val\\n        s.insert({freq[val],x++}); // {freq,x}\\n    }\\n    \\n    int pop() {\\n        auto it2=s.rbegin(); // return the iterater to last element in set i.e\\n// the one which is our ans with highest freq,if freq ties,\\n//then latest pushed,i.e having higher value of x.\\n        auto it=*(it2);// it gets the pair from the it2\\n        s.erase(it); // remove this pair from set\\n        int f=it.first;// freq\\n        int cur_x=it.second; // x\\n        int val=mp[cur_x]; // val i.e ans\\n        freq[val]--; // reduce the freq of val\\n        return val;\\n    }\\n};\\n\\n\\n```"
    },
    {
        "slug": "range-sum-query-immutable",
        "tags": "cpp",
        "release_time": 1687772148,
        "code": "class NumArray {\n    \n    /*\n        Time Complexity : O(N) + O(1)\n        Space Complexity : O(N)\n    */\n    \nprivate:\n    vector<int> prefixSum;\n    \npublic:\n    NumArray(vector<int>& nums) {\n        prefixSum.resize(nums.size());\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i=1; i<nums.size(); i++){\n            prefixSum[i] = prefixSum[i-1] + nums[i];\n        }\n    }\n    \n    int sumRange(int left, int right) {\n        if(left == 0){\n            return prefixSum[right];\n        }\n        \n        return prefixSum[right] - prefixSum[left-1];\n    }\n};\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray* obj = new NumArray(nums);\n * int param_1 = obj->sumRange(left,right);\n */",
        "content": "```\\nclass NumArray {\\n    \\n    /*\\n        Time Complexity : O(N) + O(1)\\n        Space Complexity : O(N)\\n    */\\n    \\nprivate:\\n    vector<int> prefixSum;\\n    \\npublic:\\n    NumArray(vector<int>& nums) {\\n        prefixSum.resize(nums.size());\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0){\\n            return prefixSum[right];\\n        }\\n        \\n        return prefixSum[right] - prefixSum[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```"
    },
    {
        "slug": "flip-string-to-monotone-increasing",
        "tags": "cpp",
        "release_time": 1673920922,
        "code": "class Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        int flip=0,one=0,n = s.size();\n        for(int i=0;i<n;i++){\n            if(s[i]=='1'){\n                one++;\n            }else{\n                if(one==0)continue;\n                else flip++;\n            }\n            if(one<flip)flip = one;\n        }\n        return flip;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nspecial mention : [prathz](https://leetcode.com/problems/flip-string-to-monotone-increasing/solutions/3061177/c-prefix-sum/?orderBy=hot)  for this approach\\nPrefix sum \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSkip the loop until we find the first \\'1\\'\\nafter finding first occurrence of \\'1\\' we have to keep a count of number of \\'1\\'s in countOnes\\n\\nif we find any \\'0\\' after occurrence of \\'1\\' it means turning that \\'0\\' to one may be one possible solution so we have to keep number of flip needed in countFlips variable\\n\\nif value of countFlips is greater than countOnes(number of ones) then converting all \\'1\\' to \\'0\\' would be better option so assign value of countOnes to the countFlips\\n\\nin the end we will return countFlips\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int flip=0,one=0,n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\'){\\n                one++;\\n            }else{\\n                if(one==0)continue;\\n                else flip++;\\n            }\\n            if(one<flip)flip = one;\\n        }\\n        return flip;\\n    }\\n};\\n\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting the no. of 1\\'s to flip on left side + no. of 0\\'s to flip on right side of each index i and then select minimum flips from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain a prefix and suffix array to count 1 on left side and 0 on right side.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n = s.size(),ans = INT_MAX;\\n        vector<int> onecount(n,0),zerocount(n,0);\\n        onecount[0] = 0,zerocount[n-1]=0;\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'1\\')onecount[i] = onecount[i-1]+1;\\n            else onecount[i] = onecount[i-1];\\n            if(s[n-i]==\\'0\\')zerocount[n-i-1] = zerocount[n-i]+1;\\n            else zerocount[n-i-1] = zerocount[n-i];\\n        }\\n        for(int i=0;i<n;i++){\\n            ans = min(ans,zerocount[i]+onecount[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCounting the no. of 1\\'s to flip on left side + no. of 0\\'s to flip on right side of each index i and then select minimum flips from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n### TLE on 73rd test case \\n# Code\\n```\\nclass Solution {\\nprivate:\\nint onecount(string s){\\n    int n = s.size();\\n    int cnt=0;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'1\\')cnt++;\\n    }\\n    return cnt;\\n}\\nint zerocount(string s){\\n    int n = s.size();\\n    int cnt=0;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'0\\')cnt++;\\n    }\\n    return cnt;\\n}\\npublic:\\n    int minFlipsMonoIncr(string s) {\\n        int n = s.size();\\n        int mini = INT_MAX;\\n        vector<int> ans(n,0);\\n        for(int i=0;i<n;i++){\\n            ans[i]+= onecount(s.substr(0,i));\\n            ans[i]+= zerocount(s.substr(i+1));\\n            mini = min(mini,ans[i]);\\n        }\\n        return mini;\\n    }\\n};\\n```\\n"
    },
    {
        "slug": "sort-list",
        "tags": "cpp",
        "release_time": 1692157711,
        "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        vector<int>vec1;\n    ListNode*temp= head;\n    while(temp!=NULL){\nvec1.push_back(temp->val);\ntemp= temp->next;\n    }\n    sort(vec1.begin(),vec1.end());\n    ListNode*curr= head;\n   for(int i=0;i<vec1.size();i++){\n       curr->val=vec1[i];\n       curr= curr->next;\n   }\n   return head;\n    }\n    \n\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* sortList(ListNode* head) {\\n        vector<int>vec1;\\n    ListNode*temp= head;\\n    while(temp!=NULL){\\nvec1.push_back(temp->val);\\ntemp= temp->next;\\n    }\\n    sort(vec1.begin(),vec1.end());\\n    ListNode*curr= head;\\n   for(int i=0;i<vec1.size();i++){\\n       curr->val=vec1[i];\\n       curr= curr->next;\\n   }\\n   return head;\\n    }\\n    \\n\\n};\\n\\n```"
    },
    {
        "slug": "maximum-score-from-removing-stones",
        "tags": "cpp",
        "release_time": 1690509520,
        "code": "class Solution {\npublic:\n    int maximumScore(int a, int b, int c) {\n        int maxi = max(a,max(b,c));\n        int mini = min(a,min(b,c));\n        int mid = a+b+c-maxi-mini;\n        if(mini+mid<maxi) return mini+mid;\n\n        return (a+b+c)/2;\n    }\n};",
        "content": "\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumScore(int a, int b, int c) {\\n        int maxi = max(a,max(b,c));\\n        int mini = min(a,min(b,c));\\n        int mid = a+b+c-maxi-mini;\\n        if(mini+mid<maxi) return mini+mid;\\n\\n        return (a+b+c)/2;\\n    }\\n};\\n```"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "tags": "cpp",
        "release_time": 1677989182,
        "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        vector<vector<int>>v;\n        int i,n;\n        if(!root)return -1;        \n        queue<TreeNode*>q;\n        priority_queue<long long>pq;\n        q.push(root);\n        while(!q.empty()){\n            n=q.size();\n            long long sum=0;\n            for(i=0;i<n;i++){\n                TreeNode* x = q.front();\n                q.pop();\n                sum+=x->val;\n                if(x->left)q.push(x->left);\n                if(x->right)q.push(x->right);\n            }\n            pq.push(sum);\n        }\n        if(pq.size()<k)return -1;\n        k=k-1;\n        while(k--)pq.pop();\n        return pq.top();\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Level Order Traversal find the sum of elements at each level and store them in priority queue. Now return the kth largest element from the priority queue if found otherwise return -1;\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    long long kthLargestLevelSum(TreeNode* root, int k) {\\n        vector<vector<int>>v;\\n        int i,n;\\n        if(!root)return -1;        \\n        queue<TreeNode*>q;\\n        priority_queue<long long>pq;\\n        q.push(root);\\n        while(!q.empty()){\\n            n=q.size();\\n            long long sum=0;\\n            for(i=0;i<n;i++){\\n                TreeNode* x = q.front();\\n                q.pop();\\n                sum+=x->val;\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n            pq.push(sum);\\n        }\\n        if(pq.size()<k)return -1;\\n        k=k-1;\\n        while(k--)pq.pop();\\n        return pq.top();\\n    }\\n};\\n```\\n\\nFor more such solutions, you can join my telegram channel : \\nhttps://t.me/leetcodegfgdailysolution\\n"
    },
    {
        "slug": "number-of-subarrays-with-gcd-equal-to-k",
        "tags": "cpp",
        "release_time": 1666559599,
        "code": "class Solution {\npublic:\n    int subarrayGCD(vector<int>& nums, int k) {\n        \n        int result = 0; // We may not have any subarray.\n        \n        int n = nums.size();\n        \n        for (int l = 0; l < n; l++)\n        {\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\n            for (int r = l; r < n; r++)\n            {\n                /* \n                We update our current_gcd value in the inner loop. \n                If we somehow reach to k at some point, we'll draw an arrow from our left anchor to the that point. \n                If we found a subarray that has elements with gcd k, increment result.\n                We repeat that steps for each left anchor.\n                */ \n                current_gcd = gcd(current_gcd, nums[r]); \n                if (current_gcd == k)\n                    result++;\n            }\n        }\n        return result;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int subarrayGCD(vector<int>& nums, int k) {\\n        \\n        int result = 0; // We may not have any subarray.\\n        \\n        int n = nums.size();\\n        \\n        for (int l = 0; l < n; l++)\\n        {\\n            int current_gcd = nums[l]; // Choose a left anchor, mark it as gcd\\n            for (int r = l; r < n; r++)\\n            {\\n                /* \\n                We update our current_gcd value in the inner loop. \\n                If we somehow reach to k at some point, we\\'ll draw an arrow from our left anchor to the that point. \\n                If we found a subarray that has elements with gcd k, increment result.\\n                We repeat that steps for each left anchor.\\n                */ \\n                current_gcd = gcd(current_gcd, nums[r]); \\n                if (current_gcd == k)\\n                    result++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```"
    },
    {
        "slug": "kids-with-the-greatest-number-of-candies",
        "tags": "cpp",
        "release_time": 1681692061,
        "code": "class Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& c, int ec) {\n        int maxi = INT_MIN;\n        for(int i = 0;i<c.size();i++){\n            if(maxi<c[i]){\n                maxi = c[i];\n            }\n        }\n        vector<bool>ans;\n        for(int i = 0;i<c.size();i++){\n            if(c[i]+ec >=maxi){\n                ans.push_back(1);\n            }\n            else{\n                ans.push_back(0);\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> kidsWithCandies(vector<int>& c, int ec) {\\n        int maxi = INT_MIN;\\n        for(int i = 0;i<c.size();i++){\\n            if(maxi<c[i]){\\n                maxi = c[i];\\n            }\\n        }\\n        vector<bool>ans;\\n        for(int i = 0;i<c.size();i++){\\n            if(c[i]+ec >=maxi){\\n                ans.push_back(1);\\n            }\\n            else{\\n                ans.push_back(0);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "construct-the-longest-new-string",
        "tags": "cpp",
        "release_time": 1687623013,
        "code": "class Solution {\npublic:\n    int longestString(int x, int y, int z) {\n        int mn=min(x,y);\n        int cnt=0;\n        if(x!=y)cnt=1;\n        return (mn+mn+cnt+z)*2;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to check only x and y value\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestString(int x, int y, int z) {\\n        int mn=min(x,y);\\n        int cnt=0;\\n        if(x!=y)cnt=1;\\n        return (mn+mn+cnt+z)*2;\\n    }\\n};\\n```"
    },
    {
        "slug": "maximum-value-of-a-string-in-an-array",
        "tags": "cpp",
        "release_time": 1683726196,
        "code": "class Solution {\npublic:\n    int maximumValue(vector<string>& strs) {\n        int max = 0;\n\t    for (int i = 0; i < strs.size(); i++) {\n\t    \tstring text = \"1\" + strs[i]; // add a 1 in the beginning to handle cases that starts with 0's\n\t    \tdouble value1 = stod(text + \"0\");\n\t    \tdouble value2 = stod(text) * 10;\n\t    \tif (value1 == value2) {\n\t    \t\t// integer\n\t    \t\tint value = stoi(strs[i]);\n\t    \t\tmax = (max < value ? value : max);\n\t    \t}\n\t    \telse {\n\t    \t\t// string\n\t    \t\tint length = strs[i].length();\n\t    \t\tmax = (max < length ? length : max);\n\t    \t}\n\t    }\n\t    return max;\n    }\n};",
        "content": "# Intuition\\nAt first I thought about integer properties and how to use them to distinguish between them and strings, the Idea was to find an operation that can be performed on the integer and strings and gives the same value iff the string was actually an integer.\\n\\n# Approach\\nI used $$stod(string)$$ to get the numbers in the prefix of the string\\nand mutiplied that number by 10\\nso if there was an char in the middle or at the end of the string\\nthe multiplication would be different.\\nand adding 1 to the beggining of the string to handle the cases that starts with 0 because 0*10=0.\\n\\nExample: \"00a1\"\\n    when $$ stod(100a1) = 100 $$ -> $$ 100 * 10 = 1000 $$\\n    but $$ stod(100a10) = 100 $$\\n    since $$ 1000 != 100 $$ \\n    00a1 must be string\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumValue(vector<string>& strs) {\\n        int max = 0;\\n\\t    for (int i = 0; i < strs.size(); i++) {\\n\\t    \\tstring text = \"1\" + strs[i]; // add a 1 in the beginning to handle cases that starts with 0\\'s\\n\\t    \\tdouble value1 = stod(text + \"0\");\\n\\t    \\tdouble value2 = stod(text) * 10;\\n\\t    \\tif (value1 == value2) {\\n\\t    \\t\\t// integer\\n\\t    \\t\\tint value = stoi(strs[i]);\\n\\t    \\t\\tmax = (max < value ? value : max);\\n\\t    \\t}\\n\\t    \\telse {\\n\\t    \\t\\t// string\\n\\t    \\t\\tint length = strs[i].length();\\n\\t    \\t\\tmax = (max < length ? length : max);\\n\\t    \\t}\\n\\t    }\\n\\t    return max;\\n    }\\n};\\n```"
    },
    {
        "slug": "combinations",
        "tags": "cpp",
        "release_time": 1690854546,
        "code": "class Solution {\npublic:\n    \n    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){\n        if(k==0){\n            ans.push_back(sub_ans);\n            return;\n        }\n        if(num == n+1) return;\n        \n        // skip\n        solve(n,k,num+1,sub_ans,ans);\n        \n        // acquire\n        sub_ans.push_back(num);\n        solve(n,k-1,num+1,sub_ans,ans);\n        sub_ans.pop_back();\n    }\n    \n    vector<vector<int>> combine(int n, int k) {\n        vector<vector<int>> ans;\n        vector<int> sub_ans;\n        \n        solve(n,k,1,sub_ans,ans);\n        \n        return ans;\n    }\n};",
        "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(int n, int k, int num, vector<int> &sub_ans, vector<vector<int>> &ans){\\n        if(k==0){\\n            ans.push_back(sub_ans);\\n            return;\\n        }\\n        if(num == n+1) return;\\n        \\n        // skip\\n        solve(n,k,num+1,sub_ans,ans);\\n        \\n        // acquire\\n        sub_ans.push_back(num);\\n        solve(n,k-1,num+1,sub_ans,ans);\\n        sub_ans.pop_back();\\n    }\\n    \\n    vector<vector<int>> combine(int n, int k) {\\n        vector<vector<int>> ans;\\n        vector<int> sub_ans;\\n        \\n        solve(n,k,1,sub_ans,ans);\\n        \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "tags": "cpp",
        "release_time": 1678731739,
        "code": "class Solution {\npublic:\n    //check for palindrome, return true if it.\n    bool check(string &word)\n    {\n        int l = 0;\n        int r = word.size()-1;\n\n        while(l<r)\n        {\n            if(word[l] != word[r])\n            {\n                return false;\n            }\n            l++;\n             r--;\n        }\n        return true;\n\n    }\n    string firstPalindrome(vector<string>& words) {\n        for(int i=0;i<words.size();i++)\n        {\n            if(check(words[i]))\n            return words[i];\n        }\n\n        return \"\";\n        \n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    //check for palindrome, return true if it.\\n    bool check(string &word)\\n    {\\n        int l = 0;\\n        int r = word.size()-1;\\n\\n        while(l<r)\\n        {\\n            if(word[l] != word[r])\\n            {\\n                return false;\\n            }\\n            l++;\\n             r--;\\n        }\\n        return true;\\n\\n    }\\n    string firstPalindrome(vector<string>& words) {\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(check(words[i]))\\n            return words[i];\\n        }\\n\\n        return \"\";\\n        \\n    }\\n};\\n```"
    },
    {
        "slug": "shortest-bridge",
        "tags": "cpp",
        "release_time": 1684673230,
        "code": "class Solution {\npublic:\n\nint r[4] = {-1 , 0, 1, 0};\nint c[4] = {0 ,1 , 0 , -1};\n\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\n{\n    int n = vis[0].size();\n    vis[row][col] = 1;\n    v.push_back({row , col});\n    for(int i=0; i<4; i++)\n    {\n        int nrow = row + r[i];\n        int ncol = col + c[i];\n\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\n        {\n            dfs(nrow , ncol , v , vis , grid);\n        }\n    }\n\n}\n\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n        vector<pair<int,int>> v;\n        vector<pair<int,int>> v1;\n        vector<pair<int,int>> v2;\n        int n = grid.size();\n        vector<vector<int>> vis(n , vector<int>(n , 0));\n        bool flag = 0;\n        for(int i=0; i<n; i++)\n        {\n            for(int j=0; j<n; j++)\n            {\n                if(grid[i][j] == 1 and vis[i][j] == 0)\n                {\n                    dfs(i , j , v , vis, grid);\n                    if(flag == 0)\n                    {\n                        v1 = v;\n                        flag = 1;\n                        v.clear();\n                    }\n                    else\n                    {\n                        v2 = v;\n                    }\n                }\n            \n            }\n           \n        }\n        //printed just to check the co-ordinates****\n        //for(auto it: v1)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        //for(auto it: v2)\n        //{\n        //    cout<<it.first<<\" \"<<it.second<<endl;\n        //}\n        int ans = 1e9;\n\n\n        for(auto it: v1)\n        {\n            int row1 = it.first;\n            int col1 = it.second;\n\n            for(auto itt: v2)\n            {\n                int row2 = itt.first;\n                int col2 = itt.second;\n\n                int dist = abs(row1 - row2) + abs(col1 - col2);\n                dist--;\n                ans = min(ans , dist);\n            }\n        }\n    \n        return ans;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsimple push all the co-ordinates of the first and second island in two vectors by using dfs and then just calculate the distance between each point to every other point in both the vectors and since n is very small we will not get tle and this solution is accepted.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**1.Push all the co-ordinates of the first and second island in two vectors\\n2.then calculate the distance between each point to every point \\n3.take the minimum distance \\n4.return the minimum distance**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncomment time complexity in comments \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\ncomment space complexity in comments \\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint r[4] = {-1 , 0, 1, 0};\\nint c[4] = {0 ,1 , 0 , -1};\\n\\nvoid dfs(int row ,int col , vector<pair<int,int>> &v,vector<vector<int>>&vis,vector<vector<int>>&grid)\\n{\\n    int n = vis[0].size();\\n    vis[row][col] = 1;\\n    v.push_back({row , col});\\n    for(int i=0; i<4; i++)\\n    {\\n        int nrow = row + r[i];\\n        int ncol = col + c[i];\\n\\n        if(nrow>=0 and ncol>=0 and nrow<n and ncol<n and vis[nrow][ncol] == 0 and grid[nrow][ncol] == 1)\\n        {\\n            dfs(nrow , ncol , v , vis , grid);\\n        }\\n    }\\n\\n}\\n\\n    int shortestBridge(vector<vector<int>>& grid) {\\n        \\n        vector<pair<int,int>> v;\\n        vector<pair<int,int>> v1;\\n        vector<pair<int,int>> v2;\\n        int n = grid.size();\\n        vector<vector<int>> vis(n , vector<int>(n , 0));\\n        bool flag = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 1 and vis[i][j] == 0)\\n                {\\n                    dfs(i , j , v , vis, grid);\\n                    if(flag == 0)\\n                    {\\n                        v1 = v;\\n                        flag = 1;\\n                        v.clear();\\n                    }\\n                    else\\n                    {\\n                        v2 = v;\\n                    }\\n                }\\n            \\n            }\\n           \\n        }\\n        //printed just to check the co-ordinates****\\n        //for(auto it: v1)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        //for(auto it: v2)\\n        //{\\n        //    cout<<it.first<<\" \"<<it.second<<endl;\\n        //}\\n        int ans = 1e9;\\n\\n\\n        for(auto it: v1)\\n        {\\n            int row1 = it.first;\\n            int col1 = it.second;\\n\\n            for(auto itt: v2)\\n            {\\n                int row2 = itt.first;\\n                int col2 = itt.second;\\n\\n                int dist = abs(row1 - row2) + abs(col1 - col2);\\n                dist--;\\n                ans = min(ans , dist);\\n            }\\n        }\\n    \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "number-of-matching-subsequences",
        "tags": "cpp",
        "release_time": 1675105253,
        "code": "class Solution {\npublic:\nmap<char,vector<int>> count;\n    int numMatchingSubseq(string s, vector<string>& words) {\n        for(int i=0;i<s.size();i++){\n            count[s[i]].push_back(i);//add each position of each char\n        }\n        int z=0;\n        for(auto& x:words){\n            int p=-1;//find element greater thn this index\n            int r=0;//flag bit\n            for(int j=0;j<x.size();j++){\n                if(count.find(x[j])==count.end()){r=1;break;}\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\n                }\n            if(r==0)z+=1;\n        }\n        return z;\n    }\n};",
        "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<char,vector<int>> count;\\n    int numMatchingSubseq(string s, vector<string>& words) {\\n        for(int i=0;i<s.size();i++){\\n            count[s[i]].push_back(i);//add each position of each char\\n        }\\n        int z=0;\\n        for(auto& x:words){\\n            int p=-1;//find element greater thn this index\\n            int r=0;//flag bit\\n            for(int j=0;j<x.size();j++){\\n                if(count.find(x[j])==count.end()){r=1;break;}\\n                if(upper_bound(count[x[j]].begin(),count[x[j]].end(),p)==count[x[j]].end()){r=1;break;}//if grtr position not found\\n                p=count[x[j]][upper_bound(count[x[j]].begin(),count[x[j]].end(),p)-count[x[j]].begin()];//updating search index\\n                }\\n            if(r==0)z+=1;\\n        }\\n        return z;\\n    }\\n};\\n```"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "tags": "cpp",
        "release_time": 1690986169,
        "code": "class Solution {\npublic:\n    int find(vector<int>& inorder, int k) {\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\n        return -1;\n    }\n\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\n        return build(preorder, inorder, preIndex, inStart, inend);\n    }\n\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\n        if (inStart > inend) {\n            return NULL;\n        }\n\n        int ele = preorder[preIndex++];\n        TreeNode* root = new TreeNode(ele);\n        int pos_in_inorder = find(inorder, ele);\n\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\n        return root;\n    }\n};",
        "content": "# Intuition : First take a node from preorder, We know that for pre order traversal D-L-R and for inorder L-D-R. \\nFor this we have to build a tree according to preorder traversal one by one (by making that element as pivot) and by using inorder we have to find how many elements are left or right to that pivot element accordingly.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Simple Recursion \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n- 1) For making a tree in recursive function we\\'ll required O(n).\\n- 2) For finding element in inorder traversal we\\'ll required again O(n).\\n- Overall Complexity will be O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(vector<int>& inorder, int k) {\\n        for (int i = 0; i < inorder.size(); i++) if (inorder[i] == k) return i;\\n        return -1;\\n    }\\n\\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\\n        int preIndex = 0, inStart = 0, inend = inorder.size() - 1;\\n        return build(preorder, inorder, preIndex, inStart, inend);\\n    }\\n\\n    TreeNode* build(vector<int>& preorder, vector<int>& inorder, int& preIndex, int inStart, int inend) {\\n        if (inStart > inend) {\\n            return NULL;\\n        }\\n\\n        int ele = preorder[preIndex++];\\n        TreeNode* root = new TreeNode(ele);\\n        int pos_in_inorder = find(inorder, ele);\\n\\n        root->left = build(preorder, inorder, preIndex, inStart, pos_in_inorder - 1);\\n        root->right = build(preorder, inorder, preIndex, pos_in_inorder + 1, inend);\\n        return root;\\n    }\\n};\\n\\n```"
    },
    {
        "slug": "array-with-elements-not-equal-to-average-of-neighbors",
        "tags": "cpp",
        "release_time": 1664849911,
        "code": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        int size=nums.size();\n        for(int i=1;i<size-1;i++){\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\n                swap(nums[i],nums[i+1]);\n        }\n        return nums;\n    }\n};",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rearrangeArray(vector<int>& nums) {\\n        int size=nums.size();\\n        for(int i=1;i<size-1;i++){\\n            if((nums[i-1]<nums[i] && nums[i]<nums[i+1])||(nums[i-1]>nums[i] && nums[i]>nums[i+1]))   //If the array is strictly increasing or decreasing then swap the vlaue at current index  with value at index+1\\n                swap(nums[i],nums[i+1]);\\n        }\\n        return nums;\\n    }\\n};\\n```"
    },
    {
        "slug": "unique-paths-iii",
        "tags": "cpp",
        "release_time": 1692204101,
        "code": "class Solution {\npublic:\n   int count = 0 ; // Counter to keep track of the number of unique paths\n   int zeroes = 0 ; // Counter to keep track of the number of empty cells\n\n   // This function recursively explores the grid to find unique paths\n   void creator(vector<vector<int>>& grid, int row, int col, int length) {\n       // Base cases: if the current cell is out of bounds or marked as visited, return\n       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)\n           return; \n       \n       // If we encounter the destination (value 2) and all empty cells are covered, increment count\n       if (grid[row][col] == 2 && zeroes == length) {\n           count++;\n           return;\n       }\n       \n       int org = grid[row][col]; // Store the original value of the cell\n       grid[row][col] = 3; // Mark the cell as visited\n       \n       // Explore adjacent cells recursively in all four directions\n       creator(grid, row + 1, col, length + 1);\n       creator(grid, row - 1, col, length + 1);\n       creator(grid, row, col + 1, length + 1);\n       creator(grid, row, col - 1, length + 1);\n       \n       grid[row][col] = org; // Restore the original value of the cell\n       return;\n   }\n\n   int uniquePathsIII(vector<vector<int>>& grid) {\n       int row = 0; \n       int col = 0; \n       int free = 0; // Counter to keep track of the number of cells that can be visited\n\n       // Iterate through the grid to find the starting position and count empty cells\n       for (int i = 0; i < grid.size(); i++) {\n           for (int j = 0; j < grid[0].size(); j++) {\n               if (grid[i][j] == 1) {\n                   row = i; \n                   col = j;\n                   free++;\n               } else if (grid[i][j] == 0 || grid[i][j] == 2) {\n                   free++;\n               }\n           }\n       }\n       \n       zeroes = free; // Update the zeroes counter with the total number of empty cells\n       \n       // Start exploring paths from the initial position\n       creator(grid, row, col, 1);\n       \n       return count; // Return the total count of unique paths\n   }\n};",
        "content": "![image.png](https://assets.leetcode.com/users/images/d2a0428c-0b90-4b7f-839f-aa4ab67262ad_1692204076.471525.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int count = 0 ; // Counter to keep track of the number of unique paths\\n   int zeroes = 0 ; // Counter to keep track of the number of empty cells\\n\\n   // This function recursively explores the grid to find unique paths\\n   void creator(vector<vector<int>>& grid, int row, int col, int length) {\\n       // Base cases: if the current cell is out of bounds or marked as visited, return\\n       if (row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] == 3 || grid[row][col] == -1)\\n           return; \\n       \\n       // If we encounter the destination (value 2) and all empty cells are covered, increment count\\n       if (grid[row][col] == 2 && zeroes == length) {\\n           count++;\\n           return;\\n       }\\n       \\n       int org = grid[row][col]; // Store the original value of the cell\\n       grid[row][col] = 3; // Mark the cell as visited\\n       \\n       // Explore adjacent cells recursively in all four directions\\n       creator(grid, row + 1, col, length + 1);\\n       creator(grid, row - 1, col, length + 1);\\n       creator(grid, row, col + 1, length + 1);\\n       creator(grid, row, col - 1, length + 1);\\n       \\n       grid[row][col] = org; // Restore the original value of the cell\\n       return;\\n   }\\n\\n   int uniquePathsIII(vector<vector<int>>& grid) {\\n       int row = 0; \\n       int col = 0; \\n       int free = 0; // Counter to keep track of the number of cells that can be visited\\n\\n       // Iterate through the grid to find the starting position and count empty cells\\n       for (int i = 0; i < grid.size(); i++) {\\n           for (int j = 0; j < grid[0].size(); j++) {\\n               if (grid[i][j] == 1) {\\n                   row = i; \\n                   col = j;\\n                   free++;\\n               } else if (grid[i][j] == 0 || grid[i][j] == 2) {\\n                   free++;\\n               }\\n           }\\n       }\\n       \\n       zeroes = free; // Update the zeroes counter with the total number of empty cells\\n       \\n       // Start exploring paths from the initial position\\n       creator(grid, row, col, 1);\\n       \\n       return count; // Return the total count of unique paths\\n   }\\n};\\n\\n```"
    },
    {
        "slug": "longest-alternating-subarray",
        "tags": "cpp",
        "release_time": 1688832407,
        "code": "class Solution {\npublic:\n    int alternatingSubarray(vector<int>& v) {\n        int ans = 0;\n        for(int i = 0; i < v.size() - 1; i += 1) {\n            bool flag = true;\n            int cnt = 1;\n            for(int j = i + 1; j < v.size(); j += 1) {\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\n                flag = !flag;\n                cnt += 1;\n            }\n            ans = max(ans, cnt);\n        }\n        return ans <= 1 ? -1 : ans;\n    }\n};",
        "content": "```\\nclass Solution {\\npublic:\\n    int alternatingSubarray(vector<int>& v) {\\n        int ans = 0;\\n        for(int i = 0; i < v.size() - 1; i += 1) {\\n            bool flag = true;\\n            int cnt = 1;\\n            for(int j = i + 1; j < v.size(); j += 1) {\\n                if(v[j] - v[j - 1] != (flag ? 1 : -1)) break;\\n                flag = !flag;\\n                cnt += 1;\\n            }\\n            ans = max(ans, cnt);\\n        }\\n        return ans <= 1 ? -1 : ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "prime-in-diagonal",
        "tags": "cpp",
        "release_time": 1683960047,
        "code": "class Solution {\npublic:\n    bool check(int x){\n        if(x==1)return false;\n        for(int i = 2; i*i<=x; i++){\n            if(x%i==0)return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int i,ans=0,n=nums.size();\n        for(i = 0; i < n; i++){\n            if(check(nums[i][i]) && nums[i][i]>ans){\n                ans = nums[i][i];\n            }\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\n                ans = nums[i][n-1-i];\n            }\n        }\n        return ans;\n    }\n};",
        "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x){\\n        if(x==1)return false;\\n        for(int i = 2; i*i<=x; i++){\\n            if(x%i==0)return false;\\n        }\\n        return true;\\n    }\\n    int diagonalPrime(vector<vector<int>>& nums) {\\n        int i,ans=0,n=nums.size();\\n        for(i = 0; i < n; i++){\\n            if(check(nums[i][i]) && nums[i][i]>ans){\\n                ans = nums[i][i];\\n            }\\n            if(check(nums[i][n-1-i]) && nums[i][n-1-i]>ans){\\n                ans = nums[i][n-1-i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "find-the-longest-valid-obstacle-course-at-each-position",
        "tags": "cpp",
        "release_time": 1683425182,
        "code": "class Solution {\npublic:\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\n        \n        int n = nums.size();\n        \n        // lis store elements of longest increasing subsequence till ith\n        \n        vector<int> lis;\n        \n        // ans[i] store, no of elements satisfying the condition including ith\n        \n        vector<int> ans;\n\n        for(int i = 0; i < n; i++)\n        {\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\n                \n            ans.push_back(idx + 1);\n            \n            if(idx == lis.size())\n                lis.push_back(nums[i]);\n            \n            else\n            {\n                lis[idx] = nums[i];\n            }\n        }\n        \n        return ans;\n    }\n};",
        "content": "* ***Binary Search***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestObstacleCourseAtEachPosition(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // lis store elements of longest increasing subsequence till ith\\n        \\n        vector<int> lis;\\n        \\n        // ans[i] store, no of elements satisfying the condition including ith\\n        \\n        vector<int> ans;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int idx = upper_bound(lis.begin(), lis.end(), nums[i]) - lis.begin();\\n                \\n            ans.push_back(idx + 1);\\n            \\n            if(idx == lis.size())\\n                lis.push_back(nums[i]);\\n            \\n            else\\n            {\\n                lis[idx] = nums[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```"
    },
    {
        "slug": "length-of-longest-fibonacci-subsequence",
        "tags": "cpp",
        "release_time": 1667708738,
        "code": "class Solution {\npublic:\n  int f(int curr,int prev,vector<int>& nums,int n){\n\t\t\tint t=nums[curr]+nums[prev];\n\t\t\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\n\t\t\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\n\t\t\treturn 1;\n\t\t}\n\n\t\tint lenLongestFibSubseq(vector<int>& nums) {\n\t\t\tint n=nums.size();\n\t\t\tint maxi=0;\n\t\t\tfor(int prev2=0;prev2<n;prev2++){\n\t\t\t\tfor(int prev1=prev2+1;prev1<n;prev1++){\n\t\t\t\t\tint temp=nums[prev1]+nums[prev2];\n\t\t\t\t\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\n\t\t\t\t\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn maxi;\n\t\t}\n\t};",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int f(int curr,int prev,vector<int>& nums,int n){\\n\\t\\t\\tint t=nums[curr]+nums[prev];\\n\\t\\t\\tint i=lower_bound(nums.begin(),nums.end(),t)-nums.begin();\\n\\t\\t\\tif(i<n && nums[i]==t) return 1+f(i,curr,nums,n);\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint lenLongestFibSubseq(vector<int>& nums) {\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint maxi=0;\\n\\t\\t\\tfor(int prev2=0;prev2<n;prev2++){\\n\\t\\t\\t\\tfor(int prev1=prev2+1;prev1<n;prev1++){\\n\\t\\t\\t\\t\\tint temp=nums[prev1]+nums[prev2];\\n\\t\\t\\t\\t\\tint ind=lower_bound(nums.begin(),nums.end(),temp)-nums.begin();\\n\\t\\t\\t\\t\\tif(ind<n && nums[ind]==temp) maxi=max(maxi,2+f(ind,prev1,nums,n));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n```"
    },
    {
        "slug": "count-of-range-sum",
        "tags": "cpp",
        "release_time": 1623505237,
        "code": "class Solution {\npublic:\n    \n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\n    {\n        int count = 0;\n        \n        if(right - left <= 1)\n        {\n            if(right - left == 1)\n            {\n                return (lower <= sums[left] && sums[left] <= upper);\n            }\n            else\n            {\n                return 0;\n            }\n        }\n        \n        int mid = (left + right)/2;\n        \n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\n        \n        \n        int i = left;\n        int j = mid;\n        \n        int n = 0;\n        int m = 0;\n        \n        vector<long> cache(right - left, 0);\n        \n        int k = 0;\n        \n        \n        while(i < mid)\n        {\n            \n\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\n                {\n                    n++;\n                }\n            \n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\n                {\n                    m++;\n                }\n            \n            while(j < right && sums[j] < sums[i])\n            {\n                cache[k++] = sums[j++];\n            }\n            \n            cache[k++] = sums[i++];\n            \n            count += m-n;\n        }\n        \n        \n        while(j < right)\n        {\n            cache[k++] = sums[j++];\n        }\n        \n        \n        for(int idx = 0; idx<cache.size(); idx++)\n        {\n            sums[left + idx] = cache[idx];\n        }\n    \n        return leftSideSum + rightSideSum + count;\n        \n    }\n    \n    int countRangeSum(vector<int>& nums, int lower, int upper) {\n        \n        vector<long> prefixSum(nums.size(),0);\n        \n        int n = nums.size();\n        \n        prefixSum[0] = nums[0];\n        \n        for(int i = 1; i<nums.size(); i++)\n        {\n            prefixSum[i] = nums[i] + prefixSum[i-1];\n        }\n        \n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\n    }\n};",
        "content": "Hello, with this post I want to explain the solution to this problem to those who are encountering this problem for the first time (i.e. have not solved any other problems with this pattern), and are **NEW to solving HARD problems** in general. I will be explaining the solution found in this post https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation because this version of the solution applies commonly known concepts which anyone with basic data structures background should be able to grasp **(no BIT, fenwick tree or anything else which usually is not covered in a basic data structures course)**. Moreover, this approach is also applicable to other problems which are linked in the answer, hence it is most suitable for a beginner looking to learn general approaches/patterns.\\n\\nSo, the naive approach, which after some experience with medium problems, particularly like subarray sum etc. should come to one within a few minutes of thinking: Find the array of prefix sums, then use a nested loop to find all the sums which satisfy the given criteria. Of course O(n^2) will give TLE which is why this is HARD. \\n\\nSince I am also a beginner, I thought about it for a while and then moved on to reading a solution to understand what was the next step.\\n\\nI suppose for someone experienced, they may try some patterns with which n^2 problems are simplified, like DP or divide-and-conquer. The point of the hard problem is to start teaching you to inculcate this thinking of approaches when TLE after the naive solution is reached. So here, the mental question that should come to one\\'s mind is, \\n\\n* For DP: If I know the solution to nums[start:i-1], can I calculate the solution to nums[start:i]?\\n* For divide-and-conquer: If I know the solution to nums[start:mid] and nums[mid+1:end] (where mid = (start+end)/2 and end is the length of the array), can I calculate the solution to nums[start:end]?\\n\\nIn this case, it turns out that there is a divide and conquer solution. The solution is similar to **merge sort**.\\n\\nTake the PREFIX SUM array (and not the original array). Let this be called **sums**. \\n\\nIf we have the solution to the left and right halves of the array, we can find the solution to the complete array by finding suitable pairs of prefix sums, one from the left half and the other from the right half, and adding these to the solution from the left and right halves of the array.\\n\\nNow I will quote the crucial step from here: https://leetcode.com/problems/count-of-range-sum/discuss/1178174/Java-Clean-Merge-Sort-O(N-logN)-Solution-oror-with-detailed-Explanation\\n\\nThe merge sort based solution counts the answer while doing the merge. During the merge stage, we have already sorted the left half [start, mid) and right half [mid, end). We then iterate through the left half with index i. For each i, we need to find two indices k and j in the right half where\\n\\n* j is the first index satisfy sums[j] - sums[i] > upper and\\n* k is the first index satisfy sums[k] - sums[i] >= lower.\\n\\nThen the number of sums in [lower, upper] is j-k.\\n\\nTo understand this, consider any prefix sum after x elements. Consider another prefix sum after y elements such that x <= y. Then, if we know sums[x], then for x and y to form a range with a sum within the lower and upper bounds,  then the conditions sums[y] - sums[x] >= lower and sums[y] - sums[x] <= upper, should be satisfied. \\n\\nThis gives the **condition for y** as sums[y] <= sums[x] + upper and sums[y] >= sums[x] + lower, and y >= x.\\n\\nDuring merge sort note that the **relative ordering between the left and right halves is maintained** before the merging, so letting x belong to the left side of the array, y to the right half of the array maintains x <= y.\\n\\nHence if we make the count for each element in the left half of the array during the merge, then the count is guaranteed to be correct. \\n\\nAlso, due to sorted nature of subarrays used during merge, for a given x in the left subarray, since the right subarray is also sorted, it means that the elements within the desired range sums[x] + lower and sums[x] + upper are **found in a contiguous chunk** of the right subarray. \\n\\nMoreover, since the left subarray is also sorted, sums[x] increases with x **(monotonicity)**. This means that every time x is incremented, we can use the indices obtained for the range in the right subarray for the previous x, instead of starting both from 0, since both sums[x] + lower and sums[x] + upper can only increase. \\n\\n In the quoted bullet points above, the updates ensure that at the end of the updating, the indices cover the required range for each index.\\n\\nThe base case here is that a single element will add to the count if the element value lies between lower and upper otherwise the solution will be zero. \\n\\n**To write the solution** after understanding these steps, I used the following approach: Write merge sort in the usual way. Use two indices/pointers m and n starting from the beginning of the right subarray before the merge. At any block where the left subarray index is updated, update these two m and n. Add these to the total count. The function should return the sum of the counts of the left half, right half and the total count during the merge. \\n\\nMy first working solution in which I used the conventional merge sort template where following the main merge step there are two while loops, had to make the counts twice, once in the nested loop and once in the outside loop (since left subarray index is updated in these places). To get the form of the elegant solutions such as in the linked answer, I made the change to use an alternative form of merging where during every loop iteration, an update to the left index is guaranteed, and the merge concludes when the left subarray is completely traversed. \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int countWithMergeSort(vector<long> &sums, int left, int right, int lower, int upper)\\n    {\\n        int count = 0;\\n        \\n        if(right - left <= 1)\\n        {\\n            if(right - left == 1)\\n            {\\n                return (lower <= sums[left] && sums[left] <= upper);\\n            }\\n            else\\n            {\\n                return 0;\\n            }\\n        }\\n        \\n        int mid = (left + right)/2;\\n        \\n        int leftSideSum = countWithMergeSort(sums, left, mid, lower, upper);\\n        int rightSideSum = countWithMergeSort(sums, mid, right, lower, upper);\\n        \\n        \\n        int i = left;\\n        int j = mid;\\n        \\n        int n = 0;\\n        int m = 0;\\n        \\n        vector<long> cache(right - left, 0);\\n        \\n        int k = 0;\\n        \\n        \\n        while(i < mid)\\n        {\\n            \\n\\n            while(mid+n < right && sums[mid+n] < sums[i]+lower)\\n                {\\n                    n++;\\n                }\\n            \\n            while(mid+m < right && sums[mid+m] <= sums[i] + upper)\\n                {\\n                    m++;\\n                }\\n            \\n            while(j < right && sums[j] < sums[i])\\n            {\\n                cache[k++] = sums[j++];\\n            }\\n            \\n            cache[k++] = sums[i++];\\n            \\n            count += m-n;\\n        }\\n        \\n        \\n        while(j < right)\\n        {\\n            cache[k++] = sums[j++];\\n        }\\n        \\n        \\n        for(int idx = 0; idx<cache.size(); idx++)\\n        {\\n            sums[left + idx] = cache[idx];\\n        }\\n    \\n        return leftSideSum + rightSideSum + count;\\n        \\n    }\\n    \\n    int countRangeSum(vector<int>& nums, int lower, int upper) {\\n        \\n        vector<long> prefixSum(nums.size(),0);\\n        \\n        int n = nums.size();\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i = 1; i<nums.size(); i++)\\n        {\\n            prefixSum[i] = nums[i] + prefixSum[i-1];\\n        }\\n        \\n        return countWithMergeSort(prefixSum, 0, n, lower, upper);\\n    }\\n};\\n```\\n\\nAny comments or suggestions are welcome as I am also a beginner (took me 3+ hours to get this) who has spent some time in learning/convincing myself of the approach. I tried to address the points which took up a lot of my time while trying to understand some of the other solutions. \\n\\n\\n\\n\\n"
    },
    {
        "slug": "power-of-heroes",
        "tags": "cpp",
        "release_time": 1683993728,
        "code": "class Solution {\n    const int M = 1000000007;\n    int mul(long long x, long long y) {\n        return x * y % M;\n    }\n    \n    int add(int x, int y) {\n        if ((x += y) >= M) {\n            x -= M;\n        }\n        return x; \n    }\n\npublic:\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        const int n = nums.size();\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\n        for (int i = 1, last = 0; i < n; ++i) {\n            last = add(nums[i - 1], add(last, last));\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\n        }\n        \n        return r;\n    }\n};",
        "content": "# Intuition\\nJust sort\\n\\n# Approach\\nJust sort\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\nC++\\n```\\nclass Solution {\\n    const int M = 1000000007;\\n    int mul(long long x, long long y) {\\n        return x * y % M;\\n    }\\n    \\n    int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\npublic:\\n    int sumOfPower(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        const int n = nums.size();\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n        \\n        return r;\\n    }\\n};\\n```\\n\\n\\nJava\\n```\\n\\nclass Solution {\\n    private final int M = 1000000007;\\n    private int mul(long x, long y) {\\n        return (int) (x * y % M);\\n    }\\n\\n    private int add(int x, int y) {\\n        if ((x += y) >= M) {\\n            x -= M;\\n        }\\n        return x; \\n    }\\n\\n    public int sumOfPower(int[] nums) {\\n        Arrays.sort(nums);\\n        final int n = nums.length;\\n        int r = mul(mul(nums[0], nums[0]), nums[0]);\\n        for (int i = 1, last = 0; i < n; ++i) {\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        }\\n\\n        return r;\\n    }\\n}\\n\\n```\\n\\nPython3\\n\\n```\\nclass Solution:\\n    def sumOfPower(self, nums: List[int]) -> int:\\n        M = 1000000007\\n        def mul(x: int, y: int) -> int:\\n            return x * y % M\\n        \\n        def add(x: int, y: int) -> int:\\n            x += y\\n            if x >= M:\\n                x -= M\\n            return x; \\n        nums.sort()\\n        n = len(nums)\\n        r = mul(mul(nums[0], nums[0]), nums[0])\\n        last = 0\\n        for i in range(1, n):\\n            last = add(nums[i - 1], add(last, last));\\n            r = add(r, mul(add(last, nums[i]), mul(nums[i], nums[i])));\\n        return r;\\n\\n        \\n```\\n"
    },
    {
        "slug": "game-of-life",
        "tags": "cpp",
        "release_time": 1692484401,
        "code": "class Solution {\npublic:\n    void gameOfLife(vector<vector<int>>& board) {\n\n        int rows = board.size();\n        int cols = board[0].size();\n\n        //copying the board to 2-D vector copy\n        vector<vector<int>> copy(board);\n\n        for(int i=0; i<rows; i++)\n        {\n            for(int j=0; j<cols; j++)\n            {\n                //for counting live neighbors of the element\n                int liveNeighbors = 0; \n                \n                //iterating through all the neighbors of the element (inside the board and outside the board)\n                for(int m=i-1; m<i+2; m++)\n                {\n                    for(int n=j-1; n<j+2; n++)\n                    {\n                        //we will skip the iteration when element itself is encountered\n                        if(m==i && n==j)\n                            continue;\n\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\n                            liveNeighbors++;\n                    }\n                }\n                \n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\n                if(liveNeighbors < 2 || liveNeighbors > 3)\n                    board[i][j] = 0;\n\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\n                else if(liveNeighbors == 3)\n                    board[i][j] = 1;\n\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\n\n            }\n        }\n    }\n};",
        "content": "\\n---\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to update the grid according to the following rules : \\n1. Any live cell with fewer than two live neighbors dies as if caused by under-population.\\n2. Any live cell with two or three live neighbors lives on to the next generation.\\n3. Any live cell with more than three live neighbors dies, as if by over-population.\\n4. Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\\n\\n\\n---\\n\\n\\n# Approach 1 : Using extra space for copying the board\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will make a copy of original board and then modify the original board by counting the live neighbours from the copy board.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n        //copying the board to 2-D vector copy\\n        vector<vector<int>> copy(board);\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0; \\n                \\n                //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n\\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && copy[m][n] == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, if liveNeighbors are less than 2 or more than 3, cells will die and dead cells are already dead, so we need not check cell to be live or dead\\n                if(liveNeighbors < 2 || liveNeighbors > 3)\\n                    board[i][j] = 0;\\n\\n                //for dead cells, if liveNeighbors are exactly 3, it will live and live cell will also live for exactly 3 liveNeighbors\\n                else if(liveNeighbors == 3)\\n                    board[i][j] = 1;\\n\\n                //For live cells, if liveNeighbors are exactly 2, it will live but we need not update it as it is already live\\n\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\nWe are using extra space for copying the board.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# Approach 2 : Using no extra space\\n<!-- Describe your approach to solving the problem. -->\\n- In this approach, we will use two extra digits i.e. 2 and 3 for in-place modifications.\\n- Digits will be as follows : \\n`0 - Dead cell which will remain dead in next state`\\n`1 - Live cell which will die in next state`\\n`2 - Dead cell which will live in next state`\\n`3 - Live cell which will live in next state`\\n\\n\\nSo the approach is that we will iterate through each cell of the board and count the live Neighbors. On the basis of the conditions given in the question, we will modify the board accordingly.\\n- For live cells, if liveNeighbors are exactly 2 or 3, they will live in next state, so we will change them to 3 by adding 2 to its value . If liveNeighbors are less than 2 or more than 3, they will die in next state so we will leave it as 1.\\n-`It can be observed that even after modifying the value of live cell to 3, we can still know about the its current state by using board[i][j] mod 2 as 3%2=1.`\\n\\n- For dead cells, if liveNeighbors are exactly 3, they will live so we will update them to 2 by adding 2 to it. Otherwise they will remain dead in next state for rest of the cases, so we will not change it.\\n-`It can be observed that even after modifying the value of dead cell to 2, we can still know about the its current state by using board[i][j] mod 2 as 2%2=0.`\\n\\nSo we will use board[i][j] % 2 for checking its current state.\\n\\nNow we will iterate through the board and for all cells with values 0 or 1, we will set it to 0 and for values 2 and 3, we will set it to 1.\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void gameOfLife(vector<vector<int>>& board) {\\n\\n        int rows = board.size();\\n        int cols = board[0].size();\\n\\n\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                //for counting live neighbors of the element\\n                int liveNeighbors = 0;\\n\\n                 //iterating through all the neighbors of the element (inside the board and outside the board)\\n                for(int m=i-1; m<i+2; m++)\\n                {\\n                    for(int n=j-1; n<j+2; n++)\\n                    {\\n                        //we will skip the iteration when element itself is encountered\\n                        if(m==i && n==j)\\n                            continue;\\n                        \\n                        //checking the bounds, if indices are in range, we will check for liveNeighbors\\n                        if(m>=0 && m<rows && n>=0 && n<cols && board[m][n]%2 == 1)\\n                            liveNeighbors++;\\n                    }\\n                }\\n                \\n                //for live cells, doing the modifications\\n                if(board[i][j]%2 == 1)\\n                {\\n                    if(liveNeighbors == 2 || liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n                //for dead cells, doing the modifications\\n                else\\n                {\\n                    if(liveNeighbors == 3)\\n                        board[i][j] += 2;\\n                }\\n            }\\n        }\\n\\n        //iterating through the board and setting the values accordingly\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(board[i][j] >= 2)\\n                    board[i][j] = 1;\\n\\n                else\\n                    board[i][j] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\nNo extra space is used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n### Do upvote if it helps :)"
    }
]