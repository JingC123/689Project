[
    {
        "slug": "count-number-of-rectangles-containing-each-point",
        "tags": "java",
        "release_time": 1650772909,
        "code": "class Solution {\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\n        int max = Integer.MIN_VALUE;\n        \n        TreeMap<Integer, List<Integer>> rects = new TreeMap<>();\n        for(int[] rect : rectangles) {\n            if (!rects.containsKey(rect[1])) {\n                rects.put(rect[1], new ArrayList<Integer>());\n            }\n            \n            rects.get(rect[1]).add(rect[0]);\n            max = Math.max(max, rect[1]);\n        }\n        \n        for(int k : rects.keySet()) {\n            Collections.sort(rects.get(k));\n        }\n        \n        int[] ans = new int[points.length];\n        for(int i = 0; i < points.length; i++) {\n            if (points[i][1] > max) {\n                continue;\n            }\n\n            int count = 0;\n            \n            for(int key : rects.subMap(points[i][1], max + 1).keySet()) {\n                List<Integer> y = rects.get(key);\n                \n                count += binarySearch(y, points[i][0]);\n            }\n            \n            ans[i] = count;\n        }\n\n        return ans;\n    }\n    \n    private int binarySearch(List<Integer> vals, int val) {\n        int lo = 0;\n        int hi = vals.size() - 1;\n        int id = -1;\n        \n        while(lo <= hi) {\n            int mid = lo + (hi - lo) / 2;\n            \n            if (vals.get(mid) < val) {\n                lo = mid + 1;\n            } else {\n                id = mid;\n                hi = mid - 1;\n            }\n        }\n        \n        if (id < 0) {\n            return 0;\n        }\n        \n        return vals.size() - id;\n    }\n}",
        "content": "\\nPrepare a TreeMap with key as `y` and values as list of corresponding `x` for all the rectangle.\\nNow we can get the range of `y` co-ordinagtes in `log(n)` time using TreeMap function `subMap` and \\nfor each `y` in this submap, we can get the list of `x` coordinate and run binary search (after sorting it one time) on it to find the valid `x` co-ordinate of rectangles in `log(n)` time.\\n    \\nThe key observaion here is the range of `y`. It can only go from 1 to 100.\\nIf instead of `y`, you use `x` of rectangle as the key in the TreeMap, the code will TimeOut since `x` can vary on much wider range hence you will be running binary search too many times.\\n\\n```\\nclass Solution {\\n    public int[] countRectangles(int[][] rectangles, int[][] points) {\\n        int max = Integer.MIN_VALUE;\\n        \\n        TreeMap<Integer, List<Integer>> rects = new TreeMap<>();\\n        for(int[] rect : rectangles) {\\n            if (!rects.containsKey(rect[1])) {\\n                rects.put(rect[1], new ArrayList<Integer>());\\n            }\\n            \\n            rects.get(rect[1]).add(rect[0]);\\n            max = Math.max(max, rect[1]);\\n        }\\n        \\n        for(int k : rects.keySet()) {\\n            Collections.sort(rects.get(k));\\n        }\\n        \\n        int[] ans = new int[points.length];\\n        for(int i = 0; i < points.length; i++) {\\n            if (points[i][1] > max) {\\n                continue;\\n            }\\n\\n            int count = 0;\\n            \\n            for(int key : rects.subMap(points[i][1], max + 1).keySet()) {\\n                List<Integer> y = rects.get(key);\\n                \\n                count += binarySearch(y, points[i][0]);\\n            }\\n            \\n            ans[i] = count;\\n        }\\n\\n        return ans;\\n    }\\n    \\n    private int binarySearch(List<Integer> vals, int val) {\\n        int lo = 0;\\n        int hi = vals.size() - 1;\\n        int id = -1;\\n        \\n        while(lo <= hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            \\n            if (vals.get(mid) < val) {\\n                lo = mid + 1;\\n            } else {\\n                id = mid;\\n                hi = mid - 1;\\n            }\\n        }\\n        \\n        if (id < 0) {\\n            return 0;\\n        }\\n        \\n        return vals.size() - id;\\n    }\\n}\\n```"
    },
    {
        "slug": "final-prices-with-a-special-discount-in-a-shop",
        "tags": "java",
        "release_time": 1685478056,
        "code": "class Solution {\n    public int[] finalPrices(int[] prices) {\n        for(int i = 0; i < prices.length; i++)\n            prices[i] = getPrice(i, prices[i], prices); \n        return prices;\n    }\n\n    public int getPrice(int i, int price, int[] prices){\n        for(int j = i + 1; j < prices.length; j++)\n            if(prices[j] <= prices[i])\n                return price - prices[j];\n        return price;\n    }\n}",
        "content": "# Approach\\n\\nThe `finalPrices` function takes an integer array `prices` as input and returns an integer array as the output. It initializes a for loop that iterates from 0 to the length of the `prices` array.\\n\\nInside the loop, it calls the `getPrice` function, passing the current index `i`, the price at index `i` in the `prices` array, and the `prices` array itself. The `getPrice` function calculates the discount for the current item based on the subsequent items.\\n\\nThe `getPrice` function also uses a for loop, starting from the index next to `i` (i + 1) and continuing until the end of the `prices` array. It checks if the price at the current index `j` is less than or equal to the price at index `i`. If it is, it means a discount is available.\\n\\nIn that case, the function subtracts the discounted price (the price at index `j`) from the original price (the price at index `i`) and returns the result. This represents the final price the customer will pay for the item.\\n\\nIf no discount is found during the iteration, the function simply returns the original price, indicating that no discount is applicable for that item.\\n\\nBack in the `finalPrices` function, the result of the `getPrice` function is assigned to the `i`th index of the `prices` array. This updates the array with the final prices for each item as they are processed.\\n\\nFinally, after iterating through all the items in the `prices` array, the modified `prices` array is returned as the output of the `finalPrices` function.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] finalPrices(int[] prices) {\\n        for(int i = 0; i < prices.length; i++)\\n            prices[i] = getPrice(i, prices[i], prices); \\n        return prices;\\n    }\\n\\n    public int getPrice(int i, int price, int[] prices){\\n        for(int j = i + 1; j < prices.length; j++)\\n            if(prices[j] <= prices[i])\\n                return price - prices[j];\\n        return price;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-number-of-operations-to-move-all-balls-to-each-box",
        "tags": "java",
        "release_time": 1677333410,
        "code": "class Solution {\n    public int[] minOperations(String boxes) {\n        int [] m = new int[boxes.length()];\n        for(int i = 0; i < boxes.length(); i++){\n            for(int j = 0; j < boxes.length(); j++){\n                if(boxes.charAt(j) == '1' && i !=  j)\n                    m[i] += Math.abs(i-j);\n            }\n        }   \n        return m;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minOperations(String boxes) {\\n        int [] m = new int[boxes.length()];\\n        for(int i = 0; i < boxes.length(); i++){\\n            for(int j = 0; j < boxes.length(); j++){\\n                if(boxes.charAt(j) == \\'1\\' && i !=  j)\\n                    m[i] += Math.abs(i-j);\\n            }\\n        }   \\n        return m;\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "tags": "java",
        "release_time": 1691762677,
        "code": "class Solution {\n    public boolean checkOnesSegment(String s) {\n        int count=0;\n       int pos=0;\n       while(s.charAt(pos)!='1'){\n              pos++;\n            if(pos==s.length()){\n                return true;\n            }\n          }\n       \n       for(int i=pos;i<s.length();i++){\n          if(s.charAt(i)=='0'){\n              count++;\n          }\n          else if(count>0&&s.charAt(i)=='1'){\n              return false;\n          }\n       } \n       return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkOnesSegment(String s) {\\n        int count=0;\\n       int pos=0;\\n       while(s.charAt(pos)!=\\'1\\'){\\n              pos++;\\n            if(pos==s.length()){\\n                return true;\\n            }\\n          }\\n       \\n       for(int i=pos;i<s.length();i++){\\n          if(s.charAt(i)==\\'0\\'){\\n              count++;\\n          }\\n          else if(count>0&&s.charAt(i)==\\'1\\'){\\n              return false;\\n          }\\n       } \\n       return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "relative-sort-array",
        "tags": "java",
        "release_time": 1691725804,
        "code": "import java.util.Arrays;\n\nclass Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        Arrays.sort(arr1);\n        int[] ans = new int[arr1.length];\n        int start = 0;\n        int end = arr1.length - 1;\n        int index = 0;\n\n        for (int i = 0; i < arr2.length; i++) {\n            int target = arr2[i];\n            start = 0;\n            end = arr1.length - 1;\n\n            while (end >= start) {\n                int mid = start + (end - start) / 2;\n                if (arr1[mid] == target) {\n                    for (int j = start; j <= end; j++) {\n                        if (arr1[j] == target) {\n                            ans[index++] = arr1[j];\n                        }\n                    }\n                    break;\n                }\n                if (arr1[mid] < target) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n        }\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (index == arr1.length) {\n                break;\n            }\n            boolean found = false;\n            for (int num : arr2) {\n                if (arr1[i] == num) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ans[index++] = arr1[i];\n            }\n        }\n\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr1);\\n        int[] ans = new int[arr1.length];\\n        int start = 0;\\n        int end = arr1.length - 1;\\n        int index = 0;\\n\\n        for (int i = 0; i < arr2.length; i++) {\\n            int target = arr2[i];\\n            start = 0;\\n            end = arr1.length - 1;\\n\\n            while (end >= start) {\\n                int mid = start + (end - start) / 2;\\n                if (arr1[mid] == target) {\\n                    for (int j = start; j <= end; j++) {\\n                        if (arr1[j] == target) {\\n                            ans[index++] = arr1[j];\\n                        }\\n                    }\\n                    break;\\n                }\\n                if (arr1[mid] < target) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < arr1.length; i++) {\\n            if (index == arr1.length) {\\n                break;\\n            }\\n            boolean found = false;\\n            for (int num : arr2) {\\n                if (arr1[i] == num) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            if (!found) {\\n                ans[index++] = arr1[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "find-the-distinct-difference-array",
        "tags": "java",
        "release_time": 1683432177,
        "code": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int[] d=new int[n];\n        for (int i = 0; i < n; i++) {\n            Set<Integer> pre=new HashSet<>();\n            for (int j = 0; j <= i; j++) {\n                pre.add(nums[j]);\n            }\n            Set<Integer> suf=new HashSet<>();\n            for (int j = i + 1; j < n; j++) {\n                suf.add(nums[j]);\n            }\n            d[i]=pre.size()-suf.size();\n        }\n        return d;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int[] d=new int[n];\\n        for (int i = 0; i < n; i++) {\\n            Set<Integer> pre=new HashSet<>();\\n            for (int j = 0; j <= i; j++) {\\n                pre.add(nums[j]);\\n            }\\n            Set<Integer> suf=new HashSet<>();\\n            for (int j = i + 1; j < n; j++) {\\n                suf.add(nums[j]);\\n            }\\n            d[i]=pre.size()-suf.size();\\n        }\\n        return d;\\n    }\\n}\\n```"
    },
    {
        "slug": "binary-search-tree-iterator",
        "tags": "java",
        "release_time": 1678076629,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n\n    List<Integer> l;\n    int len;\n    int curr;\n\n    public BSTIterator(TreeNode root) {\n        BST1 B = new BST1();\n        B.inOrder(root);\n        this.l = B.l;\n        len = this.l.size();\n        this.curr = 0;\n\n    }\n\n    public int next() {\n        int data = -1;\n        if (curr < len) {\n            data = l.get(curr);\n            curr++;\n        }\n\n        return data;\n\n    }\n\n    public boolean hasNext() {\n        return curr < len;\n\n    }\n}\n\nclass BST1 {\n\n    List<Integer> l = new ArrayList<>();\n\n    public void inOrder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inOrder(root.left);\n        l.add(root.val);\n        inOrder(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
        "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n\\n    List<Integer> l;\\n    int len;\\n    int curr;\\n\\n    public BSTIterator(TreeNode root) {\\n        BST1 B = new BST1();\\n        B.inOrder(root);\\n        this.l = B.l;\\n        len = this.l.size();\\n        this.curr = 0;\\n\\n    }\\n\\n    public int next() {\\n        int data = -1;\\n        if (curr < len) {\\n            data = l.get(curr);\\n            curr++;\\n        }\\n\\n        return data;\\n\\n    }\\n\\n    public boolean hasNext() {\\n        return curr < len;\\n\\n    }\\n}\\n\\nclass BST1 {\\n\\n    List<Integer> l = new ArrayList<>();\\n\\n    public void inOrder(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        inOrder(root.left);\\n        l.add(root.val);\\n        inOrder(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```"
    },
    {
        "slug": "perfect-number",
        "tags": "java",
        "release_time": 1683370625,
        "code": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if(num==1){\n            return false;\n        }\n        int sum=1;\n        for(int i =2 ;i*i<=num;i++){\n            if(num%i==0){\n                sum+=i+ num/i;  \n            }\n        }\n        if(num==sum){\n            return true;\n        }\n        return false;\n    }\n}",
        "content": "![image.png](https://assets.leetcode.com/users/images/9efca421-50e2-4af1-94b6-5c5dcba4cc28_1683370607.0372207.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkPerfectNumber(int num) {\\n        if(num==1){\\n            return false;\\n        }\\n        int sum=1;\\n        for(int i =2 ;i*i<=num;i++){\\n            if(num%i==0){\\n                sum+=i+ num/i;  \\n            }\\n        }\\n        if(num==sum){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "tags": "java",
        "release_time": 1691442100,
        "code": "class Solution {\n    public int countPossibility(int []nums,int x){\n        int cnt=0;\n        for(int n:nums) if(n>=x) cnt++;\n        return cnt;\n    }\n    public int specialArray(int[] nums) {\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\n        for(int x:nums) maxi=Math.max(maxi,x);\n        int end = maxi;\n        while(start<=end){\n            mid = (start+end)/2;\n            int check = countPossibility(nums,mid);\n            if(check==mid) return mid;\n            if(mid<check) start=mid+1;\n            else end=mid-1;\n        }\n        return -1;\n    }\n}",
        "content": "# Intuition\\n  First of all we will discuss Why Binary Search, even if the array is not sorted . Look here the array is not sorted but lemme tell you if we have some range so we can definitely apply binary search on range because range is something which will always be in a sorted fashion for example suppose we have the range [5,20] so here 5 to 20 means 5,6,7,8,9,10...till 20 which is sorted in itself. So remember we can apply Binary Search on **range** too.\\n\\nNow, here the array is not sorted so what left? Can we figure out some range? Yes we definitely can !! Just observe this atleast we will be having 1 such element which will be greater than other elements , right? so our range will definitely start from 1 now what will be the ending point ? It will definitely be the maximum element of an array. Now we have the range [1,max_element] on which we can apply Binary Search.\\n\\nNow we can apply standard binary search algorithm here which consist of 4 steps :\\nStep 1 : Calculate the mid point.\\nStep 2 : If the mid meets the desire result we will simply returns it.\\nStep 3 : a) If the mid has more greater number than obviously the numbers which are present before to mid will also has the greater numbers so in this situation it would be like a time waste to search in the left half , rather we can reduce our search space and will eliminate the left half and can jump to the right half.\\nStep 4 : b) Otherwise we will simply jump to left part instead of searching in right half.\\n\\n# Approach\\n  Binary Search Algorithm.\\n\\n# Complexity\\n- Time complexity:\\n  O(max)*logn\\n\\n- Space complexity:\\n  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPossibility(int []nums,int x){\\n        int cnt=0;\\n        for(int n:nums) if(n>=x) cnt++;\\n        return cnt;\\n    }\\n    public int specialArray(int[] nums) {\\n        int maxi=Integer.MIN_VALUE,start=1,mid=0;\\n        for(int x:nums) maxi=Math.max(maxi,x);\\n        int end = maxi;\\n        while(start<=end){\\n            mid = (start+end)/2;\\n            int check = countPossibility(nums,mid);\\n            if(check==mid) return mid;\\n            if(mid<check) start=mid+1;\\n            else end=mid-1;\\n        }\\n        return -1;\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-number-has-equal-digit-count-and-digit-value",
        "tags": "java",
        "release_time": 1681988192,
        "code": "class Solution {\n    public boolean digitCount(String num) {\n\n        //creating an integer - integer hashmap\n\n        HashMap<Integer, Integer> map = new HashMap<>();\n\n        for(int i = 0; i < num.length(); i++)\n        {\n            char x = num.charAt(i);\n\n            int a = x - '0'; // to create character to integer\n\n            if(map.containsKey(a))\n                map.put(a,map.get(a)+1);\n\n            else\n                map.put(a,1);\n\n        }\n\n        for(int i = 0; i<num.length(); i++)\n        {\n\n            // to avoid nullPointerException\n\n            if(!map.containsKey(i))\n            {\n                if(num.charAt(i)!='0') //it must be 0, else false\n                    return false;\n                else //if it is 0, then continue\n                    continue;\n            }\n            char x = num.charAt(i); //let num[i] = x\n            int a = x - '0'; //convert x to int\n            if(a!=map.get(i)) //check if its equal to frequency\n                return false;\n\n        }\n\n        return true;\n    }\n}",
        "content": "# Intuition\\nconsidering {1210}\\n\\n    HASHMAP :\\n\\n    {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\n    index : 0 1 2 3\\n    number: 1 2 1 0\\n\\n    according to the question,\\n\\n    num[i] should be equal to frequency of index i\\n\\n    let x = num.charAt(i)\\n    convert character to integer using -\\n    int a = x - \\'0\\';\\n\\n    thus, if(a != frequency of a) i.e if(a != map.get(i)) return false;\\n\\n\\n    but to avoid null pointer exception, we must check if the hashmap contains all indices or not, if it doesnt, then num[i] must be 0 as in this case,\\n\\nindex 3 is not in hashmap {\\n        0:1\\n        1:2\\n        2:3\\n    }\\n\\nso , if it doesnot contain in hashmap (! map.containsKey(i))\\n\\nthen check if num[i] must be 0, else return false;,\\nif it is 0, then continue\\n\\n# Time Complexity - O(n)\\n# Space Complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean digitCount(String num) {\\n\\n        //creating an integer - integer hashmap\\n\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < num.length(); i++)\\n        {\\n            char x = num.charAt(i);\\n\\n            int a = x - \\'0\\'; // to create character to integer\\n\\n            if(map.containsKey(a))\\n                map.put(a,map.get(a)+1);\\n\\n            else\\n                map.put(a,1);\\n\\n        }\\n\\n        for(int i = 0; i<num.length(); i++)\\n        {\\n\\n            // to avoid nullPointerException\\n\\n            if(!map.containsKey(i))\\n            {\\n                if(num.charAt(i)!=\\'0\\') //it must be 0, else false\\n                    return false;\\n                else //if it is 0, then continue\\n                    continue;\\n            }\\n            char x = num.charAt(i); //let num[i] = x\\n            int a = x - \\'0\\'; //convert x to int\\n            if(a!=map.get(i)) //check if its equal to frequency\\n                return false;\\n\\n        }\\n\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "mirror-reflection",
        "tags": "java",
        "release_time": 1659577168,
        "code": "class Solution {\n    public int mirrorReflection(int p, int q) {\n        while(((p|q)&1) == 0){\n            p >>= 1;\n            q >>= 1;\n        }\n        return (q&1) + ((p&1)^1);\n    }\n}",
        "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    public int mirrorReflection(int p, int q) {\\n        while(((p|q)&1) == 0){\\n            p >>= 1;\\n            q >>= 1;\\n        }\\n        return (q&1) + ((p&1)^1);\\n    }\\n}\\n```"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "tags": "java",
        "release_time": 1616918029,
        "code": "class Solution {\n    int MOD = (int)(1e9+7);\n\n    public int maxNiceDivisors(int n) {\n        if(n <= 3) return n;\n        \n        /*\n            Approach\n            let say\n            m = (p1 ^ e1) * (p2 ^ e2) ....  (pn ^ en)\n            where p1, p2 ..... pn are primes\n            and e1, e2, .. ..en are exponeent (power)\n            \n            As given n is the prime factor, \n            n will be n = e1 + e2 + e3 .... en\n            \n            and number of divisor will \n              divisorCount =  e1 * e2 * e3 .... en\n            \n            \n            As in give problem statement, we want maximum divisor count\n            so if want max divisor, so must large exponent,\n            for largerst exponent, we must have smallest prime number as\n            possible as.\n            \n            \n            for this we can use only 2 numbers ,  2 and 3 as prime numbers\n            \n            we can convert any big number into 2s, 3s power\n            \n            Algorithm\n            1. Keep adding 3s as long as n \\u2265 5 and then subtarct 3 \n            2. at end it will left, either 0, 2, 4\n            3. so multiple the result by remaining n (except 0)\n            \n        */\n        \n        \n        long divisorCount = 1L;\n        int remainder = n % 3;\n        \n        if(remainder == 0){\n            divisorCount = power(3, n / 3);\n        \n        }else if(remainder == 1) {\n            divisorCount = 4 * power(3, (n - 4) / 3); \n        \n        }else if(remainder == 2){\n            divisorCount = 2 * power(3, n / 3);\n        }\n        \n        return (int) (divisorCount % MOD);\n    }\n    \n    private long power(long num, long exp){\n        if (exp == 1) return num;\n        if (exp == 0) return 1;\n        \n        long k1 = power(num, exp / 2);\n        if (exp % 2 == 0) {\n            return (k1 * k1) % MOD;\n        } else {\n            return (k1 * k1 * num) % MOD;\n        }\n    }\n}",
        "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    int MOD = (int)(1e9+7);\\n\\n    public int maxNiceDivisors(int n) {\\n        if(n <= 3) return n;\\n        \\n        /*\\n            Approach\\n            let say\\n            m = (p1 ^ e1) * (p2 ^ e2) ....  (pn ^ en)\\n            where p1, p2 ..... pn are primes\\n            and e1, e2, .. ..en are exponeent (power)\\n            \\n            As given n is the prime factor, \\n            n will be n = e1 + e2 + e3 .... en\\n            \\n            and number of divisor will \\n              divisorCount =  e1 * e2 * e3 .... en\\n            \\n            \\n            As in give problem statement, we want maximum divisor count\\n            so if want max divisor, so must large exponent,\\n            for largerst exponent, we must have smallest prime number as\\n            possible as.\\n            \\n            \\n            for this we can use only 2 numbers ,  2 and 3 as prime numbers\\n            \\n            we can convert any big number into 2s, 3s power\\n            \\n            Algorithm\\n            1. Keep adding 3s as long as n \\u2265 5 and then subtarct 3 \\n            2. at end it will left, either 0, 2, 4\\n            3. so multiple the result by remaining n (except 0)\\n            \\n        */\\n        \\n        \\n        long divisorCount = 1L;\\n        int remainder = n % 3;\\n        \\n        if(remainder == 0){\\n            divisorCount = power(3, n / 3);\\n        \\n        }else if(remainder == 1) {\\n            divisorCount = 4 * power(3, (n - 4) / 3); \\n        \\n        }else if(remainder == 2){\\n            divisorCount = 2 * power(3, n / 3);\\n        }\\n        \\n        return (int) (divisorCount % MOD);\\n    }\\n    \\n    private long power(long num, long exp){\\n        if (exp == 1) return num;\\n        if (exp == 0) return 1;\\n        \\n        long k1 = power(num, exp / 2);\\n        if (exp % 2 == 0) {\\n            return (k1 * k1) % MOD;\\n        } else {\\n            return (k1 * k1 * num) % MOD;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "distribute-candies",
        "tags": "java",
        "release_time": 1672810514,
        "code": "class Solution {\n    public int distributeCandies(int[] candyType) {\n\n    Set<Integer>st=new HashSet<>();\n\n    for(int i=0;i<candyType.length;i++){\n        st.add(candyType[i]);\n        if(st.size()>candyType.length/2)return candyType.length/2;\n    }\n\n    return st.size();\n\n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int distributeCandies(int[] candyType) {\\n\\n    Set<Integer>st=new HashSet<>();\\n\\n    for(int i=0;i<candyType.length;i++){\\n        st.add(candyType[i]);\\n        if(st.size()>candyType.length/2)return candyType.length/2;\\n    }\\n\\n    return st.size();\\n\\n    }\\n}\\n```"
    },
    {
        "slug": "implement-trie-prefix-tree",
        "tags": "java",
        "release_time": 1682938465,
        "code": "class Node{\n    Node links[]= new Node[26];\n    boolean flag=false;\n    public Node(){\n\n    }\n    boolean contains(char ch){\n        return (links[ch-'a']!=null);\n    }\n    void put(char ch, Node node){\n        links[ch-'a']=node;\n    }\n    Node get(char ch){\n        return links[ch-'a'];\n    }\n    boolean isEnd(){\n        return flag;\n    }\n    void setEnd(){\n        flag=true;\n    }\n\n}\nclass Trie {\nprivate static Node root;\n    public Trie() {\n        root=new Node();\n    }\n    \n    public void insert(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                node.put(word.charAt(i),new Node());\n            }\n            node=node.get(word.charAt(i));\n        }\n        node.setEnd();\n    }\n    \n    public boolean search(String word) {\n        Node node=root;\n        for(int i=0;i<word.length();i++){\n            if(!node.contains(word.charAt(i))){\n                return false;\n            }\n            node=node.get(word.charAt(i));\n        }\n        if(node.isEnd())\n            return true;\n        return false;\n    }\n    \n    public boolean startsWith(String prefix) {\n        Node node=root;\n        for(int i=0;i<prefix.length();i++){\n            if(!node.contains(prefix.charAt(i))){\n                return false;\n            }\n            node=node.get(prefix.charAt(i));\n        }\n        return true;\n    }\n}\n\n/**\n * Your Trie object will be instantiated and called as such:\n * Trie obj = new Trie();\n * obj.insert(word);\n * boolean param_2 = obj.search(word);\n * boolean param_3 = obj.startsWith(prefix);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node{\\n    Node links[]= new Node[26];\\n    boolean flag=false;\\n    public Node(){\\n\\n    }\\n    boolean contains(char ch){\\n        return (links[ch-\\'a\\']!=null);\\n    }\\n    void put(char ch, Node node){\\n        links[ch-\\'a\\']=node;\\n    }\\n    Node get(char ch){\\n        return links[ch-\\'a\\'];\\n    }\\n    boolean isEnd(){\\n        return flag;\\n    }\\n    void setEnd(){\\n        flag=true;\\n    }\\n\\n}\\nclass Trie {\\nprivate static Node root;\\n    public Trie() {\\n        root=new Node();\\n    }\\n    \\n    public void insert(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                node.put(word.charAt(i),new Node());\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        node.setEnd();\\n    }\\n    \\n    public boolean search(String word) {\\n        Node node=root;\\n        for(int i=0;i<word.length();i++){\\n            if(!node.contains(word.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(word.charAt(i));\\n        }\\n        if(node.isEnd())\\n            return true;\\n        return false;\\n    }\\n    \\n    public boolean startsWith(String prefix) {\\n        Node node=root;\\n        for(int i=0;i<prefix.length();i++){\\n            if(!node.contains(prefix.charAt(i))){\\n                return false;\\n            }\\n            node=node.get(prefix.charAt(i));\\n        }\\n        return true;\\n    }\\n}\\n\\n/**\\n * Your Trie object will be instantiated and called as such:\\n * Trie obj = new Trie();\\n * obj.insert(word);\\n * boolean param_2 = obj.search(word);\\n * boolean param_3 = obj.startsWith(prefix);\\n */\\n```"
    },
    {
        "slug": "n-queens",
        "tags": "java",
        "release_time": 1689162852,
        "code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n        char [][] board = new char[n][n];\n        for(int i = 0; i < board.length; i++) {\n            for(int j = 0; j < board.length; j++) {\n                board[i][j] = '.';\n            }\n        }\n        \n        List<List<String>> ans = new ArrayList<>();\n        queen(board, 0, ans);\n        return ans;\n    }\n\n    static void queen(char[][] board, int row, List<List<String>> list) {\n\n        if(row == board.length) {\n\n            list.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if(isSafe(board, row, col)) {\n                board[row][col] = 'Q';\n                queen(board, row + 1, list);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    static List<String> construct(char[][] board) {\n\n        List<String> internal = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            String row = new String(board[i]);\n            internal.add(row);\n        }\n        return internal;\n    }\n\n    static boolean isSafe(char[][] board, int row, int col) {\n\n        //for checking vertical row\n        for (int i = 0; i < row; i++) {\n            if(board[i][col] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking left diagonal\n\n        int maxLeft = Math.min(row, col);\n\n        for (int i = 1; i <= maxLeft; i++) {\n            if(board[row - i][col - i] == 'Q') {\n                return false;\n            }\n        }\n\n        //for checking right diagonal\n\n        int maxRight = Math.min(row, board.length - 1 - col);\n\n        for (int i = 1; i <= maxRight; i++) {\n            if(board[row - i][col + i] == 'Q') {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!--  -->\\nLet\\'s see the intuition behind this question.\\n\\n![WhatsApp Image 2023-07-12 at 5.11.51 PM.jpeg](https://assets.leetcode.com/users/images/d7c0148d-9d34-4e20-86a9-34da5b670c08_1689162264.640158.jpeg)\\n\\n# Approach\\n<!--  -->\\nSo, now when we know the question requires backtracking and recursion, let\\'s discuss the thought process and the approach!\\n\\n![WhatsApp Image 2023-07-12 at 5.11.52 PM.jpeg](https://assets.leetcode.com/users/images/76f56253-26ea-4299-9d02-604f8c1a88f1_1689162387.0847921.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.11.53 PM.jpeg](https://assets.leetcode.com/users/images/2872576b-425c-48c9-a5c7-ee6c8b960b72_1689162414.789056.jpeg)\\n![WhatsApp Image 2023-07-12 at 5.18.32 PM.jpeg](https://assets.leetcode.com/users/images/74aa66cb-dc07-4001-a353-ae8220a3bf0d_1689162542.4049857.jpeg)\\n\\n## Please upvote if you loved it! \\n\\n![cat.jpeg](https://assets.leetcode.com/users/images/6caea43f-b90d-4e55-befe-e8963ec23424_1689162825.9038785.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n! * n)\\n<!--  -->\\n\\n- Space complexity: O(n^2)\\n<!--  -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<String>> solveNQueens(int n) {\\n        \\n        char [][] board = new char[n][n];\\n        for(int i = 0; i < board.length; i++) {\\n            for(int j = 0; j < board.length; j++) {\\n                board[i][j] = \\'.\\';\\n            }\\n        }\\n        \\n        List<List<String>> ans = new ArrayList<>();\\n        queen(board, 0, ans);\\n        return ans;\\n    }\\n\\n    static void queen(char[][] board, int row, List<List<String>> list) {\\n\\n        if(row == board.length) {\\n\\n            list.add(construct(board));\\n            return;\\n        }\\n\\n        for (int col = 0; col < board.length; col++) {\\n            if(isSafe(board, row, col)) {\\n                board[row][col] = \\'Q\\';\\n                queen(board, row + 1, list);\\n                board[row][col] = \\'.\\';\\n            }\\n        }\\n    }\\n\\n    static List<String> construct(char[][] board) {\\n\\n        List<String> internal = new ArrayList<>();\\n        for (int i = 0; i < board.length; i++) {\\n            String row = new String(board[i]);\\n            internal.add(row);\\n        }\\n        return internal;\\n    }\\n\\n    static boolean isSafe(char[][] board, int row, int col) {\\n\\n        //for checking vertical row\\n        for (int i = 0; i < row; i++) {\\n            if(board[i][col] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking left diagonal\\n\\n        int maxLeft = Math.min(row, col);\\n\\n        for (int i = 1; i <= maxLeft; i++) {\\n            if(board[row - i][col - i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        //for checking right diagonal\\n\\n        int maxRight = Math.min(row, board.length - 1 - col);\\n\\n        for (int i = 1; i <= maxRight; i++) {\\n            if(board[row - i][col + i] == \\'Q\\') {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "similar-string-groups",
        "tags": "java",
        "release_time": 1682695025,
        "code": "class Solution {\n    boolean isSimilar(String str1,String str2)\n    {\n        int count=0;\n        for(int i=0;i<str1.length();i++)\n        {\n            if(str1.charAt(i)!=str2.charAt(i))\n            {\n                count++;\n                if(count>2)\n                {\n                    return false;\n                }\n            }\n            \n        }\n        return count==0 || count==2;\n    }\n    void dfs(String curr, String []strs, Set<String> visited)\n    {\n        //base condition\n        if(visited.contains(curr))\n        {\n            return;\n        }\n        visited.add(curr);\n        for(int i=0;i<strs.length;i++)\n        {\n         if(isSimilar(curr,strs[i]))\n         {\n             dfs(strs[i],strs,visited);\n         }   \n        }\n    }\n    public int numSimilarGroups(String[] strs)\n    {\n        int count =0;\n\n        //Base condition\n        if(strs==null ||strs.length ==0)\n        {\n            return 0;\n        }\n\n        //now create a set for visited elements which are similar\n        Set<String> visited = new HashSet<>();\n        for(String s:strs)\n        {\n            if(!visited.contains(s))\n            {\n                dfs(s,strs,visited);\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Intuition\\n![WhatsApp_Image_2023-04-28_at_8.43.47_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/fade8110-e5ae-4339-8e4e-a041ca1adfa6_1682695005.1794102.jpeg)\\n![WhatsApp_Image_2023-04-28_at_8.44.14_PM\\\\[1\\\\].jpeg](https://assets.leetcode.com/users/images/bd87a21d-7162-4964-af6b-19a3bc4e3649_1682695016.060982.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean isSimilar(String str1,String str2)\\n    {\\n        int count=0;\\n        for(int i=0;i<str1.length();i++)\\n        {\\n            if(str1.charAt(i)!=str2.charAt(i))\\n            {\\n                count++;\\n                if(count>2)\\n                {\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        return count==0 || count==2;\\n    }\\n    void dfs(String curr, String []strs, Set<String> visited)\\n    {\\n        //base condition\\n        if(visited.contains(curr))\\n        {\\n            return;\\n        }\\n        visited.add(curr);\\n        for(int i=0;i<strs.length;i++)\\n        {\\n         if(isSimilar(curr,strs[i]))\\n         {\\n             dfs(strs[i],strs,visited);\\n         }   \\n        }\\n    }\\n    public int numSimilarGroups(String[] strs)\\n    {\\n        int count =0;\\n\\n        //Base condition\\n        if(strs==null ||strs.length ==0)\\n        {\\n            return 0;\\n        }\\n\\n        //now create a set for visited elements which are similar\\n        Set<String> visited = new HashSet<>();\\n        for(String s:strs)\\n        {\\n            if(!visited.contains(s))\\n            {\\n                dfs(s,strs,visited);\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "strictly-palindromic-number",
        "tags": "java",
        "release_time": 1691219756,
        "code": "class Solution {\n    public boolean isStrictlyPalindromic(int n) {\n        boolean ans = false;\n        for(int i=2; i<n-2; i++){\n            int num = n;\n            int reverse=0;\n            int rem;\n            while(num!=0){\n                rem = num%i;\n                reverse = (reverse*10)+(rem);\n                num=num/i;\n            }\n            if(reverse==n){\n                ans = true;\n            }\n            else{\n                ans=false;\n                break;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isStrictlyPalindromic(int n) {\\n        boolean ans = false;\\n        for(int i=2; i<n-2; i++){\\n            int num = n;\\n            int reverse=0;\\n            int rem;\\n            while(num!=0){\\n                rem = num%i;\\n                reverse = (reverse*10)+(rem);\\n                num=num/i;\\n            }\\n            if(reverse==n){\\n                ans = true;\\n            }\\n            else{\\n                ans=false;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "max-consecutive-ones",
        "tags": "java",
        "release_time": 1676866256,
        "code": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int count=0;\n        int max=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1){\n                count++;\n            }else{\n                count=0;\n            }\n            max=Math.max(count,max);\n        }\n        return max;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxConsecutiveOnes(int[] nums) {\\n        int count=0;\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1){\\n                count++;\\n            }else{\\n                count=0;\\n            }\\n            max=Math.max(count,max);\\n        }\\n        return max;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximize-number-of-subsequences-in-a-string",
        "tags": "java",
        "release_time": 1647705692,
        "code": "class Solution {\n\n    public long maximumSubsequenceCount(String s, String p) {\n        long ans = 0, max = 0;\n        int cnt = 1;\n        //Assume adding 0th character of pattern at starting\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\n            if (s.charAt(i) == p.charAt(0)) cnt++;\n        }\n        max = Math.max(max, ans);\n        ans = 0; cnt = 1;\n        //Assume adding second character of pattern at end\n        for (int i = s.length() - 1; i >= 0; i--) {\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\n            if (s.charAt(i) == p.charAt(1)) cnt++;\n        }\n        max = Math.max(max, ans);\n        return max;\n    }\n}",
        "content": "```\\nclass Solution {\\n\\n    public long maximumSubsequenceCount(String s, String p) {\\n        long ans = 0, max = 0;\\n        int cnt = 1;\\n        //Assume adding 0th character of pattern at starting\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == p.charAt(1)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(0)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        ans = 0; cnt = 1;\\n        //Assume adding second character of pattern at end\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            if (s.charAt(i) == p.charAt(0)) ans += cnt;\\n            if (s.charAt(i) == p.charAt(1)) cnt++;\\n        }\\n        max = Math.max(max, ans);\\n        return max;\\n    }\\n}\\n```\\n"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "tags": "java",
        "release_time": 1686334819,
        "code": "class Solution {\n    public int minSwaps(String s) {\n        return util1(s);\n    }\n    public int util1(String str) {\n        Stack<Character> s = new Stack<>();\n        for (int i = 0; i < str.length(); i++) {\n            if (str.charAt(i) == '[') {\n                s.push(str.charAt(i));\n            } else {\n                if (s.isEmpty() == false && s.peek() == '[') {\n                    s.pop();\n                } else {\n                    s.push(str.charAt(i));\n                }\n            }\n        }\n        double pairs = s.size() / 2;\n        double a = pairs / 2.0;\n        int ans = (int) Math.ceil(a);\n        return ans;\n    }\n}",
        "content": "the trick behind is fairly easy\\n\\nfor the number of pairs which are not correct, the amount of swaps required to make them correct is Math.ceil(a), where a is the number of pairs which are not correct.\\n\\nfor eg\\nfor 5 incorrect pairs, we need 3 swaps\\nfor 3 incorrect pairs, we need 2 swaps\\nfor 2 incorrect pairs, we need 1 swap\\n\\nso simply, \\nwe need to firstly write code to remove all the valid pairs, that ways only the pairs which are incorrect will be in the stack\\nthen we simply do the calculations.\\n\\nrest the code should be self explanatory.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSwaps(String s) {\\n        return util1(s);\\n    }\\n    public int util1(String str) {\\n        Stack<Character> s = new Stack<>();\\n        for (int i = 0; i < str.length(); i++) {\\n            if (str.charAt(i) == \\'[\\') {\\n                s.push(str.charAt(i));\\n            } else {\\n                if (s.isEmpty() == false && s.peek() == \\'[\\') {\\n                    s.pop();\\n                } else {\\n                    s.push(str.charAt(i));\\n                }\\n            }\\n        }\\n        double pairs = s.size() / 2;\\n        double a = pairs / 2.0;\\n        int ans = (int) Math.ceil(a);\\n        return ans;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\n    \\n"
    },
    {
        "slug": "find-target-indices-after-sorting-array",
        "tags": "java",
        "release_time": 1688380939,
        "code": "class Solution {\n    public List<Integer> targetIndices(int[] nums, int target) {\n        ArrayList <Integer> arr = new ArrayList<>();\n        Arrays.sort(nums);\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] == target){\n                arr.add(i);\n            }\n        }\n        return arr;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> targetIndices(int[] nums, int target) {\\n        ArrayList <Integer> arr = new ArrayList<>();\\n        Arrays.sort(nums);\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i] == target){\\n                arr.add(i);\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-ways-to-earn-points",
        "tags": "java",
        "release_time": 1677989079,
        "code": "class Solution {\n    public int waysToReachTarget(int target, int[][] types) {\n        int[][] memo = new int[target + 1][types.length + 1];\n        for (int[] ints : memo) {\n            Arrays.fill(ints, -1);\n        }\n        return (int) backtrack(target, types, 0, memo);\n    }\n    \n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\n        if (target == 0) {\n            return 1;\n        }\n        if (target < 0) {\n            return 0;\n        }\n        if (memo[target][start] != -1) {\n            return memo[target][start];\n        }\n        long res = 0;\n        for (int i = start; i < types.length; i++) {\n            for (int j = 1; j <= types[i][0]; j++) {\n                if (target - j * types[i][1] < 0) {\n                    break;\n                }\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\n                res = (res + temp) % 1_000_000_007;\n            }\n        }\n        memo[target][start] = (int) res;\n        return res;\n    }\n}",
        "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int waysToReachTarget(int target, int[][] types) {\\n        int[][] memo = new int[target + 1][types.length + 1];\\n        for (int[] ints : memo) {\\n            Arrays.fill(ints, -1);\\n        }\\n        return (int) backtrack(target, types, 0, memo);\\n    }\\n    \\n    private long backtrack(int target, int[][] types, int start, int[][] memo) {\\n        if (target == 0) {\\n            return 1;\\n        }\\n        if (target < 0) {\\n            return 0;\\n        }\\n        if (memo[target][start] != -1) {\\n            return memo[target][start];\\n        }\\n        long res = 0;\\n        for (int i = start; i < types.length; i++) {\\n            for (int j = 1; j <= types[i][0]; j++) {\\n                if (target - j * types[i][1] < 0) {\\n                    break;\\n                }\\n                long temp = backtrack(target - j * types[i][1], types, i + 1, memo);\\n                res = (res + temp) % 1_000_000_007;\\n            }\\n        }\\n        memo[target][start] = (int) res;\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimize-deviation-in-array",
        "tags": "java",
        "release_time": 1677242832,
        "code": "class Solution {\n    public int minimumDeviation(int[] nums) {\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\n        int min=Integer.MAX_VALUE;\n        for (int num : nums) {\n            if (num % 2 == 1) {\n                num*=2;\n            }\n            pq.offer(num);\n            min=Math.min(min,num);\n        }\n        int minDev=Integer.MAX_VALUE;\n        while(pq.peek()%2==0){\n            int max=pq.remove();\n            int element=max/2;\n            minDev=Math.min(minDev,max-min);\n            min=Math.min(element,min);\n            pq.offer(element);\n        }\n        return Math.min(minDev,pq.peek()-min);\n    }\n}",
        "content": "**1.We create a max heap using PriorityQueue with the reverse order comparator. We do this because we want to always process the largest element in the heap first.**\\n\\n**2.We iterate over the input array and for each element, we check if it is even or odd. If it is odd, we multiply it by 2 so that we can apply the second operation (multiply by 2) on it later. We add the modified element to the heap and keep track of the minimum value we encounter.**\\n\\n**3.We initialize the minimum deviation variable to be the maximum integer value. We then keep looping until the largest element in the heap is odd. In each iteration, we remove the largest element from the heap and divide it by 2. We compute the new deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We also keep track of the new minimum value we encounter.**\\n\\n**4.Once we have a maximum odd element in the heap, we compute the deviation between the minimum and maximum elements and update the minimum deviation variable if necessary. We return the minimum deviation variable as the answer.**\\n```\\nclass Solution {\\n    public int minimumDeviation(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        int min=Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            if (num % 2 == 1) {\\n                num*=2;\\n            }\\n            pq.offer(num);\\n            min=Math.min(min,num);\\n        }\\n        int minDev=Integer.MAX_VALUE;\\n        while(pq.peek()%2==0){\\n            int max=pq.remove();\\n            int element=max/2;\\n            minDev=Math.min(minDev,max-min);\\n            min=Math.min(element,min);\\n            pq.offer(element);\\n        }\\n        return Math.min(minDev,pq.peek()-min);\\n    }\\n}\\n```\\n# **UPVOTING IS MUCH APPRECIATED**"
    },
    {
        "slug": "sign-of-the-product-of-an-array",
        "tags": "java",
        "release_time": 1682989041,
        "code": "class Solution { // Vezzz\n  public int arraySign(int[] nums) {\n    int z = 0;\n    for (int v : nums)\n      if (v == 0)\n        return 0;\n      else\n        z ^= v;\n    return z >> 31 | 1;\n  }\n}",
        "content": "# Intuition\\nOnly the sign bit matter.\\n\\n# Approach\\n- 2 negative sign bit cancel each other using xor.\\n- Early exit on `0`.\\n- Drag the sign bit over the whole int and set last bit.\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n- Space complexity: *`O(1)`*\\n\\n# Code\\n```\\nclass Solution { // Vezzz\\n  public int arraySign(int[] nums) {\\n    int z = 0;\\n    for (int v : nums)\\n      if (v == 0)\\n        return 0;\\n      else\\n        z ^= v;\\n    return z >> 31 | 1;\\n  }\\n}\\n```"
    },
    {
        "slug": "concatenation-of-consecutive-binary-numbers",
        "tags": "java",
        "release_time": 1663956056,
        "code": "class Solution {\n    static final int N = 100001, mod = 1000000007;\n    static int res[];\n    Solution(){\n        if(res==null){\n            res=new int[N];\n            for(int i=1,n=0,pow=1;i<N;i++){\n                if(i==pow){\n                    pow<<=1;\n                    n++;\n                }\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\n            }\n        }\n    }\n    public int concatenatedBinary(int n) {\n        return res[n];\n    }\n}",
        "content": "```\\nclass Solution {\\n    static final int N = 100001, mod = 1000000007;\\n    static int res[];\\n    Solution(){\\n        if(res==null){\\n            res=new int[N];\\n            for(int i=1,n=0,pow=1;i<N;i++){\\n                if(i==pow){\\n                    pow<<=1;\\n                    n++;\\n                }\\n                res[i]=(int)((((long)res[i-1]<<n)|i)%mod);\\n            }\\n        }\\n    }\\n    public int concatenatedBinary(int n) {\\n        return res[n];\\n    }\\n}\\n```"
    },
    {
        "slug": "smallest-range-covering-elements-from-k-lists",
        "tags": "java",
        "release_time": 1674752084,
        "code": "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int k = nums.size();\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\n        for(int i = 0;i<k;i++){\n            List<Integer> l = nums.get(i);\n            for(int nu : l){\n                list.add(new Pair(nu,i));\n            }\n        }\n        \n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\n        int[] ans = new int[2];\n        ans[1] = ans[0] = Integer.MAX_VALUE; \n        int i = 0,j=0;\n        List<Integer> store = new ArrayList<>();\n        HashMap<Integer,Integer> mp = new HashMap<>();\n        int totalType = 0;\n        \n        while(j<list.size()){\n            int nu = list.get(j).getKey();\n            int type = list.get(j).getValue();\n            store.add(nu);\n            int val = mp.getOrDefault(type,0);\n            mp.put(type,val+1);\n            totalType++;\n            if(mp.size()<k){\n                j++;\n            }else if(mp.size()==k){\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }\n                int dif = store.get(store.size()-1)-store.get(0);\n                if(dif<ans[1]-ans[0]){\n                    ans[0] = store.get(0);\n                    ans[1] = store.get(store.size()-1);\n                }  \n                \n                while(mp.size()==k){\n                    dif = store.get(store.size()-1)-store.get(0);\n                    if(dif<ans[1]-ans[0]){\n                        ans[0] = store.get(0);\n                        ans[1] = store.get(store.size()-1);\n                    }\n                    store.remove(0);\n                    int t = list.get(i).getValue();\n                    int vv = (int) mp.get(t);\n                    mp.put(t,vv-1);\n                    if(vv==1){\n                        mp.remove(t);\n                    }\n                    i++;\n                }\n                \n                j++;\n                \n            }\n   \n        }\n        \n        \n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }\\n        }\\n        \\n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\\n        int[] ans = new int[2];\\n        ans[1] = ans[0] = Integer.MAX_VALUE; \\n        int i = 0,j=0;\\n        List<Integer> store = new ArrayList<>();\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        int totalType = 0;\\n        \\n        while(j<list.size()){\\n            int nu = list.get(j).getKey();\\n            int type = list.get(j).getValue();\\n            store.add(nu);\\n            int val = mp.getOrDefault(type,0);\\n            mp.put(type,val+1);\\n            totalType++;\\n            if(mp.size()<k){\\n                j++;\\n            }else if(mp.size()==k){\\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }\\n                int dif = store.get(store.size()-1)-store.get(0);\\n                if(dif<ans[1]-ans[0]){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }  \\n                \\n                while(mp.size()==k){\\n                    dif = store.get(store.size()-1)-store.get(0);\\n                    if(dif<ans[1]-ans[0]){\\n                        ans[0] = store.get(0);\\n                        ans[1] = store.get(store.size()-1);\\n                    }\\n                    store.remove(0);\\n                    int t = list.get(i).getValue();\\n                    int vv = (int) mp.get(t);\\n                    mp.put(t,vv-1);\\n                    if(vv==1){\\n                        mp.remove(t);\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n                \\n            }\\n   \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "new-21-game",
        "tags": "java",
        "release_time": 1684986822,
        "code": "class Solution {\n    public double new21Game(int n, int k, int maxPts) {\n        if (k == 0 || n >= k + maxPts)\n        return 1.0;\n    \n    double[] dp = new double[n + 1];\n    double windowSum = 1.0;\n    double probability = 0.0;\n    \n    dp[0] = 1.0;\n    \n    for (int i = 1; i <= n; i++) {\n        dp[i] = windowSum / maxPts;\n        \n        if (i < k)\n            windowSum += dp[i];\n        else\n            probability += dp[i];\n        \n        if (i - maxPts >= 0)\n            windowSum -= dp[i - maxPts];\n    }\n    \n    return probability;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to calculate the probability that Alice has n or fewer points. To achieve this, we can consider the probability at each point and use dynamic programming to build up the probabilities iteratively.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we handle the base cases. If k is 0 or if n is greater than or equal to k + maxPts, Alice will always stop drawing after the first round and have a probability of 1.0 to have n or fewer points.\\n1. We create an array dp to store the probabilities for each possible number of points.\\n1. Initialize dp[0] to 1.0, indicating that Alice starts with 0 points.\\n1. We use a sliding window approach to calculate the probabilities iteratively. We maintain a windowSum variable that represents the sum of probabilities within the window of size maxPts.\\n1. Iterate from 1 to n and calculate dp[i] as windowSum / maxPts since each draw has equal probabilities.\\n1. If i is less than k, we update windowSum by adding dp[i] since we can continue drawing.\\n1. Otherwise, if i is greater than or equal to k, we update probability by adding dp[i] since Alice has stopped drawing at this point.\\n1. We adjust the windowSum by subtracting the probability that falls outside the window, i.e., dp[i - maxPts], if it exists.\\n1. Finally, we return the calculated probability.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n) because we iterate from 1 to n to calculate the probabilities.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) because we use an array dp of size n+1 to store the probabilities.\\n\\n# Code\\n```\\nclass Solution {\\n    public double new21Game(int n, int k, int maxPts) {\\n        if (k == 0 || n >= k + maxPts)\\n        return 1.0;\\n    \\n    double[] dp = new double[n + 1];\\n    double windowSum = 1.0;\\n    double probability = 0.0;\\n    \\n    dp[0] = 1.0;\\n    \\n    for (int i = 1; i <= n; i++) {\\n        dp[i] = windowSum / maxPts;\\n        \\n        if (i < k)\\n            windowSum += dp[i];\\n        else\\n            probability += dp[i];\\n        \\n        if (i - maxPts >= 0)\\n            windowSum -= dp[i - maxPts];\\n    }\\n    \\n    return probability;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-binary-tree",
        "tags": "java",
        "release_time": 1685481921,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        TreeNode root= construct(nums,0,nums.length-1);\n        return root;\n    }\n    private static TreeNode construct(int arr[], int s, int e){\n        if(s>e)return null;\n        if(s==e) return new TreeNode(arr[s]);\n\n        int idx=findMax(arr,s,e);\n        TreeNode root=new TreeNode(arr[idx]);\n        root.left=construct(arr,s,idx-1);\n        root.right=construct(arr,idx+1,e);\n\n        return root;\n    }\n\n    private static int findMax(int arr[], int s, int e){\n        int max=Integer.MIN_VALUE;\n        int idx=-1;\n        for(int i=s;i<=e; i++)\n        {\n            if(arr[i]>max){\n                max=arr[i];\n                idx=i;\n            }\n        }\n         return idx;\n    }\n\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code implements a solution to construct a maximum binary tree from an input array nums. The maximum binary tree is a binary tree where the root node has the maximum value in the array, and the left and right subtrees of the root are recursively constructed maximum binary trees from the elements to the left and right of the maximum value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a recursive approach to construct the maximum binary tree. It defines two helper functions: constructMaximumBinaryTree and construct.\\n\\n1. constructMaximumBinaryTree function:\\n\\nThis is the main entry point of the code.\\nIt takes the input array nums as a parameter and returns the root of the constructed maximum binary tree.\\nInside this function, it calls the construct function, passing the nums array and the range from 0 to nums.length - 1.\\n2. construct function:\\n\\nThis function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt constructs the maximum binary tree for the current range of elements in the array.\\nIt first checks if s is greater than e. If so, it means there are no elements in the current range, so it returns null.\\nIf s is equal to e, it means there is only one element in the current range. In this case, it creates a new TreeNode with the value of arr[s] and returns it.\\nIf there are more than one element in the current range, it finds the index of the maximum element using the findMax helper function.\\nIt creates a new TreeNode with the maximum value (arr[idx]) as the root.\\nIt recursively calls the construct function for the left subarray (from s to idx - 1) and assigns the returned value as the left child of the root.\\nIt recursively calls the construct function for the right subarray (from idx + 1 to e) and assigns the returned value as the right child of the root.\\nFinally, it returns the constructed root node of the maximum binary tree for the current range.\\n3. findMax function:\\n\\nThis helper function takes three parameters: the input array arr, the start index s, and the end index e of the current range.\\nIt iterates through the elements in the current range and finds the index of the maximum element.\\nIt initializes a variable max with the minimum integer value and idx with -1.\\nIt compares each element in the range with the current maximum value (max) and updates max and idx if a greater value is found.\\nFinally, it returns the index of the maximum element.\\nThe code uses recursion to divide the array into smaller subarrays and construct the maximum binary tree recursively. It constructs the root node based on the maximum value in the current range, assigns the left and right subtrees recursively, and returns the root node.\\n\\n# Complexity\\n- Time complexity: O(n^2) in worst case and O(n) in avg case.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe constructMaximumBinaryTree function calls the construct function, which performs a recursive construction of the maximum binary tree. The construct function divides the array into smaller subarrays and constructs the tree.\\nIn the worst case, each element in the array needs to be compared with every other element to find the maximum. This results in a time complexity of O(n^2), where n is the length of the nums array.\\nHowever, in the average case, the maximum element can be found in O(n) time. Therefore, the average time complexity of the construct function is O(n).\\nThe construct function is called recursively for each subarray, resulting in a total time complexity of O(n^2) in the worst case and O(n) in the average case.\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is determined by the recursive calls and the stack space required for each call.\\nIn the worst case, when the construct function is called recursively for each subarray, the maximum stack depth is equal to the height of the binary tree. In the worst case, the height of the binary tree can be equal to n, resulting in a space complexity of O(n).\\nAdditionally, the construct function creates new TreeNode objects during the construction process. The number of TreeNode objects created is proportional to the number of elements in the nums array. Therefore, the space complexity for the TreeNode objects is also O(n).\\nOverall, the space complexity is O(n) due to the stack space and the space required for the TreeNode objects.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\\n        TreeNode root= construct(nums,0,nums.length-1);\\n        return root;\\n    }\\n    private static TreeNode construct(int arr[], int s, int e){\\n        if(s>e)return null;\\n        if(s==e) return new TreeNode(arr[s]);\\n\\n        int idx=findMax(arr,s,e);\\n        TreeNode root=new TreeNode(arr[idx]);\\n        root.left=construct(arr,s,idx-1);\\n        root.right=construct(arr,idx+1,e);\\n\\n        return root;\\n    }\\n\\n    private static int findMax(int arr[], int s, int e){\\n        int max=Integer.MIN_VALUE;\\n        int idx=-1;\\n        for(int i=s;i<=e; i++)\\n        {\\n            if(arr[i]>max){\\n                max=arr[i];\\n                idx=i;\\n            }\\n        }\\n         return idx;\\n    }\\n\\n}\\n```"
    },
    {
        "slug": "tuple-with-same-product",
        "tags": "java",
        "release_time": 1661554822,
        "code": "class Solution {\n    public int tupleSameProduct(int[] nums) {\n        int m = nums.length;\n        int factor = 0;\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        for(int i = 0; i < m - 1; i ++) {\n            for(int j = i + 1; j < m; j ++) {\n                int curNumber = nums[i] * nums[j];\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\n                hm.put(curNumber, curNumberCount);\n            }\n        }\n        \n\t\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\n\t\t\n        for(Integer key: hm.keySet()) {\n            int count = hm.get(key);\n            if(count == 1) continue;\n            factor += count * (count - 1) / 2;\n        }\n        return factor * 8;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        int m = nums.length;\\n        int factor = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        for(int i = 0; i < m - 1; i ++) {\\n            for(int j = i + 1; j < m; j ++) {\\n                int curNumber = nums[i] * nums[j];\\n                int curNumberCount = (hm.containsKey(curNumber)) ? hm.get(curNumber) + 1 : 1;\\n                hm.put(curNumber, curNumberCount);\\n            }\\n        }\\n        \\n\\t\\t// check the qty of number, and we can get n * (n - 1) / 2 compositions\\n\\t\\t\\n        for(Integer key: hm.keySet()) {\\n            int count = hm.get(key);\\n            if(count == 1) continue;\\n            factor += count * (count - 1) / 2;\\n        }\\n        return factor * 8;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-sum-of-an-hourglass",
        "tags": "java",
        "release_time": 1689055828,
        "code": "class Solution {\n    public int maxSum(int[][] grid) {\n        int max = 0;\n        int n = grid.length;\n        int m = grid[0].length;\n        for(int i = 0; i < n-2; i++) {\n            for(int j = 0; j < m-2; j++) {\n                int sum = 0;\n                for(int z = j; z < j+3; z++) {\n                    sum += grid[i][z];\n                }\n                sum += grid[i+1][j+1];\n                 for(int z = j; z < j+3; z++) {\n                    sum += grid[i+2][z];\n                }\n                max = Math.max(sum, max);\n\n            }\n        }\n        return max;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = 0;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        for(int i = 0; i < n-2; i++) {\\n            for(int j = 0; j < m-2; j++) {\\n                int sum = 0;\\n                for(int z = j; z < j+3; z++) {\\n                    sum += grid[i][z];\\n                }\\n                sum += grid[i+1][j+1];\\n                 for(int z = j; z < j+3; z++) {\\n                    sum += grid[i+2][z];\\n                }\\n                max = Math.max(sum, max);\\n\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```"
    },
    {
        "slug": "string-compression-ii",
        "tags": "java",
        "release_time": 1665803583,
        "code": "class Solution {\n    public int getLengthOfOptimalCompression(String s, int k) {\n        int n = s.length();\n        int[][] dp = new int[110][110];\n        for (int i = 0; i <= n; i++) \n            for (int j = 0; j <= n; j++) \n                dp[i][j] = 9999;\n\t\t        dp[0][0] = 0;\n        for(int i = 1; i <= n; i++) {\n            for(int j = 0; j <= k; j++) {                \n                int cnt = 0, del = 0;\n                for(int l = i; l >= 1; l--) { \n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\n                    else del++;\n                    if(j - del >= 0) \n                        dp[i][j] = Math.min(dp[i][j], \n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\n                }\n                if (j > 0)\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);\n            }\n        }\n        return dp[n][k];\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int getLengthOfOptimalCompression(String s, int k) {\\n        int n = s.length();\\n        int[][] dp = new int[110][110];\\n        for (int i = 0; i <= n; i++) \\n            for (int j = 0; j <= n; j++) \\n                dp[i][j] = 9999;\\n\\t\\t        dp[0][0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            for(int j = 0; j <= k; j++) {                \\n                int cnt = 0, del = 0;\\n                for(int l = i; l >= 1; l--) { \\n                    if(s.charAt(l - 1) == s.charAt(i - 1)) cnt++;\\n                    else del++;\\n                    if(j - del >= 0) \\n                        dp[i][j] = Math.min(dp[i][j], \\n                                            dp[l-1][j-del] + 1 + (cnt >= 100 ? 3 : cnt >= 10 ? 2 : cnt >= 2 ? 1: 0));\\n                }\\n                if (j > 0)\\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j-1]);\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "tags": "java",
        "release_time": 1680527006,
        "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n     int   index = 1;\n      int  count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i] == nums[i-1]){\n                count++;\n            }\n            else{\n                count = 0;\n            }\n\n            if(count <= 1){\n                nums[index] = nums[i];\n                index++;\n            }\n        }\n        return index;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeDuplicates(int[] nums) {\\n     int   index = 1;\\n      int  count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i] == nums[i-1]){\\n                count++;\\n            }\\n            else{\\n                count = 0;\\n            }\\n\\n            if(count <= 1){\\n                nums[index] = nums[i];\\n                index++;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n# If this solution helped you, give it an up-vote to help others**Bold**\\n![download.jfif](https://assets.leetcode.com/users/images/e1f75de3-02bf-44d0-bb86-208e5309d274_1680526945.9427269.jpeg)"
    },
    {
        "slug": "difference-between-element-sum-and-digit-sum-of-an-array",
        "tags": "java",
        "release_time": 1683903237,
        "code": "class Solution {\n    public int differenceOfSum(int[] nums) {\n        \n        int sum=0;\n        int digitSum=0;\n\n        for(int num:nums){\n            sum+=num;\n\n            while(num>0){\n                int digit=num%10;\n                digitSum+=digit;\n                num/=10;\n            }\n\n        }\n\n        return sum-digitSum;\n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n*k) and for second code O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) and for second code O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int differenceOfSum(int[] nums) {\\n        \\n        int sum=0;\\n        int digitSum=0;\\n\\n        for(int num:nums){\\n            sum+=num;\\n\\n            while(num>0){\\n                int digit=num%10;\\n                digitSum+=digit;\\n                num/=10;\\n            }\\n\\n        }\\n\\n        return sum-digitSum;\\n    }\\n}\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public int differenceOfSum(int[] nums) {\\n\\n        // sum the all element \\n        String digit=\"\";\\n        int sum=0;\\n        for(int num: nums) {\\n            sum+=num;\\n            digit+=num;\\n        \\n        }\\n\\n        int digitSum=0;\\n        for(int i=0;i<digit.length();i++){\\n            digitSum+=digit.charAt(i)-\\'0\\';\\n        }\\nreturn sum-digitSum;\\n    }\\n}\\n```\\n\\n"
    },
    {
        "slug": "maximum-average-pass-ratio",
        "tags": "java",
        "release_time": 1675841173,
        "code": "class Solution {\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\n        for(int[] cl : classes){\n            pq.add(new Class(cl));\n        }\n        while(extraStudents > 0){\n            Class c = pq.remove();\n            c.addExtraStudent();\n            extraStudents--;\n            pq.add(c);\n        }\n        double sum = 0;\n        while(!pq.isEmpty()){\n            Class c = pq.remove();\n            sum += c.pass / c.total;\n        }\n        return sum / classes.length;\n    }\n}\nclass Class{\n    double pass;\n    double total;\n    double inc;\n    public Class(int[] cl){\n        pass = cl[0];\n        total = cl[1];\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n    public void addExtraStudent(){\n        pass += 1;\n        total += 1;\n        inc = (pass + 1) / (total + 1) - pass / total;\n    }\n}\nclass Compare implements Comparator<Class>{\n    public int compare(Class c1, Class c2){\n        if(c1.inc < c2.inc){\n            return 1;\n        }else if(c1.inc > c2.inc){\n            return -1;\n        }else{\n            return 0;\n        }\n    }\n}",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double maxAverageRatio(int[][] classes, int extraStudents) {\\n        PriorityQueue<Class> pq = new PriorityQueue<>(new Compare());\\n        for(int[] cl : classes){\\n            pq.add(new Class(cl));\\n        }\\n        while(extraStudents > 0){\\n            Class c = pq.remove();\\n            c.addExtraStudent();\\n            extraStudents--;\\n            pq.add(c);\\n        }\\n        double sum = 0;\\n        while(!pq.isEmpty()){\\n            Class c = pq.remove();\\n            sum += c.pass / c.total;\\n        }\\n        return sum / classes.length;\\n    }\\n}\\nclass Class{\\n    double pass;\\n    double total;\\n    double inc;\\n    public Class(int[] cl){\\n        pass = cl[0];\\n        total = cl[1];\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n    public void addExtraStudent(){\\n        pass += 1;\\n        total += 1;\\n        inc = (pass + 1) / (total + 1) - pass / total;\\n    }\\n}\\nclass Compare implements Comparator<Class>{\\n    public int compare(Class c1, Class c2){\\n        if(c1.inc < c2.inc){\\n            return 1;\\n        }else if(c1.inc > c2.inc){\\n            return -1;\\n        }else{\\n            return 0;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "reverse-words-in-a-string",
        "tags": "java",
        "release_time": 1692301725,
        "code": "class Solution {\n    public String reverseWords(String s) {\n        StringBuilder ans = new StringBuilder();\n        for(int i=s.length()-1; i>=0; i--){\n            if(s.charAt(i)==' '){\n                continue;\n            }\n            int start=-1;\n            for(int y=i-1; y>=0; y--){\n                if(s.charAt(y)==' '){\n                    start=y;\n                    break;\n                }\n            }\n            ans.append(s.substring(start+1, i+1) + \" \");\n            i=start;\n        }\n        ans.deleteCharAt(ans.length()-1);\n        return ans.toString();\n    }\n}",
        "content": "# Approach\\n- Two Pointer Approach\\n- Using Trim and Split\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=s.length()-1; i>=0; i--){\\n            if(s.charAt(i)==\\' \\'){\\n                continue;\\n            }\\n            int start=-1;\\n            for(int y=i-1; y>=0; y--){\\n                if(s.charAt(y)==\\' \\'){\\n                    start=y;\\n                    break;\\n                }\\n            }\\n            ans.append(s.substring(start+1, i+1) + \" \");\\n            i=start;\\n        }\\n        ans.deleteCharAt(ans.length()-1);\\n        return ans.toString();\\n    }\\n}\\n```\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n        String[] temp = s.trim().split(\" \");\\n        StringBuilder ans = new StringBuilder();\\n        for(int i=temp.length-1; i>0; i--){\\n            if(temp[i]==\"\"){\\n                continue;\\n            }\\n            ans.append(temp[i]+\" \");\\n        }\\n        ans.append(temp[0]);\\n        return ans.toString();\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-colored-pieces-if-both-neighbors-are-the-same-color",
        "tags": "java",
        "release_time": 1657989117,
        "code": "class Solution {\n    public boolean winnerOfGame(String s) {\n        //count the triplets\nint n = s.length();\n    \n        int a=0;\n        int b=0;\n        \n        for(int i=1; i<n-1; i++)\n        {\n            if(s.charAt(i)=='A' && s.charAt(i-1)=='A' && s.charAt(i+1)=='A' )\n        a++;\n            else if(s.charAt(i)=='B' && s.charAt(i-1)=='B' && s.charAt(i+1)=='B' )\n        b++;\n            \n            }\n        if(a<=b)\n            return false;\n        else\n            return true;\n        \n    \n    }\n}",
        "content": "Idea behind it is that you need to count the number of triplets of both A and B \\nint a -> number of triplets of \\'A\\'\\nint b -> number of triplets of \\'B\\'\\nif(b>=a) BOB wins else Alice wins\\n\\nAs Alice has to make a move first so if she wants to win there should be atleast  1 more  triplets of A than B\\n\\nEg There are 4 triplets of both A and B  (a=4, b=4) \\n1. Alice removes 1 A (a=3, b=4)\\n2. Bob removes 1 B (a=3, b=3)\\n3. (a=2, b=3)\\n4. (a=2, b=2)\\n5. (a=1, b=2)\\n6. (a=1, b=1)\\n7. (a=0, b=1)\\n\\nClearly Alice will lose if both have same number of triplets\\nCode \\n\\n```\\nclass Solution {\\n    public boolean winnerOfGame(String s) {\\n        //count the triplets\\nint n = s.length();\\n    \\n        int a=0;\\n        int b=0;\\n        \\n        for(int i=1; i<n-1; i++)\\n        {\\n            if(s.charAt(i)==\\'A\\' && s.charAt(i-1)==\\'A\\' && s.charAt(i+1)==\\'A\\' )\\n        a++;\\n            else if(s.charAt(i)==\\'B\\' && s.charAt(i-1)==\\'B\\' && s.charAt(i+1)==\\'B\\' )\\n        b++;\\n            \\n            }\\n        if(a<=b)\\n            return false;\\n        else\\n            return true;\\n        \\n    \\n    }\\n}\\n```\\nIf this helped you then please UpVote\\nThanks\\n\\n\\n"
    },
    {
        "slug": "loud-and-rich",
        "tags": "java",
        "release_time": 1670637012,
        "code": "class Solution {\n    int ans[];\n    Map<Integer,List<Integer>> map=new HashMap<>();\n    int temp[]=new int[0];\n    int curr_node=0;\n    List<Integer> vis=new ArrayList<Integer>();\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        \n        ans=new int[quiet.length];\n        for(int i=0;i<=richer.length;i++){\n            \n            if(!map.containsKey(i)){\n                map.put(i,new ArrayList());\n            }\n            if(i<richer.length && !map.containsKey(richer[i][0])){\n                map.put(richer[i][0],new ArrayList());\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n            else if(i<richer.length){\n                map.get(richer[i][0]).add(richer[i][1]);\n            }\n        }\n        \n        Comparator<pair> comp=new Comparator<pair>(){\n            public int compare(pair p1,pair p2){\n                if(p1.cost>p2.cost){\n                    return 1;\n                }\n                else{\n                    return -1;\n                }\n\n            }\n        };\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\n        for(int i=0;i<quiet.length;i++){\n            ans[i]=-1;\n            pq.add(new pair(i,quiet[i]));\n        }\n        \n        while(!pq.isEmpty()){\n            pair top=pq.poll();\n            //System.out.println(top.node+\" \"+top.cost);\n            curr_node=top.node;\n            if(!vis.contains(top.node)){\n            dfs(top.node);\n            }\n        }\n        return ans;\n       \n    }\n    public void dfs(int node){\n        //System.out.println(node);\n        if(ans[node]==-1){\n            ans[node]=curr_node;\n        }\n        if(!vis.contains(node) && map.containsKey(node)){\n            vis.add(node);\n             \n            for(int i : map.get(node)){\n            dfs(i);\n        \n        }\n        }\n            \n    }\n}\n\nclass pair{\n    int node,cost;\n    pair(int node,int cost){\n        this.node=node;\n        this.cost=cost;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    int ans[];\\n    Map<Integer,List<Integer>> map=new HashMap<>();\\n    int temp[]=new int[0];\\n    int curr_node=0;\\n    List<Integer> vis=new ArrayList<Integer>();\\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\\n        \\n        ans=new int[quiet.length];\\n        for(int i=0;i<=richer.length;i++){\\n            \\n            if(!map.containsKey(i)){\\n                map.put(i,new ArrayList());\\n            }\\n            if(i<richer.length && !map.containsKey(richer[i][0])){\\n                map.put(richer[i][0],new ArrayList());\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n            else if(i<richer.length){\\n                map.get(richer[i][0]).add(richer[i][1]);\\n            }\\n        }\\n        \\n        Comparator<pair> comp=new Comparator<pair>(){\\n            public int compare(pair p1,pair p2){\\n                if(p1.cost>p2.cost){\\n                    return 1;\\n                }\\n                else{\\n                    return -1;\\n                }\\n\\n            }\\n        };\\n        PriorityQueue<pair> pq=new PriorityQueue<>(comp);\\n        for(int i=0;i<quiet.length;i++){\\n            ans[i]=-1;\\n            pq.add(new pair(i,quiet[i]));\\n        }\\n        \\n        while(!pq.isEmpty()){\\n            pair top=pq.poll();\\n            //System.out.println(top.node+\" \"+top.cost);\\n            curr_node=top.node;\\n            if(!vis.contains(top.node)){\\n            dfs(top.node);\\n            }\\n        }\\n        return ans;\\n       \\n    }\\n    public void dfs(int node){\\n        //System.out.println(node);\\n        if(ans[node]==-1){\\n            ans[node]=curr_node;\\n        }\\n        if(!vis.contains(node) && map.containsKey(node)){\\n            vis.add(node);\\n             \\n            for(int i : map.get(node)){\\n            dfs(i);\\n        \\n        }\\n        }\\n            \\n    }\\n}\\n\\nclass pair{\\n    int node,cost;\\n    pair(int node,int cost){\\n        this.node=node;\\n        this.cost=cost;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "tags": "java",
        "release_time": 1688377436,
        "code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n        int count = 0;\n        for(int i=0; i<nums.length-1; i++){\n            for(int j=i+1; j<nums.length; j++){\n                if(Math.abs(nums[i]-nums[j])== k){\n                    count++;\n                }\n            }\n        }\n\n        return count;\n        \n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countKDifference(int[] nums, int k) {\\n        int count = 0;\\n        for(int i=0; i<nums.length-1; i++){\\n            for(int j=i+1; j<nums.length; j++){\\n                if(Math.abs(nums[i]-nums[j])== k){\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-strictly-increasing-cells-in-a-matrix",
        "tags": "java",
        "release_time": 1685246871,
        "code": "class Solution {\n    public int maxIncreasingCells(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        int[] rows = new int[m], cols = new int[n];\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\n        \n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\n        for(int i=0;i<m;i++) {\n            rows[i] = Integer.MIN_VALUE;\n        }\n        for(int i=0;i<n;i++) {\n            cols[i] = Integer.MIN_VALUE;\n        }\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\n            return a[0] - b[0];\n        });\n        for(int i=0;i<m;i++) {\n            for(int j=0;j<n;j++) {\n                queue.add(new int[]{mat[i][j], i, j});\n            }\n        }\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int[] arr = queue.remove();\n            int val = arr[0], row = arr[1], col = arr[2];\n            int cur = 1;\n            if(val == rows[row]) {\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\n            } else {\n                cur = Math.max(rowMaxVals[row] + 1, cur);\n            }\n            if(val == cols[col]) {\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\n            } else {\n                cur = Math.max(colMaxVals[col] + 1, cur);\n            }\n            \n\n            if(val > rows[row]) {\n                rowSubMaxVals[row] = rowMaxVals[row];\n                rows[row] = val;\n            }\n            if(val > cols[col]) {\n                colSubMaxVals[col] = colMaxVals[col];\n                cols[col] = val;\n            }\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\n            \n            res = Math.max(res, cur);\n        }\n        \n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIncreasingCells(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] rows = new int[m], cols = new int[n];\\n        int[] rowMaxVals = new int[m], colMaxVals = new int[n];\\n        \\n        int[] rowSubMaxVals = new int[m], colSubMaxVals = new int[n];\\n        for(int i=0;i<m;i++) {\\n            rows[i] = Integer.MIN_VALUE;\\n        }\\n        for(int i=0;i<n;i++) {\\n            cols[i] = Integer.MIN_VALUE;\\n        }\\n        PriorityQueue<int[]> queue = new PriorityQueue<>((int[] a, int[] b) -> {\\n            return a[0] - b[0];\\n        });\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                queue.add(new int[]{mat[i][j], i, j});\\n            }\\n        }\\n        int res = 0;\\n        while(!queue.isEmpty()) {\\n            int[] arr = queue.remove();\\n            int val = arr[0], row = arr[1], col = arr[2];\\n            int cur = 1;\\n            if(val == rows[row]) {\\n                cur = Math.max(rowSubMaxVals[row] + 1, cur);\\n            } else {\\n                cur = Math.max(rowMaxVals[row] + 1, cur);\\n            }\\n            if(val == cols[col]) {\\n                cur = Math.max(colSubMaxVals[col] + 1, cur);\\n            } else {\\n                cur = Math.max(colMaxVals[col] + 1, cur);\\n            }\\n            \\n\\n            if(val > rows[row]) {\\n                rowSubMaxVals[row] = rowMaxVals[row];\\n                rows[row] = val;\\n            }\\n            if(val > cols[col]) {\\n                colSubMaxVals[col] = colMaxVals[col];\\n                cols[col] = val;\\n            }\\n            rowMaxVals[row] = Math.max(rowMaxVals[row], cur);\\n            colMaxVals[col] = Math.max(colMaxVals[col], cur);\\n            \\n            res = Math.max(res, cur);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-primes",
        "tags": "java",
        "release_time": 1688665208,
        "code": "class Solution {\n    public int countPrimes(int n) {\n        if(n<2) return 0;\n        boolean[] primes = new boolean[n];\n         Arrays.fill(primes, true);\n         \n        int count=0;\n        for (int p = 2;p < n; p++) {\n            if(primes[p])\n            {\n                count++;\n                 if((long)p*p<n)\n                {\n                     for(int i=p*p;i<n;i+=p)\n                     primes[i]=false;\n                }\n\n            }\n          }\n    return count;\n    }\n        \n \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countPrimes(int n) {\\n        if(n<2) return 0;\\n        boolean[] primes = new boolean[n];\\n         Arrays.fill(primes, true);\\n         \\n        int count=0;\\n        for (int p = 2;p < n; p++) {\\n            if(primes[p])\\n            {\\n                count++;\\n                 if((long)p*p<n)\\n                {\\n                     for(int i=p*p;i<n;i+=p)\\n                     primes[i]=false;\\n                }\\n\\n            }\\n          }\\n    return count;\\n    }\\n        \\n \\n}\\n```"
    },
    {
        "slug": "delete-leaves-with-a-given-value",
        "tags": "java",
        "release_time": 1691591055,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\n        if(root==null){\n            return null;\n        }\n         root.left=removeLeafNodes(root.left,target);\n       root.right= removeLeafNodes(root.right,target);\n        if(root.val==target && root.left==null && root.right==null){\n            return null;\n        }\n       \n        return root;\n\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\\n        if(root==null){\\n            return null;\\n        }\\n         root.left=removeLeafNodes(root.left,target);\\n       root.right= removeLeafNodes(root.right,target);\\n        if(root.val==target && root.left==null && root.right==null){\\n            return null;\\n        }\\n       \\n        return root;\\n\\n    }\\n}\\n```"
    },
    {
        "slug": "count-nice-pairs-in-an-array",
        "tags": "java",
        "release_time": 1662432843,
        "code": "class Solution {\n    // Idea:\n    // if A + rev(B) = rev(A) + B:\n    // it means that (A-rev(A)) = (B-rev(B)).\n    // So we make a HashMap and store all the difference and its counts\n    // Each count of same difference means that we have a new nice pair\n    \n    // Helper function for calculating rev\n    public int rev(int num){\n        int result = 0;\n        while (num != 0) {\n            // for example, rev(123) = 321\n            // 1st iteration: result = 0 + 3 = 3\n            // 2nd iteration: result = 30 + 2 = 32\n            // 3rd iteration: result = 320 + 1 = 321\n            result = (result * 10) + (num % 10);\n            num /= 10;\n        }\n        return result;\n    }\n    \n    public int countNicePairs(int[] nums) {\n        long modulo = (long)Math.pow(10, 9) + 7L;\n        long result = 0;\n        Map<Integer, Integer> mapping = new HashMap<>();\n        \n        // Step 1: Calculate all (number - rev(number)) and put them into mapping\n        for (int curr : nums) {\n            int diff = curr - rev(curr);\n            mapping.put(diff, mapping.getOrDefault(diff, 0)+1);\n        }\n        \n        // Step 2: Count how many nice pairs\n        // If we have count = 2, we have (A-rev(A)) = (B-rev(B)) , so 1 nice pair\n        // If we have count = 3, we have (A-rev(A)) = (B-rev(B)) = (C-rev(C)), so (A,B) (B,C) (A,C) = 3 pairs\n        // If we have count = 4, we have (A,B) (A,C) (A,D) (B,C) (B,D) (C,D) = 6 pairs\n        // So we have count * (count-1) permutations, but since (A,B) and (B,A) are treated as 1 pair, we divided by 2.\n        for (Integer key : mapping.keySet()) {\n            int count = mapping.get(key);\n            result += (count*(count-1L)) / 2L;\n        }\n        return (int) (result % modulo);\n    }\n}",
        "content": "```\\nclass Solution {\\n    // Idea:\\n    // if A + rev(B) = rev(A) + B:\\n    // it means that (A-rev(A)) = (B-rev(B)).\\n    // So we make a HashMap and store all the difference and its counts\\n    // Each count of same difference means that we have a new nice pair\\n    \\n    // Helper function for calculating rev\\n    public int rev(int num){\\n        int result = 0;\\n        while (num != 0) {\\n            // for example, rev(123) = 321\\n            // 1st iteration: result = 0 + 3 = 3\\n            // 2nd iteration: result = 30 + 2 = 32\\n            // 3rd iteration: result = 320 + 1 = 321\\n            result = (result * 10) + (num % 10);\\n            num /= 10;\\n        }\\n        return result;\\n    }\\n    \\n    public int countNicePairs(int[] nums) {\\n        long modulo = (long)Math.pow(10, 9) + 7L;\\n        long result = 0;\\n        Map<Integer, Integer> mapping = new HashMap<>();\\n        \\n        // Step 1: Calculate all (number - rev(number)) and put them into mapping\\n        for (int curr : nums) {\\n            int diff = curr - rev(curr);\\n            mapping.put(diff, mapping.getOrDefault(diff, 0)+1);\\n        }\\n        \\n        // Step 2: Count how many nice pairs\\n        // If we have count = 2, we have (A-rev(A)) = (B-rev(B)) , so 1 nice pair\\n        // If we have count = 3, we have (A-rev(A)) = (B-rev(B)) = (C-rev(C)), so (A,B) (B,C) (A,C) = 3 pairs\\n        // If we have count = 4, we have (A,B) (A,C) (A,D) (B,C) (B,D) (C,D) = 6 pairs\\n        // So we have count * (count-1) permutations, but since (A,B) and (B,A) are treated as 1 pair, we divided by 2.\\n        for (Integer key : mapping.keySet()) {\\n            int count = mapping.get(key);\\n            result += (count*(count-1L)) / 2L;\\n        }\\n        return (int) (result % modulo);\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-palindromic-subsequences",
        "tags": "java",
        "release_time": 1682445692,
        "code": "class Solution {\n    public int removePalindromeSub(String s) {\n\tif (s.equals(new StringBuilder(s).reverse().toString())) return 1;\n\treturn 2;\n    }\n\n    \n}",
        "content": "Logic\\n\\nIt\\'s quite easy to trip over this problem since it looks like we have to do all sorts of stuff to the string to get our answer. Actually, once you identify the main trick behind this question, it\\'s really quite a simple algorithm!\\nWhat is a Subsequence?\\n\\nThis is quite important to understand. Below are the main string sub-types (literally) that could be mentioned in a question.\\n\\n    Substring: A contiguous sequence of characters in a string.\\n    Subsequence: Any sequence of characters in a string where their relative order is maintained.\\n\\nIn particular, this question is asking to remove subsequences in the string. Therefore, we don\\'t actually care where these subsequences are as long as they maintain their original relative ordering in the string. For example, a subsequence of \"leetcode\" could be \"toe\".\\nThe Major Observation:\\n\\nWhat makes a subsequence a palindrome? Well of course it\\'s when the string is the same forwards and backwards. Is \"a\" a palindrome? Yes. Is \"aa\" a palindrome? Yes. What about \"aaaaaaaaa\"? Yes!\\n\\n    The main observation here is that any string consisting of the same letters is a palindrome. Since we\\'re working with subsequences and the only characters in the string are \\'a\\' and \\'b\\', we know we can get rid of all palindromes in at most 2 steps.\\n\\nimage\\n\\nWhat other cases are there? Well when could we ever remove a palindrome in just 1 step? When the input string itself is a palindrome of course.\\nAwesome. Now we\\'re ready to start coding!\\nAlgorithm:\\n\\nIf string is a palindrome: return 1\\nElse return 2\\n\\nCode\\n\\nIf you have any questions, suggestions or improvements, feel free to let me know. Thank you for reading!\\n\\n    Solution with custom isPalindrome() function (this is the recommended choice during an interview):\\n\\npublic int removePalindromeSub(String s) {\\n\\tif (isPalindrome(s)) return 1;\\n\\treturn 2;\\n}\\n\\nprivate boolean isPalindrome(String s) {\\n\\tint i = 0, n = s.length();\\n\\twhile (i <= n/2)\\n\\t\\tif (s.charAt(i) != s.charAt(n-1-i++)) return false;\\n\\treturn true;\\n}\\n\\n    Solution with StringBuilder:\\n\\npublic int removePalindromeSub(String s) {\\n\\tif (s.equals(new StringBuilder(s).reverse().toString())) return 1;\\n\\treturn 2;\\n}\\n\\nTime Complexity: O(n) where n is the length of the string.\\nSpace Complexity: O(1) (note that the StringBuilder solution takes O(n) space).\\n\\n# Code\\n```\\nclass Solution {\\n    public int removePalindromeSub(String s) {\\n\\tif (s.equals(new StringBuilder(s).reverse().toString())) return 1;\\n\\treturn 2;\\n    }\\n\\n    \\n}\\n```"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "tags": "java",
        "release_time": 1691043692,
        "code": "class Solution {\n    public int[] smallerNumbersThanCurrent(int[] nums) {\n        int c=0;\n        int res[]=new int[nums.length],k=0;\n        for(int i=0;i<nums.length;i++){\n         for(int j=0;j<nums.length;j++){\n             if(nums[j]<nums[i]){\n                 c+=1;\n                    }\n                 }\n                res[i]=c;\n               c=0;\n              }\n      return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int c=0;\\n        int res[]=new int[nums.length],k=0;\\n        for(int i=0;i<nums.length;i++){\\n         for(int j=0;j<nums.length;j++){\\n             if(nums[j]<nums[i]){\\n                 c+=1;\\n                    }\\n                 }\\n                res[i]=c;\\n               c=0;\\n              }\\n      return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "non-decreasing-subsequences",
        "tags": "java",
        "release_time": 1674187609,
        "code": "class Solution {\n    List<List<Integer>>vec=new ArrayList<>();\n    HashSet<List<Integer>>set=new HashSet<>();\n    void solve(int []nums, int prev, List<Integer>op, int idx){\n        if(idx==nums.length){\n            if(op.size()>1){\n                set.add(op);\n            }\n            return;\n        }\n        if(prev==-1 || nums[idx]>=nums[prev]){\n            List<Integer>op1=new ArrayList<>(op);\n            op1.add(nums[idx]);\n            solve(nums,idx,op1,idx+1);\n        }\n        solve(nums,prev,op,idx+1);\n        \n    }\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<Integer>op=new ArrayList<>();\n        solve(nums,-1,op, 0);\n        Iterator<List<Integer>> it = set.iterator();\n        while(it.hasNext())vec.add(it.next());\n        return vec;\n    }\n}",
        "content": "\\n\\n\\n```\\nclass Solution {\\n    List<List<Integer>>vec=new ArrayList<>();\\n    HashSet<List<Integer>>set=new HashSet<>();\\n    void solve(int []nums, int prev, List<Integer>op, int idx){\\n        if(idx==nums.length){\\n            if(op.size()>1){\\n                set.add(op);\\n            }\\n            return;\\n        }\\n        if(prev==-1 || nums[idx]>=nums[prev]){\\n            List<Integer>op1=new ArrayList<>(op);\\n            op1.add(nums[idx]);\\n            solve(nums,idx,op1,idx+1);\\n        }\\n        solve(nums,prev,op,idx+1);\\n        \\n    }\\n    public List<List<Integer>> findSubsequences(int[] nums) {\\n        List<Integer>op=new ArrayList<>();\\n        solve(nums,-1,op, 0);\\n        Iterator<List<Integer>> it = set.iterator();\\n        while(it.hasNext())vec.add(it.next());\\n        return vec;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-ice-cream-bars",
        "tags": "java",
        "release_time": 1672980160,
        "code": "class Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        int [] arr = new int [100001];\n        for(int x : costs)arr[x]++;\n        int count = 0;\n        int index = 1;\n//If coins can buy all the ice-cream at ith index.\n        while(index<100001 && coins>=index*arr[index]){\n            coins-=index*arr[index];\n            count+=arr[index];\n            index++;\n        }\n//If coins can buy onyl some of the ice-creams at ith index.\n        while(index<100001 && coins>=index){\n            coins-=index;\n            count++;\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```"
    },
    {
        "slug": "find-the-divisibility-array-of-a-string",
        "tags": "java",
        "release_time": 1678292913,
        "code": "class Solution {\n    public int[] divisibilityArray(String word, int m) {\n    int n = word.length();\n    int[] div = new int[n];\n    long num = 0;\n    for (int i = 0; i < n; i++) {\n        long digit = word.charAt(i) - '0';\n        num = (num * 10 + digit) % m;\n        div[i] = (num == 0) ? 1 : 0;\n    }\n    return div;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] divisibilityArray(String word, int m) {\\n    int n = word.length();\\n    int[] div = new int[n];\\n    long num = 0;\\n    for (int i = 0; i < n; i++) {\\n        long digit = word.charAt(i) - \\'0\\';\\n        num = (num * 10 + digit) % m;\\n        div[i] = (num == 0) ? 1 : 0;\\n    }\\n    return div;\\n    }\\n}\\n```"
    },
    {
        "slug": "airplane-seat-assignment-probability",
        "tags": "java",
        "release_time": 1672300543,
        "code": "class Solution {\n    public double nthPersonGetsNthSeat(int n) {\n        if(n==1)\n        return 1.00000;\n        return 0.50000;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public double nthPersonGetsNthSeat(int n) {\\n        if(n==1)\\n        return 1.00000;\\n        return 0.50000;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
        "tags": "java",
        "release_time": 1620922873,
        "code": "class Solution {\n    public int getMinSwaps(String num, int k) {\n        int n = num.length();\n        \n        //store index \n        int[] number = new int[n];\n        for(int i = 0; i < n; i++){\n            int digit = num.charAt(i) - '0';\n            number[i] = digit;\n        }\n        \n        //compute kth smallest number\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\n        \n        return getMinSwaps(number, kthSmallestNumber);\n    }\n    \n    private int[] getKthSmallestNumber(int[] nums, int k){\n        while(k --> 0){\n            computeNextPermutation(nums);\n        }\n        return nums;\n    }\n    \n    private void computeNextPermutation(int[] nums){\n        int n = nums.length;\n        int i = n - 2;\n        \n        //find first index from last which value smaller than next element \n        while(i >= 0 && nums[i] >= nums[i + 1]){\n            i--;\n        }\n        \n\n        if(i >= 0){\n            //find index which is just greater than that index value (e.g i)\n            int j = n - 1;\n            while(j > i && nums[j] <= nums[i]){\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        \n        //sort all element which index greater than <i>\n        Arrays.sort(nums, i + 1, n);\n    }\n    \n    private void swap(int[] arr, int i, int j){\n        int temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    \n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\n        int swapCount = 0;\n        int n = number.length;\n        \n        for(int i = 0; i < n; i++){\n            //ignore, as it already in correct position, no need for swap\n            if(number[i] == kthSmallestNumber[i]) continue;\n            \n            //find the coorect position\n            int j = i + 1;\n            while(j < n && number[i] != kthSmallestNumber[j]){\n                j++;\n            }\n            \n            //swift to correct position\n            while(j > i){\n                swap(kthSmallestNumber, j - 1, j);\n                swapCount++;\n                j--;\n            }\n            \n        }\n        \n        return swapCount;\n    }\n}",
        "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        //store index \\n        int[] number = new int[n];\\n        for(int i = 0; i < n; i++){\\n            int digit = num.charAt(i) - \\'0\\';\\n            number[i] = digit;\\n        }\\n        \\n        //compute kth smallest number\\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\\n        \\n        return getMinSwaps(number, kthSmallestNumber);\\n    }\\n    \\n    private int[] getKthSmallestNumber(int[] nums, int k){\\n        while(k --> 0){\\n            computeNextPermutation(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void computeNextPermutation(int[] nums){\\n        int n = nums.length;\\n        int i = n - 2;\\n        \\n        //find first index from last which value smaller than next element \\n        while(i >= 0 && nums[i] >= nums[i + 1]){\\n            i--;\\n        }\\n        \\n\\n        if(i >= 0){\\n            //find index which is just greater than that index value (e.g i)\\n            int j = n - 1;\\n            while(j > i && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        \\n        //sort all element which index greater than <i>\\n        Arrays.sort(nums, i + 1, n);\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            //ignore, as it already in correct position, no need for swap\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            //find the coorect position\\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            //swift to correct position\\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "tags": "java",
        "release_time": 1683602954,
        "code": "class Solution {\n    public int minOperations(int[] nums) {\n        int count = 0;\n        for(int i = 1; i < nums.length; i++) {\n            if(nums[i] > nums[i - 1]) {\n                continue;\n            }\n            count += nums[i - 1] - nums[i] + 1;\n            nums[i] = nums[i - 1] + 1;\n        }\n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[] nums) {\\n        int count = 0;\\n        for(int i = 1; i < nums.length; i++) {\\n            if(nums[i] > nums[i - 1]) {\\n                continue;\\n            }\\n            count += nums[i - 1] - nums[i] + 1;\\n            nums[i] = nums[i - 1] + 1;\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "missing-number",
        "tags": "java",
        "release_time": 1685629239,
        "code": "class Solution {\n    public int missingNumber(int[] nums) {\n\n\n        int res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            res += ((i + 1) - nums[i]);\n        }\n        return res;\n\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int missingNumber(int[] nums) {\\n\\n\\n        int res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            res += ((i + 1) - nums[i]);\\n        }\\n        return res;\\n\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-an-original-string-exists-given-two-encoded-strings",
        "tags": "java",
        "release_time": 1641066929,
        "code": "/**\nCases:\n\ndiff > 0 meaning we need to pick more chars in s1\ndiff < 0 meaning we need to pick more chars in s2\n\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\n\n1. s1[i] == s2[j] and diff = 0\n    increment i+1 and j+1\n    \n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\n    and increment i i+1, diff-val\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\n    increment j, j+1, diff+val\n\n\n\n     01234\ns1 = l123e\ns2 = 44\n\ni: 0\nj: 0\ndiff: 0\n    // Wildcard matching on s2[j]\n    val = 4, diff = 0+4 j = 1\n    \n\ti: 0\n\tj: 1\n\tdiff: 4\n    // Literal matching on s1[i]\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\n\t\n\t\ti: 1\n\t\tj: 1\n\t\tdiff: 3\n        // Wildcard matching on s1[i]\n        val = 1 diff = 3-1 = 2 increment i\n\t\t\n\t\t\ti: 2\n\t\t\tj: 1\n\t\t\tdiff: 2\n            // Wildcard matching on s1[i]\n            val = 2 diff = 2-2 = 0   increment i\n\t\t\t\n\t\t\t\ti: 3\n\t\t\t\tj: 1\n\t\t\t\tdiff: 0 \n                // Wildcard matching on s1[i]\n                val=3 diff = 0-3 = -3, increment i\n                \n\t\t\t\t\ti: 4\n\t\t\t\t\tj: 1\n\t\t\t\t\tdiff: -3\n\t\t\t\t\t// Wildcard matching on s2[j]\n                    val = 4 diff = -3+4 =1 increment j\n                    \n\t\t\t\t\t\ti: 4\n\t\t\t\t\t\tj: 2\n\t\t\t\t\t\tdiff: 1\n                         // Literal matching on s1[i]\n                         decrement i-1 and increment i\n                         \n                            i=5\n                            j=2\n                                diff==0 return true\n                        dp[4][2][1] = true    \n\t\t\t\t\t\treturn true\n\t\t\t\t    return dp[4][1][1000-3] = true\n                return dp[3][1][0] = true\n\t\t\t\n\t\t\ti: 2\n\t\t\tj: 1\n\t\t\tdiff: 2\n\t\t\treturn dp[2][1][2] = true\n\t\t\treturn true\n\t\t\t\n\t\ti: 0\n\t\tj: 1\n\t\tdiff: 4\n\t\treturn dp[0][1][4] = true  \n    return true\n*/\n\nclass Solution {\n    //112ms\n     public boolean possiblyEquals(String s1, String s2) {\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\n     }\n    \n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\n         if(i == s1.length && j == s2.length) {\n             return diff == 0;\n         }\n         \n         if(dp[i][j][diff+1000] != null)\n             return dp[i][j][diff+1000];\n         \n         // if both i and j are at the same location and chars are same then simply increment both pointers\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\n             return dp[i][j][diff+1000] = true;\n         }\n         \n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\n         // as we are done with the current jth char\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\n             return dp[i][j][diff+1000] = true;\n         }\n         \n         // wildcard matching in s1\n         // if s1 contains l123\n         // then need to check with val as 1 then val as 12 and val as 123\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\n             val = val * 10 + s1[k] -'0';\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         // wildcard matching in s2\n         // if s2 contains l123\n         // then need to check with val as 1 then val as 12 and val as 123\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\n             val = val * 10 + s2[k] -'0';\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\n                 return dp[i][j][diff+1000] = true;\n             }\n         }\n         \n         return dp[i][j][diff+1000] = false;\n     }\n}",
        "content": "Please see the comments below.\\n\\n```\\n/**\\nCases:\\n\\ndiff > 0 meaning we need to pick more chars in s1\\ndiff < 0 meaning we need to pick more chars in s2\\n\\n-1000 < diff < 1000 as there can be at most 3 digits in the string meaning largest digits are 999\\n\\n1. s1[i] == s2[j] and diff = 0\\n    increment i+1 and j+1\\n    \\n2. if s1[i] is not digit and diff > 0  then increment i i+1, diff\\n3. if s2[j] is not digit and diff < 0 then increment j j+1, diff\\n4. if s1[i] is digit then get digit value and decrement diff val as we have covered such chars in the s1 string\\n    and increment i i+1, diff-val\\n5. if s2[j] is digit then get digit value and increment diff val as we need to cover such chars in the s2 string and\\n    increment j, j+1, diff+val\\n\\n\\n\\n     01234\\ns1 = l123e\\ns2 = 44\\n\\ni: 0\\nj: 0\\ndiff: 0\\n    // Wildcard matching on s2[j]\\n    val = 4, diff = 0+4 j = 1\\n    \\n\\ti: 0\\n\\tj: 1\\n\\tdiff: 4\\n    // Literal matching on s1[i]\\n    increment ith pointer as ith is a literal and we can move on to next char in s1 and decrement diff\\n\\t\\n\\t\\ti: 1\\n\\t\\tj: 1\\n\\t\\tdiff: 3\\n        // Wildcard matching on s1[i]\\n        val = 1 diff = 3-1 = 2 increment i\\n\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n            // Wildcard matching on s1[i]\\n            val = 2 diff = 2-2 = 0   increment i\\n\\t\\t\\t\\n\\t\\t\\t\\ti: 3\\n\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\tdiff: 0 \\n                // Wildcard matching on s1[i]\\n                val=3 diff = 0-3 = -3, increment i\\n                \\n\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\tj: 1\\n\\t\\t\\t\\t\\tdiff: -3\\n\\t\\t\\t\\t\\t// Wildcard matching on s2[j]\\n                    val = 4 diff = -3+4 =1 increment j\\n                    \\n\\t\\t\\t\\t\\t\\ti: 4\\n\\t\\t\\t\\t\\t\\tj: 2\\n\\t\\t\\t\\t\\t\\tdiff: 1\\n                         // Literal matching on s1[i]\\n                         decrement i-1 and increment i\\n                         \\n                            i=5\\n                            j=2\\n                                diff==0 return true\\n                        dp[4][2][1] = true    \\n\\t\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t    return dp[4][1][1000-3] = true\\n                return dp[3][1][0] = true\\n\\t\\t\\t\\n\\t\\t\\ti: 2\\n\\t\\t\\tj: 1\\n\\t\\t\\tdiff: 2\\n\\t\\t\\treturn dp[2][1][2] = true\\n\\t\\t\\treturn true\\n\\t\\t\\t\\n\\t\\ti: 0\\n\\t\\tj: 1\\n\\t\\tdiff: 4\\n\\t\\treturn dp[0][1][4] = true  \\n    return true\\n*/\\n\\nclass Solution {\\n    //112ms\\n     public boolean possiblyEquals(String s1, String s2) {\\n         return helper(s1.toCharArray(), s2.toCharArray(), 0, 0, 0, new Boolean[s1.length()+1][s2.length()+1][2001]);\\n     }\\n    \\n     boolean helper(char[] s1, char[] s2, int i, int j, int diff, Boolean[][][] dp) {\\n         if(i == s1.length && j == s2.length) {\\n             return diff == 0;\\n         }\\n         \\n         if(dp[i][j][diff+1000] != null)\\n             return dp[i][j][diff+1000];\\n         \\n         // if both i and j are at the same location and chars are same then simply increment both pointers\\n         if(i < s1.length && j < s2.length && diff == 0 && s1[i] == s2[j]) {\\n             if(helper(s1, s2, i+1, j+1, diff, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // if s1[i] is literal and diff > 0 then increment i and decrement diff by 1\\n         if(i < s1.length && !Character.isDigit(s1[i]) && diff > 0 && helper(s1, s2, i+1, j, diff-1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // if s2[j] is literal and diff < 0 then increment j and increment diff by 1\\n         // as we are done with the current jth char\\n         if(j < s2.length && !Character.isDigit(s2[j]) && diff < 0 && helper(s1, s2, i, j+1, diff+1, dp)) {\\n             return dp[i][j][diff+1000] = true;\\n         }\\n         \\n         // wildcard matching in s1\\n         // if s1 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = i, val = 0; k < i + 4 && k < s1.length && Character.isDigit(s1[k]); k++) {\\n             val = val * 10 + s1[k] -\\'0\\';\\n             if(helper(s1, s2, k+1, j, diff-val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         // wildcard matching in s2\\n         // if s2 contains l123\\n         // then need to check with val as 1 then val as 12 and val as 123\\n         for(int k = j, val = 0; k < j + 4 && k < s2.length && Character.isDigit(s2[k]); k++) {\\n             val = val * 10 + s2[k] -\\'0\\';\\n             if(helper(s1, s2, i, k+1, diff+val, dp)) {\\n                 return dp[i][j][diff+1000] = true;\\n             }\\n         }\\n         \\n         return dp[i][j][diff+1000] = false;\\n     }\\n}\\n```"
    },
    {
        "slug": "sum-of-mutated-array-closest-to-target",
        "tags": "java",
        "release_time": 1680185953,
        "code": "class Solution {\n    public int findBestValue(int[] arr, int target) {\n      int n = arr.length;\n        int lo = 0, hi = 0;\n        for (int i = 0; i < n; i++) {\n            hi = Math.max(hi, arr[i]);\n        }\n        \n        while (lo < hi) {\n            int mid = lo + (hi - lo) / 2;\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                sum += Math.min(arr[i], mid);\n            }\n            if (sum >= target) {\n                hi = mid;\n            } else {\n                lo = mid + 1;\n            }\n        }\n        \n        int sum1 = 0, sum2 = 0;\n        for (int i = 0; i < n; i++) {\n            sum1 += Math.min(arr[i], lo);\n            sum2 += Math.min(arr[i], lo - 1);\n        }\n        \n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findBestValue(int[] arr, int target) {\\n      int n = arr.length;\\n        int lo = 0, hi = 0;\\n        for (int i = 0; i < n; i++) {\\n            hi = Math.max(hi, arr[i]);\\n        }\\n        \\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            int sum = 0;\\n            for (int i = 0; i < n; i++) {\\n                sum += Math.min(arr[i], mid);\\n            }\\n            if (sum >= target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        int sum1 = 0, sum2 = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += Math.min(arr[i], lo);\\n            sum2 += Math.min(arr[i], lo - 1);\\n        }\\n        \\n        return Math.abs(sum2 - target) <= Math.abs(sum1 - target) ? lo - 1 : lo;\\n    }\\n}\\n```"
    },
    {
        "slug": "convert-the-temperature",
        "tags": "java",
        "release_time": 1668314039,
        "code": "class Solution {\n    public double[] convertTemperature(double celsius) {\n        double arr[] = new double[2];\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\n        arr[0] = celsius + 273.15;\n        return arr;\n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe program takes a celsius value and converts it to fahrenheit and kelvin.\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double[] convertTemperature(double celsius) {\\n        double arr[] = new double[2];\\n        arr[1] = (celsius * 9.0/5.0) + 32.0;\\n        arr[0] = celsius + 273.15;\\n        return arr;\\n    }\\n}\\n```"
    },
    {
        "slug": "tuple-with-same-product",
        "tags": "java",
        "release_time": 1611201483,
        "code": "class Solution {\n    public int tupleSameProduct(int[] nums) {\n        \n        if(nums.length < 4){\n            return 0;\n        }\n        \n        int res = 0;\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < nums.length - 1; i++){\n            \n            for(int j = i + 1; j < nums.length; j++){\n                \n                int val = nums[i] * nums[j];\n                map.put(val, map.getOrDefault(val, 0) + 1);\n            }\n        }\n        \n        for(int key : map.keySet()){\n            \n            int val = map.get(key);\n            \n            if(val > 1){\n                res += val * (val - 1) * 4;    // (val * (val - 1) / 2) * 8\n            }\n        }\n        \n        return res;\n    }\n}",
        "content": "Main idea :\\nA possible sequence can have 8 possible arrangements\\na * b = c * d\\nWe can\\'t choose all 4 numbers (a, b, c, d) from the array as it will increase time complexity ( O(n^4) )\\nBut we can choose 2 numbers as O(n^2) solution is allowed because of constraints\\nWe will store the product of a and b in a HashMap corresponding to its frequency(Why : Because then we can compare it with c * d)\\nSince all elements are distinct, there won\\'t be any duplicacy ( a != b != c != d )\\nTo get the solution we have to choose 2 equal products ( Since a * b = c * d ) (a * b = first pair and c * d = second pair)\\nnC2 = n * (n - 1) / 2\\nThen we have to multiply this by 8 because a possible sequence can have 8 arrangements\\n\\n```\\nclass Solution {\\n    public int tupleSameProduct(int[] nums) {\\n        \\n        if(nums.length < 4){\\n            return 0;\\n        }\\n        \\n        int res = 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        \\n        for(int i = 0; i < nums.length - 1; i++){\\n            \\n            for(int j = i + 1; j < nums.length; j++){\\n                \\n                int val = nums[i] * nums[j];\\n                map.put(val, map.getOrDefault(val, 0) + 1);\\n            }\\n        }\\n        \\n        for(int key : map.keySet()){\\n            \\n            int val = map.get(key);\\n            \\n            if(val > 1){\\n                res += val * (val - 1) * 4;    // (val * (val - 1) / 2) * 8\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nIf you liked this post, Please Upvote"
    },
    {
        "slug": "count-artifacts-that-can-be-extracted",
        "tags": "java",
        "release_time": 1647147289,
        "code": "class Solution {\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\n        \n        boolean visit[][]=new boolean[n][n];\n        for(int arr[]:dig){\n            visit[arr[0]][arr[1]]=true;\n        }\n        \n        int ans=0;\n        for(int arr[]:artifacts){\n            \n            boolean flag=true;\n            for(int i=arr[0];i<=arr[2];i++){\n                for(int j=arr[1];j<=arr[3];j++){\n                    if(!visit[i][j]) flag=false;\n                }\n            }\n            if(flag) ans++;\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int digArtifacts(int n, int[][] artifacts, int[][] dig) {\\n        \\n        boolean visit[][]=new boolean[n][n];\\n        for(int arr[]:dig){\\n            visit[arr[0]][arr[1]]=true;\\n        }\\n        \\n        int ans=0;\\n        for(int arr[]:artifacts){\\n            \\n            boolean flag=true;\\n            for(int i=arr[0];i<=arr[2];i++){\\n                for(int j=arr[1];j<=arr[3];j++){\\n                    if(!visit[i][j]) flag=false;\\n                }\\n            }\\n            if(flag) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-nth-node-from-end-of-list",
        "tags": "java",
        "release_time": 1683371341,
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n       ListNode start = new ListNode();\n        start.next = head;\n        ListNode fast = start;\n        ListNode slow = start;     \n\n        for(int i = 1; i <= n; ++i)\n            fast = fast.next;\n    \n        while(fast.next != null)\n        {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        \n        slow.next = slow.next.next;\n        \n        return start.next;\n    }\n}",
        "content": "# Intuition\\nwe can find the nth node just by one traversal by using two pointer approach.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTake two dummy nodes, who\\u2019s next will be pointing to the head.\\nTake another node to store the head, initially,s a dummy node(start), and the next node will be pointing to the head. The reason why we are using this extra dummy node is that there is an edge case. If the node is equal to the length of the LinkedList, then this slow will point to slow\\u2019s next\\u2192 next. And we can say our dummy start node will be broken and will be connected to the slow next\\u2192 next.\\n\\nStart traversing until the fast pointer reaches the nth node.\\n![image.png](https://assets.leetcode.com/users/images/6d30920b-bf59-4564-897d-869a54148190_1683371160.3817167.png)\\n\\nNow start traversing by one step both of the pointers until the fast pointers reach the end.\\n    \\n![image.png](https://assets.leetcode.com/users/images/6e6e1af9-8863-4eff-988c-decc91e86746_1683371181.7739182.png)\\n\\nWhen the traversal is done, just do the deleting part. Make slow pointers next to the next of the slow pointer to ignore/disconnect the given node.\\n![image.png](https://assets.leetcode.com/users/images/8fd772c7-a44b-4569-99bd-293d4c5dcd32_1683371203.3690717.png)\\n\\n\\nLast, return to the next start.\\nDry Run:  We will be taking the first example for the dry run, so, the LinkedList is [1,2,3,4,5] and the node which has to be deleted is 2 from the last. For the first time, fast ptr starts traversing from node 1 and reaches 2, as it traverses for node number 2, then the slow ptr starts increasing one, and as well as the fast ptr until it reaches the end.\\n\\n1st traversal : fast=3, slow=1\\n2nd traversal : fast=4, slow=2\\n3rd traversal : fast=5, slow=3\\nNow, the slow->next->next will be pointed to the slow->next\\n\\nSo , the new linked list will be [1,2,3,5]\\n\\nNote that the above approach is provided by Striver on Youtube I highly recommend to checkout  his video solutions.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeNthFromEnd(ListNode head, int n) {\\n       ListNode start = new ListNode();\\n        start.next = head;\\n        ListNode fast = start;\\n        ListNode slow = start;     \\n\\n        for(int i = 1; i <= n; ++i)\\n            fast = fast.next;\\n    \\n        while(fast.next != null)\\n        {\\n            fast = fast.next;\\n            slow = slow.next;\\n        }\\n        \\n        slow.next = slow.next.next;\\n        \\n        return start.next;\\n    }\\n}\\n```\\n\\n"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "tags": "java",
        "release_time": 1689531937,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index;\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> m = new HashMap<>();\n\n        for(int i = 0; i < inorder.length; i++) {\n            m.put(inorder[i], i);\n        }\n        index = postorder.length - 1;\n        return buildTree(0, postorder.length - 1, postorder, m);\n    }\n\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\n        if(l > r) return null;\n\n        int val = postorder[index];\n        index--;\n\n        TreeNode root = new TreeNode(val);\n        if(l == r) return root;\n\n        int in = m.get(val);\n\n        root.right = buildTree(in + 1, r, postorder, m);\n        root.left = buildTree(l, in - 1, postorder, m);\n\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int index;\\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\\n        Map<Integer, Integer> m = new HashMap<>();\\n\\n        for(int i = 0; i < inorder.length; i++) {\\n            m.put(inorder[i], i);\\n        }\\n        index = postorder.length - 1;\\n        return buildTree(0, postorder.length - 1, postorder, m);\\n    }\\n\\n    private TreeNode buildTree(int l, int r, int postorder[] , Map<Integer, Integer> m) {\\n        if(l > r) return null;\\n\\n        int val = postorder[index];\\n        index--;\\n\\n        TreeNode root = new TreeNode(val);\\n        if(l == r) return root;\\n\\n        int in = m.get(val);\\n\\n        root.right = buildTree(in + 1, r, postorder, m);\\n        root.left = buildTree(l, in - 1, postorder, m);\\n\\n        return root;\\n    }\\n}\\n```"
    },
    {
        "slug": "design-a-stack-with-increment-operation",
        "tags": "java",
        "release_time": 1691581091,
        "code": "class CustomStack {\n    int[] stack;\n    int inc;\n\n    public CustomStack(int maxSize) {\n        stack = new int[maxSize];\n    }\n    \n    public void push(int x) {\n       if(inc < stack.length) {\n           stack[inc++] = x;\n       } \n    }\n    \n    public int pop() {\n        int last = -1;\n        if(inc > 0) {\n            last = stack[--inc];\n            stack[inc] = 0;\n        }\n        return last;\n    }\n    \n    public void increment(int k, int val) {\n        int limit = inc > k ? k : inc;\n        for(int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}\n\n/**\n * Your CustomStack object will be instantiated and called as such:\n * CustomStack obj = new CustomStack(maxSize);\n * obj.push(x);\n * int param_2 = obj.pop();\n * obj.increment(k,val);\n */",
        "content": "# Approach\\n\\nThe goal of this problem is to design a custom stack that supports various operations such as push, pop, and an increment operation for specific elements in the stack. We need to make sure we implement these operations efficiently within the given constraints.\\n\\n**Logic:**\\n\\n1. **Initialization:** The `CustomStack` class is initialized with a constructor that takes the `maxSize` as an argument and initializes an integer array named `stack` to store the elements. An integer variable `inc` is used to keep track of the current index to which an element will be pushed.\\n\\n2. **Push Operation:** The `push` operation takes an integer `x` as an argument. If the value of `inc` (the current index) is less than the length of the `stack` array, it means there is space to push an element. So, the value `x` is added to the `stack` array at the index `inc`, and then `inc` is incremented.\\n\\n3. **Pop Operation:** The `pop` operation doesn\\'t need any arguments. It first checks if the value of `inc` is greater than 0, indicating that there are elements in the stack. If so, it decrements `inc` to point to the last pushed element and stores that element in the `last` variable. Then, the value at the index `inc` is reset to 0 (indicating an empty slot). Finally, the `last` element is returned.\\n\\n4. **Increment Operation:** The `increment` operation takes two arguments: `k` and `val`. This operation is used to increment the bottom `k` elements of the stack by `val`. The idea here is to loop through the first `k` elements of the `stack` array (or all elements if there are fewer than `k` elements) and add `val` to each of them.\\n\\n**Explanation:**\\n\\n- The `push` operation is quite straightforward. It adds an element to the stack if there\\'s space available.\\n\\n- The `pop` operation retrieves the last pushed element (if available) and also clears that slot in the stack.\\n\\n- The `increment` operation modifies the bottom `k` elements by adding `val`. The loop ensures that we only modify existing elements within the range of the stack.\\n\\nOverall, this approach uses an integer array as the main data structure to simulate the stack behavior. The use of the `inc` variable keeps track of the current index to manage elements effectively. The logic is designed to accommodate the constraints and requirements of the problem statement.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(maxSize)$$\\n\\n# Code\\n```\\nclass CustomStack {\\n    int[] stack;\\n    int inc;\\n\\n    public CustomStack(int maxSize) {\\n        stack = new int[maxSize];\\n    }\\n    \\n    public void push(int x) {\\n       if(inc < stack.length) {\\n           stack[inc++] = x;\\n       } \\n    }\\n    \\n    public int pop() {\\n        int last = -1;\\n        if(inc > 0) {\\n            last = stack[--inc];\\n            stack[inc] = 0;\\n        }\\n        return last;\\n    }\\n    \\n    public void increment(int k, int val) {\\n        int limit = inc > k ? k : inc;\\n        for(int i = 0; i < limit; i++) {\\n            stack[i] += val;\\n        }\\n    }\\n}\\n\\n/**\\n * Your CustomStack object will be instantiated and called as such:\\n * CustomStack obj = new CustomStack(maxSize);\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * obj.increment(k,val);\\n */\\n```"
    },
    {
        "slug": "swap-adjacent-in-lr-string",
        "tags": "java",
        "release_time": 1665638009,
        "code": "class Solution {\n    public boolean canTransform(String start, String end) {\n        Queue<Node> logs = new LinkedList<>();\n\n        int count = 0;\n        for (char c : start.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                logs.add(new Node(c, count));\n            }\n        }\n\n        count = 0;\n        for (char c : end.toCharArray()) {\n            if (c == 'X') count++;\n            else {\n                if (logs.isEmpty()) return false;\n\n                Node node = logs.poll();\n                if (c != node.c) return false;\n\n                if (c == 'L' && count > node.count) return false;\n                if (c == 'R' && count < node.count) return false;                \n            }\n        }\n\n        return logs.isEmpty();\n    }\n\n    class Node {\n        public Character c;\n        public int count;\n\n        public Node(Character c, int count) {\n            this.c = c;\n            this.count = count;\n        }\n    }\n}",
        "content": "The idea is must guarantee:\\n- Number of L, R are the same and keep ordering. \\n- Number of X on the left of L from `end` always less than or equal the corresponding L from `start`\\n- Number of X on the right of R from `end` always more than or equal the corresponding R from `start`\\n\\nWe can terminate the process early once got the first violation, no need to loop through the end of `start`.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canTransform(String start, String end) {\\n        Queue<Node> logs = new LinkedList<>();\\n\\n        int count = 0;\\n        for (char c : start.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                logs.add(new Node(c, count));\\n            }\\n        }\\n\\n        count = 0;\\n        for (char c : end.toCharArray()) {\\n            if (c == \\'X\\') count++;\\n            else {\\n                if (logs.isEmpty()) return false;\\n\\n                Node node = logs.poll();\\n                if (c != node.c) return false;\\n\\n                if (c == \\'L\\' && count > node.count) return false;\\n                if (c == \\'R\\' && count < node.count) return false;                \\n            }\\n        }\\n\\n        return logs.isEmpty();\\n    }\\n\\n    class Node {\\n        public Character c;\\n        public int count;\\n\\n        public Node(Character c, int count) {\\n            this.c = c;\\n            this.count = count;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "group-the-people-given-the-group-size-they-belong-to",
        "tags": "java",
        "release_time": 1687491634,
        "code": "class Solution {\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\n        ArrayList<List<Integer>> list =  new ArrayList<>();\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\n\n        for(int i = 0 ; i < groupSizes.length; i++){\n            if(hm.containsKey(groupSizes[i])){\n                hm.get(groupSizes[i]).add(i);\n            }\n            else{\n            \tArrayList<Integer> newL = new ArrayList<>();\n            \tnewL.add(i);\n                hm.put(groupSizes[i], newL);      \n            }\n\n            if(hm.get(groupSizes[i]).size() == groupSizes[i]){\n                list.add(hm.get(groupSizes[i]));\n                hm.remove(groupSizes[i]);\n            }\n        }\n            \n        return list;\n    }\n}\n// UP-VOTE IF HELPFUL",
        "content": "# Complexity\\n- Time complexity:\\nO(n)\\nWhere n is the size of the array groupSizes\\n\\n- Space complexity:\\nO(n)\\nWhere n is the size of the array groupSizes\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> groupThePeople(int[] groupSizes) {\\n        ArrayList<List<Integer>> list =  new ArrayList<>();\\n        HashMap<Integer, ArrayList<Integer>> hm = new HashMap<>();\\n\\n        for(int i = 0 ; i < groupSizes.length; i++){\\n            if(hm.containsKey(groupSizes[i])){\\n                hm.get(groupSizes[i]).add(i);\\n            }\\n            else{\\n            \\tArrayList<Integer> newL = new ArrayList<>();\\n            \\tnewL.add(i);\\n                hm.put(groupSizes[i], newL);      \\n            }\\n\\n            if(hm.get(groupSizes[i]).size() == groupSizes[i]){\\n                list.add(hm.get(groupSizes[i]));\\n                hm.remove(groupSizes[i]);\\n            }\\n        }\\n            \\n        return list;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```"
    },
    {
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "tags": "java",
        "release_time": 1682782875,
        "code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n         int res = -1;\n        ArrayList<int[]> arr = new ArrayList<>();\n        for (int i = 0; i < points.length; i++) {\n            int xPoint = points[i][0];\n            int yPoint = points[i][1];\n            if(xPoint == x || yPoint == y){\n                arr.add(points[i]);\n                System.out.println(\"Point added to arr : \" + Arrays.toString(points[i]));\n            }\n        }\n        System.out.println(\"List of valid points : \");\n        arr.forEach(ints -> {\n            System.out.print(Arrays.toString(ints) + \" \");\n        });\n        System.out.println();\n        int min = Integer.MAX_VALUE;\n        int[] minPoint = new int[]{0,0};\n        if(!arr.isEmpty()) {\n            for (int i = 0; i < arr.size(); i++) {\n                int current = Math.abs(x - arr.get(i)[0]) + Math.abs(y - arr.get(i)[1]);\n                System.out.println(\"Current distance : \" + current);\n                if (current < min) {\n                    min = current;\n                    minPoint = new int[]{arr.get(i)[0], arr.get(i)[1]};\n                }\n                System.out.println(\"Min distance : \" + min);\n                System.out.println(\"Min point : \" + Arrays.toString(minPoint));\n            }\n\n            for (int i = 0; i < points.length; i++) {\n                if (Arrays.equals(points[i], minPoint)) {\n                    res = i;\n                    System.out.println(\"Res value added \" + i);\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the index of the point in the given array that is closest to the given (x, y) coordinate and has either the same x or y coordinate as the given coordinate.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe first create an ArrayList to store all the points that have either the same x or y coordinate as the given coordinate. We then iterate through this ArrayList and calculate the distance between each point and the given coordinate. We keep track of the minimum distance found so far and the corresponding point. Finally, we iterate through the input points array to find the index of the minimum distance point and return it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n), where n is the number of points in the input array.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(k), where k is the number of valid points \\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n         int res = -1;\\n        ArrayList<int[]> arr = new ArrayList<>();\\n        for (int i = 0; i < points.length; i++) {\\n            int xPoint = points[i][0];\\n            int yPoint = points[i][1];\\n            if(xPoint == x || yPoint == y){\\n                arr.add(points[i]);\\n                System.out.println(\"Point added to arr : \" + Arrays.toString(points[i]));\\n            }\\n        }\\n        System.out.println(\"List of valid points : \");\\n        arr.forEach(ints -> {\\n            System.out.print(Arrays.toString(ints) + \" \");\\n        });\\n        System.out.println();\\n        int min = Integer.MAX_VALUE;\\n        int[] minPoint = new int[]{0,0};\\n        if(!arr.isEmpty()) {\\n            for (int i = 0; i < arr.size(); i++) {\\n                int current = Math.abs(x - arr.get(i)[0]) + Math.abs(y - arr.get(i)[1]);\\n                System.out.println(\"Current distance : \" + current);\\n                if (current < min) {\\n                    min = current;\\n                    minPoint = new int[]{arr.get(i)[0], arr.get(i)[1]};\\n                }\\n                System.out.println(\"Min distance : \" + min);\\n                System.out.println(\"Min point : \" + Arrays.toString(minPoint));\\n            }\\n\\n            for (int i = 0; i < points.length; i++) {\\n                if (Arrays.equals(points[i], minPoint)) {\\n                    res = i;\\n                    System.out.println(\"Res value added \" + i);\\n                    return res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "stream-of-characters",
        "tags": "java",
        "release_time": 1638581699,
        "code": "class StreamChecker {\n\n    class TrieNode{\n        boolean isWord;\n        TrieNode children[] = new TrieNode[26];\n    }\n    \n    TrieNode root = new TrieNode();\n    int maxSize;\n    StringBuilder sb = new StringBuilder();\n    \n    public StreamChecker(String[] words) {\n        insert(words);\n    }\n    \n    public boolean query(char letter) {\n        if(sb.length()>=maxSize){\n            sb.deleteCharAt(0);\n        }\n        sb.append(letter);\n        TrieNode curr = root;\n        \n        for(int i=sb.length()-1;i>=0;i--){\n            char ch = sb.charAt(i);\n            \n            if(curr!=null) curr = curr.children[ch-'a'];\n            \n            if(curr!=null && curr.isWord) return true;\n        }\n        return false;\n    }\n    \n    public void insert(String[] words){\n        \n        for(String s : words){\n            maxSize = Math.max(maxSize,s.length());\n            TrieNode curr = root;\n            for(int i = s.length()-1;i>=0;i--){\n                char ch = s.charAt(i);\n                if(curr.children[ch-'a']==null){\n                    curr.children[ch-'a'] = new TrieNode();\n                }\n                curr = curr.children[ch-'a'];\n            }\n            curr.isWord = true;\n        }\n    }\n}",
        "content": "**Intution:** We gonna use trie data structure to store the given words for easy searching. So firstly store all the given words in Trie but the catch here is that store every word in **reverse order** because you have to search for prefix every time so u don\\'t have to search full trie from starting to just find last few characters.\\nAfter filling trie now using query function read the next coming letter and append it to your StringBuilder and check for the current String/stream if it is present in trie or not.\\n** One more important thing here is that Don\\'t just keep adding letters in your StringBuilder....find the **maxLength** from given words array and don\\'t let the size of StringBuider increase more than that...otherwise it will give you TLE due to memory out of space problem as StringBuilder will keep growing otherwise.\\n\\n![image](https://assets.leetcode.com/users/images/1a4384df-5692-4ecb-9499-25ad65143da4_1638581642.2779667.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/479a1cef-6bab-4c16-9b9f-5422bc9f9144_1638581652.3289752.jpeg)\\n\\n\\n```\\nclass StreamChecker {\\n\\n    class TrieNode{\\n        boolean isWord;\\n        TrieNode children[] = new TrieNode[26];\\n    }\\n    \\n    TrieNode root = new TrieNode();\\n    int maxSize;\\n    StringBuilder sb = new StringBuilder();\\n    \\n    public StreamChecker(String[] words) {\\n        insert(words);\\n    }\\n    \\n    public boolean query(char letter) {\\n        if(sb.length()>=maxSize){\\n            sb.deleteCharAt(0);\\n        }\\n        sb.append(letter);\\n        TrieNode curr = root;\\n        \\n        for(int i=sb.length()-1;i>=0;i--){\\n            char ch = sb.charAt(i);\\n            \\n            if(curr!=null) curr = curr.children[ch-\\'a\\'];\\n            \\n            if(curr!=null && curr.isWord) return true;\\n        }\\n        return false;\\n    }\\n    \\n    public void insert(String[] words){\\n        \\n        for(String s : words){\\n            maxSize = Math.max(maxSize,s.length());\\n            TrieNode curr = root;\\n            for(int i = s.length()-1;i>=0;i--){\\n                char ch = s.charAt(i);\\n                if(curr.children[ch-\\'a\\']==null){\\n                    curr.children[ch-\\'a\\'] = new TrieNode();\\n                }\\n                curr = curr.children[ch-\\'a\\'];\\n            }\\n            curr.isWord = true;\\n        }\\n    }\\n}\\n```\\n\\nI hope this helped u in uderstanding this question...Thanks!!"
    },
    {
        "slug": "subarray-product-less-than-k",
        "tags": "java",
        "release_time": 1689616329,
        "code": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        int i = 0,n = nums.length,product = 1,result = 0;\n        for(int j = 0;j<n;j++)\n        {\n            product = product*nums[j];\n            while(i<=j && product>=k)\n            {\n                product = product/nums[i];\n                i++;\n            }\n            result += j-i+1;\n        }\n        return result;\n    }\n}",
        "content": "# Java Code\\n```\\nclass Solution {\\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\\n        int i = 0,n = nums.length,product = 1,result = 0;\\n        for(int j = 0;j<n;j++)\\n        {\\n            product = product*nums[j];\\n            while(i<=j && product>=k)\\n            {\\n                product = product/nums[i];\\n                i++;\\n            }\\n            result += j-i+1;\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n> ### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F"
    },
    {
        "slug": "sort-characters-by-frequency",
        "tags": "java",
        "release_time": 1670065857,
        "code": "class Solution {\n    public String frequencySort(String s) {\n        char[] arr = new char[256];\n    for(int i=0; i<s.length(); i++){\n        arr[s.charAt(i)]++;    \n    }\n    \n    StringBuilder sb = new StringBuilder();\n    int max = -1;\n    while(max != 0){\n        max = -1;\n        char maxi = 0;\n        for(char i=0; i<arr.length; i++){\n            if(arr[i] > max){\n                max = arr[i];\n                maxi = i;\n            }\n        }\n        for(int i=0; i<max; i++){\n            sb.append(maxi);   \n        }\n        arr[maxi] = 0;\n    }\n    return sb.toString();\n        \n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String frequencySort(String s) {\\n        char[] arr = new char[256];\\n    for(int i=0; i<s.length(); i++){\\n        arr[s.charAt(i)]++;    \\n    }\\n    \\n    StringBuilder sb = new StringBuilder();\\n    int max = -1;\\n    while(max != 0){\\n        max = -1;\\n        char maxi = 0;\\n        for(char i=0; i<arr.length; i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n                maxi = i;\\n            }\\n        }\\n        for(int i=0; i<max; i++){\\n            sb.append(maxi);   \\n        }\\n        arr[maxi] = 0;\\n    }\\n    return sb.toString();\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "valid-anagram",
        "tags": "java",
        "release_time": 1692021593,
        "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        if(s.length()!=t.length())return false;\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\n        for(int i=0;i<s.length();i++){\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\n            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0)-1);\n        }\n        \n        for(int i=0;i<s.length();i++){\n            if(map.get(s.charAt(i))!=0)\n            return false;\n        }\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        HashMap<Character,Integer> map=new HashMap<Character,Integer>();\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n            map.put(t.charAt(i),map.getOrDefault(t.charAt(i),0)-1);\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(map.get(s.charAt(i))!=0)\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "longest-uncommon-subsequence-i",
        "tags": "java",
        "release_time": 1688445720,
        "code": "class Solution {\n    public int findLUSlength(String a, String b) {\n        if(a.equals(b)){\n            return -1;\n        }else{\n            return Math.max(a.length(),b.length());\n        }\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int findLUSlength(String a, String b) {\\n        if(a.equals(b)){\\n            return -1;\\n        }else{\\n            return Math.max(a.length(),b.length());\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "path-sum-ii",
        "tags": "java",
        "release_time": 1678803647,
        "code": "class Solution {\n     List<List<Integer>> al = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n       \n        helper( new ArrayList<>(), root, targetSum);\n        return al;\n    }\n    void helper(List<Integer> li, TreeNode root, int targetSum)\n    {\n        if(root == null)\n        return;\n        li.add(root.val);\n        if(root.left == null && root.right == null)\n        {\n            int sum = 0;\n            for(int i: li)\n            sum+= i;\n            if(sum == targetSum)\n            al.add(li);\n        }\n        helper(new ArrayList<>(li), root.left, targetSum);\n        helper(new ArrayList<>(li), root.right, targetSum);\n    }\n}",
        "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\n     List<List<Integer>> al = new ArrayList<>();\\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\\n       \\n        helper( new ArrayList<>(), root, targetSum);\\n        return al;\\n    }\\n    void helper(List<Integer> li, TreeNode root, int targetSum)\\n    {\\n        if(root == null)\\n        return;\\n        li.add(root.val);\\n        if(root.left == null && root.right == null)\\n        {\\n            int sum = 0;\\n            for(int i: li)\\n            sum+= i;\\n            if(sum == targetSum)\\n            al.add(li);\\n        }\\n        helper(new ArrayList<>(li), root.left, targetSum);\\n        helper(new ArrayList<>(li), root.right, targetSum);\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-sum-with-exactly-k-elements",
        "tags": "java",
        "release_time": 1682846234,
        "code": "class Solution {\n    public int maximizeSum(int[] nums, int k) {\n                int max = nums[0];\n        for (int m: nums)\n            max = Math.max(m, max);\n        int sum = max++;\n        for (int i = 0; i < k - 1; i++)\n            sum += max++;\n        return sum;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n                int max = nums[0];\\n        for (int m: nums)\\n            max = Math.max(m, max);\\n        int sum = max++;\\n        for (int i = 0; i < k - 1; i++)\\n            sum += max++;\\n        return sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-number-of-rectangles-containing-each-point",
        "tags": "java",
        "release_time": 1650772874,
        "code": "class Solution {\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\n    // group by y, as 1 <= y <= 100\n    int limit = 101;\n    List<List<Integer>> group = new ArrayList<>(limit);\n    for (int i = 0; i < limit; i++) {\n      group.add(new ArrayList<>());\n    }\n\n    for (int[] rectangle : rectangles) {\n      group.get(rectangle[1]).add(rectangle[0]);\n    }\n\n    // sort each group\n    for (int i = 0; i < limit; i++) {\n      group.get(i).sort(Comparator.naturalOrder());\n    }\n\n    int m = points.length;\n    int[] result = new int[m];\n\n    for (int i = 0; i < m; i++) {\n      int count = 0;\n      for (int j = points[i][1]; j < limit; j++) {\n        List<Integer> part = group.get(j);\n        int index = Collections.binarySearch(part, points[i][0]);\n        if (index < 0) {\n          index = -index - 1;\n        }\n\n        count += part.size() - index;\n      }\n      result[i] = count;\n    }\n    return result;\n  }\n}",
        "content": "Pay attention to condition: `1 <= y <= 100`, so we should group by `y` and then binary search `x`.\\n\\nWe can save lots of time, if we group by `y` instead of `x`.\\n\\nTime: O(NlogN)\\nSpace: O(N)\\n\\n```\\nclass Solution {\\n  public int[] countRectangles(int[][] rectangles, int[][] points) {\\n    // group by y, as 1 <= y <= 100\\n    int limit = 101;\\n    List<List<Integer>> group = new ArrayList<>(limit);\\n    for (int i = 0; i < limit; i++) {\\n      group.add(new ArrayList<>());\\n    }\\n\\n    for (int[] rectangle : rectangles) {\\n      group.get(rectangle[1]).add(rectangle[0]);\\n    }\\n\\n    // sort each group\\n    for (int i = 0; i < limit; i++) {\\n      group.get(i).sort(Comparator.naturalOrder());\\n    }\\n\\n    int m = points.length;\\n    int[] result = new int[m];\\n\\n    for (int i = 0; i < m; i++) {\\n      int count = 0;\\n      for (int j = points[i][1]; j < limit; j++) {\\n        List<Integer> part = group.get(j);\\n        int index = Collections.binarySearch(part, points[i][0]);\\n        if (index < 0) {\\n          index = -index - 1;\\n        }\\n\\n        count += part.size() - index;\\n      }\\n      result[i] = count;\\n    }\\n    return result;\\n  }\\n}\\n```"
    },
    {
        "slug": "design-authentication-manager",
        "tags": "java",
        "release_time": 1673449685,
        "code": "class AuthenticationManager {\n\n    int time=0;\n\n    HashMap<String,Integer>mp=new HashMap<>();\n\n    public AuthenticationManager(int timeToLive) {\n        \n    time=timeToLive;\n\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        \n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\n    {\n    return;\n    }\n\n    mp.put(tokenId,currentTime+time);\n\n    }\n    \n    public int countUnexpiredTokens(int currentTime) {\n    \n    List<String>lr=new ArrayList<>(mp.keySet());\n    \n    for(int i=0;i<lr.size();i++){\n    \n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\n\n    }\n\n    return mp.size();\n    \n    }\n}\n\n/**\n * Your AuthenticationManager object will be instantiated and called as such:\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\n * obj.generate(tokenId,currentTime);\n * obj.renew(tokenId,currentTime);\n * int param_3 = obj.countUnexpiredTokens(currentTime);\n */",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass AuthenticationManager {\\n\\n    int time=0;\\n\\n    HashMap<String,Integer>mp=new HashMap<>();\\n\\n    public AuthenticationManager(int timeToLive) {\\n        \\n    time=timeToLive;\\n\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        \\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n    if(!mp.containsKey(tokenId)||mp.get(tokenId)<=currentTime)\\n    {\\n    return;\\n    }\\n\\n    mp.put(tokenId,currentTime+time);\\n\\n    }\\n    \\n    public int countUnexpiredTokens(int currentTime) {\\n    \\n    List<String>lr=new ArrayList<>(mp.keySet());\\n    \\n    for(int i=0;i<lr.size();i++){\\n    \\n    if(mp.get(lr.get(i))<=currentTime)mp.remove(lr.get(i));\\n\\n    }\\n\\n    return mp.size();\\n    \\n    }\\n}\\n\\n/**\\n * Your AuthenticationManager object will be instantiated and called as such:\\n * AuthenticationManager obj = new AuthenticationManager(timeToLive);\\n * obj.generate(tokenId,currentTime);\\n * obj.renew(tokenId,currentTime);\\n * int param_3 = obj.countUnexpiredTokens(currentTime);\\n */\\n```"
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "tags": "java",
        "release_time": 1677159545,
        "code": "class Solution {\n    public int countKDifference(int[] nums, int k) {\n       int ans = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    ans++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countKDifference(int[] nums, int k) {\\n       int ans = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i + 1; j < nums.length; j++) {\\n                if (Math.abs(nums[i] - nums[j]) == k) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nplease upvote, if u like this solution!"
    },
    {
        "slug": "reverse-nodes-in-even-length-groups",
        "tags": "java",
        "release_time": 1675553997,
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseEvenLengthGroups(ListNode head) {\n        if(head == null) return head;\n\n        int groupSize = 1;\n        int count = 0;\n        ListNode left = null;\n        ListNode ptr = head;\n        ListNode last = null;\n        \n        while(ptr != null) {\n            count++;\n            if(count == groupSize) {\n                if(groupSize  % 2 == 0) {\n                    ListNode end = ptr.next;\n                   // reverse\n                    ListNode cur = left;\n                    ListNode next = null;\n                    ListNode prev = ptr.next;\n                    while(cur != end) {\n                        next = cur.next;\n                        cur.next = prev;\n                        prev = cur;\n                        cur = next;\n                    }\n                    // connect\n                    last.next = prev;\n                    ptr = left;\n                   \n                }\n                last = ptr;\n                left = ptr.next;\n                count = 0;\n                groupSize++;\n            }\n            ptr = ptr.next;\n        }\n\n        if(count > 0 && count % 2 == 0) {\n            // reverse\n            ListNode cur = left;\n            ListNode next = null;\n            ListNode prev = ptr;\n\n            while(cur != null) {\n                next = cur.next;\n                cur.next = prev;\n                prev = cur;\n                cur = next;\n            }\n\n            last.next = prev;\n        }\n\n        return head;\n    }\n\n}",
        "content": "# Approach\\nUse sliding window idea by keeping track of last node (of previous group), left node (of current group), pointer node (traverse list), groupSize, count of nodes in current group.\\n\\nOnce you start iterating, you will have to reverse current group if it meets the 2 conditions.\\n1. Count == groupSize\\n2. groupSize is even\\n\\nYou reverse and connect the reversed list back to your main list. Then you must update your iteration pointer since it will be in the back of the reversed list.\\n\\nAlso update last seen node (of previous group), new left node, count, and groupsize.\\n\\nDo the same reverse for the remaining nodes.\\n\\n# Complexity\\n- Time complexity:\\nO(N): One iteration of list is done.\\n\\n- Space complexity:\\nO(1): Constant # of variables/pointers\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode reverseEvenLengthGroups(ListNode head) {\\n        if(head == null) return head;\\n\\n        int groupSize = 1;\\n        int count = 0;\\n        ListNode left = null;\\n        ListNode ptr = head;\\n        ListNode last = null;\\n        \\n        while(ptr != null) {\\n            count++;\\n            if(count == groupSize) {\\n                if(groupSize  % 2 == 0) {\\n                    ListNode end = ptr.next;\\n                   // reverse\\n                    ListNode cur = left;\\n                    ListNode next = null;\\n                    ListNode prev = ptr.next;\\n                    while(cur != end) {\\n                        next = cur.next;\\n                        cur.next = prev;\\n                        prev = cur;\\n                        cur = next;\\n                    }\\n                    // connect\\n                    last.next = prev;\\n                    ptr = left;\\n                   \\n                }\\n                last = ptr;\\n                left = ptr.next;\\n                count = 0;\\n                groupSize++;\\n            }\\n            ptr = ptr.next;\\n        }\\n\\n        if(count > 0 && count % 2 == 0) {\\n            // reverse\\n            ListNode cur = left;\\n            ListNode next = null;\\n            ListNode prev = ptr;\\n\\n            while(cur != null) {\\n                next = cur.next;\\n                cur.next = prev;\\n                prev = cur;\\n                cur = next;\\n            }\\n\\n            last.next = prev;\\n        }\\n\\n        return head;\\n    }\\n\\n}\\n```"
    },
    {
        "slug": "number-of-atoms",
        "tags": "java",
        "release_time": 1601928748,
        "code": "class Solution {\n    Map<String, Integer> res = new TreeMap<>();\n    Stack<Integer> stack = new Stack<>();\n    int multiplier = 1;\n    \n    public String countOfAtoms(String formula) {\n        int end = formula.length() - 1, i = formula.length() - 1;\n        \n        while (i >= 0) {\n            if (formula.charAt(i) == '(') {\n                multiplier /= stack.pop();\n                i--;\n                continue;\n            }\n            \n            end = i;\n            int val = 1;\n            \n            if (Character.isDigit(formula.charAt(i))) {\n                while (Character.isDigit(formula.charAt(i))) i--;\n                val = Integer.parseInt(formula.substring(i+1, end+1));\n            } \n            stack.push(val);\n            multiplier *= val;\n            \n            end = i;\n            if (Character.isLetter(formula.charAt(i))) {\n                while(Character.isLowerCase(formula.charAt(i))) i--;\n                updateMap(formula.substring(i, end+1));\n            }\n            i--;\n        }\n        \n        StringBuilder rs = new StringBuilder();\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\n            rs.append(entry.getKey());\n            if (entry.getValue() > 1) rs.append(entry.getValue());\n        }\n        return rs.toString();\n    }\n    \n    private void updateMap(String key) {\n        if (res.get(key) == null) {\n            res.put(key, multiplier);\n        } else {\n            res.put(key, multiplier + res.get(key));\n        }\n\n        multiplier /= stack.pop();\n    }\n}",
        "content": "We essentially start from the back. Each time we encounter a number we add it to the stack. We can clearly see that going backwards, a number will always be preceeded by either `)` or `element`. So in the same loop we first parse the number followed by the element/bracket. If a number is not seen, we take the default 1 as the number.\\n\\nWe maintain the stack with the multipliers encountered and keep a `multiplier` variable to store the product. Upon poping the stack, we divide by this popped number.\\n\\nEverytime we encounter a `(`, we pop the stack. We again pop the stack after each element is processed.\\n\\nWe also use StringBuilder to optimize.\\n```\\nclass Solution {\\n    Map<String, Integer> res = new TreeMap<>();\\n    Stack<Integer> stack = new Stack<>();\\n    int multiplier = 1;\\n    \\n    public String countOfAtoms(String formula) {\\n        int end = formula.length() - 1, i = formula.length() - 1;\\n        \\n        while (i >= 0) {\\n            if (formula.charAt(i) == \\'(\\') {\\n                multiplier /= stack.pop();\\n                i--;\\n                continue;\\n            }\\n            \\n            end = i;\\n            int val = 1;\\n            \\n            if (Character.isDigit(formula.charAt(i))) {\\n                while (Character.isDigit(formula.charAt(i))) i--;\\n                val = Integer.parseInt(formula.substring(i+1, end+1));\\n            } \\n            stack.push(val);\\n            multiplier *= val;\\n            \\n            end = i;\\n            if (Character.isLetter(formula.charAt(i))) {\\n                while(Character.isLowerCase(formula.charAt(i))) i--;\\n                updateMap(formula.substring(i, end+1));\\n            }\\n            i--;\\n        }\\n        \\n        StringBuilder rs = new StringBuilder();\\n        for (Map.Entry<String, Integer> entry : res.entrySet()) {\\n            rs.append(entry.getKey());\\n            if (entry.getValue() > 1) rs.append(entry.getValue());\\n        }\\n        return rs.toString();\\n    }\\n    \\n    private void updateMap(String key) {\\n        if (res.get(key) == null) {\\n            res.put(key, multiplier);\\n        } else {\\n            res.put(key, multiplier + res.get(key));\\n        }\\n\\n        multiplier /= stack.pop();\\n    }\\n}\\n```"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "tags": "java",
        "release_time": 1669374075,
        "code": "class Solution {\n    public int largestInteger(int num) {\n        String numString = \"\"+ num;\n        List<Integer> even = new ArrayList<>();\n        List<Integer> odd = new ArrayList<>();\n        for(Character c : numString.toCharArray()){\n            int n = Character.getNumericValue(c);\n            if(n%2==0){\n                even.add(n);\n            }else{\n                odd.add(n);\n            }\n        }\n        Collections.sort(even, Collections.reverseOrder());\n        Collections.sort(odd, Collections.reverseOrder());\n        String res =\"\";\n        int one=0, two=0;\n        for(int i=0; i<numString.length(); i++){\n            int n = Character.getNumericValue(numString.charAt(i));\n            if(n%2==0){\n                res += even.get(one);\n                one++;\n            }else{\n                res += odd.get(two);\n                two++;\n            }\n        }\n        return Integer.parseInt(res);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nused string and list to store the even and odd elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconverted num in string then added all values from string to even and odd list as per its type;\\nthen sorted both string in desc order\\nas we check from the original string if got even number we will put max even number from even list and incresed even list pointer same for the odd number\\n\\nConverted result string to integer to get int res and returned it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestInteger(int num) {\\n        String numString = \"\"+ num;\\n        List<Integer> even = new ArrayList<>();\\n        List<Integer> odd = new ArrayList<>();\\n        for(Character c : numString.toCharArray()){\\n            int n = Character.getNumericValue(c);\\n            if(n%2==0){\\n                even.add(n);\\n            }else{\\n                odd.add(n);\\n            }\\n        }\\n        Collections.sort(even, Collections.reverseOrder());\\n        Collections.sort(odd, Collections.reverseOrder());\\n        String res =\"\";\\n        int one=0, two=0;\\n        for(int i=0; i<numString.length(); i++){\\n            int n = Character.getNumericValue(numString.charAt(i));\\n            if(n%2==0){\\n                res += even.get(one);\\n                one++;\\n            }else{\\n                res += odd.get(two);\\n                two++;\\n            }\\n        }\\n        return Integer.parseInt(res);\\n    }\\n}\\n```"
    },
    {
        "slug": "sum-of-total-strength-of-wizards",
        "tags": "java",
        "release_time": 1655300329,
        "code": "class Solution {\n    public int totalStrength(int[] strength) {\n        int mod = 1000000007;\n        \n        int len = strength.length;\n        \n        long[] prefix = prefixSum(strength, len, mod);\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n\n        long ans = 0;\n        for(int i = 0; i < len; i++) {\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\n                int mid = stack.pop();\n                int left = stack.peek() + 1;\n                int right = i - 1;\n                \n                int n = (mid - left);\n                int t = (right - mid);\n                \n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n                val *= strength[mid];\n                \n                ans += val;\n                ans %= mod;\n            }\n            \n            stack.push(i);\n        }\n        \n        int right = len - 1;\n        while(stack.peek() != -1) {\n            int mid = stack.pop();\n            int left = stack.peek() + 1;\n            \n            int n = (mid - left);\n            int t = (right - mid);\n\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\n            val *= strength[mid];\n\n            ans += val;\n            ans %= mod;\n        }\n        \n        return (int)((ans + mod) % mod);\n    }\n    \n    private long[] prefixSum(int[] strength, int len, int mod) {\n        long[] prefix = new long[len + 1];\n        \n        for(int i = 0; i < len; i++) {\n            prefix[i + 1] = prefix[i] + strength[i];\n        }\n        \n        long[] doublePrefix = new long[len + 2];\n        for(int i = 0; i <= len; i++) {\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\n        }\n\n        return doublePrefix;\n    }\n}",
        "content": "I could not figure out `o(n)` approach on my own. \\nI needed to read at least 3 solution by really brilliant people (top voted) to understand the approach.\\nThen I had to do the math on pen-paper 3 times (made mistake 2 time) to actually understand the approach.\\nThen when I actually started coding, I made some some silly mistakes around Stack boundry and \\nthe cherry on top was that you need to do `+ mod) % mod` at almost every place you are doing any calculation.\\n\\nOverall, very good learning experience but I really pity the ones who actually face this in interview.\\n\\nRun time complexity: `4 * O(n)` =  `O(n)` \\nSpace compexity: `O(n)`\\n\\nMy java solution -\\n```\\nclass Solution {\\n    public int totalStrength(int[] strength) {\\n        int mod = 1000000007;\\n        \\n        int len = strength.length;\\n        \\n        long[] prefix = prefixSum(strength, len, mod);\\n        \\n        Deque<Integer> stack = new ArrayDeque<>();\\n        stack.push(-1);\\n\\n        long ans = 0;\\n        for(int i = 0; i < len; i++) {\\n            while(stack.peek() != -1 && strength[i] <= strength[stack.peek()]) {\\n                int mid = stack.pop();\\n                int left = stack.peek() + 1;\\n                int right = i - 1;\\n                \\n                int n = (mid - left);\\n                int t = (right - mid);\\n                \\n                long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n                val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n                val *= strength[mid];\\n                \\n                ans += val;\\n                ans %= mod;\\n            }\\n            \\n            stack.push(i);\\n        }\\n        \\n        int right = len - 1;\\n        while(stack.peek() != -1) {\\n            int mid = stack.pop();\\n            int left = stack.peek() + 1;\\n            \\n            int n = (mid - left);\\n            int t = (right - mid);\\n\\n            long val = (1l * (1 + n) * (prefix[right + 2] - prefix[mid + 1]) + mod) % mod;\\n            val -= (1l * (1 + t) * (prefix[mid + 1] - prefix[left]) + mod) % mod;\\n            val *= strength[mid];\\n\\n            ans += val;\\n            ans %= mod;\\n        }\\n        \\n        return (int)((ans + mod) % mod);\\n    }\\n    \\n    private long[] prefixSum(int[] strength, int len, int mod) {\\n        long[] prefix = new long[len + 1];\\n        \\n        for(int i = 0; i < len; i++) {\\n            prefix[i + 1] = prefix[i] + strength[i];\\n        }\\n        \\n        long[] doublePrefix = new long[len + 2];\\n        for(int i = 0; i <= len; i++) {\\n            doublePrefix[i + 1] = (doublePrefix[i] + prefix[i]) % mod;\\n        }\\n\\n        return doublePrefix;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-score-triangulation-of-polygon",
        "tags": "java",
        "release_time": 1682753898,
        "code": "class Solution {\n    int[][] dp;\n    public int minScoreTriangulation(int[] values) {\n        int l=values.length;\n        dp = new int[l][l];\n        for(int[] i : dp) Arrays.fill(i,-1);\n        return solve(values,1,l-1); \n    }\n\n    public int solve(int[] values, int i,int j)\n    {\n        if(i>=j) return 0;\n        if(dp[i][j]!=-1) return dp[i][j];\n        int min=Integer.MAX_VALUE;\n        for(int k=i;k<j;k++)\n        {\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\n                        values[i-1]*values[k]*values[j];\n            min=Math.min(min,temp);\n        }\n\n        return dp[i][j]=min;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity: n^2\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n^2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int[][] dp;\\n    public int minScoreTriangulation(int[] values) {\\n        int l=values.length;\\n        dp = new int[l][l];\\n        for(int[] i : dp) Arrays.fill(i,-1);\\n        return solve(values,1,l-1); \\n    }\\n\\n    public int solve(int[] values, int i,int j)\\n    {\\n        if(i>=j) return 0;\\n        if(dp[i][j]!=-1) return dp[i][j];\\n        int min=Integer.MAX_VALUE;\\n        for(int k=i;k<j;k++)\\n        {\\n            int temp=solve(values,i,k)+solve(values,k+1,j)+\\n                        values[i-1]*values[k]*values[j];\\n            min=Math.min(min,temp);\\n        }\\n\\n        return dp[i][j]=min;\\n    }\\n}\\n```"
    },
    {
        "slug": "max-sum-of-rectangle-no-larger-than-k",
        "tags": "java",
        "release_time": 1661575112,
        "code": "//Kadane's Algorithm Approach\n//600ms+  explained in video\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int result = Integer.MIN_VALUE;\n        \n        for(int left =0 ;left<matrix[0].length; left++){\n            \n            int[] rSum = new int[matrix.length];\n            \n            for(int right = left;right<matrix[0].length;right++){\n                for(int row=0; row < matrix.length; row++)\n                    rSum[row] += matrix[row][right];\n\t\t\t\t\t\n\t\t\t\t\t//explanation of these 3 loops starts from 02:00 in Video\n                \n                TreeSet<Integer> set = new TreeSet<>();\n                \n                set.add(0);\n                int cs = 0;\n                \n                for(int a: rSum){\n                    cs += a;\n\t\t\t\t\t\n                    //if you don't understand what exactly is going on here\n\t\t\t\t\t// then watch the video from 12:27\n\t\t\t\t\t\n                    Integer target = set.ceiling(cs-k);\n                    \n                    if(target !=null)\n                        result = Math.max(result,cs-target);\n                    set.add(cs);\n                }\n            }\n        }\n        return result;\n    }\n}",
        "content": "*Please **Upvote** if you find this explanation helpful*\\n\\n**Video Explanation**\\n[Max Sum of Rectangle No Larger Than K | YouTube](https://www.youtube.com/watch?v=rztZyG5kpvM&feature=youtu.be)\\n\\n**Java Solution**\\n\\n```\\n//Kadane\\'s Algorithm Approach\\n//600ms+  explained in video\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        int result = Integer.MIN_VALUE;\\n        \\n        for(int left =0 ;left<matrix[0].length; left++){\\n            \\n            int[] rSum = new int[matrix.length];\\n            \\n            for(int right = left;right<matrix[0].length;right++){\\n                for(int row=0; row < matrix.length; row++)\\n                    rSum[row] += matrix[row][right];\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//explanation of these 3 loops starts from 02:00 in Video\\n                \\n                TreeSet<Integer> set = new TreeSet<>();\\n                \\n                set.add(0);\\n                int cs = 0;\\n                \\n                for(int a: rSum){\\n                    cs += a;\\n\\t\\t\\t\\t\\t\\n                    //if you don\\'t understand what exactly is going on here\\n\\t\\t\\t\\t\\t// then watch the video from 12:27\\n\\t\\t\\t\\t\\t\\n                    Integer target = set.ceiling(cs-k);\\n                    \\n                    if(target !=null)\\n                        result = Math.max(result,cs-target);\\n                    set.add(cs);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n**Faster Approach**\\n```\\n//32ms - faster than 100%\\n\\nclass Solution {\\n    public int maxSumSubmatrix(int[][] matrix, int k) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (i > 0) {\\n                    matrix[i][j] += matrix[i - 1][j];\\n                }\\n                if (j > 0) {\\n                    matrix[i][j] += matrix[i][j - 1];\\n                }\\n                if (i > 0 && j > 0) {\\n                    matrix[i][j] -= matrix[i - 1][j - 1];\\n                }\\n            }\\n        }\\n        int result = Integer.MIN_VALUE;\\n        \\n        int[][] dpHigh = new int[matrix.length][matrix.length + 1];\\n        int[][] dpLow = new int[matrix.length][matrix.length + 1];\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int h = 1; h <= matrix.length - i; h++) {\\n                int theValue = getSum(matrix, i, matrix[0].length - 1, h, 1);\\n                dpLow[i][h] = theValue;\\n                dpHigh[i][h] = theValue;\\n                if (theValue == k) {\\n                    return theValue;\\n                }\\n                if (theValue < k) {\\n                    result = Math.max(result, theValue);\\n                }\\n            }\\n        }\\n        \\n        for (int i = matrix.length - 1; i >= 0; i--) {\\n            for (int j = matrix[0].length - 2; j >= 0; j--) {\\n                for (int h = 1; h <= matrix.length - i; h++) {\\n                    int newSum = getSum(matrix, i, j, h, 1);\\n                    if (dpLow[i][h] > 0) {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] = newSum;\\n                    } else if (dpHigh[i][h] < 0) {\\n                        dpLow[i][h] += newSum;\\n                        dpHigh[i][h] = newSum;\\n                    } else {\\n                        dpHigh[i][h] += newSum;\\n                        dpLow[i][h] += newSum;\\n                    }\\n                    if (dpHigh[i][h] >= result && dpLow[i][h] <= k) {\\n                        for (int w = 1; w <= matrix[0].length - j; w++) {\\n                            int sum = getSum(matrix, i, j, h, w);\\n                            if (sum == k) {\\n                                return sum;\\n                            } else if (sum < k) {\\n                                result = Math.max(result, sum);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int getSum(int[][] matrix, int i, int j, int h, int w) {\\n        int sum = matrix[i + h - 1][j + w - 1];\\n        if (i > 0) {\\n            sum -= matrix[i - 1][j + w - 1];\\n        }\\n        if (j > 0) {\\n            sum -= matrix[i + h - 1][j - 1];\\n        }\\n        if (i > 0 && j > 0) {\\n            sum += matrix[i - 1][j - 1];\\n        }\\n        return sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "tags": "java",
        "release_time": 1678770695,
        "code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for(int i=0;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=0;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        queue = new PriorityQueue<>(new MaxHeap());\n        for(int i=1;i<nums.length;i+=2){\n            queue.add(nums[i]);\n        }\n        for(int i=1;i<nums.length;i+=2){\n            nums[i]=queue.poll();\n        }\n        return nums;\n    }\n}\nclass MaxHeap implements Comparator<Integer>{\n    public int compare(Integer ca,Integer cb){\n        return cb-ca;\n    }\n}",
        "content": "\\n> # Approach\\nLet\\'s use some data structutes to solve this problem,By adding even indexed numbers into MinHeap we can sort the data in ascending order,By adding odd indexed numbers into Maxheap we can sort the data in descending order. \\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(n log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) for Priority Queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\\n        for(int i=0;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=0;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        queue = new PriorityQueue<>(new MaxHeap());\\n        for(int i=1;i<nums.length;i+=2){\\n            queue.add(nums[i]);\\n        }\\n        for(int i=1;i<nums.length;i+=2){\\n            nums[i]=queue.poll();\\n        }\\n        return nums;\\n    }\\n}\\nclass MaxHeap implements Comparator<Integer>{\\n    public int compare(Integer ca,Integer cb){\\n        return cb-ca;\\n    }\\n}\\n```"
    },
    {
        "slug": "prime-in-diagonal",
        "tags": "java",
        "release_time": 1683757802,
        "code": "class Solution {\n    public int diagonalPrime(int[][] nums) {\n        int n = nums.length;\n        int m = nums[0].length;\n        int maxim = 0;\n        for (int i = 0; i < n; i++) {\n                if (checkPrime(nums[i][i])) {\n                    maxim = Math.max(maxim, nums[i][i]);\n                } \n                if (checkPrime(nums[n-1-i][i])) {\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\n\n                }\n            \n        }\n        return maxim;\n    }\n    public boolean checkPrime(int k) {\n\n        int count = 0;\n        if (k == 1) {\n            return false;\n        }\n        for (int i = 1; i * i <= k; i++) {\n          if (k % i == 0) {\n              count += 2;\n          }\n      }\n      if (count == 2) {\n          return true; \n      } else {\n          return false;\n      }\n      \n    }\n\n}",
        "content": "**Must read if there is any doubt feel free to ask in comments**\\n\\nSomehow beginners face difficulty to understand the concept at first, but i will try my best to breakdown the question into simpler parts so that there would be ease to understand for beginners.\\n\\n\\n\\n**first we have to check prime number on the diagnol of the matrix.**\\n\\n**Step 1** -> so we make a function to check wether the given number is prime or not\\n\\n**Note** -> there are several functions to checkPrime as a naive/beginner you apply what you have learnt in fundamentals programming but it would not work\\n\\nBut here we have to create a checkPrime no. function that would be  optimized otherwise you will get **TLE** which is **Time Limit Exceeded** error.\\n\\n\\nTo find a prime number what we do firstly? -> find factors\\n\\ne.g\\n Num - > 12\\nfactors -> \\n\\n    **i** -------- **k**\\n    1 * 12 = 12\\n    2 * 6 = 12\\n    3 * 4 = 12\\n    4 * 3 = 12\\n    6 * 2 = 12\\n    12 * 1 = 12\\n\\nwe have total 6 factors \\n\\n**Trivial method: TLE occurs for this coz it isn\\'t optimized.**\\n\\nint count = 0;\\nif (k < 2) {\\n    return false;\\n}\\nfor (int i = 1; i < k; i++) {\\n    if (k % i == 0) {\\n        count++;        \\n    }\\n}\\nif (count == 2) {\\n    return true;\\n} else {\\n    return false;\\n}\\n\\nNow what if I say we do not need to iterate till k if we focus on the pattern we see that after i = 3 same numbers are repeating such as (4,3) despite (3,4) was there already , similarly (6,2) despite (2,6) is there etc...\\n\\nnow what we do is we would iterate our loop from **i to \\u221Ak** or we can write it as **i * i to k** also **so that our i iterate in the range between [1 - 3] so we have to take the square root of k. \\ni.e \\n1 * 12, 2 * 6, 3 * 4 and we get all the 6 factors till i = 3.**\\n\\n\\ne.g\\n Num - > 12\\nfactors -> 1, 2, 3, 4, 6, 12\\n**i ------- k**\\n1 * 12 = 12\\n2 * 6 = 12\\n3 * 4 = 12\\n\\n 4 * 3 = 12\\n 6 * 2 = 12\\n12 * 1 = 12\\n\\nfor (int i = 1; i * i <= k; i++) {\\n    if (k < 2) {\\n    return false;\\n    }\\n    if (k % i == 0) {\\n        count +=2; \\n//count + 2 because 1 * 12 we grab two factors from herethen why we need to go till 12.\\n\\n}\\nif (count == 2) {\\nreturn true\\n} else {\\nreturn false;\\n}\\n}\\n\\n**Now we have converted our problem in \\u221An time complexity.**\\n\\n\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int diagonalPrime(int[][] nums) {\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        int maxim = 0;\\n        for (int i = 0; i < n; i++) {\\n                if (checkPrime(nums[i][i])) {\\n                    maxim = Math.max(maxim, nums[i][i]);\\n                } \\n                if (checkPrime(nums[n-1-i][i])) {\\n                    maxim = Math.max(maxim, nums[n - i - 1][i]);\\n\\n                }\\n            \\n        }\\n        return maxim;\\n    }\\n    public boolean checkPrime(int k) {\\n\\n        int count = 0;\\n        if (k == 1) {\\n            return false;\\n        }\\n        for (int i = 1; i * i <= k; i++) {\\n          if (k % i == 0) {\\n              count += 2;\\n          }\\n      }\\n      if (count == 2) {\\n          return true; \\n      } else {\\n          return false;\\n      }\\n      \\n    }\\n\\n}\\n```"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "tags": "java",
        "release_time": 1684037017,
        "code": "class Solution {\n    public boolean doesValidArrayExist(int[] de) {\n        int ans=0;\n        for(int a:de){\n            if(a==1)\n                ans++;\n        }\n        return (ans%2==0);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean doesValidArrayExist(int[] de) {\\n        int ans=0;\\n        for(int a:de){\\n            if(a==1)\\n                ans++;\\n        }\\n        return (ans%2==0);\\n    }\\n}\\n```"
    },
    {
        "slug": "stamping-the-grid",
        "tags": "java",
        "release_time": 1641658225,
        "code": "public class Solution {\n    private static final int FILLED = 1;\n\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        // fill empty space with negative number, which indicates consecutive number of rows that have been empty\n        int height = grid.length, width = grid[0].length;\n        int[] pre = new int[width];\n        Arrays.fill(pre, 1);\n        for (int r = 0; r < height; r++) {\n            for (int c = 0; c < width; c++) {\n                if (grid[r][c] != FILLED) {\n                    grid[r][c] = pre[c] == 1 ? -1: Math.max(pre[c] - 1, -stampHeight);\n                }\n            }\n            pre = grid[r];\n        }\n\n        // scan each height, and once we find consecutive `grid` of `-stampHeight` of length `stampWidth` or longer,\n        // replace the `grid` value with `FILLED`\n        for (int r = stampHeight - 1; r < height; r++) {\n            int cnt = 0;\n            for (int c = 0; c < width; c++) {\n                if (grid[r][c] == -stampHeight) cnt++;\n                else cnt = 0;\n                if (cnt == stampWidth) fill(grid, r, c, stampHeight, stampWidth);\n                if (cnt > stampWidth) fill(grid, r, c, stampHeight, 1);\n                // width set to 1 for performance; the previous width 0 - cnt would have been already filled\n            }\n        }\n\n        // check if there is remaining cell of value that is not `FILLED`\n        for (int[] ints : grid) {\n            for (int v: ints) {\n                if (v != FILLED) return false;\n            }\n        }\n        return true;\n    }\n\n    private void fill(int[][] grid, int r, int c, int height, int width) {\n        for (int i = c - width + 1; i <= c; i++) {\n            int j = r;\n            while (j >= r - height + 1 && grid[j][i] != FILLED)\n                grid[j--][i] = FILLED;\n        }\n    }\n}",
        "content": "I recorded consecutive empty rows, filled all fillable spots by 1, and then confirmed if everything is filled\\nPlease see the comments for more detailed explanation\\n\\nGiven grid of size `m` x `n`\\nTime Complexity O(mn)\\nMemory O(n) since we use the existing grid // need pre = O(n)\\n\\n```\\npublic class Solution {\\n    private static final int FILLED = 1;\\n\\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\\n        // fill empty space with negative number, which indicates consecutive number of rows that have been empty\\n        int height = grid.length, width = grid[0].length;\\n        int[] pre = new int[width];\\n        Arrays.fill(pre, 1);\\n        for (int r = 0; r < height; r++) {\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] != FILLED) {\\n                    grid[r][c] = pre[c] == 1 ? -1: Math.max(pre[c] - 1, -stampHeight);\\n                }\\n            }\\n            pre = grid[r];\\n        }\\n\\n        // scan each height, and once we find consecutive `grid` of `-stampHeight` of length `stampWidth` or longer,\\n        // replace the `grid` value with `FILLED`\\n        for (int r = stampHeight - 1; r < height; r++) {\\n            int cnt = 0;\\n            for (int c = 0; c < width; c++) {\\n                if (grid[r][c] == -stampHeight) cnt++;\\n                else cnt = 0;\\n                if (cnt == stampWidth) fill(grid, r, c, stampHeight, stampWidth);\\n                if (cnt > stampWidth) fill(grid, r, c, stampHeight, 1);\\n                // width set to 1 for performance; the previous width 0 - cnt would have been already filled\\n            }\\n        }\\n\\n        // check if there is remaining cell of value that is not `FILLED`\\n        for (int[] ints : grid) {\\n            for (int v: ints) {\\n                if (v != FILLED) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    private void fill(int[][] grid, int r, int c, int height, int width) {\\n        for (int i = c - width + 1; i <= c; i++) {\\n            int j = r;\\n            while (j >= r - height + 1 && grid[j][i] != FILLED)\\n                grid[j--][i] = FILLED;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "count-items-matching-a-rule",
        "tags": "java",
        "release_time": 1691915583,
        "code": "class Solution {\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\n        int count = 0;  // Initialize a counter to keep track of matching items.\n\n        String type = \"type\";  // Define the string constants for different ruleKeys.\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\n\n        // Check the value of ruleKey and set the index (i) accordingly.\n        if (ruleKey.equals(type)) {\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\n        }\n        String color = \"color\";\n        if (ruleKey.equals(color)) {\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\n        }\n        String name = \"name\";\n        if (ruleKey.equals(name)) {\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\n        }\n\n        // Iterate through each item in the items list.\n        for (int j = 0; j < items.size(); j++) {\n            // Check if the property at index i of the current item matches ruleValue.\n            if (items.get(j).get(i).equals(ruleValue)) {\n                count++;  // If there's a match, increment the count.\n            }\n        }\n        \n        return count;  // Return the final count of items that match the rule.\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/3afc1634-9bf6-4067-ad26-d7bbca6fc1fd_1691915490.7061198.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countMatches(List<List<String>> items, String ruleKey, String ruleValue) {\\n        int count = 0;  // Initialize a counter to keep track of matching items.\\n\\n        String type = \"type\";  // Define the string constants for different ruleKeys.\\n        int i = 0;  // Initialize the index variable to access the correct property of the items.\\n\\n        // Check the value of ruleKey and set the index (i) accordingly.\\n        if (ruleKey.equals(type)) {\\n            i = 0;  // If ruleKey is \"type\", set index to 0 (type property).\\n        }\\n        String color = \"color\";\\n        if (ruleKey.equals(color)) {\\n            i = 1;  // If ruleKey is \"color\", set index to 1 (color property).\\n        }\\n        String name = \"name\";\\n        if (ruleKey.equals(name)) {\\n            i = 2;  // If ruleKey is \"name\", set index to 2 (name property).\\n        }\\n\\n        // Iterate through each item in the items list.\\n        for (int j = 0; j < items.size(); j++) {\\n            // Check if the property at index i of the current item matches ruleValue.\\n            if (items.get(j).get(i).equals(ruleValue)) {\\n                count++;  // If there\\'s a match, increment the count.\\n            }\\n        }\\n        \\n        return count;  // Return the final count of items that match the rule.\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "second-minimum-node-in-a-binary-tree",
        "tags": "java",
        "release_time": 1677899029,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int min=-1;\n    int secondMin=Integer.MAX_VALUE;\n    boolean flag=false;\n    public int findSecondMinimumValue(TreeNode root) {\n        if(root == null)return secondMin;\n        min =root.val;\n        help(root);\n        if(!flag){return -1;}\n        return secondMin;\n    }\n    public void help(TreeNode root){\n        if(root == null)return;\n        if(min< root.val && root.val<= secondMin){\n            secondMin = root.val;\n            flag = true;\n        }\n        help(root.left);\n        help(root.right);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you like my solution please upvote\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int min=-1;\\n    int secondMin=Integer.MAX_VALUE;\\n    boolean flag=false;\\n    public int findSecondMinimumValue(TreeNode root) {\\n        if(root == null)return secondMin;\\n        min =root.val;\\n        help(root);\\n        if(!flag){return -1;}\\n        return secondMin;\\n    }\\n    public void help(TreeNode root){\\n        if(root == null)return;\\n        if(min< root.val && root.val<= secondMin){\\n            secondMin = root.val;\\n            flag = true;\\n        }\\n        help(root.left);\\n        help(root.right);\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "tags": "java",
        "release_time": 1671532567,
        "code": "class Solution {\n    public int numberOfBeams(String[] bank) {\n        int prevLazer =0;\n        int ans =0;\n        for(String s:bank){\n            int curLazer = 0;\n            for(char c: s.toCharArray()){\n                if(c=='1'){\n                    curLazer++;\n                }\n            }\n            if(curLazer >0){\n                ans += (curLazer * prevLazer);\n                prevLazer = curLazer;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# java Code\\n```\\nclass Solution {\\n    public int numberOfBeams(String[] bank) {\\n        int prevLazer =0;\\n        int ans =0;\\n        for(String s:bank){\\n            int curLazer = 0;\\n            for(char c: s.toCharArray()){\\n                if(c==\\'1\\'){\\n                    curLazer++;\\n                }\\n            }\\n            if(curLazer >0){\\n                ans += (curLazer * prevLazer);\\n                prevLazer = curLazer;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-sum-with-exactly-k-elements",
        "tags": "java",
        "release_time": 1682812985,
        "code": "class Solution {\n    public int maximizeSum(int[] nums, int k) {\n        int max = 0;\n        for(int i = 0; i<nums.length; i++){ \n            max = Math.max(max, nums[i]);\n        }\n        \n        int ans = 0;\n        while(k>0){\n            ans+=max;\n            max = max+1;\n            k--;\n        }\n        return ans;\n    }   \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximizeSum(int[] nums, int k) {\\n        int max = 0;\\n        for(int i = 0; i<nums.length; i++){ \\n            max = Math.max(max, nums[i]);\\n        }\\n        \\n        int ans = 0;\\n        while(k>0){\\n            ans+=max;\\n            max = max+1;\\n            k--;\\n        }\\n        return ans;\\n    }   \\n}\\n```"
    },
    {
        "slug": "design-authentication-manager",
        "tags": "java",
        "release_time": 1664458448,
        "code": "class AuthenticationManager {\n\n    int timeToLive;\n    TreeSet<Integer> treeSet;\n    Map<String, Integer> map;\n    public AuthenticationManager(int timeToLive) {\n        this.timeToLive = timeToLive;\n        treeSet = new TreeSet<>();\n        map = new HashMap<>();\n    }\n    \n    public void generate(String tokenId, int currentTime) {\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.add(currentTime + timeToLive);\n    }\n    \n    public void renew(String tokenId, int currentTime) {\n        \n        Integer time = map.get(tokenId);\n\t\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\n        if (time == null || time <= currentTime) return;\n       \n\t   \n\t   // Update the hashmap and treeSet with the new values\n        map.put(tokenId, currentTime + timeToLive);\n        treeSet.remove(time);\n        treeSet.add(currentTime + timeToLive);\n        \n\t\t// Clearing the treeset from already expired timestamps, it doesn't really improve the time execution, with about 10% only.\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\n            treeSet.remove(treeSet.lower(currentTime));\n        }\n    }\n    \n\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\n    public int countUnexpiredTokens(int currentTime) {\n        return treeSet.tailSet(currentTime, false).size();\n    }\n}",
        "content": "The algorithm is pretty straightforward, the idea is to add and renew the keys with the added time to live, so we can keep the expiration value and to use a TreeSet for keeping it in a sorted manner with time complexity of O(Log (n)) for add and remove and O (M Log (n)) (where M is the number of items which will be traversed after the \"midpoint\" is found) for .tailSet().  The HashMap has the only purpose to store the expiration value of each key.\\n\\nThe Algorithm is kind of unstable and has performance between 44%  and 93%.\\n\\n```\\nclass AuthenticationManager {\\n\\n    int timeToLive;\\n    TreeSet<Integer> treeSet;\\n    Map<String, Integer> map;\\n    public AuthenticationManager(int timeToLive) {\\n        this.timeToLive = timeToLive;\\n        treeSet = new TreeSet<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void generate(String tokenId, int currentTime) {\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.add(currentTime + timeToLive);\\n    }\\n    \\n    public void renew(String tokenId, int currentTime) {\\n        \\n        Integer time = map.get(tokenId);\\n\\t\\t// If null the token was never added, or it has expired before the renew call, which makes it invalid for renewing\\n        if (time == null || time <= currentTime) return;\\n       \\n\\t   \\n\\t   // Update the hashmap and treeSet with the new values\\n        map.put(tokenId, currentTime + timeToLive);\\n        treeSet.remove(time);\\n        treeSet.add(currentTime + timeToLive);\\n        \\n\\t\\t// Clearing the treeset from already expired timestamps, it doesn\\'t really improve the time execution, with about 10% only.\\n        while (!treeSet.isEmpty() && treeSet.lower(currentTime) != null) {\\n            treeSet.remove(treeSet.lower(currentTime));\\n        }\\n    }\\n    \\n\\t// Return the number of timestamps in the treeset, which have greated expiry time than the currentTime\\n    public int countUnexpiredTokens(int currentTime) {\\n        return treeSet.tailSet(currentTime, false).size();\\n    }\\n}\\n```"
    },
    {
        "slug": "row-with-maximum-ones",
        "tags": "java",
        "release_time": 1684493016,
        "code": "class Solution {\n    public int[] rowAndMaximumOnes(int[][] mat) {\n        int count;\n        int maxCount = 0;\n        int maxCountRow = 0;\n        for(int i = 0; i < mat.length; i++) {\n            count = 0;\n            for(int j = 0; j < mat[0].length; j++) {\n                count += mat[i][j];\n            }\n            if(count > maxCount) {\n                maxCount = count;\n                maxCountRow = i;\n            }\n        }\n        return new int[]{maxCountRow, maxCount};\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```"
    },
    {
        "slug": "split-with-minimum-sum",
        "tags": "java",
        "release_time": 1678086107,
        "code": "class Solution {\n    public int splitNum(int num) {\n        int []ans=new int[10];\n        while(num>0){\n            ans[num%10]++;\n            num/=10;\n        }\n        \n        int num1=0;\n        int num2=0;\n        \n        for(int i=0;i<10;i++){\n            for(int j=0;j<ans[i];j++){\n                if(num1<=num2){\n                    num1=num1*10+i;\n                }\n                else{\n                    num2=num2*10+i;\n                }\n            }\n        }\n        return num1+num2;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int splitNum(int num) {\\n        int []ans=new int[10];\\n        while(num>0){\\n            ans[num%10]++;\\n            num/=10;\\n        }\\n        \\n        int num1=0;\\n        int num2=0;\\n        \\n        for(int i=0;i<10;i++){\\n            for(int j=0;j<ans[i];j++){\\n                if(num1<=num2){\\n                    num1=num1*10+i;\\n                }\\n                else{\\n                    num2=num2*10+i;\\n                }\\n            }\\n        }\\n        return num1+num2;\\n    }\\n}\\n```"
    },
    {
        "slug": "russian-doll-envelopes",
        "tags": "java",
        "release_time": 1653449666,
        "code": "class Solution {\n    public int binarySearch(int[] dp, int val){\n        int lo=0,hi=dp.length-1,res=0;\n        while(lo<=hi){\n            int mid=(lo+hi)/2;\n            if(dp[mid]<val){\n                res=mid;\n                lo=mid+1;\n            }else{\n                hi=mid-1;\n            }\n        }\n        return res+1;\n    }\n    public int maxEnvelopes(int[][] envelopes) {\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\n        int[] LIS=new int[envelopes.length+1];\n        Arrays.fill(LIS,Integer.MAX_VALUE);\n        LIS[0]=Integer.MIN_VALUE;\n        int ans=0;\n        for(int i=0;i<envelopes.length;i++){\n            int val=envelopes[i][1];\n            int insertIndex=binarySearch(LIS,val);\n            ans=Math.max(ans,insertIndex);\n            if(LIS[insertIndex]>=val){\n                LIS[insertIndex]=val;\n            }\n        }\n        return ans;\n    }\n}",
        "content": "**If you like this solution or find it useful, please upvote this post.**\\n<details>\\n\\t<summary>Prerequisite</summary>\\n\\t<br>\\n\\tBefore moving on to the solution, you should know how can we find the length of <strong>Longest Increasing Subsequence</strong> unsing <strong>Binary Search</strong>. You can find the detailed explanation of the logic on the below link.                                        \\n\\t</br>\\n\\t<br></br>\\n\\t<a href=\"https://leetcode.com/problems/longest-increasing-subsequence/discuss/1636162/java-binary-search-stepwise-explanation\">Longest Increasing Subsequence Using Binary Search</a>\\n</details>\\n<br></br>\\n\\n#### Why we need to sort?\\n* In these types of problem when we are dealing with two dimensions, we need to reduce the problem from two-dimensional array into a one-dimensional array in order to improve time complexity. \\n* **\"Sort first when things are undecided\"**, sorting can make the data orderly, reduce the degree of confusion, and often help us to sort out our thinking. the same is true with this question. Now, after doing the correct sorting, we just need to find Longest Increasing Subsequence of that one dimensional array.\\n**Now, you may be wondered what correct sorting actually is?**\\nIt is the sorting which we do to order to achieve the answer. Like, increasing, non-increasing sorting. Without any further discussion, let\\'s dig into Intuition followed by algorithm.\\n\\n##### Algorithm\\n* We sort the array in increasing order of width. And if two widths are same, we need to sort height in decreasing order. \\n* Now why we need to sort in decreasing order if two widths are same. By this practice, we\\'re assuring that no width will get counted more than one time. Let\\'s take an example\\nenvelopes=`[[3, 5], [6, 7], [7, 13], [6, 10], [8, 4], [7, 11]]`\\n![image](https://assets.leetcode.com/users/images/b8e49902-0d0c-477f-a396-2fbc04b4f59b_1643640325.8523316.png)\\nNow, if you see for a while, **6 and 7** is counted twice while we\\'re calculating the length of LIS, which will give the wrong ans. As question is asking, if any width/height are less than or equal, then, it is not possible to russian doll these envelopes. \\nNow, we know the problem. So, how can we tackle these conditions when two width are same, so that it won\\'t affect our answer. We can simple **reverse sort the height if two width are equal, to remove duplicacy.**\\nNow, you may question, how reverse sorting the height would remove duplicacy? As the name itself says, Longest Increasing Subsequnce, the next coming height would be less than the previous one. Hence, forbidding it to increase length count.\\n![image](https://assets.leetcode.com/users/images/31add436-310d-452d-b696-f7faff8ce2f6_1643641876.2816072.png)\\nIf you don\\'t understand how LIS is calculated here, I strongly refer you to follow the prerequisite.\\nNow, we have **sucessfully reduced the problem to LIS!** All you need to apply classical LIS on heights, to calculate the ans. This would be the maximum number of envelopes can be russian doll.\\n\\n**Code**\\n\\n```\\nclass Solution {\\n    public int binarySearch(int[] dp, int val){\\n        int lo=0,hi=dp.length-1,res=0;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(dp[mid]<val){\\n                res=mid;\\n                lo=mid+1;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        return res+1;\\n    }\\n    public int maxEnvelopes(int[][] envelopes) {\\n        Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);\\n        int[] LIS=new int[envelopes.length+1];\\n        Arrays.fill(LIS,Integer.MAX_VALUE);\\n        LIS[0]=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<envelopes.length;i++){\\n            int val=envelopes[i][1];\\n            int insertIndex=binarySearch(LIS,val);\\n            ans=Math.max(ans,insertIndex);\\n            if(LIS[insertIndex]>=val){\\n                LIS[insertIndex]=val;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNow, if you compare the code of this problem with the classical LIS, it is very similar. Infact, we have added only one line to get the maximum Russian Doll.\\n\\n`Arrays.sort(envelopes,(a,b)->a[0]==b[0]?b[1]-a[1]:a[0]-b[0]);`\\n\\nLanguage Used- **JAVA**\\nTime Complexity- **O(nlogn)**\\nSpace Complexity- **O(n)**\\n\\n**Python Solution-**\\n```class Solution:\\n    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:\\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\\n        LIS = []\\n        size = 0\\n        for (w, h) in envelopes:\\n            if not LIS or h > LIS[-1]:\\n                LIS.append(h)\\n                size += 1\\n            else:\\n                l, r = 0, size\\n                while l < r:\\n                    m = l + (r - l) // 2\\n                    if LIS[m] < h:\\n                        l = m + 1\\n                    else:\\n                        r = m\\n                LIS[l] = h\\n        return size\\n```\\nby @bettercoder168\\n\\nC++ Code\\n```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> &a, vector<int> &b){\\n        if(a[0]==b[0]){\\n            return a[1]>b[1];\\n        }\\n        return a[0]<b[0];\\n    }\\n        \\n    int maxEnvelopes(vector<vector<int>>& envelopes) {\\n        sort(envelopes.begin(), envelopes.end(), comp);\\n        int i, j, n=envelopes.size();\\n        vector<int>lis;\\n        \\n        for(i=0; i<n; i++){\\n            auto it = lower_bound(lis.begin(), lis.end(), envelopes[i][1]);\\n            if(it==lis.end()){lis.push_back(envelopes[i][1]);}\\n            else{\\n                *it = envelopes[i][1];\\n            }\\n        }\\n        return lis.size();\\n    }\\n};\\n```\\nby @uttarandas501\\n\\t\\t\\n##### If you like this solution or find it useful, please upvote this post.\\n"
    },
    {
        "slug": "orderly-queue",
        "tags": "java",
        "release_time": 1667735681,
        "code": "class Solution {\n    public String orderlyQueue(String s, int k) {\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\n            char ch[]=s.toCharArray();  \n            Arrays.sort(ch);\n            return String.valueOf(ch);\n        }\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\n             String str2=new String(s);\n             for(int i=0;i<s.length();i++){\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\n                    str2=s;                     //store smaller lexo combo\n                } \n             }\n             return str2;\n        }     \n    }\n}",
        "content": "```\\nclass Solution {\\n    public String orderlyQueue(String s, int k) {\\n        if(k>1){                        //whenver we k>1 we can make the most smallest lexographic combo\\n            char ch[]=s.toCharArray();  \\n            Arrays.sort(ch);\\n            return String.valueOf(ch);\\n        }\\n        else{   //when k=1 we have restriction to move only ine so will see from what index smallest lexo start\\n             String str2=new String(s);\\n             for(int i=0;i<s.length();i++){\\n                s=s.substring(1)+s.charAt(0); // first element is being shifted to last\\n                if(str2.compareTo(s)>0){        //if this lexo combo is smaller than previous\\n                    str2=s;                     //store smaller lexo combo\\n                } \\n             }\\n             return str2;\\n        }     \\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-all-1s-are-at-least-length-k-places-away",
        "tags": "java",
        "release_time": 1666591274,
        "code": "class Solution {\n    public boolean kLengthApart(int[] nums, int k) {\n        int last=-1;\n        for(int i=0;i < nums.length;i++)\n            if(nums[i]==1){\n                if(i-last-1 < k && last != -1)\n                    return false;\n                last=i;\n            }\n        return true;\n    }\n}",
        "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean kLengthApart(int[] nums, int k) {\\n        int last=-1;\\n        for(int i=0;i < nums.length;i++)\\n            if(nums[i]==1){\\n                if(i-last-1 < k && last != -1)\\n                    return false;\\n                last=i;\\n            }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "is-graph-bipartite",
        "tags": "java",
        "release_time": 1684477285,
        "code": "class Solution {\n    public boolean isBipartite(int[][] graph) \n    {\n        int n=graph.length;\n        int [] color = new int[n];\n        for(int i=0;i<n;i++)\n        {\n            if(color[i]!=0)\n            {\n                continue;\n            }\n            Queue<Integer> q = new LinkedList<>();\n            q.add(i);\n            color[i]=1;\n            \n            while(!q.isEmpty())\n                {\n                    int cur=q.peek();\n                    q.remove();\n\n                        for(int x : graph[cur])\n                        {\n                                if(color[x]==0)\n                                {\n                                    color[x]=-color[cur];\n                                    q.add(x);\n                                }\n                                else if(color[x]!=-color[cur])\n                                {\n                                    return false;\n                                }\n                        }\n                }\n        }\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing graph color with 2 colors blue and red. where for blue we will take 1 and for red we will take -1 and 0 for uncolored graph.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple we first going to traverse the graph with help of BFS and color node with 1 and -1. And if we ancounter a node with colored node which is not oposite to our color we will return false as we need to change the color and it is no longer Bipartite graph.\\n# Complexity\\n- Time complexity: \\n1 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n44 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isBipartite(int[][] graph) \\n    {\\n        int n=graph.length;\\n        int [] color = new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(color[i]!=0)\\n            {\\n                continue;\\n            }\\n            Queue<Integer> q = new LinkedList<>();\\n            q.add(i);\\n            color[i]=1;\\n            \\n            while(!q.isEmpty())\\n                {\\n                    int cur=q.peek();\\n                    q.remove();\\n\\n                        for(int x : graph[cur])\\n                        {\\n                                if(color[x]==0)\\n                                {\\n                                    color[x]=-color[cur];\\n                                    q.add(x);\\n                                }\\n                                else if(color[x]!=-color[cur])\\n                                {\\n                                    return false;\\n                                }\\n                        }\\n                }\\n        }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "tags": "java",
        "release_time": 1674641372,
        "code": "class Solution {\n    public int[] char_map;\n    public int countCharacters(String[] words, String chars) {\n        char_map=new int[26];\n       int ans=0;\n       for(char c : chars.toCharArray()){\n           char_map[c-'a']++;\n       }\n\n       for(String word: words){\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\n           int count =0;\n           for(char c: word.toCharArray()){\n               if(dummyArray[c-'a']>0){\n                   count++;\n                   dummyArray[c-'a']--;\n               }\n           }\n           if(count==word.length()){\n               ans+=word.length();\n           }\n       }\n       return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] char_map;\\n    public int countCharacters(String[] words, String chars) {\\n        char_map=new int[26];\\n       int ans=0;\\n       for(char c : chars.toCharArray()){\\n           char_map[c-\\'a\\']++;\\n       }\\n\\n       for(String word: words){\\n           int[] dummyArray = Arrays.copyOf(char_map, char_map.length);\\n           int count =0;\\n           for(char c: word.toCharArray()){\\n               if(dummyArray[c-\\'a\\']>0){\\n                   count++;\\n                   dummyArray[c-\\'a\\']--;\\n               }\\n           }\\n           if(count==word.length()){\\n               ans+=word.length();\\n           }\\n       }\\n       return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "move-zeroes",
        "tags": "java",
        "release_time": 1688630198,
        "code": "class Solution {\n    public void moveZeroes(int[] arr) {\n    int n = arr.length;\n    if(n<=1) return;\n    int s=0;\n    int e=1;\n    while(e<n){\n        if(arr[s]==0 && arr[e]!=0){\n            int temp = arr[s];\n            arr[s] = arr[e];\n            arr[e] = temp;\n            s++;\n            e++;\n        }else if(arr[s]==0 && arr[e]==0){\n            e++;\n        }else{\n            s++;\n            e++;\n        }\n    }\n    }\n}",
        "content": "# Intuition: Keep two pointer start and end at index 0 and 1 and follow three steps:\\n-> If element at start is 0 and end is non zero then swap them and move both pointers.\\n-> If element at both start and end is zero then move end pointer.\\n-> If both are non zeros then just move both pointers ahead till end reaches array length.   \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] arr) {\\n    int n = arr.length;\\n    if(n<=1) return;\\n    int s=0;\\n    int e=1;\\n    while(e<n){\\n        if(arr[s]==0 && arr[e]!=0){\\n            int temp = arr[s];\\n            arr[s] = arr[e];\\n            arr[e] = temp;\\n            s++;\\n            e++;\\n        }else if(arr[s]==0 && arr[e]==0){\\n            e++;\\n        }else{\\n            s++;\\n            e++;\\n        }\\n    }\\n    }\\n}\\n```"
    },
    {
        "slug": "binary-search-tree-iterator",
        "tags": "java",
        "release_time": 1678769853,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    Stack<TreeNode>s=new Stack<TreeNode>();\n    public BSTIterator(TreeNode root) {\n        pushAll(root);\n    }\n    \n    public int next() {\n        TreeNode temp=s.pop();\n        pushAll(temp.right);\n        return temp.val;\n    }\n    \n    public boolean hasNext() {\n        return !s.isEmpty();\n    }\n    public void pushAll(TreeNode node){\n        while(node!=null){\n            s.push(node);\n            node=node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```"
    },
    {
        "slug": "greatest-english-letter-in-upper-and-lower-case",
        "tags": "java",
        "release_time": 1691985955,
        "code": "class Solution {\n    public String greatestLetter(String s) {\n\n        for (int i = 'z'; i >= 'a'; i--) {\n            String lower = Character.toString(i);\n            String upper = Character.toString(i - 32);\n            if (s.contains(lower) && s.contains(upper)) {\n                return upper;\n            }\n        }\n\n        return \"\";\n    }\n}",
        "content": "# Intuition\\nThis solution iterates through the **English letters** in reverse order, starting from **\\'z\\'** and moving down to **\\'a\\'**. For each letter, it checks if both its lowercase and uppercase versions are present in the input string. The solution returns the first letter that satisfies this condition as the greatest letter that occurs **both in lowercase and uppercase**.\\n\\n# Approach\\nThe approach taken by this solution is quite straightforward. It uses a loop to iterate through the English letters in reverse order. For each letter, it constructs both the `lowercase` and `uppercase` versions using `Character.toString(i)` and `Character.toString(i - 32)`, respectively. It then checks if both of these versions are present in the input string using the `contains()` method. If a letter is found that satisfies this condition, it **returns** **the** **uppercase** **version** of that letter.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\nThe time complexity of this solution depends on the number of iterations performed by the loop. Since the loop iterates over a constant number of letters (26 letters in the English alphabet), the time complexity is **O(1)**.\\n- Space complexity:  $$O(1)$$\\nThe space complexity of this solution is also constant. The solution uses a constant amount of additional memory to store the lower and upper strings, and no extra data structures are used. Thus, the space complexity is **O(1)**.\\n\\n# Code\\n```\\nclass Solution {\\n    public String greatestLetter(String s) {\\n\\n        for (int i = \\'z\\'; i >= \\'a\\'; i--) {\\n            String lower = Character.toString(i);\\n            String upper = Character.toString(i - 32);\\n            if (s.contains(lower) && s.contains(upper)) {\\n                return upper;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n\\n```"
    },
    {
        "slug": "flatten-nested-list-iterator",
        "tags": "java",
        "release_time": 1651988347,
        "code": "public class NestedIterator implements Iterator<Integer> {\n\n    private List<Integer> integerList = new ArrayList<>();\n    private int index = 0;\n    public NestedIterator(List<NestedInteger> nestedList) {\n        for (NestedInteger nestedInteger : nestedList) {\n            flatten(nestedInteger);\n        }\n    }\n    \n    private void flatten(NestedInteger nested) {\n        if (nested.isInteger()) \n            integerList.add(nested.getInteger());\n        else \n            for (NestedInteger nestedFromList : nested.getList()) {\n                flatten(nestedFromList);\n        }\n    }\n\n    @Override\n    public boolean hasNext() {\n        return index < integerList.size();\n    }\n\n    @Override\n    public Integer next() {\n        return integerList.get(index++);\n    }\n}",
        "content": "```\\npublic class NestedIterator implements Iterator<Integer> {\\n\\n    private List<Integer> integerList = new ArrayList<>();\\n    private int index = 0;\\n    public NestedIterator(List<NestedInteger> nestedList) {\\n        for (NestedInteger nestedInteger : nestedList) {\\n            flatten(nestedInteger);\\n        }\\n    }\\n    \\n    private void flatten(NestedInteger nested) {\\n        if (nested.isInteger()) \\n            integerList.add(nested.getInteger());\\n        else \\n            for (NestedInteger nestedFromList : nested.getList()) {\\n                flatten(nestedFromList);\\n        }\\n    }\\n\\n    @Override\\n    public boolean hasNext() {\\n        return index < integerList.size();\\n    }\\n\\n    @Override\\n    public Integer next() {\\n        return integerList.get(index++);\\n    }\\n}\\n```\\n\\nMy repositories with leetcode problems solving - [Java](https://github.com/FLlGHT/algorithms/tree/master/j-algorithms/src/main/java),  [C++](https://github.com/FLlGHT/algorithms/tree/master/c-algorithms/src/main/c%2B%2B)"
    },
    {
        "slug": "populating-next-right-pointers-in-each-node",
        "tags": "java",
        "release_time": 1681981449,
        "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    \n    public static void convert(List<Node> ca){\n\n        for(int i = 0;i<ca.size() - 1;i++){\n            ca.get(i).next = ca.get(i+1);\n\n        }\n        ca.get(ca.size()-1).next = null;\n        \n    }   \n\n    public static void helper(Node node){\n        \n        if(node == null){\n            return;\n        }\n\n        Queue<Node> q = new LinkedList<>();\n\n        List<Node> ca = new ArrayList<>();\n\n        q.add(node);\n\n        while(q.size() > 0){\n            int count = q.size();\n            for(int i = 0;i<count;i++){\n                Node rem = q.remove();\n                ca.add(rem);\n                if(rem.left != null){\n                    q.add(rem.left);\n                }\n                if(rem.right != null){\n                    q.add(rem.right);\n                }\n\n            }\n            convert(ca);\n            ca = new ArrayList<>();\n        }\n\n\n    }\n    \n    \n    public Node connect(Node root) {\n        helper(root);\n        return root;\n    }\n}",
        "content": "# Approach\\n- Create a new user defined function called helper that will do all the setting up of the next.pointers\\n- In the helper function, define a queue and an arraylist named q and child array respectively.\\n- The progression through each level will be simple, that is --> Take the root node, pass it in the queue and while the queue is not empty, empty out the whole level as you check for children of each node you remove.\\n- Append the children in the child array and connect all the next pointers in the child array to the other one with a new user defined function called convert.\\n- Add all the left and right nodes if they exist to the queue.\\n- Voila, all the next connections are done.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    \\n    public static void convert(List<Node> ca){\\n\\n        for(int i = 0;i<ca.size() - 1;i++){\\n            ca.get(i).next = ca.get(i+1);\\n\\n        }\\n        ca.get(ca.size()-1).next = null;\\n        \\n    }   \\n\\n    public static void helper(Node node){\\n        \\n        if(node == null){\\n            return;\\n        }\\n\\n        Queue<Node> q = new LinkedList<>();\\n\\n        List<Node> ca = new ArrayList<>();\\n\\n        q.add(node);\\n\\n        while(q.size() > 0){\\n            int count = q.size();\\n            for(int i = 0;i<count;i++){\\n                Node rem = q.remove();\\n                ca.add(rem);\\n                if(rem.left != null){\\n                    q.add(rem.left);\\n                }\\n                if(rem.right != null){\\n                    q.add(rem.right);\\n                }\\n\\n            }\\n            convert(ca);\\n            ca = new ArrayList<>();\\n        }\\n\\n\\n    }\\n    \\n    \\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/f3a43c1f-7852-4199-989f-1ef61f24348d_1681981342.642561.jpeg)\\n"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "tags": "java",
        "release_time": 1667118093,
        "code": "class Solution {\n    public int averageValue(int[] nums) {\n        int sum = 0;\n        int count = 0;\n        for(int num:nums)\n            if (num%6==0) {\n                sum += num;\n                count++;\n            }\n        return count==0?0:Math.round(sum/count);\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int averageValue(int[] nums) {\\n        int sum = 0;\\n        int count = 0;\\n        for(int num:nums)\\n            if (num%6==0) {\\n                sum += num;\\n                count++;\\n            }\\n        return count==0?0:Math.round(sum/count);\\n    }\\n}\\n```"
    },
    {
        "slug": "populating-next-right-pointers-in-each-node",
        "tags": "java",
        "release_time": 1674631361,
        "code": "class Solution {\n    public Node connect(Node node) {\n        Map<Integer, List<Node>> map = new HashMap<>();\n        goDFS(0, node, map);\n        for (int key : map.keySet()) {\n            List<Node> list = map.get(key);\n            for (int i = 1; i < list.size(); i++) {\n                list.get(i - 1).next = list.get(i);\n            }\n        }\n        return node;\n    }\n\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\n        if (node == null) return;\n\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\n        list.add(node);\n        lvl++;\n        goDFS(lvl, node.left, map);\n        goDFS(lvl, node.right, map);\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public Node connect(Node node) {\\n        Map<Integer, List<Node>> map = new HashMap<>();\\n        goDFS(0, node, map);\\n        for (int key : map.keySet()) {\\n            List<Node> list = map.get(key);\\n            for (int i = 1; i < list.size(); i++) {\\n                list.get(i - 1).next = list.get(i);\\n            }\\n        }\\n        return node;\\n    }\\n\\n    private void goDFS(int lvl, Node node, Map<Integer, List<Node>> map) {\\n        if (node == null) return;\\n\\n        List<Node> list = map.computeIfAbsent(lvl, k -> new ArrayList<>());\\n        list.add(node);\\n        lvl++;\\n        goDFS(lvl, node.left, map);\\n        goDFS(lvl, node.right, map);\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "tags": "java",
        "release_time": 1679756521,
        "code": "class Solution {\n    public boolean areAlmostEqual(String s1, String s2) {\n        if(s1.equals(s2))\n        return true;\n        ArrayList<Character> ts=new ArrayList<>();\n        ArrayList<Character> ts1=new ArrayList<>();\n        int count=0;\n        for(int i=0;i<s1.length();i++){\n            if(s1.charAt(i)!=s2.charAt(i)){\n            ts.add(s1.charAt(i));\n            ts1.add(s2.charAt(i));    \n        }\n        }\n        for(Character co:ts){\n            if(!(ts1.contains(co)))\n            return false;\n        }\n        return (ts.size()==2 && ts1.size()==2)?true:false;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean areAlmostEqual(String s1, String s2) {\\n        if(s1.equals(s2))\\n        return true;\\n        ArrayList<Character> ts=new ArrayList<>();\\n        ArrayList<Character> ts1=new ArrayList<>();\\n        int count=0;\\n        for(int i=0;i<s1.length();i++){\\n            if(s1.charAt(i)!=s2.charAt(i)){\\n            ts.add(s1.charAt(i));\\n            ts1.add(s2.charAt(i));    \\n        }\\n        }\\n        for(Character co:ts){\\n            if(!(ts1.contains(co)))\\n            return false;\\n        }\\n        return (ts.size()==2 && ts1.size()==2)?true:false;\\n    }\\n}\\n```"
    },
    {
        "slug": "hamming-distance",
        "tags": "java",
        "release_time": 1676104831,
        "code": "import java.math.BigInteger;\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        String x_bin = Integer.toBinaryString(x);\n        String y_bin = Integer.toBinaryString(y);\n\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\n\n        int result = 0;\n        BigInteger min_bi;\n        min_bi  = new BigInteger(min_str);\n        System.out.println(\"min_bi = \"+ min_bi);\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\n        for(int i=0; i<max_len; i++){\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\n            {\n                result+=1;\n            }\n        }\n        System.out.println(max_str);\n        System.out.println(min_format_str);\n\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe crux of the problem:\\n1. Convert both numbers to Binary strings\\n2. Find the strings with maximum len and the one with min length.\\n3. Add leading zeros to the min length string so the lengths of either strings match.\\n4. Compare the chars of either string, if they don\\'t match increment result by 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOrdinary solution using loop and appropriate data types.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(length of maximum string)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Two strings with as many characters in the longest string)\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public int hammingDistance(int x, int y) {\\n        String x_bin = Integer.toBinaryString(x);\\n        String y_bin = Integer.toBinaryString(y);\\n\\n        int max_len = x_bin.length()>y_bin.length()?x_bin.length():y_bin.length();\\n        String max_str = x_bin.length()>y_bin.length()?x_bin: y_bin;\\n        String min_str = x_bin.length()>y_bin.length()?y_bin: x_bin;\\n\\n        int result = 0;\\n        BigInteger min_bi;\\n        min_bi  = new BigInteger(min_str);\\n        System.out.println(\"min_bi = \"+ min_bi);\\n        String min_format_str = String.format(\"%0\"+max_len+\"d\", min_bi);\\n        for(int i=0; i<max_len; i++){\\n            if(max_str.charAt(i)!=min_format_str.charAt(i))\\n            {\\n                result+=1;\\n            }\\n        }\\n        System.out.println(max_str);\\n        System.out.println(min_format_str);\\n\\n        return result;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-adjacent-swaps-for-k-consecutive-ones",
        "tags": "java",
        "release_time": 1609051531,
        "code": "class Solution {\n    public int minMoves(int[] a, int k) {\n\t\tint n = a.length;\n\t\tArrayList<Integer> oneInd = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif (a[i] == 1)\n\t\t\t\toneInd.add(i);\n\t\tint prfsm[] = new int[oneInd.size()];\n\t\tfor (int i = 0; i < oneInd.size(); i++)\n\t\t\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\n\t\tint ans = Integer.MAX_VALUE;\n\t\tint left = 0, right = k - 1;\n\t\twhile (right < oneInd.size()) {\n\t\t\tif (k % 2 == 1) {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * (rad + 1);\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t} else {\n\t\t\t\tint medianInd = left + (k + 1) / 2 - 1;\n\t\t\t\tint rad = medianInd - left;\n\t\t\t\tint res = (prfsm[right] - prfsm[medianInd])\n\t\t\t\t\t\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1]))\n\t\t\t\t\t\t- oneInd.get(medianInd) - rad * (rad + 1) - (rad + 1);\n\t\t\t\tans = Math.min(ans, res);\n\t\t\t}\n\t\t\tleft++;\n\t\t\tright++;\n\t\t}\n\t\treturn ans;\n\t}\n}",
        "content": "Explaination with pictures: https://leetcode.com/problems/minimum-adjacent-swaps-for-k-consecutive-ones/discuss/987607/O(n)-explanation-with-picture\\n\\n```\\nclass Solution {\\n    public int minMoves(int[] a, int k) {\\n\\t\\tint n = a.length;\\n\\t\\tArrayList<Integer> oneInd = new ArrayList<>();\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tif (a[i] == 1)\\n\\t\\t\\t\\toneInd.add(i);\\n\\t\\tint prfsm[] = new int[oneInd.size()];\\n\\t\\tfor (int i = 0; i < oneInd.size(); i++)\\n\\t\\t\\tprfsm[i] += oneInd.get(i) + (i == 0 ? 0 : prfsm[i - 1]);\\n\\t\\tint ans = Integer.MAX_VALUE;\\n\\t\\tint left = 0, right = k - 1;\\n\\t\\twhile (right < oneInd.size()) {\\n\\t\\t\\tif (k % 2 == 1) {\\n\\t\\t\\t\\tint medianInd = left + (k + 1) / 2 - 1;\\n\\t\\t\\t\\tint rad = medianInd - left;\\n\\t\\t\\t\\tint res = (prfsm[right] - prfsm[medianInd])\\n\\t\\t\\t\\t\\t\\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1])) - rad * (rad + 1);\\n\\t\\t\\t\\tans = Math.min(ans, res);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint medianInd = left + (k + 1) / 2 - 1;\\n\\t\\t\\t\\tint rad = medianInd - left;\\n\\t\\t\\t\\tint res = (prfsm[right] - prfsm[medianInd])\\n\\t\\t\\t\\t\\t\\t- ((medianInd == 0 ? 0 : prfsm[medianInd - 1]) - (left == 0 ? 0 : prfsm[left - 1]))\\n\\t\\t\\t\\t\\t\\t- oneInd.get(medianInd) - rad * (rad + 1) - (rad + 1);\\n\\t\\t\\t\\tans = Math.min(ans, res);\\n\\t\\t\\t}\\n\\t\\t\\tleft++;\\n\\t\\t\\tright++;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```"
    },
    {
        "slug": "set-matrix-zeroes",
        "tags": "java",
        "release_time": 1692355209,
        "code": "class Solution {\n    public void setZeroes(int[][] matrix) {\n        ArrayList<Integer> row = new ArrayList<>();\n        ArrayList<Integer> col = new ArrayList<>();\n        for(int i=0; i<matrix.length; i++){\n            for(int j=0; j<matrix[0].length; j++){\n                if(matrix[i][j] == 0){\n                    row.add(i);\n                    col.add(j);\n                }\n            }\n        }\n\n         for(int i=0; i<matrix.length; i++){\n            if(row.contains(i)){\n                for(int j=0; j<matrix[0].length; j++){\n                    matrix[i][j] = 0;\n                }\n            }\n            else{\n                for(int j=0; j<matrix[0].length; j++){\n                    if(col.contains(j)){\n                        matrix[i][j] = 0;\n                    }\n                }\n            }\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstoring data in first row and first col.\\n\\n# Complexity\\n- Time complexity:\\n- O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# brute force code :\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        ArrayList<Integer> row = new ArrayList<>();\\n        ArrayList<Integer> col = new ArrayList<>();\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n         for(int i=0; i<matrix.length; i++){\\n            if(row.contains(i)){\\n                for(int j=0; j<matrix[0].length; j++){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            else{\\n                for(int j=0; j<matrix[0].length; j++){\\n                    if(col.contains(j)){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\ntime - c for upper one is O(n+m)\\n\\n\\n\\n#  Optimize code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false, fc = false;\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<matrix.length; i++){\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }  \\n            }\\n        }\\n\\n        if(fr) {\\n            for(int i=0; i<matrix[0].length; i++){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if(fc) {\\n            for(int i=0; i<matrix.length; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "two-sum-ii-input-array-is-sorted",
        "tags": "java",
        "release_time": 1680722540,
        "code": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n                int left = 0;\n        int right = numbers.length - 1;\n        int tmp;\n        while (left < right)\n        {\n            if (numbers[left] + numbers[right] == target) break;\n            tmp = target - numbers[right];\n            while (numbers[left] < tmp) left++;\n            if (numbers[left] + numbers[right] == target) break;\n            tmp = target - numbers[left];\n            while (numbers[right] > tmp) right--;\n        }\n        return new int[]{left + 1, right + 1};\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public int[] twoSum(int[] numbers, int target) {\\n                int left = 0;\\n        int right = numbers.length - 1;\\n        int tmp;\\n        while (left < right)\\n        {\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[right];\\n            while (numbers[left] < tmp) left++;\\n            if (numbers[left] + numbers[right] == target) break;\\n            tmp = target - numbers[left];\\n            while (numbers[right] > tmp) right--;\\n        }\\n        return new int[]{left + 1, right + 1};\\n    }\\n}\\n```"
    },
    {
        "slug": "a-number-after-a-double-reversal",
        "tags": "java",
        "release_time": 1686977158,
        "code": "class Solution {\n    public boolean isSameAfterReversals(int num) \n    {\n        int n=num,ans=0;\n        while(n!=0)\n        {\n            int l=n%10;\n            ans=(ans*10)+l;\n            n=n/10;\n        } \n        String s1=Integer.toString(num);\n        String s2=Integer.toString(ans);\n        if(s1.length()==s2.length())  return true;\n        return false;\n    }\n}",
        "content": "# Intuition\\nStep 1: Reverse the number and store it in a variable.\\nStep 2: Take the two integers and convert it into String.\\nStep 3: Check whether both of the string length is equal or not.\\nStep 4: If it is equal return true, else return false.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isSameAfterReversals(int num) \\n    {\\n        int n=num,ans=0;\\n        while(n!=0)\\n        {\\n            int l=n%10;\\n            ans=(ans*10)+l;\\n            n=n/10;\\n        } \\n        String s1=Integer.toString(num);\\n        String s2=Integer.toString(ans);\\n        if(s1.length()==s2.length())  return true;\\n        return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "word-ladder",
        "tags": "java",
        "release_time": 1689448575,
        "code": "class Pair{\n    String first;\n    int second;\n    Pair(String first,int second){\n        this.first=first;\n        this.second=second;\n    }\n}\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Queue<Pair> q=new ArrayDeque<>();\n        //initially adding beginword and sequence length 1 into queue\n        q.add(new Pair(beginWord,1));\n        //adding all words in HashSet \n        HashSet<String> set=new HashSet<>();\n        for(int i=0;i<wordList.size();i++){\n            set.add(wordList.get(i));\n        }\n        set.remove(beginWord);\n        while(!q.isEmpty()){\n            String rem=q.peek().first;\n            int steps=q.peek().second;\n            q.remove();\n            if(rem.equals(endWord))return steps;\n            \n            //TC:N * rem.length * 26 *  0(1){hashset}\n            //SC: 0(N) hashSet\n\n            //for every character doing a change,so traverse to all the characters\n            for(int i=0;i<rem.length();i++){\n                for(char ch='a';ch<='z';ch++){\n                    char replacedcharArray[]=rem.toCharArray();\n                    replacedcharArray[i]=ch;\n                    String replacedword=new String(replacedcharArray);\n                    //exist in the set?\n                    if(set.contains(replacedword)){\n                        set.remove(replacedword);\n                        q.add(new Pair(replacedword,steps+1));\n                    }\n                }\n            }\n\n        }\n        return 0;\n\n    }\n}",
        "content": "# Approach\\nBFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:N * rem.length * 26 *  0(1){hashset}\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N) hashSet\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair{\\n    String first;\\n    int second;\\n    Pair(String first,int second){\\n        this.first=first;\\n        this.second=second;\\n    }\\n}\\nclass Solution {\\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\\n        Queue<Pair> q=new ArrayDeque<>();\\n        //initially adding beginword and sequence length 1 into queue\\n        q.add(new Pair(beginWord,1));\\n        //adding all words in HashSet \\n        HashSet<String> set=new HashSet<>();\\n        for(int i=0;i<wordList.size();i++){\\n            set.add(wordList.get(i));\\n        }\\n        set.remove(beginWord);\\n        while(!q.isEmpty()){\\n            String rem=q.peek().first;\\n            int steps=q.peek().second;\\n            q.remove();\\n            if(rem.equals(endWord))return steps;\\n            \\n            //TC:N * rem.length * 26 *  0(1){hashset}\\n            //SC: 0(N) hashSet\\n\\n            //for every character doing a change,so traverse to all the characters\\n            for(int i=0;i<rem.length();i++){\\n                for(char ch=\\'a\\';ch<=\\'z\\';ch++){\\n                    char replacedcharArray[]=rem.toCharArray();\\n                    replacedcharArray[i]=ch;\\n                    String replacedword=new String(replacedcharArray);\\n                    //exist in the set?\\n                    if(set.contains(replacedword)){\\n                        set.remove(replacedword);\\n                        q.add(new Pair(replacedword,steps+1));\\n                    }\\n                }\\n            }\\n\\n        }\\n        return 0;\\n\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-suffix-flips",
        "tags": "java",
        "release_time": 1672036497,
        "code": "class Solution {\n    public int minFlips(String target) {\n        int flips = 0;\n        char prev = target.charAt(0);\n        if (prev == '1') flips++;\n\n        for (int i = 1; i < target.length(); i++) {\n            char c = target.charAt(i);\n            if (c != prev) {\n                flips++;\n                prev = c;\n            }\n        }\n        return flips;\n    }\n}",
        "content": "# Approach\\nCount the number of different adjacent letters. Since we are working with suffices, then you can figure out that we just need to flip starting from index (from left) where it differs from target. So, we adjust initial String with zeros only starting from left and by looking each letter one by one.\\nExample:\\n00000 -> 10101\\n1. **00000**\\n2. 1**1111**\\n3. 10**000**\\n4. 101**11**\\n5. 1010**0**\\nResult: 10101\\n\\n# Complexity\\n- Time complexity: O(N), where N - number of letters.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minFlips(String target) {\\n        int flips = 0;\\n        char prev = target.charAt(0);\\n        if (prev == \\'1\\') flips++;\\n\\n        for (int i = 1; i < target.length(); i++) {\\n            char c = target.charAt(i);\\n            if (c != prev) {\\n                flips++;\\n                prev = c;\\n            }\\n        }\\n        return flips;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "tags": "java",
        "release_time": 1683601117,
        "code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for(String x : words) {\n            StringBuilder SB = new StringBuilder(x);\n            if(x.equals(SB.reverse().toString())) {\n                return x;\n            }\n        }\n        return \"\";\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for(String x : words) {\\n            StringBuilder SB = new StringBuilder(x);\\n            if(x.equals(SB.reverse().toString())) {\\n                return x;\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```"
    },
    {
        "slug": "first-completely-painted-row-or-column",
        "tags": "java",
        "release_time": 1682933570,
        "code": "class Solution {\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\n        int ind=0;\n        int m=mat.length,n=mat[0].length;\n        int row[]=new int[m];\n        int col[]=new int[n];\n        boolean flag=true;;\n        while(flag){\n            int i=0;\n            for(i=0;i<m;i++){\n                int j=0;\n                for(j=0;j<n;j++){\n                    if(mat[i][j]==arr[ind]){\n                        ind++;\n                        row[i]++;\n                        col[j]++;\n                    }\n                    if(row[i]==n || col[j]==m){\n                        flag=false;\n                        break;\n                    }\n                }\n                if(!flag)   break;\n            }\n        }\n       return ind-1;\n    }\n}",
        "content": "\\nUnoptimized but still works\\n# Complexity\\n- Time complexity:O(k*m*n)\\n- Where k is the number of operation required to make one wall to be colored\\n- m is number of rows\\n- n is number of columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        int ind=0;\\n        int m=mat.length,n=mat[0].length;\\n        int row[]=new int[m];\\n        int col[]=new int[n];\\n        boolean flag=true;;\\n        while(flag){\\n            int i=0;\\n            for(i=0;i<m;i++){\\n                int j=0;\\n                for(j=0;j<n;j++){\\n                    if(mat[i][j]==arr[ind]){\\n                        ind++;\\n                        row[i]++;\\n                        col[j]++;\\n                    }\\n                    if(row[i]==n || col[j]==m){\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(!flag)   break;\\n            }\\n        }\\n       return ind-1;\\n    }\\n}\\n```\\nOptimized Version of the same:\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- m is number of rows\\n- n is number of columns\\n- Space complexity:O(m)+O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\n    public int firstCompleteIndex(int[] arr, int[][] mat) {\\n        HashMap<Integer,int[]>hm=new HashMap<>();\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[0].length;j++){\\n                hm.put(mat[i][j],new int[]{i,j});\\n            }\\n        }\\n        int row[]=new int[mat.length];\\n        int col[]=new int[mat[0].length];\\n        int i=0;\\n        for(i=0;i<arr.length;i++){\\n            int curr[]=hm.get(arr[i]);\\n            row[curr[0]]++;\\n            col[curr[1]]++;\\n            if(row[curr[0]]==mat[0].length ||\\n                col[curr[1]]==mat.length){\\n                    break;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-array-is-good",
        "tags": "java",
        "release_time": 1690077670,
        "code": "class Solution {\n    public boolean isGood(int[] nums) {\n        Arrays.sort(nums);\n        if(nums.length==1){\n            return false;\n        }\n        else{\n           int ans=nums.length-1;\n            int count=1;\n            for(int i=0;i<nums.length-1;i++){\n                if(nums[i]==count){\n                    count++;\n                }\n                else{\n                    return false;\n                }\n            }\n            if(count-1==nums[nums.length-1]){\n                return true;\n            }\n        }\n        return false;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGood(int[] nums) {\\n        Arrays.sort(nums);\\n        if(nums.length==1){\\n            return false;\\n        }\\n        else{\\n           int ans=nums.length-1;\\n            int count=1;\\n            for(int i=0;i<nums.length-1;i++){\\n                if(nums[i]==count){\\n                    count++;\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            if(count-1==nums[nums.length-1]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "delete-characters-to-make-fancy-string",
        "tags": "java",
        "release_time": 1628352102,
        "code": "class Solution {\n    public String makeFancyString(String s) {\n        char prev = s.charAt (0);\n        int freq = 1;\n        StringBuilder res = new StringBuilder ();\n        res.append (s.charAt (0));\n        for (int i = 1; i < s.length (); i++) {\n            if (s.charAt (i) == prev)\n                freq++;\n            else {\n                prev = s.charAt (i);\n                freq = 1;\n            }\n            if (freq < 3)\n                res.append (s.charAt (i));\n        }\n        return res.toString ();\n    }\n}",
        "content": "*------Please **upvote!** if you like the solution and explanation.  Please put your doubts/queries in the comments section below.  I will try my best to answer them.------*\\n\\n***Intuition:*** If a character is repeating continuously, we will only pick it at most twice in a row.  This is kind of a Greedy idea where we pick characters such that the concatenated frequency is < 3.\\n\\n***Algorithm:***\\n\\n1.\\tAppend the first character to the result (no point deleting it!).\\n2.\\tKeep a **prev** variable and a **freq** variable marking the frequency of the character seen just before. Initialize **prev** with the first character of the string and **freq** with 1.\\n3.\\tIf the current character is equal to prev, increment **freq** by 1, else change **prev** to the current character and reset **freq = 1**.\\n4.\\tIf **freq < 3**, append the current character to the result, else skip the character.\\n5.\\tAfter the loop ends, return the resultant string.\\n\\nAvoid direct string concatenation because it takes more time as compared to StringBuilder and may cause TLE.\\n\\n```\\nclass Solution {\\n    public String makeFancyString(String s) {\\n        char prev = s.charAt (0);\\n        int freq = 1;\\n        StringBuilder res = new StringBuilder ();\\n        res.append (s.charAt (0));\\n        for (int i = 1; i < s.length (); i++) {\\n            if (s.charAt (i) == prev)\\n                freq++;\\n            else {\\n                prev = s.charAt (i);\\n                freq = 1;\\n            }\\n            if (freq < 3)\\n                res.append (s.charAt (i));\\n        }\\n        return res.toString ();\\n    }\\n}\\n```\\n\\nPlease **upvote!** if you like the solution and explanation.\\n"
    },
    {
        "slug": "delete-node-in-a-bst",
        "tags": "java",
        "release_time": 1637549657,
        "code": "class Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if(root==null) return null;\n        \n        if(key<root.val){                            \n            root.left = deleteNode(root.left,key);\n            return root;\n        }\n        \n        else if(key>root.val){\n            root.right = deleteNode(root.right,key);\n            return root;\n        }\n        \n        else{\n            if(root.left==null){\n                return root.right;\n            }\n            else if(root.right==null){\n                return root.left;\n            }\n            else{\n                TreeNode min = root.right;\n                while(min.left!=null){\n                    min = min.left;\n                }\n                \n                root.val = min.val;\n                root.right = deleteNode(root.right,min.val);\n                return root;\n            }\n        }\n    }\n}",
        "content": "**Intution:** Use the BST property to search the node and then delete if found the required node.\\n\\n* So if the traget node has value less than root then we will surely get it in the left subtree...so just call ur recursive function for the left subtree.\\n* If the traget node has value greater than root then we will surely get it in the right subtree...so just call ur recursive function for the right subtree.\\n* And now comes the case when u have to do your work that is root itself is the required node to be deleted. Here again comes three cases:\\n\\t1. \\tIf left of root is null and u also have to delete the root node...then just simply return the right subtree.\\n\\t2. \\tIf right of root is null and u also have to delete the root node...then just simply return the left subtree.\\n\\t3. \\tBoth are not null then you have to not just delete the node but also maintain the BST structure.\\nSo now you have to think if you delete the root node then which node can optimally replace it so that all the nodes on left are still small and on right are larger.\\n**So that node will be the node just greater than the largest node in the left subtree which is the smallest node in the right subtree**\\n![image](https://assets.leetcode.com/users/images/e876a47d-fe1f-46db-97c4-fbf2b3d9567b_1637549476.0494304.jpeg)\\n\\n\\t\\t* So point your pointer on the right subtree and then move it to the left most node of this subtree that will be your required node and so now replace the value of your root with this node value which will ensure that the key which u wanted to delete is deleted and the value there is  the right value.\\n\\t\\t* Now you have to delete that node whose value is already present in the root...so now that work will be done by the recursion so now just pass that right subtree in which the value is present with that nodes value which will be now the target\\n```\\nclass Solution {\\n    public TreeNode deleteNode(TreeNode root, int key) {\\n        if(root==null) return null;\\n        \\n        if(key<root.val){                            \\n            root.left = deleteNode(root.left,key);\\n            return root;\\n        }\\n        \\n        else if(key>root.val){\\n            root.right = deleteNode(root.right,key);\\n            return root;\\n        }\\n        \\n        else{\\n            if(root.left==null){\\n                return root.right;\\n            }\\n            else if(root.right==null){\\n                return root.left;\\n            }\\n            else{\\n                TreeNode min = root.right;\\n                while(min.left!=null){\\n                    min = min.left;\\n                }\\n                \\n                root.val = min.val;\\n                root.right = deleteNode(root.right,min.val);\\n                return root;\\n            }\\n        }\\n    }\\n}"
    },
    {
        "slug": "make-array-strictly-increasing",
        "tags": "java",
        "release_time": 1686968098,
        "code": "class Solution {\n    \n    HashMap<Integer, Integer> dp[];\n    TreeSet<Integer> ts;\n    \n    int makeArrayIncr(int i, int prev, int[] arr1) {\n        \n        if(i == arr1.length) return 0;\n        \n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\n        \n        int notswap = 5000;\n        \n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\n        \n        int swap = 5000;\n        \n        Integer curr = ts.higher(prev);\n        \n        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);\n        \n        dp[i].put(prev, Math.min(swap, notswap));\n        \n        // System.out.println(i + \" \" + swap + \" \" + notswap);\n        \n        return Math.min(swap, notswap);\n        \n    }\n    \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        \n        ts = new TreeSet<>();\n        for(int i : arr2) ts.add(i);\n        \n        dp = new HashMap[arr1.length];\n        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();\n        \n        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);\n        \n        return ans < 5000 ? ans : -1; \n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    HashMap<Integer, Integer> dp[];\\n    TreeSet<Integer> ts;\\n    \\n    int makeArrayIncr(int i, int prev, int[] arr1) {\\n        \\n        if(i == arr1.length) return 0;\\n        \\n        if(dp[i].containsKey(prev)) return dp[i].get(prev);\\n        \\n        int notswap = 5000;\\n        \\n        if(arr1[i] > prev) notswap = makeArrayIncr(i + 1, arr1[i], arr1);\\n        \\n        int swap = 5000;\\n        \\n        Integer curr = ts.higher(prev);\\n        \\n        if(curr != null) swap = 1 + makeArrayIncr(i + 1, curr, arr1);\\n        \\n        dp[i].put(prev, Math.min(swap, notswap));\\n        \\n        // System.out.println(i + \" \" + swap + \" \" + notswap);\\n        \\n        return Math.min(swap, notswap);\\n        \\n    }\\n    \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        \\n        ts = new TreeSet<>();\\n        for(int i : arr2) ts.add(i);\\n        \\n        dp = new HashMap[arr1.length];\\n        for(int i = 0; i < dp.length; i++) dp[i] = new HashMap<>();\\n        \\n        int ans = makeArrayIncr(0, Integer.MIN_VALUE, arr1);\\n        \\n        return ans < 5000 ? ans : -1; \\n    }\\n}\\n```"
    },
    {
        "slug": "trapping-rain-water",
        "tags": "java",
        "release_time": 1683960844,
        "code": "class Solution \n{\n    public int trap(int[] height) \n    {\n        int result = 0;\n        if(height==null || height.length<=2)\n            return result;\n        int left[] = new int[height.length];\n        int right[]= new int[height.length];\n        //scan from left to right\n        int max = height[0];\n        left[0] = height[0];\n        for(int i=1; i<height.length; i++)\n        {\n            if(height[i]<max)\n            {\n                left[i]=max;\n            }\n            else\n            {\n                left[i]=height[i];\n                max = height[i];\n            }\n        }\n        //scan from right to left\n        max = height[height.length-1];\n        right[height.length-1]=height[height.length-1];\n        for(int i=height.length-2; i>=0; i--)\n        {\n            if(height[i]<max)\n            {\n                right[i]=max;  \n            }\n            else\n            {  \n                right[i]=height[i];\n                max = height[i];\n            }\n        }\n    \n        for(int i=0; i<height.length; i++)\n        {\n            result+= Math.min(left[i],right[i])-height[i];\n        }\n        return result;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the trapped rainwater, we need to determine the effective height at each bar. The effective height at a specific bar is the minimum of the maximum heights on its left and right sides. The trapped rainwater can be calculated as the difference between the effective height and the actual height of each bar.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Check if the height array is null or has fewer than 2 elements. If so, return 0 since there are not enough bars to trap any rainwater.\\n2. Initialize a variable result to keep track of the total trapped rainwater.\\n3. Create two arrays, left and right, each with the same length as the height array. These arrays will store the maximum heights on the left and right sides of each bar, respectively.\\n4. Scan the height array from left to right:\\n- Initialize a variable max to store the maximum height encountered so far, starting with the height of the first bar.\\n- For each bar at index i, compare its height with the current max:\\n1. If the height of the current bar is less than the current max, set left[i] to max, indicating that the maximum height on the left side is still max.\\n1. Otherwise, update left[i] and max to the height of the current bar since it becomes the new maximum height encountered so far.\\n5. Scan the height array from right to left (similar to step 4) to populate the right array with the maximum heights on the right side of each bar.\\n6. Iterate over the height array:\\n- For each bar at index i, calculate the trapped rainwater by subtracting the actual height (height[i]) from the minimum of the maximum heights on the left and right sides (Math.min(left[i], right[i])).\\n- Add the calculated trapped rainwater to the result variable.\\n7. Return the final result which represents the total trapped rainwater.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n), where n is the length of the height array. The code performs three separate scans over the height array, each taking linear time. Hence, the overall time complexity is linear.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(n), where n is the length of the height array. This is due to the additional arrays left and right that store the maximum heights on the left and right sides of each bar, respectively. The space required is proportional to the size of the input array.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int trap(int[] height) \\n    {\\n        int result = 0;\\n        if(height==null || height.length<=2)\\n            return result;\\n        int left[] = new int[height.length];\\n        int right[]= new int[height.length];\\n        //scan from left to right\\n        int max = height[0];\\n        left[0] = height[0];\\n        for(int i=1; i<height.length; i++)\\n        {\\n            if(height[i]<max)\\n            {\\n                left[i]=max;\\n            }\\n            else\\n            {\\n                left[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n        //scan from right to left\\n        max = height[height.length-1];\\n        right[height.length-1]=height[height.length-1];\\n        for(int i=height.length-2; i>=0; i--)\\n        {\\n            if(height[i]<max)\\n            {\\n                right[i]=max;  \\n            }\\n            else\\n            {  \\n                right[i]=height[i];\\n                max = height[i];\\n            }\\n        }\\n    \\n        for(int i=0; i<height.length; i++)\\n        {\\n            result+= Math.min(left[i],right[i])-height[i];\\n        }\\n        return result;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-number-of-points-from-grid-queries",
        "tags": "java",
        "release_time": 1670731767,
        "code": "class Solution {\n    public int[] maxPoints(int[][] a, int[] q) {\n        \n        int n = a.length;\n        int m = a[0].length;\n        \n        int l = q.length;\n        int[][] p = new int[l][2];\n        \n        for(int i = 0 ; i < l ; i++) {\n            \n            p[i][0] = i;\n            p[i][1] = q[i];\n        }\n        \n        Arrays.sort(p, (o1,o2)-> {\n            \n            if(o1[1] == o2[1]) {\n                \n                Integer.compare(o1[0],o2[0]);\n            }\n            \n            return Integer.compare(o1[1],o2[1]);\n        });\n        \n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\n            \n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\n        });\n        \n        qu.add(new int[]{0,0});\n        \n        boolean[][] v = new boolean[n][m];\n        int cnt = 0;\n        int idx = 0;\n        \n        while(qu.size() > 0 && idx < l) {\n            \n            int[] f = qu.remove();\n            int r = f[0] , c = f[1];\n            \n            if(v[r][c]) continue;\n            \n            v[r][c] = true;\n            \n            if(a[r][c] < p[idx][1]) {\n                \n                cnt++;\n            }\n            else{\n                \n                q[p[idx][0]] = cnt;\n                idx++;\n                qu.add(f);\n                v[r][c] = false;\n                continue;\n            }\n            \n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\n        }\n        \n        while(idx < l) {\n            \n            q[p[idx][0]] = cnt;\n            idx++;\n        }\n        \n        return q;\n    }\n}",
        "content": "# Intuition\\nUse the concept of offline query.\\n\\n# Approach\\nFirst sort the query and then use priorityqueue to get min value cell.\\nif value is less than query update count \\nelse cnt is ans for ith query.\\n\\n\\n# Complexity\\n- Time complexity: O(n*m*log(n*m))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] maxPoints(int[][] a, int[] q) {\\n        \\n        int n = a.length;\\n        int m = a[0].length;\\n        \\n        int l = q.length;\\n        int[][] p = new int[l][2];\\n        \\n        for(int i = 0 ; i < l ; i++) {\\n            \\n            p[i][0] = i;\\n            p[i][1] = q[i];\\n        }\\n        \\n        Arrays.sort(p, (o1,o2)-> {\\n            \\n            if(o1[1] == o2[1]) {\\n                \\n                Integer.compare(o1[0],o2[0]);\\n            }\\n            \\n            return Integer.compare(o1[1],o2[1]);\\n        });\\n        \\n        PriorityQueue<int[]> qu = new PriorityQueue<>((o1,o2)->{\\n            \\n            return Integer.compare(a[o1[0]][o1[1]],a[o2[0]][o2[1]]);\\n        });\\n        \\n        qu.add(new int[]{0,0});\\n        \\n        boolean[][] v = new boolean[n][m];\\n        int cnt = 0;\\n        int idx = 0;\\n        \\n        while(qu.size() > 0 && idx < l) {\\n            \\n            int[] f = qu.remove();\\n            int r = f[0] , c = f[1];\\n            \\n            if(v[r][c]) continue;\\n            \\n            v[r][c] = true;\\n            \\n            if(a[r][c] < p[idx][1]) {\\n                \\n                cnt++;\\n            }\\n            else{\\n                \\n                q[p[idx][0]] = cnt;\\n                idx++;\\n                qu.add(f);\\n                v[r][c] = false;\\n                continue;\\n            }\\n            \\n            if(c+1 < m && v[r][c+1] == false) qu.add(new int[]{r,c+1});\\n            if(r+1 < n && v[r+1][c] == false) qu.add(new int[]{r+1,c});\\n            if(r-1 >=0 && v[r-1][c] == false) qu.add(new int[]{r-1,c});\\n            if(c-1 >= 0 && v[r][c-1] == false) qu.add(new int[]{r,c-1});\\n        }\\n        \\n        while(idx < l) {\\n            \\n            q[p[idx][0]] = cnt;\\n            idx++;\\n        }\\n        \\n        return q;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-palindrome-with-fixed-length",
        "tags": "java",
        "release_time": 1690442915,
        "code": "class Solution {\n    public long[] kthPalindrome(int[] queries, int intLength) {\n        int n=queries.length;\n        long ans[]=new long[n];\n        int ans_i=0;\n        \n        \n        int palindrome_present = ( intLength+1 )/2 ;\n        \n        long l=(long)Math.pow(10,palindrome_present-1); //10\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\n        for(int q:queries){\n            if(q<=(r-l+1)){\n                String left_half=Long.toString(l+q-1);\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\n                \n            }\n            else{\n                ans[ans_i]=-1;\n            }\n            \n            ans_i++;\n        }\n        \n        return ans;\n    }\n}",
        "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/82cc68e9-a96c-40f4-a46a-e7c7966a60cc_1690442908.0847147.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] kthPalindrome(int[] queries, int intLength) {\\n        int n=queries.length;\\n        long ans[]=new long[n];\\n        int ans_i=0;\\n        \\n        \\n        int palindrome_present = ( intLength+1 )/2 ;\\n        \\n        long l=(long)Math.pow(10,palindrome_present-1); //10\\n        long r=(long)Math.pow(10,palindrome_present)-1; //99\\n        for(int q:queries){\\n            if(q<=(r-l+1)){\\n                String left_half=Long.toString(l+q-1);\\n                String right_half=(new StringBuilder(left_half)).reverse().toString();\\n                ans[ans_i]=Long.parseLong( left_half+right_half.substring(intLength % 2 ) );\\n                \\n            }\\n            else{\\n                ans[ans_i]=-1;\\n            }\\n            \\n            ans_i++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "apply-discount-every-n-orders",
        "tags": "java",
        "release_time": 1672208305,
        "code": "class Cashier {\n    HashMap<Integer,Integer>stock=new HashMap<>();\n    int n;\n    int discount;\n    int itr=0;\n    public Cashier(int n, int discount, int[] products, int[] prices) {\n        for(int i=0;i<products.length;i++){\n            stock.put(products[i],prices[i]);\n        }\n        this.n=n;\n        this.discount=discount;\n    }\n    \n    public double getBill(int[] product, int[] amount) {\n        double total=0;\n        for(int i=0;i<product.length;i++){\n            total+=(double)(amount[i]*stock.get(product[i]));\n        }\n        itr++;\n        if(itr==n){\n            total*=(double)(((100-discount)/100d));\n            itr=0;\n        }\n        return total;\n    }\n}\n\n/**\n * Your Cashier object will be instantiated and called as such:\n * Cashier obj = new Cashier(n, discount, products, prices);\n * double param_1 = obj.getBill(product,amount);\n */",
        "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Cashier {\\n    HashMap<Integer,Integer>stock=new HashMap<>();\\n    int n;\\n    int discount;\\n    int itr=0;\\n    public Cashier(int n, int discount, int[] products, int[] prices) {\\n        for(int i=0;i<products.length;i++){\\n            stock.put(products[i],prices[i]);\\n        }\\n        this.n=n;\\n        this.discount=discount;\\n    }\\n    \\n    public double getBill(int[] product, int[] amount) {\\n        double total=0;\\n        for(int i=0;i<product.length;i++){\\n            total+=(double)(amount[i]*stock.get(product[i]));\\n        }\\n        itr++;\\n        if(itr==n){\\n            total*=(double)(((100-discount)/100d));\\n            itr=0;\\n        }\\n        return total;\\n    }\\n}\\n\\n/**\\n * Your Cashier object will be instantiated and called as such:\\n * Cashier obj = new Cashier(n, discount, products, prices);\\n * double param_1 = obj.getBill(product,amount);\\n */\\n```"
    },
    {
        "slug": "find-greatest-common-divisor-of-array",
        "tags": "java",
        "release_time": 1684308599,
        "code": "class Solution {\n    public int findGCD(int[] nums) {\n        Arrays.sort(nums);\n        int GCD = 1;\n        for(int i = 1; i <= nums[0]; i++) {\n            if(nums[0] % i == 0 && nums[nums.length - 1] % i == 0) {\n                GCD = i;\n            }\n        }\n        return GCD;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findGCD(int[] nums) {\\n        Arrays.sort(nums);\\n        int GCD = 1;\\n        for(int i = 1; i <= nums[0]; i++) {\\n            if(nums[0] % i == 0 && nums[nums.length - 1] % i == 0) {\\n                GCD = i;\\n            }\\n        }\\n        return GCD;\\n    }\\n}\\n```"
    },
    {
        "slug": "min-stack",
        "tags": "java",
        "release_time": 1690830559,
        "code": "class MinStack {\n    Stack<Integer> minStack;\n    Stack<Integer> stack;\n\n    public MinStack() {\n        minStack = new Stack<>();\n        stack = new Stack<>();\n    }\n    \n    public void push(int val) {\n        int currentMin;\n        \n        if (minStack.isEmpty() || val <= (currentMin = minStack.peek()))\n            minStack.push(val);\n        else\n            minStack.push(currentMin);\n\n        stack.push(val);\n    }\n    \n    public void pop() {\n        stack.pop();\n        minStack.pop();\n    }\n    \n    public int top() {\n        return stack.peek();\n    }\n    \n    public int getMin() {\n        return minStack.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first intuition is that, at each \"push\" operation we must know what is the current minimum and update it according to val. However simply holding the current minimum is not enough since after a \"pop\" operation, our current minimum may not be present and we have no way of knowing what the previous minimum was. Therefore we need to store the minimum value for each element of the stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt is again intuitive to use another stack for this purpose. Let\\'s call it the \"minStack\".\\n\\nFor each \"push\" operation, we are going to compare the value to our current minimum and if it\\'s smaller than that, we are going to push the \"val\" to the minStack. Otherwise, we are going to peek at the minStack and push it that value again.\\nFor each \"pop\" operation, we are going to pop both from the main stack and the minStack. Therefore for each step, we will have the same \"minimum value\" information available.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity for each operation is O(1) as requested in the problem text.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is O(n) + O(n) = O(2n) = O(n) since we are pushing for each element to both main stack and minStack.\\n\\n# Code\\n```\\nclass MinStack {\\n    Stack<Integer> minStack;\\n    Stack<Integer> stack;\\n\\n    public MinStack() {\\n        minStack = new Stack<>();\\n        stack = new Stack<>();\\n    }\\n    \\n    public void push(int val) {\\n        int currentMin;\\n        \\n        if (minStack.isEmpty() || val <= (currentMin = minStack.peek()))\\n            minStack.push(val);\\n        else\\n            minStack.push(currentMin);\\n\\n        stack.push(val);\\n    }\\n    \\n    public void pop() {\\n        stack.pop();\\n        minStack.pop();\\n    }\\n    \\n    public int top() {\\n        return stack.peek();\\n    }\\n    \\n    public int getMin() {\\n        return minStack.peek();\\n    }\\n}\\n\\n/**\\n * Your MinStack object will be instantiated and called as such:\\n * MinStack obj = new MinStack();\\n * obj.push(val);\\n * obj.pop();\\n * int param_3 = obj.top();\\n * int param_4 = obj.getMin();\\n */\\n```"
    },
    {
        "slug": "sum-in-a-matrix",
        "tags": "java",
        "release_time": 1683993959,
        "code": "class Solution {\n    public int matrixSum(int[][] nums) {\n        int score = 0;\n        int n = nums.length;\n        int m = nums[0].length;\n        for(int[] a :nums)\n        {\n            Arrays.sort(a);\n        }\n        for(int i=0;i<m;i++)\n        {\n            int max = 0;\n            for(int j=0;j<n;j++)\n            {\n                max = Math.max(max,nums[j][i]);\n            }\n            score+=max;\n        }\n        return score;\n    }\n}",
        "content": "# Intuition\\n**First sort the array rowwise then add maximum for each column.**\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int matrixSum(int[][] nums) {\\n        int score = 0;\\n        int n = nums.length;\\n        int m = nums[0].length;\\n        for(int[] a :nums)\\n        {\\n            Arrays.sort(a);\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                max = Math.max(max,nums[j][i]);\\n            }\\n            score+=max;\\n        }\\n        return score;\\n    }\\n}\\n```"
    },
    {
        "slug": "keyboard-row",
        "tags": "java",
        "release_time": 1691312916,
        "code": "class Solution {\n    public String[] findWords(String[] words) {\n        List<String> res = new ArrayList<>();\n        String firstRow = \"qwertyuiop\";\n        String secondRow = \"asdfghjkl\";\n        String thirdRow = \"zxcvbnm\";\n\n        loop:\n        for(String word : words) {\n            char[] chars = word.toLowerCase().toCharArray();\n\n            boolean canBeTyped = true;\n            for(char c : chars) {\n                int idx = firstRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n\n            canBeTyped = true;\n            for(char c : chars) {\n                int idx = secondRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n\n            canBeTyped = true;\n            for(char c : chars) {\n                int idx = thirdRow.indexOf(c);\n                if(idx == -1) {\n                    canBeTyped = false;\n                    break;\n                }\n            }\n            if(canBeTyped) {\n                res.add(word);\n                continue loop;\n            }\n        }\n        \n        String[] ans = new String[res.size()];\n        int i = 0;\n        for(String word : res) {\n            ans[i++] = word;\n        }\n\n        return ans;\n    }\n}",
        "content": "# Approach\\nTo solve this problem, we need to check whether each word can be typed using letters from only one row of the American keyboard. We can achieve this by iterating through each word and checking if all its characters belong to the same row.\\n\\n**Logic:**\\n1. Create three sets to store the characters of each row in the American keyboard: `firstRow`, `secondRow`, and `thirdRow`. Initialize them with the corresponding characters.\\n2. Initialize an empty list `res` to store the words that can be typed using only one row.\\n3. Loop through each word in the input array `words`.\\n4. For each word, convert it to lowercase (to handle both uppercase and lowercase characters).\\n5. Check if all characters of the word belong to the same row:\\n   - Create a boolean variable `canBeTyped` and set it to `true`.\\n   - For each character in the word, check if it belongs to the first row (`firstRow.indexOf(c) != -1`). If not, set `canBeTyped` to `false` and break the loop.\\n   - If `canBeTyped` is still `true` after checking all characters, it means the word can be typed using the first row. Add the word to the `res` list and continue to the next word.\\n   - Repeat the above steps for the second and third rows, adding the word to the `res` list if it can be typed using any of these rows.\\n6. Convert the `res` list to the final result array `ans`.\\n7. Return the `ans` array containing words that can be typed using only one row.\\n\\n**Step-by-Step Example:**\\nLet\\'s take an example to understand the approach better:\\nInput: words = [\"Hello\", \"Alaska\", \"Dad\", \"Peace\"]\\n\\n1. Initialize three sets: `firstRow = {\"q\", \"w\", \"e\", \"r\", \"t\", \"y\", \"u\", \"i\", \"o\", \"p\"}`, `secondRow = {\"a\", \"s\", \"d\", \"f\", \"g\", \"h\", \"j\", \"k\", \"l\"}`, `thirdRow = {\"z\", \"x\", \"c\", \"v\", \"b\", \"n\", \"m\"}`.\\n2. Initialize an empty list `res`.\\n3. For the first word \"Hello\":\\n   - Convert it to lowercase: \"hello\".\\n   - Check each character: \\'h\\', \\'e\\', \\'l\\', \\'l\\', \\'o\\'.\\n   - All characters are in the second row (`secondRow.indexOf(\\'h\\') != -1` is true), so `canBeTyped = true`.\\n   - Add \"Hello\" to `res` and continue to the next word.\\n4. For the second word \"Alaska\":\\n   - Convert it to lowercase: \"alaska\".\\n   - Check each character: \\'a\\', \\'l\\', \\'a\\', \\'s\\', \\'k\\', \\'a\\'.\\n   - First character \\'a\\' is in the second row, but the second character \\'l\\' is in the third row, so `canBeTyped = false`.\\n   - Move to the next row: check if all characters belong to the third row.\\n   - All characters are in the third row (`thirdRow.indexOf(\\'a\\') != -1`, `thirdRow.indexOf(\\'l\\') != -1`, etc.), so `canBeTyped = true`.\\n   - Add \"Alaska\" to `res` and continue to the next word.\\n5. For the third word \"Dad\":\\n   - Convert it to lowercase: \"dad\".\\n   - Check each character: \\'d\\', \\'a\\', \\'d\\'.\\n   - All characters are in the second row, so `canBeTyped = true`.\\n   - Add \"Dad\" to `res` and continue to the next word.\\n6. For the fourth word \"Peace\":\\n   - Convert it to lowercase: \"peace\".\\n   - Check each character: \\'p\\', \\'e\\', \\'a\\', \\'c\\', \\'e\\'.\\n   - First character \\'p\\' is in the first row, but the second character \\'e\\' is in the second row, so `canBeTyped = false`.\\n   - Move to the next row: check if all characters belong to the second row.\\n   - All characters are in the second row (`secondRow.indexOf(\\'p\\') != -1`, `secondRow.indexOf(\\'e\\') != -1`, etc.), so `canBeTyped = true`.\\n   - Add \"Peace\" to `res` and continue to the next word.\\n\\n7. Convert the `res` list to the final result array `ans`: `ans = [\"Alaska\", \"Dad\"]`.\\n8. Return the `ans` array as the final output.\\n\\n# Complexity    \\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findWords(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        String firstRow = \"qwertyuiop\";\\n        String secondRow = \"asdfghjkl\";\\n        String thirdRow = \"zxcvbnm\";\\n\\n        loop:\\n        for(String word : words) {\\n            char[] chars = word.toLowerCase().toCharArray();\\n\\n            boolean canBeTyped = true;\\n            for(char c : chars) {\\n                int idx = firstRow.indexOf(c);\\n                if(idx == -1) {\\n                    canBeTyped = false;\\n                    break;\\n                }\\n            }\\n            if(canBeTyped) {\\n                res.add(word);\\n                continue loop;\\n            }\\n\\n            canBeTyped = true;\\n            for(char c : chars) {\\n                int idx = secondRow.indexOf(c);\\n                if(idx == -1) {\\n                    canBeTyped = false;\\n                    break;\\n                }\\n            }\\n            if(canBeTyped) {\\n                res.add(word);\\n                continue loop;\\n            }\\n\\n            canBeTyped = true;\\n            for(char c : chars) {\\n                int idx = thirdRow.indexOf(c);\\n                if(idx == -1) {\\n                    canBeTyped = false;\\n                    break;\\n                }\\n            }\\n            if(canBeTyped) {\\n                res.add(word);\\n                continue loop;\\n            }\\n        }\\n        \\n        String[] ans = new String[res.size()];\\n        int i = 0;\\n        for(String word : res) {\\n            ans[i++] = word;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\n***Optimized Version:***\\n```\\nclass Solution {\\n    public String[] findWords(String[] words) {\\n        List<String> res = new ArrayList<>();\\n\\n        loop:\\n        for (String word : words) {\\n            char[] chars = word.toLowerCase().toCharArray();\\n            if (canBeTypedUsingRow(chars, \"qwertyuiop\") || canBeTypedUsingRow(chars, \"asdfghjkl\") || canBeTypedUsingRow(chars, \"zxcvbnm\")) {\\n                res.add(word);\\n            }\\n        }\\n\\n        String[] ans = new String[res.size()];\\n        int i = 0;\\n        for (String word : res) {\\n            ans[i++] = word;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean canBeTypedUsingRow(char[] chars, String row) {\\n        for (char c : chars) {\\n            if (row.indexOf(c) == -1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-k-digits",
        "tags": "java",
        "release_time": 1680704468,
        "code": "class Solution {\n    public String removeKdigits(String num, int k) {\n        Stack<Character> st = new Stack<>();\n        for(Character ch : num.toCharArray()) {\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\n                st.pop();\n                k--;\n            }\n\n            if(!st.isEmpty() || ch != '0') {\n                st.push(ch);\n            }\n        }\n\n        // This is a special edge case --> 1 2 3 4\n        while(!st.isEmpty() && k-- > 0) {\n            st.pop();\n        }\n        if(st.isEmpty()) return \"0\";\n        \n\n        // Store the ans -->\n        String ans = \"\";\n        while(!st.isEmpty()) {\n            ans = st.peek() + ans;\n            st.pop();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\n    public String removeKdigits(String num, int k) {\\n        Stack<Character> st = new Stack<>();\\n        for(Character ch : num.toCharArray()) {\\n            while(!st.isEmpty() && k > 0 && ch < st.peek()) {\\n                st.pop();\\n                k--;\\n            }\\n\\n            if(!st.isEmpty() || ch != \\'0\\') {\\n                st.push(ch);\\n            }\\n        }\\n\\n        // This is a special edge case --> 1 2 3 4\\n        while(!st.isEmpty() && k-- > 0) {\\n            st.pop();\\n        }\\n        if(st.isEmpty()) return \"0\";\\n        \\n\\n        // Store the ans -->\\n        String ans = \"\";\\n        while(!st.isEmpty()) {\\n            ans = st.peek() + ans;\\n            st.pop();\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimize-the-maximum-difference-of-pairs",
        "tags": "java",
        "release_time": 1691551599,
        "code": "class Solution {\n    public int minimizeMax(int[] A, int p) {\n        int n = A.length;\n        Arrays.sort(A);\n        int l = 0;\n        int r = A[n-1]-A[0];\n        int mid;\n        while(l<r){\n            mid = (l+r)/2;\n            if(helper(A, mid, p)>=p) r = mid;\n            else l = mid +1;\n        }\n        return l;\n    }\n    \n    public int helper(int [] A, int diff, int p){\n        int i = 1; int count = 0;\n        while(i<A.length){\n            if(A[i]-A[i-1]<=diff){\n                i++;\n                count++;\n            }\n            i++;\n        }\n        return count;\n    }\n}",
        "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/kvEVrnNuIUc\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public int minimizeMax(int[] A, int p) {\\n        int n = A.length;\\n        Arrays.sort(A);\\n        int l = 0;\\n        int r = A[n-1]-A[0];\\n        int mid;\\n        while(l<r){\\n            mid = (l+r)/2;\\n            if(helper(A, mid, p)>=p) r = mid;\\n            else l = mid +1;\\n        }\\n        return l;\\n    }\\n    \\n    public int helper(int [] A, int diff, int p){\\n        int i = 1; int count = 0;\\n        while(i<A.length){\\n            if(A[i]-A[i-1]<=diff){\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minimizeMax(vector<int>& A, int p) {\\n        int n = A.size();\\n        sort(A.begin(), A.end());\\n        int l = 0;\\n        int r = A[n - 1] - A[0];\\n        int mid;\\n        while (l < r) {\\n            mid = (l + r) / 2;\\n            if (helper(A, mid, p) >= p) {\\n                r = mid;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n\\n    int helper(vector<int>& A, int diff, int p) {\\n        int i = 1, count = 0;\\n        while (i < A.size()) {\\n            if (A[i] - A[i - 1] <= diff) {\\n                i++;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def minimizeMax(self, A: List[int], p: int) -> int:\\n        n = len(A)\\n        A.sort()\\n        l, r = 0, A[n - 1] - A[0]\\n        while l < r:\\n            mid = (l + r) // 2\\n            if self.helper(A, mid, p) >= p:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n    \\n    def helper(self, A: List[int], diff: int, p: int) -> int:\\n        i, count = 1, 0\\n        while i < len(A):\\n            if A[i] - A[i - 1] <= diff:\\n                i += 1\\n                count += 1\\n            i += 1\\n        return count\\n\\n```"
    },
    {
        "slug": "transpose-matrix",
        "tags": "java",
        "release_time": 1683736465,
        "code": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int[][] ans = new int[matrix[0].length][matrix.length];\n        int row = 0;\n        int col = 0;\n\n        for(int i = 0; i < matrix.length; i++) {\n            for(int j = 0; j < matrix[0].length; j++) {\n                ans[row][col] = matrix[i][j];\n\n                row++;\n\n                if(row % ans.length == 0) {\n                    row = 0;\n                    col++;\n                }\n            }\n        }\n        return ans;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] transpose(int[][] matrix) {\\n        int[][] ans = new int[matrix[0].length][matrix.length];\\n        int row = 0;\\n        int col = 0;\\n\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                ans[row][col] = matrix[i][j];\\n\\n                row++;\\n\\n                if(row % ans.length == 0) {\\n                    row = 0;\\n                    col++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "largest-substring-between-two-equal-characters",
        "tags": "java",
        "release_time": 1675183693,
        "code": "class Solution {\n    public int maxLengthBetweenEqualCharacters(String s) {\n        int res=-1;\n        HashMap<Character,Integer> hm=new HashMap<>();\n        for(int i=0;i<s.length();i++){\n            char c=s.charAt(i);\n            if(hm.containsKey(c))\n                res=Math.max(res,i-hm.get(c)-1);\n            else\n                hm.put(c,i);\n        }\n\n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Store each char along with their position in a HashMap.\\n- If a char occurs again, calc their index diffrences.\\n- return the max difference.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(min(n, k))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxLengthBetweenEqualCharacters(String s) {\\n        int res=-1;\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            if(hm.containsKey(c))\\n                res=Math.max(res,i-hm.get(c)-1);\\n            else\\n                hm.put(c,i);\\n        }\\n\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-sum-of-an-hourglass",
        "tags": "java",
        "release_time": 1665324662,
        "code": "class Solution {\n    public int maxSum(int[][] grid) {\n        int max = -1, m = grid.length, n = grid[0].length;\n        for (int row = 0; row < m - 2; row++) {\n            for (int col = 0; col < n - 2; col++) {\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\n                temp += grid[row + 1][col + 1];\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\n                if (max < temp) {\n                    max = temp;\n                }\n            }\n        }\n        return max;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int maxSum(int[][] grid) {\\n        int max = -1, m = grid.length, n = grid[0].length;\\n        for (int row = 0; row < m - 2; row++) {\\n            for (int col = 0; col < n - 2; col++) {\\n                int temp = grid[row][col] + grid[row][col + 1] + grid[row][col + 2];\\n                temp += grid[row + 1][col + 1];\\n                temp += grid[row + 2][col] + grid[row + 2][col + 1] + grid[row + 2][col + 2];\\n                if (max < temp) {\\n                    max = temp;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-subsequence-in-non-increasing-order",
        "tags": "java",
        "release_time": 1687718829,
        "code": "class Solution {\n    public List<Integer> minSubsequence(int[] nums) {\n       int n = nums.length;\n       Arrays.sort(nums);\n       int sum=0,s=0;\n       List<Integer> list = new ArrayList<>();\n       for(int i=0;i<n;i++){\n           sum+=nums[i];\n       }\n       for(int j=n-1;j>=0;j--){\n           s+=nums[j];\n           sum=sum-nums[j];\n           list.add(nums[j]);\n           if(s>sum){\n               break;\n           }\n       }\n       return list; \n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> minSubsequence(int[] nums) {\\n       int n = nums.length;\\n       Arrays.sort(nums);\\n       int sum=0,s=0;\\n       List<Integer> list = new ArrayList<>();\\n       for(int i=0;i<n;i++){\\n           sum+=nums[i];\\n       }\\n       for(int j=n-1;j>=0;j--){\\n           s+=nums[j];\\n           sum=sum-nums[j];\\n           list.add(nums[j]);\\n           if(s>sum){\\n               break;\\n           }\\n       }\\n       return list; \\n    }\\n}\\n```"
    },
    {
        "slug": "richest-customer-wealth",
        "tags": "java",
        "release_time": 1677838003,
        "code": "class Solution {\n    public int maximumWealth(int[][] accounts) {\n        int largest = accounts[0][0];\n        for(int customer[] : accounts){\n            int currentSum = 0;\n            for(int bank : customer) currentSum += bank;\n            largest = Math.max(largest, currentSum);\n        }\n        return largest;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity -> O(n x m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity -> O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssssssss Up Vote (^-^)\\n![images.jpeg](https://assets.leetcode.com/users/images/53cdccd9-6cb0-4b64-9808-5c2e027c747f_1678719675.3869877.jpeg)\\nPlssssssss Up Vote (^-^)\\n\\n`Very much thank you for visiting (*_*)` \\u2764\\uFE0F\\n\\n`Comment below and get a Up vote!` \\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\n    public int maximumWealth(int[][] accounts) {\\n        int largest = accounts[0][0];\\n        for(int customer[] : accounts){\\n            int currentSum = 0;\\n            for(int bank : customer) currentSum += bank;\\n            largest = Math.max(largest, currentSum);\\n        }\\n        return largest;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-unequal-triplets-in-array",
        "tags": "java",
        "release_time": 1668916901,
        "code": "class Solution {\n    public int unequalTriplets(int[] nums) {\n        int ans=0;\n        for(int i=0; i < nums.length; i++)\n            for(int j=i+1; j < nums.length; j++)\n                for(int k=j+1; k < nums.length; k++)\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\n                        ans++;\n        return ans;\n    }\n}",
        "content": "* *Time Complexity :* **O(n^3)**\\n* *Space Complexity :* **O(1)**\\n##### Java\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i < nums.length; i++)\\n            for(int j=i+1; j < nums.length; j++)\\n                for(int k=j+1; k < nums.length; k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n        return ans;\\n    }\\n}\\n```\\n##### C++\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                for(int k = j + 1; k < nums.size(); k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n\\t\\t\\t\\t\\t\\tans++;\\n        return ans;\\n    }\\n};\\n```\\n##### Python\\n```\\nclass Solution(object):\\n    def unequalTriplets(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```"
    },
    {
        "slug": "to-lower-case",
        "tags": "java",
        "release_time": 1689583806,
        "code": "class Solution {\n    public String toLowerCase(String s) {\n        return s.toLowerCase();\n        \n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toLowerCase(String s) {\\n        return s.toLowerCase();\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "cinema-seat-allocation",
        "tags": "java",
        "release_time": 1644478675,
        "code": "class Solution {\n    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {\n        Map<Integer,List<Integer>> map = new HashMap<>();\n        \n        \n        for(int[] i : reservedSeats){\n            map.putIfAbsent(i[0],new ArrayList<>());\n            map.get(i[0]).add(i[1]);\n        }\n        \n        \n        int ans = 2*(n - map.size());\n        \n        for(Map.Entry<Integer,List<Integer>> entry : map.entrySet()){\n            List<Integer> seats = entry.getValue();\n            \n            boolean isLeftAisle = false, isRightAisle = false, isMiddle = false;\n            \n            for(int seat : seats){\n                \n                if(seat >= 2 && seat <= 5)\n                    isLeftAisle = true;\n                if(seat >= 6 && seat <= 9)\n                    isRightAisle = true;\n                if(seat >=4 && seat <= 7)\n                    isMiddle = true;\n                    \n                if(isLeftAisle && isRightAisle && isMiddle){\n                    break;\n                }\n            }\n            \n            if(!isLeftAisle)\n                ans += 1;\n            if(!isRightAisle)\n                ans += 1;\n            if(isLeftAisle && isRightAisle && !isMiddle)\n                ans += 1;\n            \n        }\n       \n        return ans;\n        \n    }\n}",
        "content": "I have solved this question using HashMap and Simple If-Else.\\n\\nFirst try to understand at max how many such group of 4 persons you can allow in a row if all seats are available? The answer is 2. How? \\nAs per the question, we know that there are 3 sections -\\n1. Left Aisle -> starts from column 2 and ends at column 5\\n2. Middle -> starts from column 4 and ends at column 7\\n3. Right Aisle -> starts from column 6 and ends at column 9\\n\\nColumn 1 & 10 doesnt have any importance.\\n\\nNow, Let\\'s say I take the middle (4-7) to allow group of 4 person, then I wont be able to use either of the aisle. In this case I allowed 1 group.\\n\\nNow, Let\\'s say, I take both the aisles instead of middle i.e., I put 1 group of 4 people in left aisle and another 1 group of 4 people in right aisle, then I wont be able to use middle. In this case I allowed 2 groups.\\n\\nHence I can say that if column from 2-9 is available then I will greedily choose the two aisles instead of middle and thus allowing max groups in a particular row. \\n\\nWhat if either of the aisle is blocked? \\n\\nWhenever an aisle is blocked there can be two scenarios -\\n\\n1. Only left half (2-3 column) of left aisle is blocked and not the right half of left aisle which lies in middle(4-5 column). Similarly, only right half (8-9 column) of right aisle is blocked and not the left half of right aisle which lies in middle(6-7 column) or both.\\n\\t\\t\\ta. I can use the middle if both the aisles are blocked. Then I can allow max of 1 group which is in the middle.\\n\\t\\t\\tb. I can use either middle or any one of the aisle which is free. Then I can allow max of 1 group which can be in the middle or either of the free aisle.\\n\\t\\t\\t\\nHence in this scenario, I can allow a max of 1 group.\\n\\n2. Right Half of Left Aisle (4-5 columns) or Left Half of Right Aisle (6-7 columns) or both is blocked which lies in middle (4-7 columns).\\n\\t\\t\\ta. I can use either of the free aisle. Then I can allow max of 1 group which is in either of the free aisle.\\n\\t\\t\\tb. I cannot allow group because if both aisle blocked based in above columns placement, then it blocks all the section. Then 0 groups allowed.\\n\\t\\t\\t\\nHence in this scenario, I can allow a max of 1 group if either of the aisle is free else 0.\\n\\nWhat if middle is blocked?\\n\\nWhenever middle is blocked there can be 1 scenario -\\n\\n1. Only left half (4-5 column) of middle and right half(4-5) of left aisle is blocked. Similarly, only right half (6-7 column) of middle and left half of right aisle is blocked or both.\\n\\t\\t\\ta. I can use either of the free aisle which is free. Then I can allow max of 1 group which can be in the middle or either of the free aisle or else 0 if both aisle blocked.\\n\\t\\t\\t\\nHence in this scenario, I can allow a max of 1 group if either of the aisle is free or else 0 group.\\n\\nNow that I am clear on positioning and accordingly allocationg, I need to form the conditions based on which I will keep on adding the max groups that I can allow in every row.\\n\\nOne catch here -> Let\\'s say there are **n** rows. In the **reservedSeats** array, it will have only those row information for which certain seats/columns are blocked. This means that the rows for which all seats are available can be easily taken into consideration without any checks. Based on the above explanations, I can confidently say that, if any row has all seats available, then I can allow max of 2 groups. Then I can say\\n\\t ****Initial ans = 2(TotalNoOfRows-noOfRowsNotHavingAllSeatsAvailable)**** \\n\\n\\nSteps :\\n\\n1. Create a Hashmap to store row to columns/seats mapping. For each row what all columns/seats are blocked. Row is key and value is List of columns/seats blocked in that row.\\n2. **n** is the total no of rows. Size of HashMap will give the no of rows not having all seats available.\\n3. Take initial ans =  2*(n-size of hashmap)\\n4.  Run for loop to loop through hashmap.\\n\\t\\ta. For each row, store the list of columns(seats) in a List.\\n\\t\\tb. Initialize 3 boolean variable -> leftaisle : false, rightfalse : false, middle : false. Here false means it is not blocked.\\n\\t\\tb. Loop through the above list\\n\\t\\t\\t\\t\\t\\ti. Check if the column(seat) lies in left aisle. If yes, then make leftaisle : true\\n\\t\\t\\t\\t\\t\\tii. Check if the column(seat) lies in right aisle. If yes, then make rightaisle : true\\n\\t\\t\\t\\t\\t\\tiii. Check if the column(seat) lies in middle. If yes, then make middle : true\\n\\t\\t\\t\\t\\t\\tiv. Check if all the three boolean variables(three sections) are blocked i.e., having true as values, then terminate the loop. This step is to avoid further checks as it doesn\\'t make any sense to keep on checking if at any point I found that I cannot use any of the sections.\\n\\t\\tc. Check if leftaisle is false which means its free, then add 1 to ans.\\n\\t\\td. Check if rightaisle is false which means its free, then add 1 to ans.\\n\\t\\te. Check if middle is false which means its free but both the aisles are true which means its blocked, then add 1 to ans;\\n5. Return ans;\\t\\n\\n\\n```\\nclass Solution {\\n    public int maxNumberOfFamilies(int n, int[][] reservedSeats) {\\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        \\n        for(int[] i : reservedSeats){\\n            map.putIfAbsent(i[0],new ArrayList<>());\\n            map.get(i[0]).add(i[1]);\\n        }\\n        \\n        \\n        int ans = 2*(n - map.size());\\n        \\n        for(Map.Entry<Integer,List<Integer>> entry : map.entrySet()){\\n            List<Integer> seats = entry.getValue();\\n            \\n            boolean isLeftAisle = false, isRightAisle = false, isMiddle = false;\\n            \\n            for(int seat : seats){\\n                \\n                if(seat >= 2 && seat <= 5)\\n                    isLeftAisle = true;\\n                if(seat >= 6 && seat <= 9)\\n                    isRightAisle = true;\\n                if(seat >=4 && seat <= 7)\\n                    isMiddle = true;\\n                    \\n                if(isLeftAisle && isRightAisle && isMiddle){\\n                    break;\\n                }\\n            }\\n            \\n            if(!isLeftAisle)\\n                ans += 1;\\n            if(!isRightAisle)\\n                ans += 1;\\n            if(isLeftAisle && isRightAisle && !isMiddle)\\n                ans += 1;\\n            \\n        }\\n       \\n        return ans;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-operations-to-make-array-equal",
        "tags": "java",
        "release_time": 1691588994,
        "code": "class Solution {\n    public int minOperations(int n) {\n        int result = 0;\n        \n        if (n % 2 == 0) {\n            result = (n / 2) * (n / 2);\n        } else {\n            result = ((n - 1) / 2) * ((n + 1) / 2);\n        }\n        \n        return result;\n    }\n}",
        "content": "# Intuition\\njust observe the pattern\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int n) {\\n        int result = 0;\\n        \\n        if (n % 2 == 0) {\\n            result = (n / 2) * (n / 2);\\n        } else {\\n            result = ((n - 1) / 2) * ((n + 1) / 2);\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "merge-strings-alternately",
        "tags": "java",
        "release_time": 1692376529,
        "code": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n     char [] arr1=word1.toCharArray();\n     char [] arr2=word2.toCharArray();\n     char [] merge = new char[arr1.length+arr2.length];\n    int i=0,j=0;\n    while( i< merge.length){\n        if(j<arr1.length){\n            merge[i]=arr1[j];\n            i++;\n        }\n        if( j< arr2.length){\n            merge[i]=arr2[j];\n            i++;\n        }\n        j++;\n    }\n    return new String(merge);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n Steps of the mergeAlternately function:\\n\\nConvert input strings word1 and word2 into character arrays arr1 and arr2.\\nInitialize a new character array merge with a length of arr1.length + arr2.length to hold the merged characters.\\nInitialize two indices: i for the merge array and j for tracking characters in word2.\\nStart a loop that iterates until the merge array is filled with characters from both input strings:\\na. Check if j is within the bounds of arr1:\\nIf true, assign arr1[j] to merge[i] and increment both i and j.\\nb. Check if j is within the bounds of arr2:\\nIf true, assign arr2[j] to merge[i] and increment both i and j.\\nReturn a new string created from the merge array using the String constructor.\\n\\n# Complexity\\n- Time complexity:\\nO(max(m,n))\\n\\n- Space complexity:\\nO(m,n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String mergeAlternately(String word1, String word2) {\\n     char [] arr1=word1.toCharArray();\\n     char [] arr2=word2.toCharArray();\\n     char [] merge = new char[arr1.length+arr2.length];\\n    int i=0,j=0;\\n    while( i< merge.length){\\n        if(j<arr1.length){\\n            merge[i]=arr1[j];\\n            i++;\\n        }\\n        if( j< arr2.length){\\n            merge[i]=arr2[j];\\n            i++;\\n        }\\n        j++;\\n    }\\n    return new String(merge);\\n    }\\n}\\n```"
    },
    {
        "slug": "optimal-partition-of-string",
        "tags": "java",
        "release_time": 1692452053,
        "code": "class Solution {\n    public int partitionString(String s) {\n        char[] arr = s.toCharArray();\n        int i = 0;\n        int count = 0;\n        \n        while (i < arr.length) {\n            int j = i + 1;\n            boolean[] seen = new boolean[26]; // To track characters seen in the current substring\n            \n            seen[arr[i] - 'a'] = true; // Mark the first character as seen\n            \n            while (j < arr.length && !seen[arr[j] - 'a']) {\n                seen[arr[j] - 'a'] = true; // Mark new characters as seen\n                j++;\n            }\n            \n            count++; // Increment the count for each substring\n            i = j; // Move i to the next substring\n        }\n        \n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionString(String s) {\\n        char[] arr = s.toCharArray();\\n        int i = 0;\\n        int count = 0;\\n        \\n        while (i < arr.length) {\\n            int j = i + 1;\\n            boolean[] seen = new boolean[26]; // To track characters seen in the current substring\\n            \\n            seen[arr[i] - \\'a\\'] = true; // Mark the first character as seen\\n            \\n            while (j < arr.length && !seen[arr[j] - \\'a\\']) {\\n                seen[arr[j] - \\'a\\'] = true; // Mark new characters as seen\\n                j++;\\n            }\\n            \\n            count++; // Increment the count for each substring\\n            i = j; // Move i to the next substring\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "furthest-building-you-can-reach",
        "tags": "java",
        "release_time": 1689069278,
        "code": "class Solution {\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\n        PriorityQueue<Integer> p = new PriorityQueue<>();\n        for(int i=1;i<heights.length;i++){\n            int diff = heights[i] - heights[i-1];\n            if(diff > 0){\n                p.add(diff);\n            }\n            if(p.size() > ladders){\n                bricks -= p.poll();\n            }\n            if(bricks < 0){\n                return i-1;\n            }\n        }\n        if(bricks >= 0) return heights.length-1;\n        return -1;\n    }\n}",
        "content": "# Intuition\\nIdeally we have to use top \\'ladders\\' positive differences in building heighs using ladders and redst using bricks. So we have to maintain a min heap which keeps track positive differences, only the top \\'ladders\\' greatest differences will be used by ladders..\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int furthestBuilding(int[] heights, int bricks, int ladders) {\\n        PriorityQueue<Integer> p = new PriorityQueue<>();\\n        for(int i=1;i<heights.length;i++){\\n            int diff = heights[i] - heights[i-1];\\n            if(diff > 0){\\n                p.add(diff);\\n            }\\n            if(p.size() > ladders){\\n                bricks -= p.poll();\\n            }\\n            if(bricks < 0){\\n                return i-1;\\n            }\\n        }\\n        if(bricks >= 0) return heights.length-1;\\n        return -1;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-product-difference-between-two-pairs",
        "tags": "java",
        "release_time": 1683517149,
        "code": "class Solution {\n    public int maxProductDifference(int[] nums) {\n        Arrays.sort(nums);\n        int n =nums.length;\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\n    }\n}",
        "content": "\\n\\n#  Superb Logic in java\\n```\\nclass Solution {\\n    public int maxProductDifference(int[] nums) {\\n        Arrays.sort(nums);\\n        int n =nums.length;\\n    return nums[n-1]*nums[n-2]-nums[0]*nums[1];\\n    }\\n}\\n```\\n# please upvote me it would encourages me so much"
    },
    {
        "slug": "n-ary-tree-preorder-traversal",
        "tags": "java",
        "release_time": 1676960316,
        "code": "class Solution {\n    List<Integer> arr = new ArrayList<>();\n    public List<Integer> preorder(Node root) {\n        if (root==null) return arr;\n        arr.add(root.val);\n        for (Node i : root.children) {\n            preorder(i);\n        }\n        return arr;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    List<Integer> arr = new ArrayList<>();\\n    public List<Integer> preorder(Node root) {\\n        if (root==null) return arr;\\n        arr.add(root.val);\\n        for (Node i : root.children) {\\n            preorder(i);\\n        }\\n        return arr;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-strength-of-a-group",
        "tags": "java",
        "release_time": 1685203355,
        "code": "class Solution {\n    private long maxStrength;\n\n    public long maxStrength(int[] nums) {\n        maxStrength = Integer.MIN_VALUE;\n        helper(nums, 0, 1, 0);\n        return maxStrength;\n    }\n\n    private void helper(int[] nums, int index, long product, int size) {\n        if (index >= nums.length) {\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\n            return;\n        }\n\n        helper(nums, index + 1, product * nums[index], size + 1);\n        helper(nums, index + 1, product, size);\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    private long maxStrength;\\n\\n    public long maxStrength(int[] nums) {\\n        maxStrength = Integer.MIN_VALUE;\\n        helper(nums, 0, 1, 0);\\n        return maxStrength;\\n    }\\n\\n    private void helper(int[] nums, int index, long product, int size) {\\n        if (index >= nums.length) {\\n            if(size != 0) maxStrength = Math.max(maxStrength, product);\\n            return;\\n        }\\n\\n        helper(nums, index + 1, product * nums[index], size + 1);\\n        helper(nums, index + 1, product, size);\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "search-insert-position",
        "tags": "java",
        "release_time": 1691938245,
        "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        ArrayList<Integer>atr=new ArrayList<>();\n        for(int a:nums){\n            atr.add(a);\n        }\n        atr.add(target);\n        Collections.sort(atr);\n        int k=atr.indexOf(target);\n        return k;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7c0897c-8dc0-4fa5-aeca-e836b2887d45_1691938187.8801217.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        ArrayList<Integer>atr=new ArrayList<>();\\n        for(int a:nums){\\n            atr.add(a);\\n        }\\n        atr.add(target);\\n        Collections.sort(atr);\\n        int k=atr.indexOf(target);\\n        return k;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-number-of-integers-to-choose-from-a-range-i",
        "tags": "java",
        "release_time": 1679763684,
        "code": "class Solution {\n    public int maxCount(int[] banned, int n, int maxSum) {\n\n        // Create a HashSet of banned integers for fast lookup\n        Set<Integer> banSet = new HashSet<>();\n        for (int num : banned) {\n            banSet.add(num);\n        }\n\n        // Initialize count and sum to 0\n        int count = 0;\n        int sum = 0;\n\n        // Iterate over the range [1, n]\n        for (int i = 1; i <= n; i++) {\n\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\n            // Increment count and add the current integer to sum\n                count++;\n                sum += i;\n            }\n        }\n    // Return the maximum count of chosen integers\n    return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/bfae0867-a2e9-46fd-a802-cdd36cf2f897_1679763680.3311183.png)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int[] banned, int n, int maxSum) {\\n\\n        // Create a HashSet of banned integers for fast lookup\\n        Set<Integer> banSet = new HashSet<>();\\n        for (int num : banned) {\\n            banSet.add(num);\\n        }\\n\\n        // Initialize count and sum to 0\\n        int count = 0;\\n        int sum = 0;\\n\\n        // Iterate over the range [1, n]\\n        for (int i = 1; i <= n; i++) {\\n\\n            // Check if the current integer is not banned and adding it to sum does not exceed maxSum\\n            if (!banSet.contains(i) && (sum + i <= maxSum)) {\\n            // Increment count and add the current integer to sum\\n                count++;\\n                sum += i;\\n            }\\n        }\\n    // Return the maximum count of chosen integers\\n    return count;\\n    }\\n}\\n\\n\\n```"
    },
    {
        "slug": "intersection-of-two-linked-lists",
        "tags": "java",
        "release_time": 1688896252,
        "code": "public class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n\n        ListNode a = headA;\n        ListNode b = headB;\n\n        while(a!=b) {\n            a = a==null ? headB : a.next;\n            b = b==null ? headA : b.next;\n        }\n        return a;\n    }\n}",
        "content": "# Code\\n```\\npublic class Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n\\n        ListNode a = headA;\\n        ListNode b = headB;\\n\\n        while(a!=b) {\\n            a = a==null ? headB : a.next;\\n            b = b==null ? headA : b.next;\\n        }\\n        return a;\\n    }\\n}\\n```"
    },
    {
        "slug": "gas-station",
        "tags": "java",
        "release_time": 1688419594,
        "code": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int extraFuel=0, reqiuredFuel=0,start=0;\n        for(int i=0;i<gas.length;i++){\n            extraFuel+=(gas[i]-cost[i]);\n            if(extraFuel<0){\n                start=i+1;\n                reqiuredFuel+=extraFuel;\n                extraFuel=0;\n            }\n        }\n        if(reqiuredFuel+extraFuel>=0){\n            return start;\n        }\n        return -1;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int canCompleteCircuit(int[] gas, int[] cost) {\\n        int extraFuel=0, reqiuredFuel=0,start=0;\\n        for(int i=0;i<gas.length;i++){\\n            extraFuel+=(gas[i]-cost[i]);\\n            if(extraFuel<0){\\n                start=i+1;\\n                reqiuredFuel+=extraFuel;\\n                extraFuel=0;\\n            }\\n        }\\n        if(reqiuredFuel+extraFuel>=0){\\n            return start;\\n        }\\n        return -1;\\n    }\\n}\\n```"
    },
    {
        "slug": "stone-game-v",
        "tags": "java",
        "release_time": 1603754086,
        "code": "class Solution {\n    public int stoneGameV(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] pre = new int[n+1];\n        for(int i = 1; i <= n; i++) {\n            pre[i] = pre[i-1] + stoneValue[i-1];\n        }\n        int[][] dp = new int[n][n];\n        for(int l = 1; l < n; l++) {\n            for(int i = 0; i < n-l; i++) {\n                int j = i+l, res = 0;\n                for(int k = i; k < j; k++) {\n                    int left = pre[k+1] - pre[i], right = pre[j+1] - pre[k+1];\n                    if(left < right) {\n                        res = Math.max(res, left + dp[i][k]);\n                    } else if(left > right) {\n                        res = Math.max(res, right + dp[k+1][j]);\n                    } else {\n                        res = Math.max(res, left + dp[i][k]);\n                        res = Math.max(res, right + dp[k+1][j]);\n                    }\n                }\n                dp[i][j] = res;\n            }\n        }\n        return dp[0][n-1];\n    }\n}",
        "content": "**O(n^3)**\\n\\n**Basic approach**\\ndp[i][j]: max score you can obtain from stones[i..j]\\nsum[i][j]: sum of stoneValues[i..j]\\nTry all possible k i.e. k goes from i to j-1:\\nwe have 2 choices for score: **sum[i][k] + dp[i][k]** and **sum[k+1][j] + dp[k+1][j]**\\nbut we can only pick the side where sum is smaller or either of them when both sides are equal.\\nTake the maximum score from all of these choices and we have computed dp[i][j].\\nIn all my codes, I am building the dp table bottom-up i.e. dp[0][1], dp[1][2] gets calculated before dp[0][2].\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n];\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, res = 0;\\n                for(int k = i; k < j; k++) {\\n                    int left = pre[k+1] - pre[i], right = pre[j+1] - pre[k+1];\\n                    if(left < right) {\\n                        res = Math.max(res, left + dp[i][k]);\\n                    } else if(left > right) {\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    } else {\\n                        res = Math.max(res, left + dp[i][k]);\\n                        res = Math.max(res, right + dp[k+1][j]);\\n                    }\\n                }\\n                dp[i][j] = res;\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\\n\\n**O(n^2 log n)**\\n\\n**Optimization**\\nAs k goes from i to j in stones[i..j], sum of left part sum[i][k] increases continuously and it remains a valid subarray for our consideration for calculating dp[i][j] until the point when it becomes greater than right half. From that point onwards, all the right ones are valid subarrays for consideration. We can find this critical k (= **k\\'**) using binary search. Forget about boundary cases and equal halves etc for now, just try to understand the general idea.\\n\\ndp[i][j] = max( max(sum[i][k] + dp[i][k]) for k: i to **k\\'**, max(sum[k][j] + dp[k][j]) for k: **k\\'**+1 to j )\\n(refer to the code for exact condition for all cases)\\n\\nIf we have to calculate first and second terms in above by iterating from k: i to **k\\'** or k: **k\\'**+1 to j, then it\\'d take O(n) time and we are back to first solution. What we can instead do is maintain 2 more arrays defined as:\\nleft[i][j] = max( sum[i][k] + dp[i][k] for k: i to j )\\nright[i][j] = max( sum[k][j] + dp[k][j] for k: i to j )\\n\\nand use them to redefine dp[i][j] = max( left[i][**k\\'**], right[**k\\'**+1][j] )\\n\\nNote that left and right arrays can also be calculated along with dp table so they don\\'t increase our worst case time complexity.\\n\\nleft[i][j] = max( left[i][j-1],  sum[i][j] + dp[i][j] )\\nright[i][j] = max( right[i+1][j],  sum[i][j] + dp[i][j] )\\n\\nWith these ideas in mind and taking care of boundary cases like **k\\'** == i or **k\\'** == j and equal halves etc, we have our solution ready.\\n\\n```\\nclass Solution {\\n    // returns first index where sum of left half >= sum of right half\\n    private int search(int[] pre, int l, int r) {\\n        int sum = pre[r+1] - pre[l], L = l;\\n        while(l < r) {\\n            int m = l + ((r - l) >> 1);\\n            if(((pre[m+1] - pre[L]) << 1) >= sum) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[] pre = new int[n+1];\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + stoneValue[i-1];\\n        }\\n        int[][] dp = new int[n][n], left = new int[n][n], right = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            left[i][i] = right[i][i] = stoneValue[i];\\n        }\\n        for(int l = 1; l < n; l++) {\\n            for(int i = 0; i < n-l; i++) {\\n                int j = i+l, k = search(pre, i, j);\\n                int sum = pre[j+1] - pre[i], leftHalf = pre[k+1] - pre[i];\\n                if((leftHalf << 1) == sum) {    // equal parts\\n                    dp[i][j] = Math.max(left[i][k], right[k+1][j]);\\n                } else {    // left half > right half\\n                    dp[i][j] = Math.max(k == i ? 0 : left[i][k-1], k == j ? 0 : right[k+1][j]);\\n                }\\n                left[i][j] = Math.max(left[i][j-1], sum + dp[i][j]);\\n                right[i][j] = Math.max(right[i+1][j], sum + dp[i][j]);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```\\n\\n**O(n^2)**\\n\\n**Optimization**\\nWe can optimize the previous solution even further by getting rid of the binary search step needed to find the critical k (= **k\\'**) of stones[i..j].\\nBinary search is great when we need the answer for arbitrary i and j but why not calculate dp[i][j] in such an order where we could leverage the **k\\'** information from previous i and j.\\n\\nSuppose we know the **k\\'** for stones[i..j], what do we know about **k\\'** for stones[i..j+1]? It is either the same or it got shifted a few places to the right.\\nAnd so if we calculate dp values in the order: dp[i][i], dp[i][i+1], dp[i][i+2], ..., dp[i][j], we can essentially keep track of **k\\'** as we go within that same linear time bound.\\n\\nUsing this idea, we implement the final solution. Couple of pointers about my code:\\n* mid: represents **k\\'** or first index such that left half >= right half\\n* with i < j, max[i][j] represents left[i][j] of previous solution i.e. max(dp[i][i], dp[i][i+1], dp[i][i+2] .. dp[i][j]) and max[j][i] represents right[i][j] of previous solution i.e. max(dp[i][j], dp[i+1][j], dp[i+2][j] .. dp[j][j]). We could have used two different arrays left and right just like previous solution but this trick saves space.\\n* I am traversing in the order: dp[j][j], dp[j-1,j], dp[j-2, j], .., dp[i][j] instead of the above mentioned order but the idea remains same.\\n\\n```\\nclass Solution {\\n    public int stoneGameV(int[] stoneValue) {\\n        int n = stoneValue.length;\\n        int[][] dp = new int[n][n], max = new int[n][n];\\n        for(int i = 0; i < n; i++) {\\n            max[i][i] = stoneValue[i];\\n        }\\n        for(int j = 1; j < n; j++) {\\n            int mid = j, sum = stoneValue[j], rightHalf = 0;\\n            for(int i = j-1; i >= 0; i--) {\\n                sum += stoneValue[i];\\n                while((rightHalf + stoneValue[mid]) * 2 <= sum) {\\n                    rightHalf += stoneValue[mid--];\\n                }\\n                dp[i][j] = rightHalf * 2 == sum ? max[i][mid] : (mid == i ? 0 : max[i][mid - 1]);\\n                dp[i][j] = Math.max(dp[i][j], mid == j ? 0 : max[j][mid + 1]);\\n                max[i][j] = Math.max(max[i][j - 1], dp[i][j] + sum);\\n                max[j][i] = Math.max(max[j][i + 1], dp[i][j] + sum);\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n}\\n```"
    },
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "tags": "java",
        "release_time": 1683965436,
        "code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int prod=1;\n        int sum=0;\n        while(n>0) {\n            int rem=n%10;\n            sum+=rem;\n            prod*=rem;\n            n/=10;\n        }\n        return prod-sum;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        int prod=1;\\n        int sum=0;\\n        while(n>0) {\\n            int rem=n%10;\\n            sum+=rem;\\n            prod*=rem;\\n            n/=10;\\n        }\\n        return prod-sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "word-search",
        "tags": "java",
        "release_time": 1689140219,
        "code": "class Solution {\n    private boolean visited[][];\n    public boolean exist(char[][] board, String word) {\n        int m=board.length, n=board[0].length;\n        visited=new boolean[m][n];\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;\n            }\n        }\n        return false;\n\n        \n    }\n    public boolean dfs(char[][] board,int i,int j,int index,String word){\n        if(index==word.length()) return true;\n        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){\n            return false;\n        }\n        visited[i][j]=true;\n        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);\n        visited[i][j]  = false;\n        return found;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n- Space complexity:\\nO(m*n)\\n# Code\\n```\\nclass Solution {\\n    private boolean visited[][];\\n    public boolean exist(char[][] board, String word) {\\n        int m=board.length, n=board[0].length;\\n        visited=new boolean[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==word.charAt(0)&&dfs(board,i,j,0,word)) return true;\\n            }\\n        }\\n        return false;\\n\\n        \\n    }\\n    public boolean dfs(char[][] board,int i,int j,int index,String word){\\n        if(index==word.length()) return true;\\n        if(i<0||j<0||i>=board.length||j>=board[0].length||board[i][j]!=word.charAt(index)||visited[i][j]){\\n            return false;\\n        }\\n        visited[i][j]=true;\\n        boolean found= dfs(board,i+1,j,index+1,word)||dfs(board,i-1,j,index+1,word)||dfs(board,i,j+1,index+1,word)||dfs(board,i,j-1,index+1,word);\\n        visited[i][j]  = false;\\n        return found;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-good-nodes-in-binary-tree",
        "tags": "java",
        "release_time": 1690560837,
        "code": "class Solution {\n    int count = 0;\n    \n    public void countGoodNodes(TreeNode root, int maximum) {\n            if(root!=null) {\n                if (maximum <= root.val) {\n                    maximum = root.val;\n                    count++;\n                }\n            countGoodNodes(root.left,maximum);\n            countGoodNodes(root.right, maximum);\n        } \n    }\n\n    public int goodNodes(TreeNode root) {\n        int maximum = root.val;\n        countGoodNodes(root,  maximum);\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    \\n    public void countGoodNodes(TreeNode root, int maximum) {\\n            if(root!=null) {\\n                if (maximum <= root.val) {\\n                    maximum = root.val;\\n                    count++;\\n                }\\n            countGoodNodes(root.left,maximum);\\n            countGoodNodes(root.right, maximum);\\n        } \\n    }\\n\\n    public int goodNodes(TreeNode root) {\\n        int maximum = root.val;\\n        countGoodNodes(root,  maximum);\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "intersection-of-multiple-arrays",
        "tags": "java",
        "release_time": 1650773246,
        "code": "class Solution {\n    public List<Integer> intersection(int[][] nums) {\n        \n        List<Integer> ans = new ArrayList<>();\n        \n        int[] count  = new int[1001];\n        \n        for(int[] arr : nums){\n            for(int i : arr){\n                count[i]++;\n            }\n        }\n        \n       for(int i=0;i<count.length;i++){\n           if(count[i]==nums.length){\n               ans.add(i);\n           }\n       }\n        \n        return ans;\n    }\n}",
        "content": "```\\n\\nclass Solution {\\n    public List<Integer> intersection(int[][] nums) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        \\n        int[] count  = new int[1001];\\n        \\n        for(int[] arr : nums){\\n            for(int i : arr){\\n                count[i]++;\\n            }\\n        }\\n        \\n       for(int i=0;i<count.length;i++){\\n           if(count[i]==nums.length){\\n               ans.add(i);\\n           }\\n       }\\n        \\n        return ans;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "tags": "java",
        "release_time": 1690174250,
        "code": "class Solution {\n    public int isWinner(int[] player1, int[] player2) {\n        int i=1,j=i-1,k=i-2;\n        int p1=player1[0],p2=player2[0];\n        while(i<player1.length){\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\n                p1+=2*player1[i];\n            }\n            else{\n                p1+=player1[i];\n            }\n            i++;\n            j++;\n            k++;\n        }\n        int l=1,m=l-1,n=l-2;\n        while(l<player2.length){\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\n                p2+=2*player2[l];\n            }\n            else{\n                p2+=player2[l];\n            }\n            l++;\n            m++;\n            n++;\n        }\n        if(p1>p2) return 1;\n        else if(p1==p2) return 0;\n        else return 2;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int isWinner(int[] player1, int[] player2) {\\n        int i=1,j=i-1,k=i-2;\\n        int p1=player1[0],p2=player2[0];\\n        while(i<player1.length){\\n            if((j>=0 && player1[j]==10 ) || (k>=0 && player1[k]==10)){\\n                p1+=2*player1[i];\\n            }\\n            else{\\n                p1+=player1[i];\\n            }\\n            i++;\\n            j++;\\n            k++;\\n        }\\n        int l=1,m=l-1,n=l-2;\\n        while(l<player2.length){\\n            if((m>=0 && player2[m]==10 ) || (n>=0 && player2[n]==10)){\\n                p2+=2*player2[l];\\n            }\\n            else{\\n                p2+=player2[l];\\n            }\\n            l++;\\n            m++;\\n            n++;\\n        }\\n        if(p1>p2) return 1;\\n        else if(p1==p2) return 0;\\n        else return 2;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-odd-numbers-in-an-interval-range",
        "tags": "java",
        "release_time": 1683277667,
        "code": "class Solution {\n    public int countOdds(int low, int high) {\n        if(low%2==0 && high%2==0)\n            return (high-low)/2;\n        else\n            return (high-low)/2+1;\n    }\n}",
        "content": "# Intuition\\nAt first i thought to execute it with using loops.\\n\\n# Approach\\nThere are four possible ways to get no.of odd numbers from low and high limits.\\nWhen both numbers are even print half of its difference else by adding one to it.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countOdds(int low, int high) {\\n        if(low%2==0 && high%2==0)\\n            return (high-low)/2;\\n        else\\n            return (high-low)/2+1;\\n    }\\n}\\n```"
    },
    {
        "slug": "delete-columns-to-make-sorted-ii",
        "tags": "java",
        "release_time": 1691030696,
        "code": "class Solution {\n  public int minDeletionSize(String[] strs) {\n    boolean delete[] = new boolean[101];\n    int ans = 0;\n    boolean flag = false;\n    for (int l = 0; l < strs[0].length(); l++) {\n      boolean deletec[] = new boolean[101];\n      for (int o = 0; o < delete.length; o++) {\n        deletec[o] = delete[o];\n      }\n      for (int i = 1; i < strs.length; i++) {\n        for (int j = 0; j < strs[0].length(); j++) {\n          if (!delete[j]) {\n            if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\n              deletec[j] = true;\n            } else if (strs[i].charAt(j) == strs[i - 1].charAt(j)) {\n              continue;\n            } else {\n              break;\n            }\n          }\n        }\n      }\n      for (int i = 0; i < delete.length; i++) {\n        if (delete[i] != deletec[i]) {\n          flag = true;\n        }\n      }\n      if (flag) {\n        delete = deletec;\n        continue;\n      } else break;\n\n    }\n    for (int i = 0; i < delete.length; i++) {\n      if (delete[i]) ans++;\n    }\n\n    return ans;\n  }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minDeletionSize(String[] strs) {\\n    boolean delete[] = new boolean[101];\\n    int ans = 0;\\n    boolean flag = false;\\n    for (int l = 0; l < strs[0].length(); l++) {\\n      boolean deletec[] = new boolean[101];\\n      for (int o = 0; o < delete.length; o++) {\\n        deletec[o] = delete[o];\\n      }\\n      for (int i = 1; i < strs.length; i++) {\\n        for (int j = 0; j < strs[0].length(); j++) {\\n          if (!delete[j]) {\\n            if (strs[i].charAt(j) < strs[i - 1].charAt(j)) {\\n              deletec[j] = true;\\n            } else if (strs[i].charAt(j) == strs[i - 1].charAt(j)) {\\n              continue;\\n            } else {\\n              break;\\n            }\\n          }\\n        }\\n      }\\n      for (int i = 0; i < delete.length; i++) {\\n        if (delete[i] != deletec[i]) {\\n          flag = true;\\n        }\\n      }\\n      if (flag) {\\n        delete = deletec;\\n        continue;\\n      } else break;\\n\\n    }\\n    for (int i = 0; i < delete.length; i++) {\\n      if (delete[i]) ans++;\\n    }\\n\\n    return ans;\\n  }\\n}\\n```"
    },
    {
        "slug": "count-common-words-with-one-occurrence",
        "tags": "java",
        "release_time": 1685170196,
        "code": "class Solution {\n    public int countWords(String[] words1, String[] words2) {\n        Map<String, Integer> map1 = new HashMap<>();\n        Map<String, Integer> map2 = new HashMap<>();\n\n        for (String s: words1){\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\n            else map1.put(s, 1);\n        }\n        for (String s: words2){\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\n            else map2.put(s, 1);\n        }\n        int count = 0;\n        for(String i : words1){\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\n                count++;\n            }\n        }\n\n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countWords(String[] words1, String[] words2) {\\n        Map<String, Integer> map1 = new HashMap<>();\\n        Map<String, Integer> map2 = new HashMap<>();\\n\\n        for (String s: words1){\\n            if(map1.containsKey(s)) map1.put(s, map1.get(s)+1);\\n            else map1.put(s, 1);\\n        }\\n        for (String s: words2){\\n            if(map2.containsKey(s)) map2.put(s, map2.get(s)+1);\\n            else map2.put(s, 1);\\n        }\\n        int count = 0;\\n        for(String i : words1){\\n            if(map1.get(i) == 1 && map2.getOrDefault(i,0) == 1 ){\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "n-ary-tree-postorder-traversal",
        "tags": "java",
        "release_time": 1683442211,
        "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    List<Integer> ans=new ArrayList<>();\n    public List<Integer> postorder(Node root) {\n        if(root==null) return ans;\n        for(Node n: root.children){\n            postorder(n);\n        }\n        ans.add(root.val);\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> children;\\n\\n    public Node() {}\\n\\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, List<Node> _children) {\\n        val = _val;\\n        children = _children;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    List<Integer> ans=new ArrayList<>();\\n    public List<Integer> postorder(Node root) {\\n        if(root==null) return ans;\\n        for(Node n: root.children){\\n            postorder(n);\\n        }\\n        ans.add(root.val);\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "implement-queue-using-stacks",
        "tags": "java",
        "release_time": 1665846213,
        "code": "class MyQueue {\n// creat argument / veriables\n    private Stack<Integer> stack1 = new Stack<>();\n    private Stack<Integer> stack2 = new Stack<>();\n        \n    public MyQueue() {\n      \n    }\n    \n    public void push(int x) {\n       if(stack1.isEmpty()){\n           stack1.push(x);  // pushing in stack1\n           return;\n       }        \n        while(!stack1.isEmpty()){\n            stack2.push(stack1.pop()); // first Popping in stack1 then pushing stack1's pop value in stack2\n            // stack1.pop();\n        }\n        stack1.push(x);\n        while(!stack2.empty()){\n            stack1.push(stack2.pop()); // first Popping in stack2 then pusing stack2's pop value in stack1\n            // stack2.pop();\n        }\n    }\n    \n    public int pop() {\n        return stack1.pop(); // Popping in stack1 \n    }\n    \n    public int peek() {\n        return stack1.peek();\n    }\n    \n    public boolean empty() {\n       return stack1.isEmpty() && stack2.isEmpty();   \n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */",
        "content": "```\\nclass MyQueue {\\n// creat argument / veriables\\n    private Stack<Integer> stack1 = new Stack<>();\\n    private Stack<Integer> stack2 = new Stack<>();\\n        \\n    public MyQueue() {\\n      \\n    }\\n    \\n    public void push(int x) {\\n       if(stack1.isEmpty()){\\n           stack1.push(x);  // pushing in stack1\\n           return;\\n       }        \\n        while(!stack1.isEmpty()){\\n            stack2.push(stack1.pop()); // first Popping in stack1 then pushing stack1\\'s pop value in stack2\\n            // stack1.pop();\\n        }\\n        stack1.push(x);\\n        while(!stack2.empty()){\\n            stack1.push(stack2.pop()); // first Popping in stack2 then pusing stack2\\'s pop value in stack1\\n            // stack2.pop();\\n        }\\n    }\\n    \\n    public int pop() {\\n        return stack1.pop(); // Popping in stack1 \\n    }\\n    \\n    public int peek() {\\n        return stack1.peek();\\n    }\\n    \\n    public boolean empty() {\\n       return stack1.isEmpty() && stack2.isEmpty();   \\n    }\\n}\\n\\n/**\\n * Your MyQueue object will be instantiated and called as such:\\n * MyQueue obj = new MyQueue();\\n * obj.push(x);\\n * int param_2 = obj.pop();\\n * int param_3 = obj.peek();\\n * boolean param_4 = obj.empty();\\n */\\n```"
    },
    {
        "slug": "split-array-into-consecutive-subsequences",
        "tags": "java",
        "release_time": 1599999408,
        "code": "// This is a greedy approach. The whole idea is to first look for an existing group\n// to join for the current num. If no, then create a new group. \n// Here a group means group of 3 or more numbers as mentioned in question description. \n\n//Well, If u didn't understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\n\nclass Solution {\n    public boolean isPossible(int[] nums) {\n        // This hashmap tells us about whether a number in num is available for a job or not\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\n        \n        // This hashmap tells a number (say x), if there is a job vacancy for them\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\n        \n        // We store the count of every num in nums into avaibilityMap. Basically, a number's count is the avaibility of it.\n        for(int i : nums){\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\n        }\n        \n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\n        for(int i=0;i<nums.length;i++){\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\n            if(avaibilityMap.get(nums[i])<=0){\n                continue;\n            }\n            \n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\n            else if(wantMap.getOrDefault(nums[i],0)>0){\n                // Yes, someone is looking, so we decrease the avaibility count of that number\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                \n                // we also decrease its count from the job vacancy space / wantMap\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\n                \n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\n            }\n            \n            // Ooh, we are here means nums[i] was not able to find a job.\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\n                \n                // Yay! both 2 friends are available. Let's start a company.\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \n                // avaibilityMap\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\n                \n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\n            }\n            \n            // Bad luck case, nums[i] not able to start his/her company, so just return false\n            else{\n                return false;\n            }\n        }\n        \n        // All good till here so we return true\n        return true;\n    }\n}",
        "content": "**Consider this hypothetical story to better understand this question : [After reading this you will understand the code like a breeze. I hope you enjoy the story!]**\\n\\n1. Consider the numbers in the nums array are actual persons that are looking for a job. If they are available, they try to find a job. If no one wants them they go on to start their own company. But, here is the twist, a new company can be started only if it can have atleast 3 persons available. ( Are you thinking why 3? => Read the question description again.)\\n\\n2. The most important thing to note here is that each person in num, first tries to look for a job and if he/she does not gets success, he/she starts a company with 3 consecutive members. [as we want to find subsequences with consecutive numbers of length atleast 3. Think a subsequence as a company for now]\\n\\n3. So, let\\'s come to our first scenario - A person `(let\\'s say x)` looks for a job and finds it. YAY!! So, this person joins an already existing company and then he/she creates a vacancy for another person `x+1` in the job search section, so that another one like him/her do not have to face any struggle like he/she faced. He/She is a good guy/girl. No?\\n\\n4. Now, let\\'s come to our second possibility of our story. The guy/girl was not able to find a job :( \\nBUT, he/she `(let\\'s say x)` was very ambitious. So he/she decides- \\'Let\\'s build a company with me (that is x), x+1 and x+2\\'. So he/she checks with (x+1) and (x+2), if they are available to build a company as it requires 3 persons to start a company. \\n\\nHere comes two scenario:\\n\\na. x finds both the potential teammates/partners, `(x+1)` & `(x+2)` to be available so, they go on to start a new company and then after finding their own company, as a goodwill they create a new job vacancy looking for `(x+3)` so that `(x+3)` do not face any struggle they faced. People are good, believe me :) \\n\\nb. x was just out of luck, he/she was able to find their teammates i.e. (x+1) & (x+2). In this case have hope and just return false to quickly complete the program execution (BACK TO REALITY :p )\\n\\n\\n**Here is the code [If you haven\\'t read the story above, please read it to understand the solution] :**\\n\\n```\\n// This is a greedy approach. The whole idea is to first look for an existing group\\n// to join for the current num. If no, then create a new group. \\n// Here a group means group of 3 or more numbers as mentioned in question description. \\n\\n//Well, If u didn\\'t understand, keep the above story of company in mind and try to understand the code below through comments, you will be fine.\\n\\nclass Solution {\\n    public boolean isPossible(int[] nums) {\\n        // This hashmap tells us about whether a number in num is available for a job or not\\n        HashMap<Integer,Integer> avaibilityMap = new HashMap<>();\\n        \\n        // This hashmap tells a number (say x), if there is a job vacancy for them\\n        HashMap<Integer,Integer> wantMap = new HashMap<>();\\n        \\n        // We store the count of every num in nums into avaibilityMap. Basically, a number\\'s count is the avaibility of it.\\n        for(int i : nums){\\n            avaibilityMap.put(i, avaibilityMap.getOrDefault(i,0)+1);\\n        }\\n        \\n        // We iterate through each number in the nums array. Remember the story ? So, treat them like a person.\\n        for(int i=0;i<nums.length;i++){\\n            // First we check if our current num/person is available. If it is not we just continue with next num/person\\n            if(avaibilityMap.get(nums[i])<=0){\\n                continue;\\n            }\\n            \\n            // If the person is available, first we check if there is a job vacancy for him/her. Basically, is someone looking for him/her?\\n            else if(wantMap.getOrDefault(nums[i],0)>0){\\n                // Yes, someone is looking, so we decrease the avaibility count of that number\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                \\n                // we also decrease its count from the job vacancy space / wantMap\\n                wantMap.put(nums[i], wantMap.getOrDefault(nums[i],0)-1);\\n                \\n                // Then as a goodwill, he/she will also create a job vacancy for (num[i]+1) in job vacancy space / wantMap, as we need consecutive numbers only\\n                wantMap.put(nums[i]+1, wantMap.getOrDefault(nums[i]+1,0)+1);\\n            }\\n            \\n            // Ooh, we are here means nums[i] was not able to find a job.\\n            // so, nums[i] tries to start his/her own company by checking avaibility of his/her friends i.e. (nums[i]+1) and (nums[i]+2)\\n            else if(avaibilityMap.getOrDefault(nums[i],0)>0 && avaibilityMap.getOrDefault(nums[i]+1,0)>0 && avaibilityMap.getOrDefault(nums[i]+2,0)>0){\\n                \\n                // Yay! both 2 friends are available. Let\\'s start a company.\\n                // So we decrease the avaibility count of nums[i], (nums[i]+1) and (nums[i]+2) from the \\n                // avaibilityMap\\n                avaibilityMap.put(nums[i], avaibilityMap.getOrDefault(nums[i],0)-1);\\n                avaibilityMap.put(nums[i]+1, avaibilityMap.getOrDefault(nums[i]+1,0)-1);\\n                avaibilityMap.put(nums[i]+2, avaibilityMap.getOrDefault(nums[i]+2,0)-1);\\n                \\n                // Also, as a goodwill, we create a new job vacancy for (nums[i]+3), as we need consecutive numbers only\\n                wantMap.put(nums[i]+3, wantMap.getOrDefault(nums[i]+3,0)+1);\\n            }\\n            \\n            // Bad luck case, nums[i] not able to start his/her company, so just return false\\n            else{\\n                return false;\\n            }\\n        }\\n        \\n        // All good till here so we return true\\n        return true;\\n    }\\n}\\n```\\n\\n\\n***Again to reiterate the logic :\\nThe logic is to just apply a greedy approach and try to find a group of 3 consecutive numbers first and then for other numbers try to check if existing groups can be used or it is neccessary to create a new group.***\\n\\n**Hope you enjoyed the story and if you liked it please upvote.Thanks!**"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "tags": "java",
        "release_time": 1689418968,
        "code": "class Solution {\n    double possible = 0.0;\n    double valid = 0.0;\n    \n    public double getProbability(int[] balls) {\n        int[] first = new int[balls.length];\n        int[] second = new int[balls.length];\n        dfs(balls, first, second, 0, 0, 0);\n        return valid / possible;\n    }\n    \n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\n        // finish all colors, check if this's a possible/valid distribution\n        if (idx == balls.length) {\n            // find one possible distribution\n            if (num1 == num2) {\n                // compute fake permutation\n                double distrib = permFake(first) * permFake(second);\n                possible += distrib;\n                \n                // find one valid distribution\n                if (unique(first) == unique(second)) {\n                    valid += distrib;\n                }\n            }\n            return;\n        }\n        \n        // distribute balls in current color to two bins\n        for (int b = 0; b <= balls[idx]; b++) {\n            first[idx] = b;\n            second[idx] = balls[idx] - b;\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\n        }\n    }\n    \n    // unique colors in \n    private int unique(int[] balls) {\n        int unique = 0;\n        for (int b: balls)\n            unique += b > 0 ? 1 : 0;\n        return unique;\n    }\n    \n    // return 1 / (b1!b2!b3!...bn!) \n    private double permFake(int[] balls) {\n        double ret = 1.0;\n        for (int b: balls)\n            ret /= factorial(b);\n        return ret;\n    }\n    \n    private int factorial(int n){\n        int ret = 1;\n        while (n > 0) {\n            ret *= n;\n            n--;\n        }\n        return ret;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    double possible = 0.0;\\n    double valid = 0.0;\\n    \\n    public double getProbability(int[] balls) {\\n        int[] first = new int[balls.length];\\n        int[] second = new int[balls.length];\\n        dfs(balls, first, second, 0, 0, 0);\\n        return valid / possible;\\n    }\\n    \\n    private void dfs(int[] balls, int[] first, int[] second, int num1, int num2, int idx) {\\n        // finish all colors, check if this\\'s a possible/valid distribution\\n        if (idx == balls.length) {\\n            // find one possible distribution\\n            if (num1 == num2) {\\n                // compute fake permutation\\n                double distrib = permFake(first) * permFake(second);\\n                possible += distrib;\\n                \\n                // find one valid distribution\\n                if (unique(first) == unique(second)) {\\n                    valid += distrib;\\n                }\\n            }\\n            return;\\n        }\\n        \\n        // distribute balls in current color to two bins\\n        for (int b = 0; b <= balls[idx]; b++) {\\n            first[idx] = b;\\n            second[idx] = balls[idx] - b;\\n            dfs (balls, first, second, num1 + first[idx], num2 + second[idx], idx + 1);\\n        }\\n    }\\n    \\n    // unique colors in \\n    private int unique(int[] balls) {\\n        int unique = 0;\\n        for (int b: balls)\\n            unique += b > 0 ? 1 : 0;\\n        return unique;\\n    }\\n    \\n    // return 1 / (b1!b2!b3!...bn!) \\n    private double permFake(int[] balls) {\\n        double ret = 1.0;\\n        for (int b: balls)\\n            ret /= factorial(b);\\n        return ret;\\n    }\\n    \\n    private int factorial(int n){\\n        int ret = 1;\\n        while (n > 0) {\\n            ret *= n;\\n            n--;\\n        }\\n        return ret;\\n    }\\n}\\n```"
    },
    {
        "slug": "domino-and-tromino-tiling",
        "tags": "java",
        "release_time": 1671862293,
        "code": "class Solution {\n    private long[] dp;\n    int MOD = (int)Math.pow(10 , 9) + 7;\n    public long solve(int n){\n        if(n==0) return 1;\n        if(n<3) return n;\n\n        if(dp[n]!=-1) return dp[n];\n\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\n    }\n    public int numTilings(int n) {\n        this.dp = new long[n+1];\n        Arrays.fill(dp , -1);\n\n        return (int)solve(n)%MOD;\n    }\n}",
        "content": "# Intuition\\n- The basic approach to solve this problem was by using brute force recursion.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Then after realising the over-lapping sub problems in it the whole problem was solved using the memoization technique of Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$ + recursive stack space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private long[] dp;\\n    int MOD = (int)Math.pow(10 , 9) + 7;\\n    public long solve(int n){\\n        if(n==0) return 1;\\n        if(n<3) return n;\\n\\n        if(dp[n]!=-1) return dp[n];\\n\\n        return dp[n] = 2*solve(n-1)%MOD+solve(n-3)%MOD;\\n    }\\n    public int numTilings(int n) {\\n        this.dp = new long[n+1];\\n        Arrays.fill(dp , -1);\\n\\n        return (int)solve(n)%MOD;\\n    }\\n}\\n```"
    },
    {
        "slug": "diagonal-traverse-ii",
        "tags": "java",
        "release_time": 1687196653,
        "code": "class Solution {\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\n        List<Integer>[] map = new ArrayList[100001];\n        for (int i = 0; i < m; i++) {\n            size += nums.get(i).size();\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                int sum = i + j;\n                if (map[sum] == null) map[sum] = new ArrayList<>();\n                map[sum].add(nums.get(i).get(j));\n                maxSum = Math.max(maxSum, sum);\n            }\n        }\n        int[] res = new int[size];\n        for (int i = 0; i <= maxSum; i++) {\n            List<Integer> cur = map[i];\n            for (int j = cur.size() - 1; j >= 0; j--) {\n                res[index++] = cur.get(j);\n            }\n        }\n        return res;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(List<List<Integer>> nums) {\\n        int m = nums.size(), maxSum = 0, size = 0, index = 0;\\n        List<Integer>[] map = new ArrayList[100001];\\n        for (int i = 0; i < m; i++) {\\n            size += nums.get(i).size();\\n            for (int j = 0; j < nums.get(i).size(); j++) {\\n                int sum = i + j;\\n                if (map[sum] == null) map[sum] = new ArrayList<>();\\n                map[sum].add(nums.get(i).get(j));\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n        int[] res = new int[size];\\n        for (int i = 0; i <= maxSum; i++) {\\n            List<Integer> cur = map[i];\\n            for (int j = cur.size() - 1; j >= 0; j--) {\\n                res[index++] = cur.get(j);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-different-subsequences-gcds",
        "tags": "java",
        "release_time": 1617547962,
        "code": "class Solution {\n    int max = 0;\n    Set<Integer> exist = new HashSet();\n    public int countDifferentSubsequenceGCDs(int[] nums) {\n        getMax(nums);\n        for(int num : nums) exist.add(num);\n        int count = 0;\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      //  <---- findGCD\n        return count;\n    }\n    public void getMax(int[] nums){\n        for(int i : nums) max = Math.max(max, i);\n    }\n    public int gcd(int a, int b){\n        return (a == 0) ? b : gcd(b % a, a);\n    }\n\tpublic boolean findGCD(int num){\n        int val = 0;\n        for(int i = num; i <= max; i+= num)\n            if(exist.contains(i)) val = gcd(i, val);          //  <---- gcd between two number\n        return (val == num);\n    }\n}",
        "content": "**PLEASE UPVOTE IF YOU FIND THIS USEFUL**\\n\\n* Generating all subsets and finding the gcd will lead you to `TLE`\\n* We can try to build optimization around based on the constraint `1 <= nums[i] <= 2 * 10^5`\\n* The limit is `200000` and we find GCD for all the numbers available between them. we can limit to the `max` number in the input array, `nums`. \\n* We pick a number `num` and check if the GCD subsequence exists equals to the same number. If it exists then the elements of the gcd susequence will be the multiple of the same number passed. This is the reason why we increment the value by num in `findGCD`\\n* Maintaining a set `exist` for easy existence check for the number in the `nums`\\n* Increment the counter `count` if the gcd between the numbers matches\\n\\n**Time:**  N Log N (GCD worst case is logN)\\n**Space:** O(N) (usage of Set for N numbers)\\n```\\nclass Solution {\\n    int max = 0;\\n    Set<Integer> exist = new HashSet();\\n    public int countDifferentSubsequenceGCDs(int[] nums) {\\n        getMax(nums);\\n        for(int num : nums) exist.add(num);\\n        int count = 0;\\n        for (int i=1;i<=max;i++) if(findGCD(i)) count++;      //  <---- findGCD\\n        return count;\\n    }\\n    public void getMax(int[] nums){\\n        for(int i : nums) max = Math.max(max, i);\\n    }\\n    public int gcd(int a, int b){\\n        return (a == 0) ? b : gcd(b % a, a);\\n    }\\n\\tpublic boolean findGCD(int num){\\n        int val = 0;\\n        for(int i = num; i <= max; i+= num)\\n            if(exist.contains(i)) val = gcd(i, val);          //  <---- gcd between two number\\n        return (val == num);\\n    }\\n}\\n```"
    },
    {
        "slug": "solve-the-equation",
        "tags": "java",
        "release_time": 1660715087,
        "code": "class Solution {\n    int x = 0;\n    int val = 0;\n    public String solveEquation(String equation) {\n        String[] eq = equation.split(\"=\");\n        String left = eq[0];\n        String right = eq[1];\n        List<String> l = new ArrayList<>();\n        List<String> r = new ArrayList<>();     \n        int i = 0;  \n        for(i=0;i<left.length();i++){\n            char c = left.charAt(i);\n            if(c=='+' || c=='-' || c=='x'){\n                l.add(left.charAt(i)+\"\");\n            }else{\n                String num = \"\";\n                int j = i;\n                for(j=i;j<left.length();j++){\n                    if('0'<=left.charAt(j) && left.charAt(j)<='9'){\n                        num += left.charAt(j);\n                    }else{\n                        break;\n                    }\n                }\n                l.add(num);\n                if(j<left.length()){\n                    l.add(left.charAt(j)+\"\");\n                }\n                i = j;\n            }\n        }\n        for(i=0;i<right.length();i++){\n            char c = right.charAt(i);\n            if(c=='+' || c=='-' || c=='x'){\n                r.add(right.charAt(i)+\"\");\n            }else{\n                String num = c+\"\";\n                int j = i+1;\n                for(j=i+1;j<right.length();j++){\n                    if('0'<=right.charAt(j) && right.charAt(j)<='9'){\n                        num += right.charAt(j);\n                    }else{\n                        break;\n                    }\n                }\n                r.add(num);\n                if(j<right.length()){\n                    r.add(right.charAt(j)+\"\");\n                }\n                i = j;\n            }\n        }\n        String[] lhs = new String[l.size()];\n        String[] rhs = new String[r.size()];\n        \n        for(i=0;i<l.size();i++){\n            lhs[i] = l.get(i);\n        }\n        for(i=0;i<r.size();i++){\n            rhs[i] = r.get(i);\n        }\n        solve(lhs,1);\n        solve(rhs,2);\n        String ans = \"\";\n        val *= -1;\n        if(x==0 && val!=0){\n            return \"No solution\";\n        }\n        if(x==0 && val==0){\n            ans = \"Infinite solutions\";\n        }else{\n            ans = \"x=\"+String.valueOf(val/x);\n        }\n        return ans;\n    }\n    public void solve(String[] arr,int type){\n        String plus = \"+\";\n        String minus = \"-\";\n        if(type==2){\n            plus = \"-\";\n            minus = \"+\";\n        }\n        int i = 0;\n        for(i=0;i<arr.length;i++){\n            if(arr[i].equals(\"x\")){\n                if(type==2){\n                    x--;\n                }\n                else{\n                    x++;\n                }\n            }\n            if('0'<=arr[i].charAt(0) && arr[i].charAt(0)<='9'){\n                if(i+1<arr.length && arr[i+1].equals(\"x\")){\n                    if(type==2){\n                        x -=Integer.valueOf(arr[i]);\n                    }else{\n                        x +=Integer.valueOf(arr[i]);\n                    }\n                    i++;\n                }\n                else{\n                    if(type==2){\n                        val -= Integer.valueOf(arr[i]);\n                    }else{\n                        val += Integer.valueOf(arr[i]);\n                    }\n                }\n            }\n            if(arr[i].equals(plus)){\n                if(arr[i+1].equals(\"x\")){\n                    x++;\n                    i++;\n                }else{\n                    if(i+2<arr.length){\n                        if(arr[i+2].equals(\"x\")){\n                            x += Integer.valueOf(arr[i+1]);\n                            i+=2;\n                        }else{\n                            val += Integer.valueOf(arr[i+1]);\n                            i++;\n                        }\n                    }else{\n                        val += Integer.valueOf(arr[i+1]);\n                        i++;\n                    }\n                }\n            }\n            if(arr[i].equals(minus)){\n                if(arr[i+1].equals(\"x\")){\n                    x--;\n                    i++;\n                }else{\n                    if(i+2<arr.length){\n                        if(arr[i+2].equals(\"x\")){\n                            x -= Integer.valueOf(arr[i+1]);\n                            i+=2;\n                        }else{\n                            val -= Integer.valueOf(arr[i+1]);\n                            i++;\n                        }\n                    }else{\n                        val -= Integer.valueOf(arr[i+1]);\n                        i++;\n                    }\n                }\n            }\n        }\n    }\n}",
        "content": "```\\nclass Solution {\\n    int x = 0;\\n    int val = 0;\\n    public String solveEquation(String equation) {\\n        String[] eq = equation.split(\"=\");\\n        String left = eq[0];\\n        String right = eq[1];\\n        List<String> l = new ArrayList<>();\\n        List<String> r = new ArrayList<>();     \\n        int i = 0;  \\n        for(i=0;i<left.length();i++){\\n            char c = left.charAt(i);\\n            if(c==\\'+\\' || c==\\'-\\' || c==\\'x\\'){\\n                l.add(left.charAt(i)+\"\");\\n            }else{\\n                String num = \"\";\\n                int j = i;\\n                for(j=i;j<left.length();j++){\\n                    if(\\'0\\'<=left.charAt(j) && left.charAt(j)<=\\'9\\'){\\n                        num += left.charAt(j);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                l.add(num);\\n                if(j<left.length()){\\n                    l.add(left.charAt(j)+\"\");\\n                }\\n                i = j;\\n            }\\n        }\\n        for(i=0;i<right.length();i++){\\n            char c = right.charAt(i);\\n            if(c==\\'+\\' || c==\\'-\\' || c==\\'x\\'){\\n                r.add(right.charAt(i)+\"\");\\n            }else{\\n                String num = c+\"\";\\n                int j = i+1;\\n                for(j=i+1;j<right.length();j++){\\n                    if(\\'0\\'<=right.charAt(j) && right.charAt(j)<=\\'9\\'){\\n                        num += right.charAt(j);\\n                    }else{\\n                        break;\\n                    }\\n                }\\n                r.add(num);\\n                if(j<right.length()){\\n                    r.add(right.charAt(j)+\"\");\\n                }\\n                i = j;\\n            }\\n        }\\n        String[] lhs = new String[l.size()];\\n        String[] rhs = new String[r.size()];\\n        \\n        for(i=0;i<l.size();i++){\\n            lhs[i] = l.get(i);\\n        }\\n        for(i=0;i<r.size();i++){\\n            rhs[i] = r.get(i);\\n        }\\n        solve(lhs,1);\\n        solve(rhs,2);\\n        String ans = \"\";\\n        val *= -1;\\n        if(x==0 && val!=0){\\n            return \"No solution\";\\n        }\\n        if(x==0 && val==0){\\n            ans = \"Infinite solutions\";\\n        }else{\\n            ans = \"x=\"+String.valueOf(val/x);\\n        }\\n        return ans;\\n    }\\n    public void solve(String[] arr,int type){\\n        String plus = \"+\";\\n        String minus = \"-\";\\n        if(type==2){\\n            plus = \"-\";\\n            minus = \"+\";\\n        }\\n        int i = 0;\\n        for(i=0;i<arr.length;i++){\\n            if(arr[i].equals(\"x\")){\\n                if(type==2){\\n                    x--;\\n                }\\n                else{\\n                    x++;\\n                }\\n            }\\n            if(\\'0\\'<=arr[i].charAt(0) && arr[i].charAt(0)<=\\'9\\'){\\n                if(i+1<arr.length && arr[i+1].equals(\"x\")){\\n                    if(type==2){\\n                        x -=Integer.valueOf(arr[i]);\\n                    }else{\\n                        x +=Integer.valueOf(arr[i]);\\n                    }\\n                    i++;\\n                }\\n                else{\\n                    if(type==2){\\n                        val -= Integer.valueOf(arr[i]);\\n                    }else{\\n                        val += Integer.valueOf(arr[i]);\\n                    }\\n                }\\n            }\\n            if(arr[i].equals(plus)){\\n                if(arr[i+1].equals(\"x\")){\\n                    x++;\\n                    i++;\\n                }else{\\n                    if(i+2<arr.length){\\n                        if(arr[i+2].equals(\"x\")){\\n                            x += Integer.valueOf(arr[i+1]);\\n                            i+=2;\\n                        }else{\\n                            val += Integer.valueOf(arr[i+1]);\\n                            i++;\\n                        }\\n                    }else{\\n                        val += Integer.valueOf(arr[i+1]);\\n                        i++;\\n                    }\\n                }\\n            }\\n            if(arr[i].equals(minus)){\\n                if(arr[i+1].equals(\"x\")){\\n                    x--;\\n                    i++;\\n                }else{\\n                    if(i+2<arr.length){\\n                        if(arr[i+2].equals(\"x\")){\\n                            x -= Integer.valueOf(arr[i+1]);\\n                            i+=2;\\n                        }else{\\n                            val -= Integer.valueOf(arr[i+1]);\\n                            i++;\\n                        }\\n                    }else{\\n                        val -= Integer.valueOf(arr[i+1]);\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "unique-paths-iii",
        "tags": "java",
        "release_time": 1691850472,
        "code": "class Solution {\n    public int uniquePathsIII(int[][] grid) {\n        \n        int row = 0;\n        int col = 0;\n        for(int i = 0; i < grid.length; i++) {\n            for(int j = 0; j < grid[0].length; j++) {\n                if(grid[i][j] == 1) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n        }\n        boolean[][] used = new boolean[grid.length][grid[0].length];\n        return count(grid, used, row, col);\n    }\n\n    int count(int[][] grid, boolean[][] used, int row, int col) {\n\n        used[row][col] = true;\n        if(grid[row][col] == 2) {\n            if(isValid(used, grid) && grid[row][col] != -1) {\n                used[row][col] = false;\n                return 1;\n            }\n            used[row][col] = false;\n            return 0;\n        }\n        if(grid[row][col] == -1) {\n            used[row][col] = false;\n            return 0;\n        }\n\n        int paths = 0;\n\n        //DOWN\n        if(row < grid.length - 1 && !used[row + 1][col]) {\n            paths += count(grid, used, row + 1, col);\n        }\n        //RIGHT\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\n            paths += count(grid, used, row, col + 1);\n        }\n        //UP\n        if(row > 0 && !used[row - 1][col]) {\n            paths += count(grid, used, row - 1, col);\n        }\n        //LEFT\n        if(col > 0 && !used[row][col - 1]) {\n            paths += count(grid, used, row, col - 1);\n        }\n\n        used[row][col] = false;\n        return paths;\n    }\n\n    boolean isValid(boolean[][] used, int[][] grid) {\n\n        for(int i = 0; i < used.length; i++) {\n            for(int j = 0; j < used[0].length; j++) {\n                if(grid[i][j] == 0) {\n                    if(!used[i][j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: Exponential\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m * n)\\nBecause we are using extra used 2D array of size m * n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n**CLEAN CODE :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**CODE WITH EXPLANATION :**\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n\\n        //finding the starting square\\'s row and column\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        //boolean array named (used) is used to store the squares which have already been used\\n        //till now in a particular path\\n\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n\\n        return count(grid, used, row, col);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col) {\\n\\n        used[row][col] = true;\\n\\n        //we have arrived at the ending square. Now, it might be possible, that the path we \\n        //followed till here from starting position, does not contain all the 0 squares\\n        //therefore to decide this we call the isValid function\\n        //Also, it might happen that there\\'s an obstacle on the same ending square, in this\\n        //case we won\\'t find any path because the destination square is itself an obstacle\\n        //so we return 0. and to check this only we have put another \\n        //condition grid[row][col] != -1\\n\\n        if(grid[row][col] == 2) {\\n            if(isValid(used, grid) && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        //if we have arrived at an obstacle square, then return 0, because we can\\'t obtain \\n        //any further paths including this square, because this is an obstacle\\n        //while returning, unmark this square as used, i.e. mark it as unused\\n\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1);\\n        }\\n\\n        //backtrack, mark the square as unused now!\\n        used[row][col] = false;\\n\\n        return paths;\\n    }\\n\\n    //to check whether the path which we have travelled from starting square to ending square\\n    //contains all the 0 squares in it or not. If the path does not contain all the 0 sqaures\\n    //then isValid return false, and we do not count this path and hence return 0 in the count\\n    //function.\\n    //if the path contains all the 0 squares, then isValid return true, and hence \\n    //we count this path and hence in count function we return 1, as we got one path\\n    //which contains all the 0 squares.\\n\\n    boolean isValid(boolean[][] used, int[][] grid) {\\n\\n        for(int i = 0; i < used.length; i++) {\\n            for(int j = 0; j < used[0].length; j++) {\\n                if(grid[i][j] == 0) {\\n                    if(!used[i][j]) {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n**NO NEED OF ISVALID FUNCTION :**\\n\\n```\\nclass Solution {\\n    public int uniquePathsIII(int[][] grid) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int countZeros = 0;\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                if(grid[i][j] == 1) {\\n                    row = i;\\n                    col = j;\\n                }\\n                if(grid[i][j] == 0) {\\n                    countZeros++;\\n                }\\n            }\\n        }\\n        boolean[][] used = new boolean[grid.length][grid[0].length];\\n        return count(grid, used, row, col, countZeros + 1);\\n    }\\n\\n    int count(int[][] grid, boolean[][] used, int row, int col, int countZeros) {\\n\\n        used[row][col] = true;\\n        if(grid[row][col] == 2) {\\n            if(countZeros == 0 && grid[row][col] != -1) {\\n                used[row][col] = false;\\n                return 1;\\n            }\\n            used[row][col] = false;\\n            return 0;\\n        }\\n        if(grid[row][col] == -1) {\\n            used[row][col] = false;\\n            return 0;\\n        }\\n\\n        int paths = 0;\\n\\n        //DOWN\\n        if(row < grid.length - 1 && !used[row + 1][col]) {\\n            paths += count(grid, used, row + 1, col, countZeros - 1);\\n        }\\n        //RIGHT\\n        if(col < grid[0].length - 1 && !used[row][col + 1]) {\\n            paths += count(grid, used, row, col + 1, countZeros - 1);\\n        }\\n        //UP\\n        if(row > 0 && !used[row - 1][col]) {\\n            paths += count(grid, used, row - 1, col, countZeros - 1);\\n        }\\n        //LEFT\\n        if(col > 0 && !used[row][col - 1]) {\\n            paths += count(grid, used, row, col - 1, countZeros - 1);\\n        }\\n\\n        used[row][col] = false;\\n        return paths;\\n    }\\n}\\n```\\n![cat.jpeg](https://assets.leetcode.com/users/images/dbaf10c4-ebb1-47e6-abb2-32d99d5c3a38_1691850467.298222.jpeg)\\n\\n"
    },
    {
        "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
        "tags": "java",
        "release_time": 1673935549,
        "code": "class Solution {\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\n        int currSum = 0; // For storing the sum value of window size\n        int countK = 0; // To check if the size is achieved then start adding the values\n        int countRes = 0; // To store the result count\n        int len = arr.length;\n        int avg;\n        for(int i=0 ; i<len ; i++){\n            currSum += arr[i];\n            countK++;\n            if(countK >= k){\n                avg = (currSum/k);\n                if(avg >= threshold){\n                    countRes++;\n                }\n                /**\n                    This will subtract the first element in the window and \n                    in the next iteration, the new window will be added.\n                    For e.g:\n                    arr=[1,2,3,4,5] and k = 3\n                    i=2\n                    currSum = (1+2+3) = 6\n                    currSum = currSum - arr[(i+1)-k];\n                    window is (1,2,3) - Subtract 1 from the window\n                    then shift the window.\n                    currSum = 6 - arr[0]; \n                **/\n                currSum = currSum - arr[(i+1)-k]; \n            }\n        }\n        return countRes;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to create windows of size k and move ahead with that window size keeping in mind. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the window and calculate the sum.\\nCheck the window size.\\nIf window Size is achieved then calulate the average and match it with threshold. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\\n        int currSum = 0; // For storing the sum value of window size\\n        int countK = 0; // To check if the size is achieved then start adding the values\\n        int countRes = 0; // To store the result count\\n        int len = arr.length;\\n        int avg;\\n        for(int i=0 ; i<len ; i++){\\n            currSum += arr[i];\\n            countK++;\\n            if(countK >= k){\\n                avg = (currSum/k);\\n                if(avg >= threshold){\\n                    countRes++;\\n                }\\n                /**\\n                    This will subtract the first element in the window and \\n                    in the next iteration, the new window will be added.\\n                    For e.g:\\n                    arr=[1,2,3,4,5] and k = 3\\n                    i=2\\n                    currSum = (1+2+3) = 6\\n                    currSum = currSum - arr[(i+1)-k];\\n                    window is (1,2,3) - Subtract 1 from the window\\n                    then shift the window.\\n                    currSum = 6 - arr[0]; \\n                **/\\n                currSum = currSum - arr[(i+1)-k]; \\n            }\\n        }\\n        return countRes;\\n    }\\n}\\n```"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "tags": "java",
        "release_time": 1663654171,
        "code": "class Solution {\n    public String largestGoodInteger(String num) {\n        int n=-1;\n        StringBuilder sb = new StringBuilder();\n        for(int i=0;i<num.length()-2;i++){\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                sb.append(num.charAt(i));\n                if(Integer.parseInt(sb.toString())>n)\n                    n=Integer.parseInt(sb.toString());\n                sb.setLength(0);\n            }\n        }\n        if(n==-1)\n            return \"\";\n        String s = Integer.toString(n);\n        if(s.equals(\"0\"))\n            return \"000\";\n        return s;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n        int n=-1;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<num.length()-2;i++){\\n            if(num.charAt(i)==num.charAt(i+1) && num.charAt(i)==num.charAt(i+2)){\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                sb.append(num.charAt(i));\\n                if(Integer.parseInt(sb.toString())>n)\\n                    n=Integer.parseInt(sb.toString());\\n                sb.setLength(0);\\n            }\\n        }\\n        if(n==-1)\\n            return \"\";\\n        String s = Integer.toString(n);\\n        if(s.equals(\"0\"))\\n            return \"000\";\\n        return s;\\n    }\\n}\\n```\\nKindly upvote if you like the code."
    },
    {
        "slug": "find-all-people-with-secret",
        "tags": "java",
        "release_time": 1687729516,
        "code": "class DisjointSet {\n    int[] root;\n    Long[] rank;\n    DisjointSet(int size, Set<Integer> secretKeepers) {\n        root = new int[size];\n        rank = new Long[size];\n        for (int i = 0; i < size; i++) {\n            root[i] = i;\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\n        }\n    }\n\n    public int find(int vertex) {\n        if(root[vertex] == vertex) return vertex;\n        return root[vertex] = find(root[vertex]);\n    }\n\n    public void union(int vertex1, int vertex2) {\n        int root1 = find(vertex1);\n        int root2 = find(vertex2);\n        if(root1 != root2) {\n            if(rank[root1] > rank[root2]) {\n                root[root2] = root1;\n            } else if (rank[root2] > rank[root1]) {\n                root[root1] = root2;\n            } else {\n                root[root2] = root1;\n                rank[root1]++;\n            }\n        }\n    }\n\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\n        for (int vertex: visited) {\n            if(secretKeepers.contains(find(vertex)))\n                secretKeepers.add(vertex);\n            else \n                root[vertex] = vertex;\n        }\n        return secretKeepers;\n    }\n}\n\nclass Solution {\n    private int maxTime = Integer.MIN_VALUE;\n    private int minTime = Integer.MAX_VALUE;\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\n        for (int time = minTime; time <= maxTime; time++) {\n            if(!timeToMeetings.containsKey(time)) continue;\n            Set<Integer> visited = new HashSet<>();\n            for (Integer[] meeting: timeToMeetings.get(time)) {\n                int person1 = meeting[0], person2 = meeting[1];\n                disjointSet.union(person1, person2);\n                visited.add(person1);\n                visited.add(person2);\n            }\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\n        }\n        return new ArrayList<>(secretKeepers);\n    }\n\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\n        for (int[] meeting: meetings) {\n            maxTime = Math.max(maxTime, meeting[2]);\n            minTime = Math.min(minTime, meeting[2]);\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\n        }\n        return timeToMeetings;\n    }\n}",
        "content": "# Code\\n```\\nclass DisjointSet {\\n    int[] root;\\n    Long[] rank;\\n    DisjointSet(int size, Set<Integer> secretKeepers) {\\n        root = new int[size];\\n        rank = new Long[size];\\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = secretKeepers.contains(i) ? Integer.MAX_VALUE : 1L;\\n        }\\n    }\\n\\n    public int find(int vertex) {\\n        if(root[vertex] == vertex) return vertex;\\n        return root[vertex] = find(root[vertex]);\\n    }\\n\\n    public void union(int vertex1, int vertex2) {\\n        int root1 = find(vertex1);\\n        int root2 = find(vertex2);\\n        if(root1 != root2) {\\n            if(rank[root1] > rank[root2]) {\\n                root[root2] = root1;\\n            } else if (rank[root2] > rank[root1]) {\\n                root[root1] = root2;\\n            } else {\\n                root[root2] = root1;\\n                rank[root1]++;\\n            }\\n        }\\n    }\\n\\n    public Set<Integer> getAllSecretKeepers(Set<Integer> secretKeepers, Set<Integer> visited) {\\n        for (int vertex: visited) {\\n            if(secretKeepers.contains(find(vertex)))\\n                secretKeepers.add(vertex);\\n            else \\n                root[vertex] = vertex;\\n        }\\n        return secretKeepers;\\n    }\\n}\\n\\nclass Solution {\\n    private int maxTime = Integer.MIN_VALUE;\\n    private int minTime = Integer.MAX_VALUE;\\n    public List<Integer> findAllPeople(int n, int[][] meetings, int firstPerson) {\\n        Set<Integer> secretKeepers = new HashSet<>(List.of(0, firstPerson));\\n        Map<Integer, List<Integer[]>> timeToMeetings = getTimeToMeetings(meetings);\\n        DisjointSet disjointSet = new DisjointSet(n, secretKeepers);\\n        for (int time = minTime; time <= maxTime; time++) {\\n            if(!timeToMeetings.containsKey(time)) continue;\\n            Set<Integer> visited = new HashSet<>();\\n            for (Integer[] meeting: timeToMeetings.get(time)) {\\n                int person1 = meeting[0], person2 = meeting[1];\\n                disjointSet.union(person1, person2);\\n                visited.add(person1);\\n                visited.add(person2);\\n            }\\n            secretKeepers = disjointSet.getAllSecretKeepers(secretKeepers, visited);\\n        }\\n        return new ArrayList<>(secretKeepers);\\n    }\\n\\n    private Map<Integer, List<Integer[]>> getTimeToMeetings(int[][] meetings) {\\n        Map<Integer, List<Integer[]>> timeToMeetings = new HashMap<>();\\n        for (int[] meeting: meetings) {\\n            maxTime = Math.max(maxTime, meeting[2]);\\n            minTime = Math.min(minTime, meeting[2]);\\n            timeToMeetings.computeIfAbsent(meeting[2], e-> new ArrayList<>()).add(new Integer[]{meeting[0], meeting[1]});\\n        }\\n        return timeToMeetings;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-penalty-for-a-shop",
        "tags": "java",
        "release_time": 1675491701,
        "code": "class Solution {\n    public int bestClosingTime(String customers) {\n        int[][] penalty = new int[customers.length()+1][2];\n        int no = 0;\n        for (int i = 0; i < customers.length(); i++) {\n            penalty[i][0] = no;\n            if(customers.charAt(i) == 'N') no++;\n        }\n        int yes = 0;\n        for (int i = customers.length()-1; i >= 0; i--) {\n            if(customers.charAt(i) == 'Y') yes++;\n            penalty[i][1] = yes;\n        }\n        penalty[customers.length()][0] = no;\n        penalty[customers.length()][1] = 0;\n        int mn = customers.length()+1;\n        int ii = -1;\n        for (int i = 0; i <= customers.length(); i++) {\n            System.out.println(penalty[i][0] + \" \" + penalty[i][1]);\n            if(mn > penalty[i][0] + penalty[i][1]){\n                mn = penalty[i][0] + penalty[i][1];\n                ii = i;\n            }\n        }\n        return ii;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int bestClosingTime(String customers) {\\n        int[][] penalty = new int[customers.length()+1][2];\\n        int no = 0;\\n        for (int i = 0; i < customers.length(); i++) {\\n            penalty[i][0] = no;\\n            if(customers.charAt(i) == \\'N\\') no++;\\n        }\\n        int yes = 0;\\n        for (int i = customers.length()-1; i >= 0; i--) {\\n            if(customers.charAt(i) == \\'Y\\') yes++;\\n            penalty[i][1] = yes;\\n        }\\n        penalty[customers.length()][0] = no;\\n        penalty[customers.length()][1] = 0;\\n        int mn = customers.length()+1;\\n        int ii = -1;\\n        for (int i = 0; i <= customers.length(); i++) {\\n            System.out.println(penalty[i][0] + \" \" + penalty[i][1]);\\n            if(mn > penalty[i][0] + penalty[i][1]){\\n                mn = penalty[i][0] + penalty[i][1];\\n                ii = i;\\n            }\\n        }\\n        return ii;\\n    }\\n}\\n```"
    },
    {
        "slug": "longest-valid-parentheses",
        "tags": "java",
        "release_time": 1688495250,
        "code": "class Solution {\n    public int longestValidParentheses(String s) {\n        Stack<Integer> st = new Stack<>();\n        st.push(-1);\n        int n = 0;\n        for(int i = 0; i < s.length(); i++)\n        {\n            if(s.charAt(i) == '(')\n                st.push(i);\n            else if(s.charAt(i) == ')')\n            {\n                st.pop();\n                if(st.empty())\n                    st.push(i);\n                else\n                    n = Math.max(n, i - st.peek());\n            }\n        }\n        return n;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int longestValidParentheses(String s) {\\n        Stack<Integer> st = new Stack<>();\\n        st.push(-1);\\n        int n = 0;\\n        for(int i = 0; i < s.length(); i++)\\n        {\\n            if(s.charAt(i) == \\'(\\')\\n                st.push(i);\\n            else if(s.charAt(i) == \\')\\')\\n            {\\n                st.pop();\\n                if(st.empty())\\n                    st.push(i);\\n                else\\n                    n = Math.max(n, i - st.peek());\\n            }\\n        }\\n        return n;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "tags": "java",
        "release_time": 1678131044,
        "code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        \n        int sIndex = 100000;\n        int sDistance = 100000;\n\n        for (int i = 0; i < points.length; i++) {\n            \n            // Check if is a valid point\n            if (points[i][0] == x || points[i][1] == y) {\n\n                // Check if it is better than the previous best\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n                if (sDistance > distance) {\n                    sDistance = distance;\n                    sIndex = i;\n                }\n            }\n        }\n\n        // Check if we have a valid point to return\n        if (sIndex == 100000)\n            return -1;\n        return sIndex;\n    }\n}",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution involves a simple **iteration of the array**. \\n\\n*At each iteration* we have to check if **the point is valid**, in this case we have to check if the distance of this point is shorter than the distance that we found in previous iterations.\\n\\n**Note:** The initialization of sIndex and sDistance is higher than the *maximum value allowed by the input conditions*.\\n \\n# Complexity\\n- **Time complexity:** $O(n)$\\n- **Speed Beats:** 100%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity:** $O(1)$\\n- **Memory Beats:** 78.3%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        \\n        int sIndex = 100000;\\n        int sDistance = 100000;\\n\\n        for (int i = 0; i < points.length; i++) {\\n            \\n            // Check if is a valid point\\n            if (points[i][0] == x || points[i][1] == y) {\\n\\n                // Check if it is better than the previous best\\n                int distance = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n                if (sDistance > distance) {\\n                    sDistance = distance;\\n                    sIndex = i;\\n                }\\n            }\\n        }\\n\\n        // Check if we have a valid point to return\\n        if (sIndex == 100000)\\n            return -1;\\n        return sIndex;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximal-rectangle",
        "tags": "java",
        "release_time": 1691836401,
        "code": "class Pair<T, U> {\n    public final T first;\n    public final U second;\n\n    public Pair(T first, U second) {\n        this.first = first;\n        this.second = second;\n    }\n}\n\nclass Solution {\n    public int maximalRectangle(char[][] matrix) {\n        int n = matrix.length, m = matrix[0].length;\n        int[] nums = new int[m];\n        for (int j = 0; j < m; j++) {\n            nums[j] = matrix[0][j] - '0';\n        }\n        int max = maximumAreaHistogram(nums);\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == '0') {\n                    nums[j] = 0;\n                } else {\n                    nums[j] += (matrix[i][j] - '0');\n                }\n            }\n            max = Math.max(max, maximumAreaHistogram(nums));\n        }\n        return max;\n    }\n    public int maximumAreaHistogram(int[] heights) {\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\n        int[] left = new int[heights.length];\n        int pseudoIndex = -1;\n        //NSL\n        for (int i = 0; i < heights.length; i++) {\n            if (stack1.size() == 0) {\n                left[i] = pseudoIndex;\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\n                left[i] = stack1.peek().second;\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\n                    stack1.pop();\n                }\n                if (stack1.size() == 0) {\n                    left[i] = pseudoIndex;\n                } else {\n                    left[i] = stack1.peek().second;\n                }\n            }\n            stack1.push(new Pair<>(heights[i], i));\n        }\n        //NSR\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\n        int[] right = new int[heights.length];\n        pseudoIndex = heights.length;\n        for (int i = heights.length - 1; i >= 0; i--) {\n            if (stack2.size() == 0) {\n                right[i] = pseudoIndex;\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\n                right[i] = stack2.peek().second;\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\n                    stack2.pop();\n                }\n                if (stack2.size() == 0) {\n                    right[i] = pseudoIndex;\n                } else {\n                    right[i] = stack2.peek().second;\n                }\n            }\n            stack2.push(new Pair<>(heights[i], i));\n        }\n\n        int[] width = new int[heights.length];\n        for (int i = 0; i < heights.length; i++) {\n            width[i] = right[i] - left[i] - 1;\n        }\n\n        int[] area = new int[heights.length];\n        int maxArea = 0;\n        for (int i = 0; i < heights.length; i++) {\n            area[i] = heights[i] * width[i];\n            if (area[i] > maxArea) maxArea = area[i];\n        }\n        return maxArea;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Pair<T, U> {\\n    public final T first;\\n    public final U second;\\n\\n    public Pair(T first, U second) {\\n        this.first = first;\\n        this.second = second;\\n    }\\n}\\n\\nclass Solution {\\n    public int maximalRectangle(char[][] matrix) {\\n        int n = matrix.length, m = matrix[0].length;\\n        int[] nums = new int[m];\\n        for (int j = 0; j < m; j++) {\\n            nums[j] = matrix[0][j] - \\'0\\';\\n        }\\n        int max = maximumAreaHistogram(nums);\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == \\'0\\') {\\n                    nums[j] = 0;\\n                } else {\\n                    nums[j] += (matrix[i][j] - \\'0\\');\\n                }\\n            }\\n            max = Math.max(max, maximumAreaHistogram(nums));\\n        }\\n        return max;\\n    }\\n    public int maximumAreaHistogram(int[] heights) {\\n        Stack<Pair<Integer, Integer>> stack1 = new Stack<>();\\n        int[] left = new int[heights.length];\\n        int pseudoIndex = -1;\\n        //NSL\\n        for (int i = 0; i < heights.length; i++) {\\n            if (stack1.size() == 0) {\\n                left[i] = pseudoIndex;\\n            } else if (stack1.size() > 0 && stack1.peek().first < heights[i]) {\\n                left[i] = stack1.peek().second;\\n            } else if (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                while (stack1.size() > 0 && stack1.peek().first >= heights[i]) {\\n                    stack1.pop();\\n                }\\n                if (stack1.size() == 0) {\\n                    left[i] = pseudoIndex;\\n                } else {\\n                    left[i] = stack1.peek().second;\\n                }\\n            }\\n            stack1.push(new Pair<>(heights[i], i));\\n        }\\n        //NSR\\n        Stack<Pair<Integer, Integer>> stack2 = new Stack<>();\\n        int[] right = new int[heights.length];\\n        pseudoIndex = heights.length;\\n        for (int i = heights.length - 1; i >= 0; i--) {\\n            if (stack2.size() == 0) {\\n                right[i] = pseudoIndex;\\n            } else if (stack2.size() > 0 && stack2.peek().first < heights[i]) {\\n                right[i] = stack2.peek().second;\\n            } else if (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                while (stack2.size() > 0 && stack2.peek().first >= heights[i]) {\\n                    stack2.pop();\\n                }\\n                if (stack2.size() == 0) {\\n                    right[i] = pseudoIndex;\\n                } else {\\n                    right[i] = stack2.peek().second;\\n                }\\n            }\\n            stack2.push(new Pair<>(heights[i], i));\\n        }\\n\\n        int[] width = new int[heights.length];\\n        for (int i = 0; i < heights.length; i++) {\\n            width[i] = right[i] - left[i] - 1;\\n        }\\n\\n        int[] area = new int[heights.length];\\n        int maxArea = 0;\\n        for (int i = 0; i < heights.length; i++) {\\n            area[i] = heights[i] * width[i];\\n            if (area[i] > maxArea) maxArea = area[i];\\n        }\\n        return maxArea;\\n    }\\n}\\n```"
    },
    {
        "slug": "reverse-words-in-a-string",
        "tags": "java",
        "release_time": 1688410064,
        "code": "class Solution {\n    public String reverseWords(String s) {\n     s = s.trim();\n     int left = 0, right = s.length() - 1;\n     String ans = \"\";\n     String temp = \"\";\n     //Iterate the string and keep on adding to form a word\n\t//If empty space is encountered then add the current word to the result\n     while(left <= right) {\n         char ch = s.charAt(left);\n         if(ch != ' ')\n         temp += ch;\n         else if(ch == ' ') {\n             if(!ans.equals(\"\"))\n             ans = temp.trim() + \" \" + ans.trim();\n             else \n             ans = temp.trim();\n             temp = \"\";\n         }\n         left ++;\n     }\n//If not empty string then add to the result(Last word is added)\n     if(!temp.equals(\"\")) {\n         if(!ans.equals(\"\"))\n          ans = temp.trim() + \" \" + ans.trim();\n         else \n          ans = temp.trim();\n     }\n     return ans;\n    }\n}",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String reverseWords(String s) {\\n     s = s.trim();\\n     int left = 0, right = s.length() - 1;\\n     String ans = \"\";\\n     String temp = \"\";\\n     //Iterate the string and keep on adding to form a word\\n\\t//If empty space is encountered then add the current word to the result\\n     while(left <= right) {\\n         char ch = s.charAt(left);\\n         if(ch != \\' \\')\\n         temp += ch;\\n         else if(ch == \\' \\') {\\n             if(!ans.equals(\"\"))\\n             ans = temp.trim() + \" \" + ans.trim();\\n             else \\n             ans = temp.trim();\\n             temp = \"\";\\n         }\\n         left ++;\\n     }\\n//If not empty string then add to the result(Last word is added)\\n     if(!temp.equals(\"\")) {\\n         if(!ans.equals(\"\"))\\n          ans = temp.trim() + \" \" + ans.trim();\\n         else \\n          ans = temp.trim();\\n     }\\n     return ans;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL"
    },
    {
        "slug": "intersection-of-two-linked-lists",
        "tags": "java",
        "release_time": 1691478947,
        "code": "class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        int ac = 0;\n        int bc = 0;\n        ListNode a = headA;\n        ListNode b = headB;\n        while(a != null){\n            ac++;\n            a = a.next;\n        }\n        while(b != null){\n            bc++;\n            b = b.next;\n        }\n        while(ac > bc){\n            ac--;\n            headA = headA.next;\n        }\n        while(bc > ac){\n            bc--;\n            headB = headB.next;\n        }\n        \n        while(headA != headB){\n            headA = headA.next;\n            headB = headB.next;\n        }\n        return headA;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\\n        int ac = 0;\\n        int bc = 0;\\n        ListNode a = headA;\\n        ListNode b = headB;\\n        while(a != null){\\n            ac++;\\n            a = a.next;\\n        }\\n        while(b != null){\\n            bc++;\\n            b = b.next;\\n        }\\n        while(ac > bc){\\n            ac--;\\n            headA = headA.next;\\n        }\\n        while(bc > ac){\\n            bc--;\\n            headB = headB.next;\\n        }\\n        \\n        while(headA != headB){\\n            headA = headA.next;\\n            headB = headB.next;\\n        }\\n        return headA;\\n    }\\n}\\n"
    },
    {
        "slug": "lowest-common-ancestor-of-a-binary-search-tree",
        "tags": "java",
        "release_time": 1681332056,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if(root == null || root == p || root == q)return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\n\n        if(left == null)return right;\n        if(right == null)return left;\n        else{\n            return root;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\\n        if(root == null || root == p || root == q)return root;\\n\\n        TreeNode left = lowestCommonAncestor(root.left, p , q);\\n        TreeNode right = lowestCommonAncestor(root.right, p ,q);\\n\\n        if(left == null)return right;\\n        if(right == null)return left;\\n        else{\\n            return root;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "tags": "java",
        "release_time": 1687758678,
        "code": "class Solution {\n    public int numberOfGoodSubarraySplits(int[] nums) {\n        \n       List<Integer> list = new ArrayList<>();\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==1) list.add(i);\n        }\n        if(list.size()==0) return 0;\n        if(list.size()==1) return 1;\n        int mod =(int)1e9+7;\n        long res = 1;\n        for(int i=0;i<list.size()-1;i++){\n                long index1 = (long)list.get(i);\n                long index2 = (long)list.get(i+1);\n                res =  ( res%mod * (index2-index1)%mod)%mod;\n                \n            \n        }\n        return (int)res;\n         \n        \n       \n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    public int numberOfGoodSubarraySplits(int[] nums) {\\n        \\n       List<Integer> list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==1) list.add(i);\\n        }\\n        if(list.size()==0) return 0;\\n        if(list.size()==1) return 1;\\n        int mod =(int)1e9+7;\\n        long res = 1;\\n        for(int i=0;i<list.size()-1;i++){\\n                long index1 = (long)list.get(i);\\n                long index2 = (long)list.get(i+1);\\n                res =  ( res%mod * (index2-index1)%mod)%mod;\\n                \\n            \\n        }\\n        return (int)res;\\n         \\n        \\n       \\n        \\n    }\\n}"
    },
    {
        "slug": "rotating-the-box",
        "tags": "java",
        "release_time": 1621094749,
        "code": "// O(n^2) time | O(n^2) space\nclass Solution {\n    public char[][] rotateTheBox(char[][] box) {\n        int m = box.length;\n        int n = box[0].length;\n        char[][] matrix = new char[n][m];   \n        \n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\n        \n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\n        \n        return matrix;\n    }\n    \n    public void turnGravity(char[][] matrix, int m, int n){\n        for(int c = 0; c < n; c++){\n            int last  = m-1;\n            for(int r = m-1; r >= 0; r--){\n                char val =  matrix[r][c];\n                if(val == '.') continue;\n                if(val == '*') last = r-1;\n                if(val == '#') {\n                    matrix[r][c] = '.';\n                    matrix[last][c] = '#';\n                    last--;\n                }\n            }\n        }\n    }\n    \n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\n\t// numbers represents sequence it would be copied\n\t//[4][1]\n\t//[5][2]\n\t//[6][3]\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\n               matrix[r][c] = box[i][j];\n            }\n        }\n    }\n}",
        "content": "**So idea here is**\\n1. First turn 90 degree\\n2. Make things fall\\n\\n```\\n// O(n^2) time | O(n^2) space\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int m = box.length;\\n        int n = box[0].length;\\n        char[][] matrix = new char[n][m];   \\n        \\n        turnBox(box, matrix, m, n); // turn the box clockwise 90 degree\\n        \\n        turnGravity(matrix, n, m); // cause that falling effect, since matrix turned so n,m\\n        \\n        return matrix;\\n    }\\n    \\n    public void turnGravity(char[][] matrix, int m, int n){\\n        for(int c = 0; c < n; c++){\\n            int last  = m-1;\\n            for(int r = m-1; r >= 0; r--){\\n                char val =  matrix[r][c];\\n                if(val == \\'.\\') continue;\\n                if(val == \\'*\\') last = r-1;\\n                if(val == \\'#\\') {\\n                    matrix[r][c] = \\'.\\';\\n                    matrix[last][c] = \\'#\\';\\n                    last--;\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void turnBox(char[][] box, char[][] matrix, int m, int n){\\n\\t// numbers represents sequence it would be copied\\n\\t//[4][1]\\n\\t//[5][2]\\n\\t//[6][3]\\n        for(int i = 0, c = m-1; i < m; i++,c--){ // c: 4,3,2,1..\\n            for(int j = 0, r = 0; j < n; j++, r++){ // r:0,1,2,3..\\n               matrix[r][c] = box[i][j];\\n            }\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "check-if-point-is-reachable",
        "tags": "java",
        "release_time": 1674362091,
        "code": "class Solution {\n    public boolean isReachable(int targetX, int targetY) {\n        if (targetX > targetY)\n            return isReachable(targetY, targetX);\n        if (targetX % 2 == 0)\n            return isReachable(targetX / 2, targetY);\n        if (targetY % 2 == 0)\n            return isReachable(targetX, targetY / 2);\n            \n        if (targetX == 1) \n            return true;\n        \n        if (targetY == targetX)\n            return false;\n\n        return isReachable(targetX, (targetX + targetY) / 2);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst, if x,y is reachable, then y,x is reachable. So only take care the case x <= y.>\\nThe end point, if x = 1, then it surely is true, since you can use 1,1 and x,y -> x, 2y to reach 1,k until k is not smaller than y, then use x,y -> x, y-x to reach the final value.\\nif x = y and x is odd number and not 1, then it is a false case. since x, x and only come from x,0 and x,2x. And x,2x can only get from x,0 and x,3x. With go into a loop and none of them can go from 1,1.\\nSo when target x or y is even, divide it until odd. Then check if it fit the end points.\\nIf not, then x,y can go from x,x+y. Since x+y is even, so it can go to x,(x + y) / 2.\\nIn this case, for x,y, since (x+y)/2 is smaller then y, and it is possibly to be even again and keep divide 2. So finally it will either go to end with x = y case or it will go to x = 1 case.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isReachable(int targetX, int targetY) {\\n        if (targetX > targetY)\\n            return isReachable(targetY, targetX);\\n        if (targetX % 2 == 0)\\n            return isReachable(targetX / 2, targetY);\\n        if (targetY % 2 == 0)\\n            return isReachable(targetX, targetY / 2);\\n            \\n        if (targetX == 1) \\n            return true;\\n        \\n        if (targetY == targetX)\\n            return false;\\n\\n        return isReachable(targetX, (targetX + targetY) / 2);\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-amount-of-time-to-fill-cups",
        "tags": "java",
        "release_time": 1674567895,
        "code": "class Solution {\n    public int fillCups(int[] amount) {\n        Arrays.sort(amount);\n        int ans = 0;\n        int lo=0, hi=2;\n        if(amount[0] == 0) lo++;\n        if(lo==1 && amount[1]==0) return amount[2];\n\n        else if(lo==1){\n            ans += amount[hi];\n            return ans;\n        }\n        while(amount[lo] != 0){\n            ans++;\n            amount[lo]--;\n            amount[hi]--;\n            if(amount[hi-1] > amount[hi]){\n                int temp = amount[hi-1];\n                amount[hi-1] = amount[hi];\n                amount[hi] = temp;\n            }\n        }\n\n        ans += amount[2];\n        return ans;\n    }\n}",
        "content": "# Intuition\\nJust keep filling the least and most required cups together\\n\\n# Approach\\nSort the array. Keep removing the smallest value and the largest value by 1, until the smallest one is zero, then increase the answer by the left out max value\\n\\n# Complexity\\n- Time complexity:\\nO(smallest value)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int fillCups(int[] amount) {\\n        Arrays.sort(amount);\\n        int ans = 0;\\n        int lo=0, hi=2;\\n        if(amount[0] == 0) lo++;\\n        if(lo==1 && amount[1]==0) return amount[2];\\n\\n        else if(lo==1){\\n            ans += amount[hi];\\n            return ans;\\n        }\\n        while(amount[lo] != 0){\\n            ans++;\\n            amount[lo]--;\\n            amount[hi]--;\\n            if(amount[hi-1] > amount[hi]){\\n                int temp = amount[hi-1];\\n                amount[hi-1] = amount[hi];\\n                amount[hi] = temp;\\n            }\\n        }\\n\\n        ans += amount[2];\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "tags": "java",
        "release_time": 1669373945,
        "code": "class Solution {\n    public String firstPalindrome(String[] words) {\n        for (String s : words) {\n            if (isPalindrome(s)) return s;\n        }\n\n        return \"\";\n    }\n\n    public boolean isPalindrome(String s) {\n        int i = 0, j = s.length() - 1;\n\n        while (i < j) {\n            if (s.charAt(i++) != s.charAt(j--)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n\n// TC: O(n * k), SC: O(1)\n// n -> length of words\n// k -> length of longest string in words",
        "content": "### **Please Upvote** :D\\n##### 1. By checking if its a palindrome using two pointers:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words) {\\n            if (isPalindrome(s)) return s;\\n        }\\n\\n        return \"\";\\n    }\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```\\n##### 2. Using strinbuilder to reverse the strings and compare:\\n```\\nclass Solution {\\n    public String firstPalindrome(String[] words) {\\n        for (String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            sb.append(s).reverse();\\n\\n            if (s.equals(sb.toString())){\\n                return s;\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k), SC: O(1)\\n// n -> length of words\\n// k -> length of longest string in words\\n```"
    },
    {
        "slug": "next-greater-element-i",
        "tags": "java",
        "release_time": 1689926303,
        "code": "//starting with the end of array, when stack is empty, there is no greatter element the the last so put -1 in map\n//push it in stack. Now next element compare it with top element in stack. if nums2 < topof stack\n//put stack.peek in map else we will keep popping until we find element in stack which is greater than nums2 element\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // int [] arr = new int[nums2.length];\n        Stack<Integer> stack = new Stack<>();\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for(int i = nums2.length-1; i>=0; i--){\n            \n            if(stack.isEmpty()) {\n                // arr[i] = -1;\n                map.put(nums2[i], -1);\n            }\n            else if(!stack.isEmpty() && nums2[i]< stack.peek()){\n                // arr[i]= stack.peek();\n                map.put(nums2[i], stack.peek());\n            }\n            else{ // (!stack.isEmpty() && nums2[i]>= stack.peek())\n\n                while(!stack.isEmpty() && nums2[i]>= stack.peek()){\n                    stack.pop();\n                }\n                    if(stack.isEmpty()){\n                        // arr[i]= -1;\n                        map.put(nums2[i], -1);\n                    }\n                    else{\n                        // arr[i] = stack.peek();\n                        map.put(nums2[i], stack.peek());\n                    }    \n            }\n            stack.push(nums2[i]);\n        }\n\n        int ans[] = new int[nums1.length];\n        for(int i=0; i<nums1.length; i++){\n            ans[i] = map.get(nums1[i]);\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\nThis type of problem is called monotonic stack problems\\nApproach explained in code with comments\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//starting with the end of array, when stack is empty, there is no greatter element the the last so put -1 in map\\n//push it in stack. Now next element compare it with top element in stack. if nums2 < topof stack\\n//put stack.peek in map else we will keep popping until we find element in stack which is greater than nums2 element\\nclass Solution {\\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\\n        // int [] arr = new int[nums2.length];\\n        Stack<Integer> stack = new Stack<>();\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i = nums2.length-1; i>=0; i--){\\n            \\n            if(stack.isEmpty()) {\\n                // arr[i] = -1;\\n                map.put(nums2[i], -1);\\n            }\\n            else if(!stack.isEmpty() && nums2[i]< stack.peek()){\\n                // arr[i]= stack.peek();\\n                map.put(nums2[i], stack.peek());\\n            }\\n            else{ // (!stack.isEmpty() && nums2[i]>= stack.peek())\\n\\n                while(!stack.isEmpty() && nums2[i]>= stack.peek()){\\n                    stack.pop();\\n                }\\n                    if(stack.isEmpty()){\\n                        // arr[i]= -1;\\n                        map.put(nums2[i], -1);\\n                    }\\n                    else{\\n                        // arr[i] = stack.peek();\\n                        map.put(nums2[i], stack.peek());\\n                    }    \\n            }\\n            stack.push(nums2[i]);\\n        }\\n\\n        int ans[] = new int[nums1.length];\\n        for(int i=0; i<nums1.length; i++){\\n            ans[i] = map.get(nums1[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n![upVoteCatt.jpg](https://assets.leetcode.com/users/images/9b769025-fd88-4347-a90a-4e5c36078d82_1689926295.8722274.jpeg)\\n"
    },
    {
        "slug": "find-nearest-point-that-has-the-same-x-or-y-coordinate",
        "tags": "java",
        "release_time": 1683538037,
        "code": "class Solution {\n    public int nearestValidPoint(int x, int y, int[][] points) {\n        int minManh = Integer.MAX_VALUE;\n        int indMin = -1;\n        for (int i = 0; i < points.length; i++)\n        {\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\n            {\n                minManh = tmpManh;\n                indMin = i;\n            }\n        }\n        return indMin;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public int nearestValidPoint(int x, int y, int[][] points) {\\n        int minManh = Integer.MAX_VALUE;\\n        int indMin = -1;\\n        for (int i = 0; i < points.length; i++)\\n        {\\n            int tmpManh = Math.abs(x - points[i][0]) + Math.abs(y - points[i][1]);\\n            if ((x == points[i][0] || y == points[i][1]) && (tmpManh < minManh))\\n            {\\n                minManh = tmpManh;\\n                indMin = i;\\n            }\\n        }\\n        return indMin;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-number-of-balloons",
        "tags": "java",
        "release_time": 1688984016,
        "code": "class Solution {\n    public int maxNumberOfBalloons(String text) {\n        final int[][] cache = new int[2][5];\n        cache[0][0] = 97;  // a\n        cache[0][1] = 98;  // b\n        cache[0][2] = 108; // l\n        cache[0][3] = 110; // n\n        cache[0][4] = 111; // o\n        \n        // cacl letter frequencies\n        for (char ch : text.toCharArray()) {\n            final int intValue = ch;\n            for (int i = 0; i < 5; i++) {\n                if (intValue == cache[0][i]) {\n                    cache[1][i]++;\n                    break;\n                }\n            }\n        }\n\n        // l & o meet twice\n        cache[1][2] /= 2;\n        cache[1][4] /= 2;\n\n        // find the bottleneck\n        int min = Integer.MAX_VALUE;\n        for (int frequency: cache[1]) {\n            min = Math.min(min, frequency);\n        }\n\n        return min;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxNumberOfBalloons(String text) {\\n        final int[][] cache = new int[2][5];\\n        cache[0][0] = 97;  // a\\n        cache[0][1] = 98;  // b\\n        cache[0][2] = 108; // l\\n        cache[0][3] = 110; // n\\n        cache[0][4] = 111; // o\\n        \\n        // cacl letter frequencies\\n        for (char ch : text.toCharArray()) {\\n            final int intValue = ch;\\n            for (int i = 0; i < 5; i++) {\\n                if (intValue == cache[0][i]) {\\n                    cache[1][i]++;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // l & o meet twice\\n        cache[1][2] /= 2;\\n        cache[1][4] /= 2;\\n\\n        // find the bottleneck\\n        int min = Integer.MAX_VALUE;\\n        for (int frequency: cache[1]) {\\n            min = Math.min(min, frequency);\\n        }\\n\\n        return min;\\n    }\\n}\\n```"
    },
    {
        "slug": "sort-array-by-increasing-frequency",
        "tags": "java",
        "release_time": 1685118755,
        "code": "class Solution {\n    public int[] frequencySort(int[] a) {\n\tArrayList<Integer>al=new ArrayList<>();\n\t    for(int i=0;i<a.length;i++){\n\t        al.add(a[i]);\n\t    }\n\t    \nTreeSet<Integer>t2=new TreeSet<>(al);\nint k[]=new int[t2.size()];\nint c[]=new int[t2.size()];\nint x=0;\n\t    for(int i:t2){\n\t        c[x]=i;\n\tk[x]=Collections.frequency(al,i);\n\tx++;\n\t    }\n\t    for(int i=0;i<k.length;i++){\n\t        for(int j=i+1;j<k.length;j++){\n\t            if(k[i]>=k[j]){\n\t                int t=k[i];\n\t                k[i]=k[j];\n\t                k[j]=t;\n\t                int t1=c[i];\n\t                c[i]=c[j];\n\t                c[j]=t1;\n\t            }\n\t        }    \n\t    }\n\t\t\tint ans[]=new int[a.length];\n\t\t\tint r=0;\n\t    for(int i=0;i<k.length;i++){\n\t        int l=k[i];\n\t        while(l>0){\n\t        ans[r]=c[i];\n\t\t\tr++;\n\t        l--;\n\t        }\n\t    }\nreturn ans;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int[] frequencySort(int[] a) {\\n\\tArrayList<Integer>al=new ArrayList<>();\\n\\t    for(int i=0;i<a.length;i++){\\n\\t        al.add(a[i]);\\n\\t    }\\n\\t    \\nTreeSet<Integer>t2=new TreeSet<>(al);\\nint k[]=new int[t2.size()];\\nint c[]=new int[t2.size()];\\nint x=0;\\n\\t    for(int i:t2){\\n\\t        c[x]=i;\\n\\tk[x]=Collections.frequency(al,i);\\n\\tx++;\\n\\t    }\\n\\t    for(int i=0;i<k.length;i++){\\n\\t        for(int j=i+1;j<k.length;j++){\\n\\t            if(k[i]>=k[j]){\\n\\t                int t=k[i];\\n\\t                k[i]=k[j];\\n\\t                k[j]=t;\\n\\t                int t1=c[i];\\n\\t                c[i]=c[j];\\n\\t                c[j]=t1;\\n\\t            }\\n\\t        }    \\n\\t    }\\n\\t\\t\\tint ans[]=new int[a.length];\\n\\t\\t\\tint r=0;\\n\\t    for(int i=0;i<k.length;i++){\\n\\t        int l=k[i];\\n\\t        while(l>0){\\n\\t        ans[r]=c[i];\\n\\t\\t\\tr++;\\n\\t        l--;\\n\\t        }\\n\\t    }\\nreturn ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "max-area-of-island",
        "tags": "java",
        "release_time": 1672631767,
        "code": "class Solution {\n    public int max = 0;\n    public int sum = 0;\n    public int maxAreaOfIsland(int[][] grid) {\n        for(int i = 0; i<grid.length;i++)\n        {\n            for(int j = 0; j<grid[i].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    sum = 0; \n                    dfs(grid,i,j);\n                    max  = Math.max(max,sum);\n                }\n            }\n        }\n\n        return max;\n    }\n\n    private void dfs(int[][] grid ,int r ,int c)\n    {\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\n        {\n            return ;\n        }\n\n        sum++;\n        grid[r][c] = 0;\n        dfs(grid,r,c+1);\n        dfs(grid,r,c-1);\n        dfs(grid,r+1,c);\n        dfs(grid,r-1,c);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int max = 0;\\n    public int sum = 0;\\n    public int maxAreaOfIsland(int[][] grid) {\\n        for(int i = 0; i<grid.length;i++)\\n        {\\n            for(int j = 0; j<grid[i].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    sum = 0; \\n                    dfs(grid,i,j);\\n                    max  = Math.max(max,sum);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    private void dfs(int[][] grid ,int r ,int c)\\n    {\\n        if(r>=grid.length || c>=grid[0].length || r<0|| c<0 || grid[r][c]==0)\\n        {\\n            return ;\\n        }\\n\\n        sum++;\\n        grid[r][c] = 0;\\n        dfs(grid,r,c+1);\\n        dfs(grid,r,c-1);\\n        dfs(grid,r+1,c);\\n        dfs(grid,r-1,c);\\n    }\\n}\\n```"
    },
    {
        "slug": "goat-latin",
        "tags": "java",
        "release_time": 1683445696,
        "code": "class Solution {\n    public String toGoatLatin(String sentence) {\n        sentence.toLowerCase();\n        String[] words=sentence.split(\" \",0);\n        int i=1;\n        String ans=\"\";\n        for(String word:words){\n           \n            char p1=word.charAt(0);\n            char p=word.toLowerCase().charAt(0);\n            String k=\"\";\n            if(p=='a'||p=='i'||p=='o'||p=='e'||p=='u'){\n                k+=word+\"ma\";\n            }\n            else{\n                k+=word.substring(1,word.length());\n                k+=p1;\n                k+=\"ma\";\n            }\n            for(int m=0;m<i;m++){\n               k+='a';\n            }\n            ans+=k;\n            if(i!=words.length)ans+=\" \";\n            i++;\n        }\n        return ans;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String toGoatLatin(String sentence) {\\n        sentence.toLowerCase();\\n        String[] words=sentence.split(\" \",0);\\n        int i=1;\\n        String ans=\"\";\\n        for(String word:words){\\n           \\n            char p1=word.charAt(0);\\n            char p=word.toLowerCase().charAt(0);\\n            String k=\"\";\\n            if(p==\\'a\\'||p==\\'i\\'||p==\\'o\\'||p==\\'e\\'||p==\\'u\\'){\\n                k+=word+\"ma\";\\n            }\\n            else{\\n                k+=word.substring(1,word.length());\\n                k+=p1;\\n                k+=\"ma\";\\n            }\\n            for(int m=0;m<i;m++){\\n               k+=\\'a\\';\\n            }\\n            ans+=k;\\n            if(i!=words.length)ans+=\" \";\\n            i++;\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-students-doing-homework-at-a-given-time",
        "tags": "java",
        "release_time": 1690396136,
        "code": "class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int n=endTime.length;\n    int cnt=0;\n        for(int i=0;i<n;i++)\n        {\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\n            {\n                cnt++;\n            }\n        }\n        return cnt;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\\n        int n=endTime.length;\\n    int cnt=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(endTime[i]>=queryTime && queryTime>=startTime[i] )\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```"
    },
    {
        "slug": "groups-of-strings",
        "tags": "java",
        "release_time": 1643524944,
        "code": "class Solution {\n    public int[] groupStrings(String[] words) {\n        int n = words.length;\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\n        int[] masks = new int[n];\n        for (int i = 0; i < n; i++) {\n            for (char ch : words[i].toCharArray()) {\n                masks[i] |= (1 << ch - 'a');\n            }\n            maskToIndex.put(masks[i], i);\n        }\n        \n        DisjointSet disjointSet = new DisjointSet(n);\n        for (int i = 0; i < n; i++) {\n            // This is necessary to union the duplicate words\n            disjointSet.union(i, maskToIndex.get(masks[i]));\n            for (char ch : words[i].toCharArray()) {\n                // Removing ch from the word\n                int maskWithoutCh = masks[i] ^ (1 << ch - 'a');\n                if (maskToIndex.containsKey(maskWithoutCh)) {\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\n                }\n                \n                // Replace ch with any other charactor\n                for (int j = 0; j < 26; j++) {\n\t\t\t\t\t// Skip if the word already contains the char at j\n                    if (j == ch - 'a' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\n                        continue;\n                    }\n                    int maskWithReplace = maskWithoutCh | (1 << j);\n                    if (maskToIndex.containsKey(maskWithReplace)) {\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\n                    }\n                }\n            }\n        }\n        return disjointSet.getState();\n    }\n\n    private final class DisjointSet {\n        private int[] parent;\n        private int[] size;\n        private int groupCount;\n        private int maxSize;\n        \n        DisjointSet(int n) {\n            groupCount = n;\n            maxSize = 1;\n            parent = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                size[i] = 1;\n            }\n        }\n        \n        public int find(int a) {\n            if (parent[a] != a) {\n                parent[a] = find(parent[a]);\n            }\n            return parent[a];\n        }\n        \n        public void union(int a, int b) {\n            if (a == b) {\n                return;\n            }\n            int pa = find(a);\n            int pb = find(b);\n            if (pa != pb) {\n\t\t\t\t// Improving the runtime for find operations by joining the small group to large one\n                if (size[pb] < size[pa]) {\n                    parent[pa] = pb;\n                    size[pb] += size[pa];\n                    maxSize = Math.max(maxSize, size[pb]);\n                } else {\n                    parent[pb] = pa;\n                    size[pa] += size[pb];\n                    maxSize = Math.max(maxSize, size[pa]);\n                }\n                groupCount--;\n            }\n        }\n        \n        public int[] getState() {\n            return new int[]{groupCount, maxSize};\n        }\n    }\n}",
        "content": "My O(26 * 26 * n) solution using union-find + bitmask. using a couple of ideas to optimize the runtime. Beat 100% with ~600ms runtime.\\n\\n```\\nclass Solution {\\n    public int[] groupStrings(String[] words) {\\n        int n = words.length;\\n        Map<Integer, Integer> maskToIndex = new HashMap<>();\\n        int[] masks = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            for (char ch : words[i].toCharArray()) {\\n                masks[i] |= (1 << ch - \\'a\\');\\n            }\\n            maskToIndex.put(masks[i], i);\\n        }\\n        \\n        DisjointSet disjointSet = new DisjointSet(n);\\n        for (int i = 0; i < n; i++) {\\n            // This is necessary to union the duplicate words\\n            disjointSet.union(i, maskToIndex.get(masks[i]));\\n            for (char ch : words[i].toCharArray()) {\\n                // Removing ch from the word\\n                int maskWithoutCh = masks[i] ^ (1 << ch - \\'a\\');\\n                if (maskToIndex.containsKey(maskWithoutCh)) {\\n                    disjointSet.union(i, maskToIndex.get(maskWithoutCh));\\n                }\\n                \\n                // Replace ch with any other charactor\\n                for (int j = 0; j < 26; j++) {\\n\\t\\t\\t\\t\\t// Skip if the word already contains the char at j\\n                    if (j == ch - \\'a\\' || (maskWithoutCh | (1 << j)) == maskWithoutCh) {\\n                        continue;\\n                    }\\n                    int maskWithReplace = maskWithoutCh | (1 << j);\\n                    if (maskToIndex.containsKey(maskWithReplace)) {\\n                        disjointSet.union(i, maskToIndex.get(maskWithReplace));\\n                    }\\n                }\\n            }\\n        }\\n        return disjointSet.getState();\\n    }\\n\\n    private final class DisjointSet {\\n        private int[] parent;\\n        private int[] size;\\n        private int groupCount;\\n        private int maxSize;\\n        \\n        DisjointSet(int n) {\\n            groupCount = n;\\n            maxSize = 1;\\n            parent = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int a) {\\n            if (parent[a] != a) {\\n                parent[a] = find(parent[a]);\\n            }\\n            return parent[a];\\n        }\\n        \\n        public void union(int a, int b) {\\n            if (a == b) {\\n                return;\\n            }\\n            int pa = find(a);\\n            int pb = find(b);\\n            if (pa != pb) {\\n\\t\\t\\t\\t// Improving the runtime for find operations by joining the small group to large one\\n                if (size[pb] < size[pa]) {\\n                    parent[pa] = pb;\\n                    size[pb] += size[pa];\\n                    maxSize = Math.max(maxSize, size[pb]);\\n                } else {\\n                    parent[pb] = pa;\\n                    size[pa] += size[pb];\\n                    maxSize = Math.max(maxSize, size[pa]);\\n                }\\n                groupCount--;\\n            }\\n        }\\n        \\n        public int[] getState() {\\n            return new int[]{groupCount, maxSize};\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "cousins-in-binary-tree-ii",
        "tags": "java",
        "release_time": 1681576707,
        "code": "class Solution {\n    class Pair{\n        TreeNode node;\n        TreeNode parent;\n        public Pair(TreeNode n, TreeNode p){\n            node = n;\n            parent = p;\n        }\n    }\n    \n    public TreeNode replaceValueInTree(TreeNode root) {\n        // same depth diff parent\n        Queue<Pair> q = new LinkedList<>();\n        q.add(new Pair(root, null));\n        \n        int curLevelChildSum = 0;\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \n        \n        while(!q.isEmpty()){\n           \n            \n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\n            curLevelChildSum = 0;   // reset cursum\n            \n            int size = q.size();\n            \n            while(size-- > 0){\n                Pair front = q.poll();\n                \n                TreeNode node = front.node;\n                TreeNode par = front.parent;\n\n                int childsum = 0; \n                // left\n                if(node.left != null){\n                    q.add(new Pair(node.left, node));\n                    childsum += node.left.val;\n                }\n                // right\n                if(node.right != null){\n                    q.add(new Pair(node.right, node));\n                    childsum += node.right.val;\n                }\n                \n                // put value in map\n                map.put(node, childsum);\n                \n                curLevelChildSum += childsum;\n                \n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node's parent\n            }\n            \n        }\n        \n        return root;\n    }\n}",
        "content": "**Time** O(n)\\n**Space** O(n+n)\\n\\n**Explanation**\\nEach node we need:\\ntotal childsum of the level\\nparent\\'s child sum\\nso putting in map with parent and childsum of parent\\nnode.val = (totalchildsum of prevlevel - parent\\'s child sum)\\n\\nPlease do dry run on test case\\n```\\nclass Solution {\\n    class Pair{\\n        TreeNode node;\\n        TreeNode parent;\\n        public Pair(TreeNode n, TreeNode p){\\n            node = n;\\n            parent = p;\\n        }\\n    }\\n    \\n    public TreeNode replaceValueInTree(TreeNode root) {\\n        // same depth diff parent\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(root, null));\\n        \\n        int curLevelChildSum = 0;\\n        Map<TreeNode, Integer> map = new HashMap<>();       // storing parent : childsum   \\n        \\n        while(!q.isEmpty()){\\n           \\n            \\n            int lastLevelChildSum = curLevelChildSum;    // prevsum = cursum\\n            curLevelChildSum = 0;   // reset cursum\\n            \\n            int size = q.size();\\n            \\n            while(size-- > 0){\\n                Pair front = q.poll();\\n                \\n                TreeNode node = front.node;\\n                TreeNode par = front.parent;\\n\\n                int childsum = 0; \\n                // left\\n                if(node.left != null){\\n                    q.add(new Pair(node.left, node));\\n                    childsum += node.left.val;\\n                }\\n                // right\\n                if(node.right != null){\\n                    q.add(new Pair(node.right, node));\\n                    childsum += node.right.val;\\n                }\\n                \\n                // put value in map\\n                map.put(node, childsum);\\n                \\n                curLevelChildSum += childsum;\\n                \\n                node.val = lastLevelChildSum - map.getOrDefault(par, 0);  // get(par) gives me childsum of this node\\'s parent\\n            }\\n            \\n        }\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nUpvote Kardo Yr !"
    },
    {
        "slug": "count-unguarded-cells-in-the-grid",
        "tags": "java",
        "release_time": 1651346958,
        "code": "class Solution {\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\n        int result = 0, cnti, cntj;\n        for(int[] i : walls){       //We insert all the walls\n            res[i[0]][i[1]] = 2;\n        }\n        for(int[] i : guards){      //We insert all the guards\n            res[i[0]][i[1]] = 1;  \n        }\n        for(int i = 0; i < res.length;i++){\n            for(int j = 0; j < res[i].length;j++){\n                if(res[i][j] == 1){     //If we found a guard...\n                    cnti = i;   //Position of the guard\n                    cntj = j;   //Position of the guard\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\n                        res[cnti-1][cntj] = 3;\n                        cnti--;\n                    }\n                    cnti = i;  //We reset the value to the initial one\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\n                        res[cnti+1][cntj] = 3;\n                        cnti++;\n                    }\n                    cnti = i;  //We reset the value to the initial one\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\n                        res[cnti][cntj-1] = 3;\n                        cntj--;\n                    }\n                    cntj = j;  //We reset the value to the initial one\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\n                        res[cnti][cntj+1] = 3;\n                        cntj++;\n                    }\n                }\n            }\n        }\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\n            for(int j : i){\n                if(j == 0){   //If we find a '0', we add one to the counter as it is an unguarded cell\n                    result++;\n                }\n            }\n        }\n        return result;  //We return the number of unguarded cells\n    }\n}",
        "content": "# | JAVA | Step by step Solution -->\\n1. We wil create a matrix call `res` with dimensions (`m`,`n`). When created, the matrix will contain only zeros.\\n    Zeros represent unguarded cells.\\n\\n2. We add the walls to the correct positions in `res`, the same case for the guards. \\n    Walls will be represented in `res` with the number 2 and guards using the number 1.\\n\\t\\n3. We start parsing the matrix, if we find a 1 (guard), we try to change the respective cells \\n    affected in `res` with the number 3 until we face a wall or another guard.\\n\\t\\n4. Once all the guards have guarded their respective cells, we parse the matrix again, if we find\\n    a zero (unguarded cell) we add one to the counter (`result`).\\n\\n5. We return `result` :). Hope you have understand it!! \\n\\nLeave a like and a comment if you have any question.\\n\\n```\\nclass Solution {\\n    public int countUnguarded(int m, int n, int[][] guards, int[][] walls) {\\n        int[][] res = new int[m][n];   //We create the matrix with the proper dimension\\n        int result = 0, cnti, cntj;\\n        for(int[] i : walls){       //We insert all the walls\\n            res[i[0]][i[1]] = 2;\\n        }\\n        for(int[] i : guards){      //We insert all the guards\\n            res[i[0]][i[1]] = 1;  \\n        }\\n        for(int i = 0; i < res.length;i++){\\n            for(int j = 0; j < res[i].length;j++){\\n                if(res[i][j] == 1){     //If we found a guard...\\n                    cnti = i;   //Position of the guard\\n                    cntj = j;   //Position of the guard\\n                    while(cnti-1 != -1 && res[cnti-1][cntj] != 2 && res[cnti-1][cntj] != 1){  //If we can go up in the matrix...\\n                        res[cnti-1][cntj] = 3;\\n                        cnti--;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cnti+1 != m && res[cnti+1][cntj] != 2 && res[cnti+1][cntj] != 1){   //If we can go down in the matrix...\\n                        res[cnti+1][cntj] = 3;\\n                        cnti++;\\n                    }\\n                    cnti = i;  //We reset the value to the initial one\\n                    while(cntj-1 != -1 && res[cnti][cntj-1] != 2 && res[cnti][cntj-1] != 1){  //If we can go to left in the matrix...\\n                        res[cnti][cntj-1] = 3;\\n                        cntj--;\\n                    }\\n                    cntj = j;  //We reset the value to the initial one\\n                    while(cntj+1 != n && res[cnti][cntj+1] != 2 && res[cnti][cntj+1] != 1){  //If we can go to rigth in the matrix...\\n                        res[cnti][cntj+1] = 3;\\n                        cntj++;\\n                    }\\n                }\\n            }\\n        }\\n        for(int[] i : res){   //Once we have marked the correct squares in the matrix...\\n            for(int j : i){\\n                if(j == 0){   //If we find a \\'0\\', we add one to the counter as it is an unguarded cell\\n                    result++;\\n                }\\n            }\\n        }\\n        return result;  //We return the number of unguarded cells\\n    }\\n}\\n```\\n\\n"
    },
    {
        "slug": "second-minimum-node-in-a-binary-tree",
        "tags": "java",
        "release_time": 1683616223,
        "code": "class Solution {\n    public int findSecondMinimumValue(TreeNode root) {\n        Set<Integer>hs=new HashSet();\n        find(root,hs);\n        int k=0;\n        int[] ans=new int[hs.size()];\n        for(var i:hs){\n            ans[k++]=i;\n        }\n        Arrays.sort(ans);\n        if(ans.length==1)return -1;   \n         return ans[1];\n    }\n    static void find(TreeNode root,Set<Integer>hs){\n        if(root==null)return;\n        find(root.left,hs);\n        hs.add(root.val);\n        find(root.right,hs);\n    }\n}",
        "content": "# Approach\\nThe given code is a Java implementation of a solution to find the second minimum value in a binary tree. Let\\'s break down the approach step by step:\\n\\n1. The `findSecondMinimumValue` method takes a `TreeNode` object called `root` as input and returns an integer.\\n\\n2. Inside the method, a `HashSet` called `hs` is created to store unique values encountered during the tree traversal.\\n\\n3. The `find` method is called to perform an in-order traversal of the binary tree. It takes the `root` node and the `hs` set as parameters.\\n\\n4. The `find` method is a recursive function that performs an in-order traversal of the binary tree. It visits the left subtree first, then adds the value of the current node to the `hs` set, and finally visits the right subtree.\\n\\n5. After the traversal is complete, the `hs` set will contain all unique values from the binary tree.\\n\\n6. An integer variable `k` is initialized to 0, and an integer array `ans` of size `hs.size()` is created to store the values from the `hs` set.\\n\\n7. A for-each loop iterates over the elements of the `hs` set and assigns them to the `ans` array.\\n\\n8. The `ans` array is sorted in ascending order using the `Arrays.sort` method.\\n\\n9. If the length of the `ans` array is 1, it means there is only one unique value in the binary tree. In this case, -1 is returned as there is no second minimum value.\\n\\n10. Otherwise, the second element (index 1) of the sorted `ans` array is returned as the second minimum value.\\n\\nIn summary, the code performs an in-order traversal of a binary tree, collects all unique values in a `HashSet`, and then finds the second minimum value from the collected values.\\n\\n# Complexity\\n- **Time complexity**:\\nThe time complexity of the code is O(n + m log m), where n is the number of nodes in the tree and m is the number of unique values in the tree.\\n\\n- **Space complexity**:\\nThe space complexity of the code is O(n + m) in the average case and O(n) in the worst case, where n is the number of nodes in the tree and m is the number of unique values.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findSecondMinimumValue(TreeNode root) {\\n        Set<Integer>hs=new HashSet();\\n        find(root,hs);\\n        int k=0;\\n        int[] ans=new int[hs.size()];\\n        for(var i:hs){\\n            ans[k++]=i;\\n        }\\n        Arrays.sort(ans);\\n        if(ans.length==1)return -1;   \\n         return ans[1];\\n    }\\n    static void find(TreeNode root,Set<Integer>hs){\\n        if(root==null)return;\\n        find(root.left,hs);\\n        hs.add(root.val);\\n        find(root.right,hs);\\n    }\\n}\\n```"
    },
    {
        "slug": "move-zeroes",
        "tags": "java",
        "release_time": 1684064317,
        "code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        int m=-1;\n        for(int i=0; i<nums.length; i++)\n        {\n            if(nums[i]==0)\n            {\n                if(m==-1 || nums[m]!=0)\n                {\n                    m=i;\n                }\n            }\n            else\n            {\n                if(m!=-1)\n                {\n                    int temp = nums[i];\n                    nums[i]=nums[m];\n                    nums[m]=temp;\n                    m++;\n                }\n            }\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this solution is to move all the zeroes in the input array nums to the end of the array while maintaining the relative order of the non-zero elements\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable m to -1, which will keep track of the position of the first zero encountered.\\n2. Traverse the array nums from left to right: a. If the current element is zero, and m is -1 or the element at position m is non-zero, set m to the current index. b. If the current element is non-zero and m is not -1, swap the current element with the element at position m and increment m.\\n3. After the traversal, all the zeroes will be at the end of the array, and the relative order of the non-zero elements will be maintained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O(n), where n is the length of the input array nums. The algorithm iterates through the array once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), as the algorithm only uses a constant amount of extra space to store the variable m and the temporary variable temp used for swapping elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public void moveZeroes(int[] nums) {\\n        int m=-1;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                if(m==-1 || nums[m]!=0)\\n                {\\n                    m=i;\\n                }\\n            }\\n            else\\n            {\\n                if(m!=-1)\\n                {\\n                    int temp = nums[i];\\n                    nums[i]=nums[m];\\n                    nums[m]=temp;\\n                    m++;\\n                }\\n            }\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "difference-of-number-of-distinct-values-on-diagonals",
        "tags": "java",
        "release_time": 1685255570,
        "code": "class Solution {\n    public int[][] differenceOfDistinctValues(int[][] grid) {\n               int m = grid.length;\n        int n = grid[0].length;\n        int[][] res=new int[m][n];\n        for(int i=0;i<grid.length;i++){\n            for(int j=0;j<grid[0].length;j++){\n                res[i][j]=calculate(grid,i,j);\n            }\n        }\n        return res;\n    }\n    \n    int calculate(int[][] arr,int i,int j){\n        int r1=i;\n        int r2=i;\n        int c1=j;\n        int c2=j;\n        \n        HashSet<Integer> hs1=new HashSet(); // to store distinct values of upper diagonal\n        HashSet<Integer> hs2=new HashSet(); // to store distinct values of lower diagonal\n        \n        // to store distinct values of upper diagonal\n        while(r1>0 && c1>0){\n            hs1.add(arr[--r1][--c1]);\n        }\n        \n        // to store distinct values of lower diagonal\n        while(r2<arr.length-1 && c2<arr[0].length-1){\n            hs2.add(arr[++r2][++c2]);\n        }\n        return Math.abs(hs1.size()-hs2.size());\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[][] differenceOfDistinctValues(int[][] grid) {\\n               int m = grid.length;\\n        int n = grid[0].length;\\n        int[][] res=new int[m][n];\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                res[i][j]=calculate(grid,i,j);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int calculate(int[][] arr,int i,int j){\\n        int r1=i;\\n        int r2=i;\\n        int c1=j;\\n        int c2=j;\\n        \\n        HashSet<Integer> hs1=new HashSet(); // to store distinct values of upper diagonal\\n        HashSet<Integer> hs2=new HashSet(); // to store distinct values of lower diagonal\\n        \\n        // to store distinct values of upper diagonal\\n        while(r1>0 && c1>0){\\n            hs1.add(arr[--r1][--c1]);\\n        }\\n        \\n        // to store distinct values of lower diagonal\\n        while(r2<arr.length-1 && c2<arr[0].length-1){\\n            hs2.add(arr[++r2][++c2]);\\n        }\\n        return Math.abs(hs1.size()-hs2.size());\\n    }\\n}\\n```"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "tags": "java",
        "release_time": 1692429746,
        "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0;\n        for(int i=1; i<prices.length; i++){\n            if(prices[i]>prices[i-1]){\n                profit+=prices[i]-prices[i-1];\n            }\n        }\n        return profit;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int profit=0;\\n        for(int i=1; i<prices.length; i++){\\n            if(prices[i]>prices[i-1]){\\n                profit+=prices[i]-prices[i-1];\\n            }\\n        }\\n        return profit;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-population-year",
        "tags": "java",
        "release_time": 1690826675,
        "code": "class Solution {\n    public int maximumPopulation(int[][] logs) {\n        int[] arr = new int[101];\n        for(int[] log : logs) {\n            int birth = log[0];\n            int death = log[1];\n            arr[birth-1950]++;\n            arr[death-1950]--;\n        }\n\n        int max = arr[0];\n        int year = 1950;\n        for(int i = 1 ; i < 101; i++) {\n            arr[i] += arr[i-1];\n            if(arr[i] > max) {\n                max = arr[i];\n                year = 1950 + i;\n            }\n        }\n        return year;\n    }\n}",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We want to analyze a range of years from 1950 to 2050, and we\\'ll use an array of size 101 to store our data.\\n\\n2. To work with the array more conveniently, we will shift the input years to the range of 0 to 100. For example, for the year 1950, we will store it at index 0, for 1951 at index 1, and so on.\\n\\n3. For every log entry [birth, death], increment the value in array at index \\'birth\\' by 1 and decrement the value at index \\'death\\' by 1.\\n\\n4. While doing the prefix sum, we will simultaneously find the year with the maximum number of people alive in the range.\\n\\n5. Finally, the result will be the year with the maximum number of people alive, but we need to convert it back to the original year by adding 1950 to the index.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumPopulation(int[][] logs) {\\n        int[] arr = new int[101];\\n        for(int[] log : logs) {\\n            int birth = log[0];\\n            int death = log[1];\\n            arr[birth-1950]++;\\n            arr[death-1950]--;\\n        }\\n\\n        int max = arr[0];\\n        int year = 1950;\\n        for(int i = 1 ; i < 101; i++) {\\n            arr[i] += arr[i-1];\\n            if(arr[i] > max) {\\n                max = arr[i];\\n                year = 1950 + i;\\n            }\\n        }\\n        return year;\\n    }\\n}\\n```\\n![WhatsApp Image 2023-07-31 at 11.33.06 PM.jpeg](https://assets.leetcode.com/users/images/7288dd9b-bf65-4e4b-8a0c-15a50e28ec5c_1690826615.9786594.jpeg)\\n\\n"
    },
    {
        "slug": "lfu-cache",
        "tags": "java",
        "release_time": 1678871787,
        "code": "class LFUCache {\n\n    final int capacity;\n    int curSize;\n    int minFrequency;\n    Map<Integer, DLLNode> cache;\n    Map<Integer, DoubleLinkedList> frequencyMap;\n\n    /*.*/\n    /*\n    * @param capacity: total capacity of LFU Cache\n    * @param curSize: current size of LFU cache\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\n    * double linked list by their frequencies\n    * */\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.curSize = 0;\n        this.minFrequency = 0;\n\n        this.cache = new HashMap<>();\n        this.frequencyMap = new HashMap<>();\n    }\n\n    /** get node value by key, and then update node frequency as well as relocate that node **/\n    public int get(int key) {\n        DLLNode curNode = cache.get(key);\n        if (curNode == null) {\n            return -1;\n        }\n        updateNode(curNode);\n        return curNode.val;\n    }\n\n    /**\n     * add new node into LFU cache, as well as double linked list\n     * condition 1: if LFU cache has input key, update node value and node position in list\n     * condition 2: if LFU cache does NOT have input key\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\n     *  in minimum frequency list, then add new node\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\n     * **/\n    public void put(int key, int value) {\n        // corner case: check cache capacity initialization\n        if (capacity == 0) {\n            return;\n        }\n\n        if (cache.containsKey(key)) {\n            DLLNode curNode = cache.get(key);\n            curNode.val = value;\n            updateNode(curNode);\n        }\n        else {\n            curSize++;\n            if (curSize > capacity) {\n                // get minimum frequency list\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\n                cache.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                curSize--;\n            }\n            // reset min frequency to 1 because of adding new node\n            minFrequency = 1;\n            DLLNode newNode = new DLLNode(key, value);\n\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\n            curList.addNode(newNode);\n            frequencyMap.put(1, curList);\n            cache.put(key, newNode);\n        }\n    }\n\n    public void updateNode(DLLNode curNode) {\n        int curFreq = curNode.frequency;\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\n        curList.removeNode(curNode);\n\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\n        // we need to remove the entire list and then increase min frequency value by 1\n        if (curFreq == minFrequency && curList.listSize == 0) {\n            minFrequency++;\n        }\n\n        curNode.frequency++;\n        // add current node to another list has current frequency + 1,\n        // if we do not have the list with this frequency, initialize it\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\n        newList.addNode(curNode);\n        frequencyMap.put(curNode.frequency, newList);\n    }\n\n    /*\n    * @param key: node key\n    * @param val: node value\n    * @param frequency: frequency count of current node\n    * (all nodes connected in same double linked list has same frequency)\n    * @param prev: previous pointer of current node\n    * @param next: next pointer of current node\n    * */\n    class DLLNode {\n        int key;\n        int val;\n        int frequency;\n        DLLNode prev;\n        DLLNode next;\n\n        public DLLNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n            this.frequency = 1;\n        }\n    }\n\n    /*\n    * @param listSize: current size of double linked list\n    * @param head: head node of double linked list\n    * @param tail: tail node of double linked list\n    * */\n    class DoubleLinkedList {\n        int listSize;\n        DLLNode head;\n        DLLNode tail;\n        public DoubleLinkedList() {\n            this.listSize = 0;\n            this.head = new DLLNode(0, 0);\n            this.tail = new DLLNode(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        /** add new node into head of list and increase list size by 1 **/\n        public void addNode(DLLNode curNode) {\n            DLLNode nextNode = head.next;\n            curNode.next = nextNode;\n            curNode.prev = head;\n            head.next = curNode;\n            nextNode.prev = curNode;\n            listSize++;\n        }\n\n        /** remove input node and decrease list size by 1**/\n        public void removeNode(DLLNode curNode) {\n            DLLNode prevNode = curNode.prev;\n            DLLNode nextNode = curNode.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n            listSize--;\n        }\n\n    }\n}\n\n/**\n * Your LFUCache object will be instantiated and called as such:\n * LFUCache obj = new LFUCache(capacity);\n * int param_1 = obj.get(key);\n * obj.put(key,value);\n */",
        "content": "\\n\\n# Code\\n```\\nclass LFUCache {\\n\\n    final int capacity;\\n    int curSize;\\n    int minFrequency;\\n    Map<Integer, DLLNode> cache;\\n    Map<Integer, DoubleLinkedList> frequencyMap;\\n\\n    /*.*/\\n    /*\\n    * @param capacity: total capacity of LFU Cache\\n    * @param curSize: current size of LFU cache\\n    * @param minFrequency: frequency of the last linked list (the minimum frequency of entire LFU cache)\\n    * @param cache: a hash map that has key to Node mapping, which used for storing all nodes by their keys\\n    * @param frequencyMap: a hash map that has key to linked list mapping, which used for storing all\\n    * double linked list by their frequencies\\n    * */\\n    public LFUCache(int capacity) {\\n        this.capacity = capacity;\\n        this.curSize = 0;\\n        this.minFrequency = 0;\\n\\n        this.cache = new HashMap<>();\\n        this.frequencyMap = new HashMap<>();\\n    }\\n\\n    /** get node value by key, and then update node frequency as well as relocate that node **/\\n    public int get(int key) {\\n        DLLNode curNode = cache.get(key);\\n        if (curNode == null) {\\n            return -1;\\n        }\\n        updateNode(curNode);\\n        return curNode.val;\\n    }\\n\\n    /**\\n     * add new node into LFU cache, as well as double linked list\\n     * condition 1: if LFU cache has input key, update node value and node position in list\\n     * condition 2: if LFU cache does NOT have input key\\n     *  - sub condition 1: if LFU cache does NOT have enough space, remove the Least Recent Used node\\n     *  in minimum frequency list, then add new node\\n     *  - sub condition 2: if LFU cache has enough space, add new node directly\\n     * **/\\n    public void put(int key, int value) {\\n        // corner case: check cache capacity initialization\\n        if (capacity == 0) {\\n            return;\\n        }\\n\\n        if (cache.containsKey(key)) {\\n            DLLNode curNode = cache.get(key);\\n            curNode.val = value;\\n            updateNode(curNode);\\n        }\\n        else {\\n            curSize++;\\n            if (curSize > capacity) {\\n                // get minimum frequency list\\n                DoubleLinkedList minFreqList = frequencyMap.get(minFrequency);\\n                cache.remove(minFreqList.tail.prev.key);\\n                minFreqList.removeNode(minFreqList.tail.prev);\\n                curSize--;\\n            }\\n            // reset min frequency to 1 because of adding new node\\n            minFrequency = 1;\\n            DLLNode newNode = new DLLNode(key, value);\\n\\n            // get the list with frequency 1, and then add new node into the list, as well as into LFU cache\\n            DoubleLinkedList curList = frequencyMap.getOrDefault(1, new DoubleLinkedList());\\n            curList.addNode(newNode);\\n            frequencyMap.put(1, curList);\\n            cache.put(key, newNode);\\n        }\\n    }\\n\\n    public void updateNode(DLLNode curNode) {\\n        int curFreq = curNode.frequency;\\n        DoubleLinkedList curList = frequencyMap.get(curFreq);\\n        curList.removeNode(curNode);\\n\\n        // if current list the the last list which has lowest frequency and current node is the only node in that list\\n        // we need to remove the entire list and then increase min frequency value by 1\\n        if (curFreq == minFrequency && curList.listSize == 0) {\\n            minFrequency++;\\n        }\\n\\n        curNode.frequency++;\\n        // add current node to another list has current frequency + 1,\\n        // if we do not have the list with this frequency, initialize it\\n        DoubleLinkedList newList = frequencyMap.getOrDefault(curNode.frequency, new DoubleLinkedList());\\n        newList.addNode(curNode);\\n        frequencyMap.put(curNode.frequency, newList);\\n    }\\n\\n    /*\\n    * @param key: node key\\n    * @param val: node value\\n    * @param frequency: frequency count of current node\\n    * (all nodes connected in same double linked list has same frequency)\\n    * @param prev: previous pointer of current node\\n    * @param next: next pointer of current node\\n    * */\\n    class DLLNode {\\n        int key;\\n        int val;\\n        int frequency;\\n        DLLNode prev;\\n        DLLNode next;\\n\\n        public DLLNode(int key, int val) {\\n            this.key = key;\\n            this.val = val;\\n            this.frequency = 1;\\n        }\\n    }\\n\\n    /*\\n    * @param listSize: current size of double linked list\\n    * @param head: head node of double linked list\\n    * @param tail: tail node of double linked list\\n    * */\\n    class DoubleLinkedList {\\n        int listSize;\\n        DLLNode head;\\n        DLLNode tail;\\n        public DoubleLinkedList() {\\n            this.listSize = 0;\\n            this.head = new DLLNode(0, 0);\\n            this.tail = new DLLNode(0, 0);\\n            head.next = tail;\\n            tail.prev = head;\\n        }\\n\\n        /** add new node into head of list and increase list size by 1 **/\\n        public void addNode(DLLNode curNode) {\\n            DLLNode nextNode = head.next;\\n            curNode.next = nextNode;\\n            curNode.prev = head;\\n            head.next = curNode;\\n            nextNode.prev = curNode;\\n            listSize++;\\n        }\\n\\n        /** remove input node and decrease list size by 1**/\\n        public void removeNode(DLLNode curNode) {\\n            DLLNode prevNode = curNode.prev;\\n            DLLNode nextNode = curNode.next;\\n            prevNode.next = nextNode;\\n            nextNode.prev = prevNode;\\n            listSize--;\\n        }\\n\\n    }\\n}\\n\\n/**\\n * Your LFUCache object will be instantiated and called as such:\\n * LFUCache obj = new LFUCache(capacity);\\n * int param_1 = obj.get(key);\\n * obj.put(key,value);\\n */\\n```"
    },
    {
        "slug": "number-of-zero-filled-subarrays",
        "tags": "java",
        "release_time": 1679359163,
        "code": "class Solution {\n    public long zeroFilledSubarray(int[] nums) {\n        long res = 0;\n        for (int i = 0; i < nums.length; i++) {\n            int cur = 0;\n            while (i < nums.length && nums[i] == 0) {\n                cur += 1;\n                res += cur;\n                i++;\n            }\n        }\n        return res;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public long zeroFilledSubarray(int[] nums) {\\n        long res = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            int cur = 0;\\n            while (i < nums.length && nums[i] == 0) {\\n                cur += 1;\\n                res += cur;\\n                i++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-the-number-of-good-subarrays",
        "tags": "java",
        "release_time": 1673771500,
        "code": "class Solution {\n        public long countGood(int[] nums, int k) {\n        long ans = 0;\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int j = 0;\n        long countPairs = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (map.containsKey(nums[i])) {\n\n                int val = map.get(nums[i]);\n                //to replace the  the previous pair with new pairs\n                countPairs -= ((long) val * (val - 1) / 2);\n                map.put(nums[i], map.get(nums[i]) + 1);\n                 val = map.get(nums[i]);\n                countPairs += ((long) val * (val - 1) / 2);\n\n            } else{\n                map.put(nums[i], 1);\n            }\n            \n            // System.out.println(countPairs);\n             //sliding the window to right \n            while (j <= i && countPairs >= k) {\n                int cur = map.get(nums[j]);\n                countPairs -= (long) cur * (cur - 1) / 2;\n                map.put(nums[j], cur - 1);\n                cur = map.get(nums[j]);\n                countPairs += (long) (cur ) * (cur -1) / 2;\n                j++;\n                ans += (nums.length - i);\n            }\n\n        }\n        return ans;\n\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nSliding Window \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public long countGood(int[] nums, int k) {\\n        long ans = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0;\\n        long countPairs = 0;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (map.containsKey(nums[i])) {\\n\\n                int val = map.get(nums[i]);\\n                //to replace the  the previous pair with new pairs\\n                countPairs -= ((long) val * (val - 1) / 2);\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n                 val = map.get(nums[i]);\\n                countPairs += ((long) val * (val - 1) / 2);\\n\\n            } else{\\n                map.put(nums[i], 1);\\n            }\\n            \\n            // System.out.println(countPairs);\\n             //sliding the window to right \\n            while (j <= i && countPairs >= k) {\\n                int cur = map.get(nums[j]);\\n                countPairs -= (long) cur * (cur - 1) / 2;\\n                map.put(nums[j], cur - 1);\\n                cur = map.get(nums[j]);\\n                countPairs += (long) (cur ) * (cur -1) / 2;\\n                j++;\\n                ans += (nums.length - i);\\n            }\\n\\n        }\\n        return ans;\\n\\n    }\\n}\\n```"
    },
    {
        "slug": "magic-squares-in-grid",
        "tags": "java",
        "release_time": 1648659719,
        "code": "class Solution {\n    /** Algorithm\n        1. If nr of columns or rows < 3 return false \n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\n           - use a boolean[10] seen to mark the already present number in 3x3 view\n           - return false if number if <1 or > 9\n           - return false if any found sum is different that a reference sum\n        4. Count the views /3x3 matrices and return their number   \n    */\n    public int numMagicSquaresInside(int[][] grid) {\n        if(grid.length < 3 || grid[0].length < 3) {\n            return 0;\n        }\n        int magicSquares = 0;\n        for (int i = 0; i < grid.length -2; i++) {\n            for (int j = 0; j < grid[i].length -2; j++) {\n                if (isMagicSquare(grid, i, j)) {\n                    magicSquares++;\n                }\n            }\n        }\n        return magicSquares;\n    }\n    \n    private boolean isMagicSquare(int[][] grid, int row, int col) {\n        // map the present number is a boolean of 10 (1-9)\n        boolean[] seen = new boolean[10];\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\n        int tempSum = 0;\n        // row sum\n        for (int i = row; i <= row +2; i++) {\n            tempSum = 0;\n            for (int j = col; j <= col +2; j++) {\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\n                    return false;\n                }\n                seen[grid[i][j]] = true;\n                tempSum += grid[i][j];\n            }\n            if (tempSum != sum) {\n                return false;\n            }\n        }\n        //col sum\n        for (int j = col; j <= col +2; j++) {\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\n                return false;\n            }\n        }\n        //diag 1 and 2\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\n            return false;\n        }\n        return true;\n    }\n}",
        "content": "```\\nclass Solution {\\n    /** Algorithm\\n        1. If nr of columns or rows < 3 return false \\n        2. Traverse the grid with i, j from 0 to row -2, col -2 and count how many magic squares/views exist.\\n        3. For each such view (3x3), determine if it satisfies the listen conditions:\\n           - use a boolean[10] seen to mark the already present number in 3x3 view\\n           - return false if number if <1 or > 9\\n           - return false if any found sum is different that a reference sum\\n        4. Count the views /3x3 matrices and return their number   \\n    */\\n    public int numMagicSquaresInside(int[][] grid) {\\n        if(grid.length < 3 || grid[0].length < 3) {\\n            return 0;\\n        }\\n        int magicSquares = 0;\\n        for (int i = 0; i < grid.length -2; i++) {\\n            for (int j = 0; j < grid[i].length -2; j++) {\\n                if (isMagicSquare(grid, i, j)) {\\n                    magicSquares++;\\n                }\\n            }\\n        }\\n        return magicSquares;\\n    }\\n    \\n    private boolean isMagicSquare(int[][] grid, int row, int col) {\\n        // map the present number is a boolean of 10 (1-9)\\n        boolean[] seen = new boolean[10];\\n        // calculate a reference sum, the sum of first row than has to match with the rest of 7 sums\\n        int sum = grid[row][col] + grid[row][col+1] + grid[row][col+2];\\n        int tempSum = 0;\\n        // row sum\\n        for (int i = row; i <= row +2; i++) {\\n            tempSum = 0;\\n            for (int j = col; j <= col +2; j++) {\\n                // if nr if < 9 or > 9 OR already exists, return immediately false as this 3x3 grid is not magic\\n                if (grid[i][j] > 9 || grid[i][j] < 1 || seen[grid[i][j]]) {\\n                    return false;\\n                }\\n                seen[grid[i][j]] = true;\\n                tempSum += grid[i][j];\\n            }\\n            if (tempSum != sum) {\\n                return false;\\n            }\\n        }\\n        //col sum\\n        for (int j = col; j <= col +2; j++) {\\n            if (grid[row][j] + grid[row +1][j] + grid[row+2][j] != sum) {\\n                return false;\\n            }\\n        }\\n        //diag 1 and 2\\n        if (grid[row][col] + grid[row+1][col+1] + grid[row+2][col+2] != sum ||\\n           grid[row][col+2] + grid[row+1][col+1] + grid[row+2][col] != sum) {\\n            return false;\\n        }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "baseball-game",
        "tags": "java",
        "release_time": 1689567966,
        "code": "class Solution {\n    public int calPoints(String[] operations) {\n\n        Stack<Integer> stack = new Stack<>();\n        \n        for(int i=0; i<operations.length; i++){\n            if(operations[i].equals(\"C\")){\n                stack.pop();\n            }else if(operations[i].equals(\"D\")){\n                stack.push(stack.peek() * 2);\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\n                int value1 = stack.pop();\n                int value2 = stack.pop();\n                int value = value1+ value2;\n                //push value2 back to the stack frist\n                stack.push(value2);\n                stack.push(value1);\n                stack.push(value);\n            }else {\n                stack.push(Integer.parseInt(operations[i]));\n            }\n        }\n        \n        System.out.println(\"Stack\" + stack);\n\n        int sum =0;\n        while (!stack.isEmpty()){\n            sum += stack.pop();\n        }\n        \n        return sum;\n    }\n}",
        "content": "# Approach1: Use Stack\\n# Approach2: Use Dequeue\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int calPoints(String[] operations) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        \\n        for(int i=0; i<operations.length; i++){\\n            if(operations[i].equals(\"C\")){\\n                stack.pop();\\n            }else if(operations[i].equals(\"D\")){\\n                stack.push(stack.peek() * 2);\\n            }else if(operations[i].equals(\"+\") && stack.size()>=2){\\n                int value1 = stack.pop();\\n                int value2 = stack.pop();\\n                int value = value1+ value2;\\n                //push value2 back to the stack frist\\n                stack.push(value2);\\n                stack.push(value1);\\n                stack.push(value);\\n            }else {\\n                stack.push(Integer.parseInt(operations[i]));\\n            }\\n        }\\n        \\n        System.out.println(\"Stack\" + stack);\\n\\n        int sum =0;\\n        while (!stack.isEmpty()){\\n            sum += stack.pop();\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "tags": "java",
        "release_time": 1692286085,
        "code": "class Solution {\n    public int minBitFlips(int start, int goal) {\n        int cnt = 0;\n        while(start != goal){\n            if((goal & 1) != (start & 1)){\n                start ^= 1;\n                cnt++;\n            }\n            goal >>= 1;\n           start >>= 1;\n        }\n        return cnt;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minBitFlips(int start, int goal) {\\n        int cnt = 0;\\n        while(start != goal){\\n            if((goal & 1) != (start & 1)){\\n                start ^= 1;\\n                cnt++;\\n            }\\n            goal >>= 1;\\n           start >>= 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```"
    },
    {
        "slug": "permutation-sequence",
        "tags": "java",
        "release_time": 1690145161,
        "code": "class Solution {\n    public String getPermutation(int n, int k) {\n        String ans = \"\";\n        ArrayList<Integer> num = new ArrayList<>();\n        int fact = 1;\n        for(int i = 1;i<n;i++){\n            fact=fact*i;\n            num.add(i);\n        }\n        num.add(n);\n        k=k-1;\n        while(true){\n            ans = ans + num.get(k/fact);\n            num.remove(k/fact);\n            if(num.size()==0)break;\n            k = k % fact;\n            fact = fact / num.size();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\nDivide and conquer\\u274C\\nRemove and conquer\\u2714\\n\\n# Approach\\nIn this code you have to only understand three lines \\nlets start with \\n1. ans = ans + num.get(k/fact); \\nSo lets take an example 1 as example , we have given n = 3 and k = 3\\nif we pick 1 then we left with 2 , 3;\\nif we pick 2 then we left with 1 , 3;\\nas we know permutation of n is n!,when we pick any number then picked number is not counted factorial of remaing number is stored, thats why \\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\nby this our factorial is 2 .\\nthere is factorial of n-1.\\nlets reduce the k by  1 because we have 0-based indexing , according to 0 based index we need now 2nd permutation\\nk = 2.\\nnow if we say what is k/fact , which gives us the starting value of our kth permutaion , which means 2/2 is 1 and we have to add 1th index value to our ans , now our ans is updated to 2.\\n2. lets understand this k = k % fact, \\nas we added 1 th index value to our ans , we have surity that if we pick 1th index then the permutations of remaining 2 elements give us next index to our ans , means\\nif we pick 2 then remaing is [1,3] then we have to find kth permutataion from this and so how can we update our k , so can it gives us value what we needed ,\\ncurrect k = 2 and fact  = 2,after 2 = 2 % 2, we have k = 0,which means we have our remaining value in 0th permutaion of remaining element [1,3].\\n3. fact = fact / num.size();\\nas we get our first value , so we have to remove it from our list , as we added   num.get(k/fact) to our ans , we have to remove it now ,\\nby this we removed it num.remove(k/fact); as in previous step we updated our k and elements left 2 so we have to also update our factorial also .\\nsee uf we have n =3 then factorial is 6\\nn = 2 then factorial is 2\\nn= 1 factorial is 1 , \\nand we know we will choose 1 value from our n then there is n-1 left , so we have to find factorial of n-1 , you will understand this after this,as we removed 2 we have remaing elements \\n[1,3] and k =0\\nwe know we will choose one element from this and find permutaions of remaining elements,\\n0th = we will choose 1 and find permutaion of [3]\\n1th  = we will choose 3 and find permutation of [1]\\nso why we need factorial of n-1, by this current fact = 2 and after removing 1th index from num size of our list is also 2 .\\n2 = 2 / 2 , nothing but 1.\\n- Now we are ready to pick our next value  new k = 0 , new list size is 2 and fact = 1.\\nans = ans + num.get(0/1), so we choose 0th index value from our list and remove it from list , now updated ans is 21.\\nAfter this we again update the value of k and fact , by steps i mention earlier new k is also 0  new fact is also 1 and new size of list is 1 ,  after this only one remaing value in our list is 1 we add it to ans and remove it from list which make list  0 \\n if(num.size()==0)break; and when this condition is checkec it break the infintie loop and return the ans .\\n\\nThank You , if any step i am wrong or unable to make clear concept forgive me \\uD83D\\uDE4F.\\n# Code\\n```\\nclass Solution {\\n    public String getPermutation(int n, int k) {\\n        String ans = \"\";\\n        ArrayList<Integer> num = new ArrayList<>();\\n        int fact = 1;\\n        for(int i = 1;i<n;i++){\\n            fact=fact*i;\\n            num.add(i);\\n        }\\n        num.add(n);\\n        k=k-1;\\n        while(true){\\n            ans = ans + num.get(k/fact);\\n            num.remove(k/fact);\\n            if(num.size()==0)break;\\n            k = k % fact;\\n            fact = fact / num.size();\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "pass-the-pillow",
        "tags": "java",
        "release_time": 1680694428,
        "code": "class Solution {\n    public int passThePillow(int n, int time) {\n        int num=(time/(n-1));\n        if(n>time){\n            return time+1;\n        }\n        if(num%2==1){\n            return n-((time%(n-1)));\n        }\n            \n        return (time%(n-1))+1;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int passThePillow(int n, int time) {\\n        int num=(time/(n-1));\\n        if(n>time){\\n            return time+1;\\n        }\\n        if(num%2==1){\\n            return n-((time%(n-1)));\\n        }\\n            \\n        return (time%(n-1))+1;\\n    }\\n}\\n```"
    },
    {
        "slug": "check-completeness-of-a-binary-tree",
        "tags": "java",
        "release_time": 1678844682,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isCompleteTree(TreeNode root) {\n        boolean end = false;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            TreeNode currentNode = queue.poll();\n            if(currentNode == null) {\n                end = true;\n            } else {\n                if(end) {\n                    return false;\n                }\n                queue.offer(currentNode.left);\n                queue.offer(currentNode.right);\n            }\n        }\n        return true;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isCompleteTree(TreeNode root) {\\n        boolean end = false;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()) {\\n            TreeNode currentNode = queue.poll();\\n            if(currentNode == null) {\\n                end = true;\\n            } else {\\n                if(end) {\\n                    return false;\\n                }\\n                queue.offer(currentNode.left);\\n                queue.offer(currentNode.right);\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```"
    },
    {
        "slug": "add-binary",
        "tags": "java",
        "release_time": 1692196406,
        "code": "import java.math.BigInteger;\nclass Solution {\n    public String addBinary(String a, String b) {\n        BigInteger A=new BigInteger(a,2);\n        BigInteger B=new BigInteger(b,2);\n        BigInteger c=A.add(B);\n        return c.toString(2);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a4479753-912f-41ab-abdb-8c757f98bd03_1692196384.1712396.png)\\n\\n\\n# Code\\n```\\nimport java.math.BigInteger;\\nclass Solution {\\n    public String addBinary(String a, String b) {\\n        BigInteger A=new BigInteger(a,2);\\n        BigInteger B=new BigInteger(b,2);\\n        BigInteger c=A.add(B);\\n        return c.toString(2);\\n    }\\n}\\n```"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "tags": "java",
        "release_time": 1669530463,
        "code": "class Solution {\n\tpublic int numberOfArithmeticSlices(int[] arr) {\n\t\tint n = arr.length;\n\t\tHashMap<Integer, Integer>[] map = new HashMap[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmap[i] = new HashMap<>();\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tfor (int j = 0; j < i; j++) {\n\t\t\t\tlong cd = (long) arr[i] - (long) arr[j];\n\t\t\t\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\n\t\t\t\t\tcontinue;\n\t\t\t\tint asj = map[j].getOrDefault((int) cd, 0);\n\t\t\t\tint asi = map[i].getOrDefault((int) cd, 0);\n\t\t\t\tans += asj;\n\t\t\t\tmap[i].put((int) cd, asi + asj + 1);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}",
        "content": "# Code\\n```\\nclass Solution {\\n\\tpublic int numberOfArithmeticSlices(int[] arr) {\\n\\t\\tint n = arr.length;\\n\\t\\tHashMap<Integer, Integer>[] map = new HashMap[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tmap[i] = new HashMap<>();\\n\\t\\t}\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tfor (int j = 0; j < i; j++) {\\n\\t\\t\\t\\tlong cd = (long) arr[i] - (long) arr[j];\\n\\t\\t\\t\\tif (cd <= Integer.MIN_VALUE || cd >= Integer.MAX_VALUE)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tint asj = map[j].getOrDefault((int) cd, 0);\\n\\t\\t\\t\\tint asi = map[i].getOrDefault((int) cd, 0);\\n\\t\\t\\t\\tans += asj;\\n\\t\\t\\t\\tmap[i].put((int) cd, asi + asj + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```"
    },
    {
        "slug": "make-costs-of-paths-equal-in-a-binary-tree",
        "tags": "java",
        "release_time": 1684215665,
        "code": "class Solution {\n    int res = 0;\n    public int minIncrements(int n, int[] cost) {\n        dfs(1, cost);\n        return res;\n    }\n\n    // get the max cost of a path of sub tree root at i;\n    public int dfs(int i, int[] cost) {\n        if (i > cost.length) return 0;\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\n        // you need keep two child tree has the same cost of path.\n        // best way to tune the root of lower cost path, increase the\n        // lower root, by Math.abs(left - right);\n        res += Math.abs(left - right);\n        return cost[i - 1] + Math.max(left, right);\n    }\n}",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee comments\\n# Complexity\\nT O(N)\\nS O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    public int minIncrements(int n, int[] cost) {\\n        dfs(1, cost);\\n        return res;\\n    }\\n\\n    // get the max cost of a path of sub tree root at i;\\n    public int dfs(int i, int[] cost) {\\n        if (i > cost.length) return 0;\\n        int left = dfs(i * 2, cost), right = dfs(i * 2 + 1, cost);\\n        // you need keep two child tree has the same cost of path.\\n        // best way to tune the root of lower cost path, increase the\\n        // lower root, by Math.abs(left - right);\\n        res += Math.abs(left - right);\\n        return cost[i - 1] + Math.max(left, right);\\n    }\\n}\\n```"
    },
    {
        "slug": "next-permutation",
        "tags": "java",
        "release_time": 1689771556,
        "code": "class Solution {\n    public void nextPermutation(int[] n) {\n        //breakpoint\n       if(  n==null || n.length<=1)return;\n\t\t\n\t\tint i = n.length-2;\n\n\t\twhile(i>=0 && n[i]>=n[i+1])i--;\n\t\t\n\t\tint j=n.length-1;\n\t\t\n\t\tif(i>=0) {\n\t\t\twhile(n[j]<=n[i])j--;\n\t\t\tswap(n,i,j);\n\t\t}\n\t\t\n\t\treverse(n,i+1,n.length-1);\n\t\t\n\t\tfor(int p=0;p<n.length;p++) {\n\t\t\tSystem.out.println(n[p]);\n\t\t}\n\t\t\n\t}\n\tpublic static void swap(int n[],int i,int j) {\n\t\tint temp=n[i];\n\t\tn[i]=n[j];\n\t\tn[j]=temp;\n\t}\n\tpublic static void reverse(int n[],int i,int j) {\n\t\twhile(i<j) {\n\t\t\tswap(n,i,j);\n\t\t\ti++;\n\t\t\tj--;\n\t\t}\n\t}\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Find the breakpoint(position where n[i]<n[i+1])\\n- Then find the element which greater than breakpoint but is the smallest\\n- Swap the variables i.e breakpoint and the other variable which we have find\\n- Then reverse the remaning array \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(3N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] n) {\\n        //breakpoint\\n       if(  n==null || n.length<=1)return;\\n\\t\\t\\n\\t\\tint i = n.length-2;\\n\\n\\t\\twhile(i>=0 && n[i]>=n[i+1])i--;\\n\\t\\t\\n\\t\\tint j=n.length-1;\\n\\t\\t\\n\\t\\tif(i>=0) {\\n\\t\\t\\twhile(n[j]<=n[i])j--;\\n\\t\\t\\tswap(n,i,j);\\n\\t\\t}\\n\\t\\t\\n\\t\\treverse(n,i+1,n.length-1);\\n\\t\\t\\n\\t\\tfor(int p=0;p<n.length;p++) {\\n\\t\\t\\tSystem.out.println(n[p]);\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\tpublic static void swap(int n[],int i,int j) {\\n\\t\\tint temp=n[i];\\n\\t\\tn[i]=n[j];\\n\\t\\tn[j]=temp;\\n\\t}\\n\\tpublic static void reverse(int n[],int i,int j) {\\n\\t\\twhile(i<j) {\\n\\t\\t\\tswap(n,i,j);\\n\\t\\t\\ti++;\\n\\t\\t\\tj--;\\n\\t\\t}\\n\\t}\\n}\\n```"
    },
    {
        "slug": "filling-bookcase-shelves",
        "tags": "java",
        "release_time": 1661784386,
        "code": "class Solution {\n    public int minHeightShelves(int[][] books, int shelfWidth) {\n        int dp[]=new int[books.length+1];\n        dp[0]=0;\n        for(int i=1;i<=books.length;i++){\n            int min=dp[i-1]+books[i-1][1];\n            int height=books[i-1][1];\n            int width=books[i-1][0];\n            int j=i-2;\n            while(j>=0 && width+books[j][0]<=shelfWidth){\n                width+=books[j][0];\n                height=Math.max(height,books[j][1]);\n                min=Math.min(min,height+dp[j]);\n                --j;\n            }\n            dp[i]=min;\n        }\n        return dp[books.length];\n    }\n}",
        "content": "The concept used here is to take each block at one level more than the previous level and then one by one start taking previous blocks into this level till the width condition is satisfied.\\n```\\nclass Solution {\\n    public int minHeightShelves(int[][] books, int shelfWidth) {\\n        int dp[]=new int[books.length+1];\\n        dp[0]=0;\\n        for(int i=1;i<=books.length;i++){\\n            int min=dp[i-1]+books[i-1][1];\\n            int height=books[i-1][1];\\n            int width=books[i-1][0];\\n            int j=i-2;\\n            while(j>=0 && width+books[j][0]<=shelfWidth){\\n                width+=books[j][0];\\n                height=Math.max(height,books[j][1]);\\n                min=Math.min(min,height+dp[j]);\\n                --j;\\n            }\\n            dp[i]=min;\\n        }\\n        return dp[books.length];\\n    }\\n}\\n```"
    },
    {
        "slug": "guess-number-higher-or-lower",
        "tags": "java",
        "release_time": 1689963688,
        "code": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return \t     -1 if num is higher than the picked number\n *\t\t\t      1 if num is lower than the picked number\n *               otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int low=0,high=n;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            int x= guess(mid);\n            if(x==0) \n            {\n                return mid;\n            }\n            else if(x==-1)\n            {\n                high=mid-1;\n            }\n            else\n            {\n                low = mid+1;\n            }\n        }\n        return -1;\n    }\n}",
        "content": "# Code\\n```\\n/** \\n * Forward declaration of guess API.\\n * @param  num   your guess\\n * @return \\t     -1 if num is higher than the picked number\\n *\\t\\t\\t      1 if num is lower than the picked number\\n *               otherwise return 0\\n * int guess(int num);\\n */\\n\\npublic class Solution extends GuessGame {\\n    public int guessNumber(int n) {\\n        int low=0,high=n;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            int x= guess(mid);\\n            if(x==0) \\n            {\\n                return mid;\\n            }\\n            else if(x==-1)\\n            {\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-distance-to-the-target-element",
        "tags": "java",
        "release_time": 1687435674,
        "code": "class Solution {\n    public int getMinDistance(int[] nums, int target, int start) {\n     int n = nums.length;\n     int min = Integer.MAX_VALUE;\n     for(int i=0;i<n;i++){\n         if(nums[i]==target){\n          if(Math.abs(i-start)<min){\n              min = Math.abs(i-start);\n          }   \n         }\n     }\n     return min;   \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```"
    },
    {
        "slug": "goal-parser-interpretation",
        "tags": "java",
        "release_time": 1691232280,
        "code": "class Solution {\n    public String interpret(String command) {\n        String str1 = command.replace(\"()\", \"o\");\n        String str2 = str1.replace(\"(al)\", \"al\");\n        return str2;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String interpret(String command) {\\n        String str1 = command.replace(\"()\", \"o\");\\n        String str2 = str1.replace(\"(al)\", \"al\");\\n        return str2;\\n    }\\n}\\n```"
    },
    {
        "slug": "knight-probability-in-chessboard",
        "tags": "java",
        "release_time": 1690027908,
        "code": "class Solution {\n    public double knightProbability(int n, int k, int row, int column) {\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\n        // We use dynamic programming to store the probabilities at each cell for each move...\n        // The dp array is a 3-dimensional array...\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\n        double[][][] dp = new double[k + 1][n][n];\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\n        dp[0][row][column] = 1.0;\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\n        for (int i = 1; i <= k; i++) {\n            // For each cell, it considers all 8 possible moves of the knight &\n            // Calculates the probability of reaching that cell from the neighboring cells.\n            for (int r = 0; r < n; r++) {\n                for (int c = 0; c < n; c++) {\n                    for (int[] d : dir) {\n                        // Introduce the terms newRow & newCol...\n                        int newRow = r + d[0];\n                        int newCol = c + d[1];\n                        // If the new cell is within the bounds of the chessboard....\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                            // update by adding the probability of the previous move divided by 8.0...\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\n                        }\n                    }\n                }\n            }\n        }\n        // Initialize the output probability...\n        double output = 0.0;\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                output += dp[k][r][c];\n            }\n        }\n        // return the output that the knight remains on the board after k moves.\n        return output;\n    }\n}",
        "content": "# **Java Solution:**\\n```\\nclass Solution {\\n    public double knightProbability(int n, int k, int row, int column) {\\n        int[][] dir = {{-2, -1}, {-1, -2}, {1, -2}, {2, -1}, {2, 1}, {1, 2}, {-1, 2}, {-2, 1}};\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp[i][r][c] represents the probability of the knight being at cell (r, c) after i moves...\\n        double[][][] dp = new double[k + 1][n][n];\\n        // At first, initialize dp[0][row][column] to 1.0, as the knight starts at the specified cell.\\n        dp[0][row][column] = 1.0;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int i = 1; i <= k; i++) {\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int[] d : dir) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + d[0];\\n                        int newCol = c + d[1];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            dp[i][r][c] += dp[i - 1][newRow][newCol] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // Initialize the output probability...\\n        double output = 0.0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[k][r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    double knightProbability(int n, int k, int row, int column) {\\n        // We use dynamic programming to store the probabilities at each cell for each move...\\n        // The dp array is a 3-dimensional array...\\n        // dp represents the probability of the knight being at cell (r, c) after m moves...\\n        vector<vector<double>> dp(n, vector<double>(n, 0));\\n        vector<int> dr = {-2, -2, -1, -1, 1, 1, 2, 2};\\n        vector<int> dc = {-1, 1, -2, 2, -2, 2, -1, 1};\\n        // At first, initialize dp[0][row][column] to 1, as the knight starts at the specified cell.\\n        dp[row][column] = 1;\\n        // For each move from 1 to k, the algorithm iterates over each cell on the chessboard.\\n        for (int m = 0; m < k; m++) {\\n            vector<vector<double>> tmp(n, vector<double>(n, 0));\\n            // For each cell, it considers all 8 possible moves of the knight &\\n            // Calculates the probability of reaching that cell from the neighboring cells.\\n            for (int r = 0; r < n; r++) {\\n                for (int c = 0; c < n; c++) {\\n                    for (int i = 0; i < 8; i++) {\\n                        // Introduce the terms newRow & newCol...\\n                        int newRow = r + dr[i];\\n                        int newCol = c + dc[i];\\n                        // If the new cell is within the bounds of the chessboard....\\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\\n                            // update by adding the probability of the previous move divided by 8.0...\\n                            tmp[newRow][newCol] += dp[r][c] / 8.0;\\n                        }\\n                    }\\n                }\\n            }\\n            dp = tmp;\\n        }\\n        // Initialize the output probability...\\n        double output = 0;\\n        // Sum up the output probabilities of all cells at the kth move to get the final output probability.\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                output += dp[r][c];\\n            }\\n        }\\n        // return the output that the knight remains on the board after k moves.\\n        return output;\\n    }\\n};\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**"
    },
    {
        "slug": "delete-node-in-a-linked-list",
        "tags": "java",
        "release_time": 1665632376,
        "code": "class Solution {\n    public void deleteNode(ListNode node) {\n        node.val=node.next.val;\n        node.next=node.next.next;\n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    public void deleteNode(ListNode node) {\\n        node.val=node.next.val;\\n        node.next=node.next.next;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "make-array-strictly-increasing",
        "tags": "java",
        "release_time": 1686968225,
        "code": "class Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = helper(0, -1, arr1, arr2);\n        \n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int operation = Integer.MAX_VALUE-100;\n\n        \n        if (arr1[i] > prev) {\n            operation = helper(i + 1, arr1[i], arr1, arr2);\n        }\n\n       \n        int idx = binarySearch(arr2, prev);\n\n        \n        if (idx < arr2.length) {\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev),operation);\n        return operation;\n    }\n    \n    private static int binarySearch(int[] arr, int value) {\n        int left = 0, right = arr.length-1;\n        while (left <= right) {\n            int mid = left+(right-left) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid-1;\n            }\n        }\n        return left;\n    } \n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution { \\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\\n        Arrays.sort(arr2);\\n        \\n        int answer = helper(0, -1, arr1, arr2);\\n        \\n        return answer < Integer.MAX_VALUE-100 ? answer : -1;\\n    }\\n    \\n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\\n    private int helper(int i, int prev, int[] arr1, int[] arr2) {\\n        if (i == arr1.length) {\\n            return 0;\\n        }\\n        if (dp.containsKey(new Pair<>(i, prev))) {\\n            return dp.get(new Pair<>(i, prev));\\n        }\\n\\n        int operation = Integer.MAX_VALUE-100;\\n\\n        \\n        if (arr1[i] > prev) {\\n            operation = helper(i + 1, arr1[i], arr1, arr2);\\n        }\\n\\n       \\n        int idx = binarySearch(arr2, prev);\\n\\n        \\n        if (idx < arr2.length) {\\n            operation = Math.min(operation, 1 + helper(i + 1, arr2[idx], arr1, arr2));\\n        }\\n\\n        dp.put(new Pair<>(i, prev),operation);\\n        return operation;\\n    }\\n    \\n    private static int binarySearch(int[] arr, int value) {\\n        int left = 0, right = arr.length-1;\\n        while (left <= right) {\\n            int mid = left+(right-left) / 2;\\n            if (arr[mid] <= value) {\\n                left = mid + 1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return left;\\n    } \\n}\\n```"
    },
    {
        "slug": "valid-triangle-number",
        "tags": "java",
        "release_time": 1689855211,
        "code": "class Solution {\n    public int triangleNumber(int[] nums) {\n        int n=nums.length;\n        Arrays.sort(nums);\n        int count=0;\n        for(int c=n-1;c>=2;c--){\n            int a=0;\n            int b=c-1;\n            while(a<b){\n                if(nums[a]+nums[b]>nums[c]){\n                    count+=(b-a);\n                    b--;\n                }\n                else{\n                    a++;\n                }\n            }\n        }\n        return count;\n        \n    }\n}",
        "content": "# Intuition\\nFor right angled triangle, it should satisfy following 3 conditions (a,b and c are sides of triangle)\\na+b>c\\na+c>b\\nb+c>a\\n\\nSuppose c>a+b then 2nd and 3rd condition is going to satisfy automatically so always keep the c at index with value greater than a and b\\n\\n# Approach\\nSteps:\\n1.Sort the array in increasing order\\n2.After sorting ,initially c as n-1 (intially as loop will be going for c from n-1 to 2 as at last c can be at 2nd, b at 1st and a at 0th index. \\n  b=c-1 , a=0\\n  (Keeping c at fixed index, we will be moving a and b in order to satisfy the condition a+b>c) .\\n3.while(a<b) \\n  check the nums[a] + nums[b] > nums[c] , \\n  if this exists then \\n    -for all the values after the nums[left],the condition nums[a] + nums[b] > nums[c] is going to satisfy, store (b-a) count in ans\\n    -decrement b\\n  else\\n    -increment a as we need to maximize sum so that it becoms greater than nums[c]\\n4.return ans\\n\\n\\n# Complexity\\n- Time complexity: O(N2)\\n- Space complexity:O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int triangleNumber(int[] nums) {\\n        int n=nums.length;\\n        Arrays.sort(nums);\\n        int count=0;\\n        for(int c=n-1;c>=2;c--){\\n            int a=0;\\n            int b=c-1;\\n            while(a<b){\\n                if(nums[a]+nums[b]>nums[c]){\\n                    count+=(b-a);\\n                    b--;\\n                }\\n                else{\\n                    a++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "unique-paths",
        "tags": "java",
        "release_time": 1676523157,
        "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        return findPath(0, 0, m, n, dp);\n    }\n    int findPath(int path1, int path2, int m, int n, int[][] dp) {\n        if (path1+1==m && path2+1==n) return 1;\n        if (path1==m) return 0;\n        if (path2==n) return 0;\n        if (dp[path1][path2]!=0) return dp[path1][path2];\n        dp[path1][path2] = findPath(path1+1, path2, m, n, dp) + findPath(path1, path2+1, m ,n, dp);\n        return dp[path1][path2];\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int uniquePaths(int m, int n) {\\n        int[][] dp = new int[m][n];\\n        return findPath(0, 0, m, n, dp);\\n    }\\n    int findPath(int path1, int path2, int m, int n, int[][] dp) {\\n        if (path1+1==m && path2+1==n) return 1;\\n        if (path1==m) return 0;\\n        if (path2==n) return 0;\\n        if (dp[path1][path2]!=0) return dp[path1][path2];\\n        dp[path1][path2] = findPath(path1+1, path2, m, n, dp) + findPath(path1, path2+1, m ,n, dp);\\n        return dp[path1][path2];\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-average-subarray-i",
        "tags": "java",
        "release_time": 1669014919,
        "code": "class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        double maxSum =-11111111;\n        double sum1=0,sum=0;\n        int sw=0;\n        for(int we=0;we<nums.length;we++){\n            sum+=nums[we];\n            if(we>=(k-1)){\n                sum1=(double)sum/k;\n                maxSum=Math.max(sum1,maxSum);\n                sum-=nums[sw];\n                sw++;\n            }\n        }\n        return maxSum;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public double findMaxAverage(int[] nums, int k) {\\n        double maxSum =-11111111;\\n        double sum1=0,sum=0;\\n        int sw=0;\\n        for(int we=0;we<nums.length;we++){\\n            sum+=nums[we];\\n            if(we>=(k-1)){\\n                sum1=(double)sum/k;\\n                maxSum=Math.max(sum1,maxSum);\\n                sum-=nums[sw];\\n                sw++;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```"
    },
    {
        "slug": "same-tree",
        "tags": "java",
        "release_time": 1691573493,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n   \n    public boolean isSameTree(TreeNode p, TreeNode q) {\n     if (p == null && q == null) {\n            return true;\n        }\n        \n        if (p == null || q == null) {\n            return false;\n        }\n        \n        if (p.val != q.val) {\n            return false;\n        }\n        \n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n   \\n    public boolean isSameTree(TreeNode p, TreeNode q) {\\n     if (p == null && q == null) {\\n            return true;\\n        }\\n        \\n        if (p == null || q == null) {\\n            return false;\\n        }\\n        \\n        if (p.val != q.val) {\\n            return false;\\n        }\\n        \\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\\n\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "is-graph-bipartite",
        "tags": "java",
        "release_time": 1684457315,
        "code": "class Solution {\n\tint[] colors;\n    public boolean isBipartite(int[][] graph) {\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\n\t\tcolors = new int[graph.length];\n\t\t\n\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\tadj.putIfAbsent(i, new ArrayList<Integer>());\n\t\t\tfor(int j=0;j<graph[i].length;j++){\n                adj.get(i).add(graph[i][j]);\n            }\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tif(colors[i]==0 && adj.get(i)==null) {\n\t\t\t\tcolors[i]=1;\n\t\t\t}\n\t\t\telse if(colors[i]==0 && !(adj.get(i)==null)) {\n\t\t\t\tif(!bfs(adj, i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\n\t\tArrayList<Integer> que = new ArrayList<Integer>();\n\t\tque.add(node);\n\t\tcolors[node] = 1;\n\t\tint c =0;\n\t\twhile(que.size()>0) {\n\t\t\t\n\t\t\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\n\t\t\t\tif(colors[adj.get(que.get(0)).get(i)]==0) {\n\t\t\t\t\tif(colors[que.get(0)]==1) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 2;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t\telse if(colors[que.get(0)]==2) {\n\t\t\t\t\t\tcolors[adj.get(que.get(0)).get(i)] = 1;\n\t\t\t\t\t\tque.add(adj.get(que.get(0)).get(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n            }\n\t\t\tque.remove(0);\n\t\t}\n\t\treturn true\t;\n\t}\n}",
        "content": "# PLEASE UPVOTE!!!\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing BFS and Graph Coloring Approach.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\nN is no of edges\\n\\n# Code\\n```\\nclass Solution {\\n\\tint[] colors;\\n    public boolean isBipartite(int[][] graph) {\\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<Integer, ArrayList<Integer>>();\\n\\t\\tcolors = new int[graph.length];\\n\\t\\t\\n\\t\\tfor (int i = 0; i < graph.length; i++) {\\n\\t\\t\\tadj.putIfAbsent(i, new ArrayList<Integer>());\\n\\t\\t\\tfor(int j=0;j<graph[i].length;j++){\\n                adj.get(i).add(graph[i][j]);\\n            }\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < colors.length; i++) {\\n\\t\\t\\tif(colors[i]==0 && adj.get(i)==null) {\\n\\t\\t\\t\\tcolors[i]=1;\\n\\t\\t\\t}\\n\\t\\t\\telse if(colors[i]==0 && !(adj.get(i)==null)) {\\n\\t\\t\\t\\tif(!bfs(adj, i)) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tprivate boolean bfs(HashMap<Integer, ArrayList<Integer>> adj, int node) {\\n\\t\\tArrayList<Integer> que = new ArrayList<Integer>();\\n\\t\\tque.add(node);\\n\\t\\tcolors[node] = 1;\\n\\t\\tint c =0;\\n\\t\\twhile(que.size()>0) {\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<adj.get(que.get(0)).size();i++) {\\n\\t\\t\\t\\tif(colors[adj.get(que.get(0)).get(i)]==0) {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==1) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 2;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(colors[que.get(0)]==2) {\\n\\t\\t\\t\\t\\t\\tcolors[adj.get(que.get(0)).get(i)] = 1;\\n\\t\\t\\t\\t\\t\\tque.add(adj.get(que.get(0)).get(i));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tif(colors[que.get(0)]==colors[adj.get(que.get(0)).get(i)]) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t}\\n            }\\n\\t\\t\\tque.remove(0);\\n\\t\\t}\\n\\t\\treturn true\\t;\\n\\t}\\n}\\n\\n```"
    },
    {
        "slug": "minimum-number-of-food-buckets-to-feed-the-hamsters",
        "tags": "java",
        "release_time": 1638030003,
        "code": "class Solution {\n    public int minimumBuckets(String street)\n    {\n        Set<Integer> set = new HashSet<>();\n        if(!street.contains(\".\")) return -1;\n        int count = 0;\n        for(int i=0;i<street.length();i++)\n        {\n            if(street.charAt(i)=='H')\n            {\n                if((i==0 && street.charAt(i+1)=='H')||(i==street.length()-1 && street.charAt(i-1)=='H'))\n                    return -1;\n                else if(i!=0 && i!=street.length()-1 && street.charAt(i+1)=='H' && street.charAt(i-1)=='H')\n                    return -1;\n            }\n            else if(i!=0 && i!=street.length()-1 && street.charAt(i-1)=='H' && street.charAt(i+1)=='H' && !set.contains(i-1) && !set.contains(i+1))\n            {\n                set.add(i-1);\n                set.add(i+1);\n                count++;\n            }\n        }\n        for(int i=0;i<street.length();i++)\n        {\n            if(street.charAt(i)=='H' && !set.contains(i))\n                count++;\n        }\n        return count;\n    }\n}",
        "content": "// first run a loop and check if there is any house whose left and right both doesn\\'t have a bucket return -1 from there and check in the same loop if there is any bucket whose left and right both are houses  if we find it save both the houses index in a set and make a single count of it because this bucket fills 2 houses water at a time\\n\\n// in 2nd loop just check how much houses are left and increase the count\\n\\n// just return the count\\n\\n\\n```\\nclass Solution {\\n    public int minimumBuckets(String street)\\n    {\\n        Set<Integer> set = new HashSet<>();\\n        if(!street.contains(\".\")) return -1;\\n        int count = 0;\\n        for(int i=0;i<street.length();i++)\\n        {\\n            if(street.charAt(i)==\\'H\\')\\n            {\\n                if((i==0 && street.charAt(i+1)==\\'H\\')||(i==street.length()-1 && street.charAt(i-1)==\\'H\\'))\\n                    return -1;\\n                else if(i!=0 && i!=street.length()-1 && street.charAt(i+1)==\\'H\\' && street.charAt(i-1)==\\'H\\')\\n                    return -1;\\n            }\\n            else if(i!=0 && i!=street.length()-1 && street.charAt(i-1)==\\'H\\' && street.charAt(i+1)==\\'H\\' && !set.contains(i-1) && !set.contains(i+1))\\n            {\\n                set.add(i-1);\\n                set.add(i+1);\\n                count++;\\n            }\\n        }\\n        for(int i=0;i<street.length();i++)\\n        {\\n            if(street.charAt(i)==\\'H\\' && !set.contains(i))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "longest-common-prefix",
        "tags": "java",
        "release_time": 1691938780,
        "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        Arrays.sort(strs);\n        String start=strs[0];\n         String end=strs[strs.length-1];\n         int count=0;\n         for(int i=0;i<start.length();i++){\n             if(start.charAt(i)==end.charAt(i)){\n            count++;\n             }\n             else{\n                 break;\n             }\n         }\n        \n         return end.substring(0,count);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/0be6da10-ddf1-4c9f-8387-b9e1137e1d2e_1691938734.0515819.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String start=strs[0];\\n         String end=strs[strs.length-1];\\n         int count=0;\\n         for(int i=0;i<start.length();i++){\\n             if(start.charAt(i)==end.charAt(i)){\\n            count++;\\n             }\\n             else{\\n                 break;\\n             }\\n         }\\n        \\n         return end.substring(0,count);\\n    }\\n}\\n```"
    },
    {
        "slug": "largest-element-in-an-array-after-merge-operations",
        "tags": "java",
        "release_time": 1690084837,
        "code": "class Solution {\n    public long maxArrayValue(int[] nums) {\n        if(nums.length==1)\n        {\n            return (long)nums[0];\n        }\n        if(nums.length==2)\n        {\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\n        }\n        int size=nums.length;\n        long ans=0,dat=(long)nums[size-1];\n        for(int i=size-2;i>=0;i--)\n        {\n            long val=(long)nums[i];\n            if(val<=dat)\n            {\n                dat=dat+val;\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n            }\n            else\n            {\n                if(dat>ans)\n                {\n                    ans=dat;\n                }\n                dat=val;\n            }\n        }\n        return dat;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxArrayValue(int[] nums) {\\n        if(nums.length==1)\\n        {\\n            return (long)nums[0];\\n        }\\n        if(nums.length==2)\\n        {\\n            return nums[0] <= nums[1] ? (long)(nums[0]+nums[1]) : (long)(Math.max(nums[0],nums[1]));\\n        }\\n        int size=nums.length;\\n        long ans=0,dat=(long)nums[size-1];\\n        for(int i=size-2;i>=0;i--)\\n        {\\n            long val=(long)nums[i];\\n            if(val<=dat)\\n            {\\n                dat=dat+val;\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n            }\\n            else\\n            {\\n                if(dat>ans)\\n                {\\n                    ans=dat;\\n                }\\n                dat=val;\\n            }\\n        }\\n        return dat;\\n    }\\n}\\n```"
    },
    {
        "slug": "h-index-ii",
        "tags": "java",
        "release_time": 1689538082,
        "code": "class Solution {\n    public int hIndex(int[] citations) {\n        // O(n) Time Complexity\n        // int n = citations.length;\n        // int index = 0;\n        // while(index < n && n - index > citations[index]){\n        //     index++;\n        // }\n        // return n - index;\n\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\n        int left = 0, right = citations.length - 1;\n        int n = citations.length;\n        while(left <= right){\n            int mid = left + (right - left) / 2;\n            if(citations[mid] == n - mid) return n - mid;\n            else if(citations[mid] < n - mid) left = mid + 1;\n            else right = mid - 1;\n        }\n        return n - left;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(logn)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int hIndex(int[] citations) {\\n        // O(n) Time Complexity\\n        // int n = citations.length;\\n        // int index = 0;\\n        // while(index < n && n - index > citations[index]){\\n        //     index++;\\n        // }\\n        // return n - index;\\n\\n        // O(logn) Time Complexity // Binary Search:- Since Sorted Array\\n        int left = 0, right = citations.length - 1;\\n        int n = citations.length;\\n        while(left <= right){\\n            int mid = left + (right - left) / 2;\\n            if(citations[mid] == n - mid) return n - mid;\\n            else if(citations[mid] < n - mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return n - left;\\n    }\\n}\\n```"
    },
    {
        "slug": "find-common-characters",
        "tags": "java",
        "release_time": 1676385955,
        "code": "class Solution {\n    public List<String> commonChars(String[] words) {\n      \n        int vt[][]= new int[26][3];\n        for(int i=0;i<26;i++)\n            vt[i][1]=1000000;\n        \n    \n        int n=words.length;\n        for(String st:words){\n            \n            for(char c:st.toCharArray()){\n                vt[c-'a'][0]++;\n                vt[c-'a'][2]++;\n            }\n            for(int i=0;i<26;i++){\n                vt[i][1]=Math.min(vt[i][1],vt[i][2]);vt[i][2]=0;}\n  \n        }\n        List<String> list=new ArrayList<>();\n        for(int i=0;i<26;i++){\n          while(vt[i][0]>=n && vt[i][1]-->0)list.add(String.valueOf((char)(97+i)));}\n      \n        return list;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif any charactor was present in all strings,and minimum occurence throw-over all string will be occurence of character in result list;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreate a 2d array --[0] will contains no of string that contains it;\\n   --[1] minimum occurence throw over all strings\\n   --[2] temperary occurence in current string,for comparision\\n\\nthen find all character according to condition descrived in intuition\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nno of strings = n\\nsize of string = m\\n TC -$$O(n*m)$$\\n\\nExicution time =3s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSC -$$O(26)$$\\nthat constante so = $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> commonChars(String[] words) {\\n      \\n        int vt[][]= new int[26][3];\\n        for(int i=0;i<26;i++)\\n            vt[i][1]=1000000;\\n        \\n    \\n        int n=words.length;\\n        for(String st:words){\\n            \\n            for(char c:st.toCharArray()){\\n                vt[c-\\'a\\'][0]++;\\n                vt[c-\\'a\\'][2]++;\\n            }\\n            for(int i=0;i<26;i++){\\n                vt[i][1]=Math.min(vt[i][1],vt[i][2]);vt[i][2]=0;}\\n  \\n        }\\n        List<String> list=new ArrayList<>();\\n        for(int i=0;i<26;i++){\\n          while(vt[i][0]>=n && vt[i][1]-->0)list.add(String.valueOf((char)(97+i)));}\\n      \\n        return list;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-senior-citizens",
        "tags": "java",
        "release_time": 1683999672,
        "code": "class Solution {\n    public int countSeniors(String[] details) {\n\n     int count=0;\n     for(int i=0;i<details.length;i++)\n     {\n         int a=details[i].charAt(11)-'0';\n         a*=10;\n         a+=details[i].charAt(12)-'0';\n         if(a>60)\n         {\n             count++;\n         }\n     }\n     return count;    \n    }\n}",
        "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n     int count=0;\\n     for(int i=0;i<details.length;i++)\\n     {\\n         int a=details[i].charAt(11)-\\'0\\';\\n         a*=10;\\n         a+=details[i].charAt(12)-\\'0\\';\\n         if(a>60)\\n         {\\n             count++;\\n         }\\n     }\\n     return count;    \\n    }\\n}\\n```"
    },
    {
        "slug": "n-th-tribonacci-number",
        "tags": "java",
        "release_time": 1675068570,
        "code": "class Solution {\n    public int tribonacci(int n) {\n        if(n==0)return 0;\n        if(n==1||n==2) return 1;\n        int dp[]=new int[n+1];\n        dp[0]=0;\n        dp[1]=1;\n        dp[2]=1;\n        for(int i=3;i<=n;i++){\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\n        }\n        return dp[n];\n    }\n}",
        "content": "# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int tribonacci(int n) {\\n        if(n==0)return 0;\\n        if(n==1||n==2) return 1;\\n        int dp[]=new int[n+1];\\n        dp[0]=0;\\n        dp[1]=1;\\n        dp[2]=1;\\n        for(int i=3;i<=n;i++){\\n            dp[i]=dp[i-1]+dp[i-2]+dp[i-3];\\n        }\\n        return dp[n];\\n    }\\n}\\n```"
    },
    {
        "slug": "remove-element",
        "tags": "java",
        "release_time": 1674758451,
        "code": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                int temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i++;\n            }\n        }\n        return i;\n    }\n}",
        "content": "# Approach\\n- I am using Two pointers method\\n- After shifting the val to the right side of the array.\\n- Just return the value of k which is length of array excluding val.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int removeElement(int[] nums, int val) {\\n        int i = 0;\\n        for (int j = 0; j < nums.length; j++) {\\n            if (nums[j] != val) {\\n                int temp = nums[i];\\n                nums[i] = nums[j];\\n                nums[j] = temp;\\n                i++;\\n            }\\n        }\\n        return i;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n"
    },
    {
        "slug": "maximum-or",
        "tags": "java",
        "release_time": 1683993826,
        "code": "class Solution {\n    public long maximumOr(int[] nums, int k) {\n        int n = nums.length;\n        long[] prefix = new long[n];\n        long[] suffix = new long[n];\n        prefix[0] = 0;\n        suffix[n-1] = 0;\n        for(int i= 1;i<n;i++)\n        {\n            prefix[i] = prefix[i-1]|nums[i-1];\n        }\n        for(int i=n-2;i>=0;i--)\n        {\n            suffix[i] = suffix[i+1]|nums[i+1];\n        }\n        long max =0;\n        for(int i=0;i<n;i++)\n        {\n            long val = prefix[i]|suffix[i];\n            long v = nums[i]*(long)Math.pow(2,k);\n            max = Math.max(max,val|v);\n        }\n        return max;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumOr(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] prefix = new long[n];\\n        long[] suffix = new long[n];\\n        prefix[0] = 0;\\n        suffix[n-1] = 0;\\n        for(int i= 1;i<n;i++)\\n        {\\n            prefix[i] = prefix[i-1]|nums[i-1];\\n        }\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            suffix[i] = suffix[i+1]|nums[i+1];\\n        }\\n        long max =0;\\n        for(int i=0;i<n;i++)\\n        {\\n            long val = prefix[i]|suffix[i];\\n            long v = nums[i]*(long)Math.pow(2,k);\\n            max = Math.max(max,val|v);\\n        }\\n        return max;\\n    }\\n}\\n```"
    },
    {
        "slug": "binary-tree-zigzag-level-order-traversal",
        "tags": "java",
        "release_time": 1689593804,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n\n        List<List<Integer>> zlist = new ArrayList<>();\n        List<Integer> list ;\n        Queue<TreeNode> q = new LinkedList<>();\n        int size = 0;\n        boolean flag = false;\n\n        if(root == null)\n            return zlist;\n\n        q.offer(root);\n\n        while(!q.isEmpty())\n        {\n            size = q.size();\n            list = new ArrayList<>();\n            while(size-- >0)\n            {\n                root = q.poll();\n\n                if(root.left!=null)\n                  q.add(root.left);\n                if(root.right!=null)\n                  q.add(root.right);\n\n                  list.add(root.val);\n            }\n                //reverse list\n            if(flag == true)\n                Collections.reverse(list);\n            \n            flag = !flag;\n            zlist.add(list);\n        }\n            return zlist;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\\n\\n        List<List<Integer>> zlist = new ArrayList<>();\\n        List<Integer> list ;\\n        Queue<TreeNode> q = new LinkedList<>();\\n        int size = 0;\\n        boolean flag = false;\\n\\n        if(root == null)\\n            return zlist;\\n\\n        q.offer(root);\\n\\n        while(!q.isEmpty())\\n        {\\n            size = q.size();\\n            list = new ArrayList<>();\\n            while(size-- >0)\\n            {\\n                root = q.poll();\\n\\n                if(root.left!=null)\\n                  q.add(root.left);\\n                if(root.right!=null)\\n                  q.add(root.right);\\n\\n                  list.add(root.val);\\n            }\\n                //reverse list\\n            if(flag == true)\\n                Collections.reverse(list);\\n            \\n            flag = !flag;\\n            zlist.add(list);\\n        }\\n            return zlist;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "random-point-in-non-overlapping-rectangles",
        "tags": "java",
        "release_time": 1683885250,
        "code": "class Solution {\n    \n    int[][] rects;\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\n    int nPoints = 0;\n    \n    Random rng = new Random();\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        int index = 0;\n        for (int[] rect : rects) {\n\t\t    // inserts cumulative weight key pointing to rectangle index\n            weightedRectIndex.put(nPoints, index++);\n            nPoints += width(rect) * height(rect);\n        }\n    }\n    \n    public int[] pick() {\n\t    // generates random point within total weight\n        int point = rng.nextInt(nPoints);\n\t\t// finds appropriate rectangle\n        var entry = weightedRectIndex.floorEntry(point);\n\t\t// find point within the current rectangle\n        int rectPoint = point - entry.getKey();\n        int[] rect = rects[entry.getValue()];\n        return new int[]{\n            rect[0] + rectPoint % width(rect), \n            rect[1] + rectPoint / width(rect)};\n    }\n    \n    private int width(int[] rect) {\n        return rect[2] - rect[0] + 1;\n    }\n    \n    private int height(int[] rect) {\n        return rect[3] - rect[1] + 1;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    int[][] rects;\\n    TreeMap<Integer, Integer> weightedRectIndex = new TreeMap<>();\\n    int nPoints = 0;\\n    \\n    Random rng = new Random();\\n\\n    public Solution(int[][] rects) {\\n        this.rects = rects;\\n        int index = 0;\\n        for (int[] rect : rects) {\\n\\t\\t    // inserts cumulative weight key pointing to rectangle index\\n            weightedRectIndex.put(nPoints, index++);\\n            nPoints += width(rect) * height(rect);\\n        }\\n    }\\n    \\n    public int[] pick() {\\n\\t    // generates random point within total weight\\n        int point = rng.nextInt(nPoints);\\n\\t\\t// finds appropriate rectangle\\n        var entry = weightedRectIndex.floorEntry(point);\\n\\t\\t// find point within the current rectangle\\n        int rectPoint = point - entry.getKey();\\n        int[] rect = rects[entry.getValue()];\\n        return new int[]{\\n            rect[0] + rectPoint % width(rect), \\n            rect[1] + rectPoint / width(rect)};\\n    }\\n    \\n    private int width(int[] rect) {\\n        return rect[2] - rect[0] + 1;\\n    }\\n    \\n    private int height(int[] rect) {\\n        return rect[3] - rect[1] + 1;\\n    }\\n}\\n```"
    },
    {
        "slug": "continuous-subarray-sum",
        "tags": "java",
        "release_time": 1666813455,
        "code": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {      \n        Map<Integer, Integer> map = new HashMap<>();\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n            sum %= k; \n            if (sum == 0 && i > 0) return true;\n            if (map.containsKey(sum) && i - map.get(sum) > 1) return true;\n            \n            if(!map.containsKey(sum))map.put(sum, i); \n                        \n        }\n        return false;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {      \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sum %= k; \\n            if (sum == 0 && i > 0) return true;\\n            if (map.containsKey(sum) && i - map.get(sum) > 1) return true;\\n            \\n            if(!map.containsKey(sum))map.put(sum, i); \\n                        \\n        }\\n        return false;\\n    }\\n}\\n\\n\\n\\n```"
    },
    {
        "slug": "jewels-and-stones",
        "tags": "java",
        "release_time": 1689949381,
        "code": "class Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        int count = 0;\n\n        for(int i=0; i<stones.length(); i++){\n            char c = stones.charAt(i);\n            if(jewels.contains(String.valueOf(c))){\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int numJewelsInStones(String jewels, String stones) {\\n        int count = 0;\\n\\n        for(int i=0; i<stones.length(); i++){\\n            char c = stones.charAt(i);\\n            if(jewels.contains(String.valueOf(c))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "populating-next-right-pointers-in-each-node",
        "tags": "java",
        "release_time": 1674038373,
        "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if (root == null) return null;\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for(int i = 0; i < size; i++) {\n                Node node = queue.poll();\n                if(i < size - 1) {\n                    node.next = queue.peek();\n                }\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n                if(node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n        }\n        return root;\n\n    }\n    \n\n}",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.offer(root);\\n\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++) {\\n                Node node = queue.poll();\\n                if(i < size - 1) {\\n                    node.next = queue.peek();\\n                }\\n                if(node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if(node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n        }\\n        return root;\\n\\n    }\\n    \\n\\n}\\n```"
    },
    {
        "slug": "shortest-path-in-a-grid-with-obstacles-elimination",
        "tags": "java",
        "release_time": 1667138796,
        "code": "class Solution {\n    int [] dirs = {0, 1, 0, -1, 0};\n    public int shortestPath(int[][] grid, int k) {\n        int m = grid.length, n = grid[0].length;\n        if(k >= m+n -2) return m+n-2;\n        \n        boolean[][][] visited = new boolean [m][n][k+1];\n        Queue<int[]> q = new LinkedList<>();\n        q.offer(new int[]{0, 0, k, 0});\n        visited[0][0][k] = true;\n        \n        while(!q.isEmpty()){\n            int [] top = q.poll();\n          \n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\n            \n            if(r == m-1 && c == n -1) return dist;\n            for(int i = 0; i< 4; i++){\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\n                int newK = curk - grid[nr][nc];\n            \n                if(newK >= 0 && !visited[nr][nc][newK]){\n                    visited[nr][nc][newK] = true;\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\n                }\n            }\n        }\n        return -1;\n    }\n}",
        "content": "```\\nclass Solution {\\n    int [] dirs = {0, 1, 0, -1, 0};\\n    public int shortestPath(int[][] grid, int k) {\\n        int m = grid.length, n = grid[0].length;\\n        if(k >= m+n -2) return m+n-2;\\n        \\n        boolean[][][] visited = new boolean [m][n][k+1];\\n        Queue<int[]> q = new LinkedList<>();\\n        q.offer(new int[]{0, 0, k, 0});\\n        visited[0][0][k] = true;\\n        \\n        while(!q.isEmpty()){\\n            int [] top = q.poll();\\n          \\n            int r = top[0], c = top[1], curk = top[2], dist = top[3];\\n            \\n            if(r == m-1 && c == n -1) return dist;\\n            for(int i = 0; i< 4; i++){\\n                int nr = r + dirs[i], nc = c + dirs[i + 1];\\n                if(nr < 0 || nr == m || nc < 0 || nc == n) continue;\\n                int newK = curk - grid[nr][nc];\\n            \\n                if(newK >= 0 && !visited[nr][nc][newK]){\\n                    visited[nr][nc][newK] = true;\\n                    q.offer(new int[]{nr, nc, newK, dist + 1});\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```"
    },
    {
        "slug": "robot-return-to-origin",
        "tags": "java",
        "release_time": 1684399544,
        "code": "class Solution {\n    public boolean judgeCircle(String moves) {\n        int point[] = {0,0};\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (Character m: moves.toCharArray()) {\n            int ind = 0;\n            switch (m)\n            {\n                case 'U': {\n                    ind = 0;\n                    break;\n                }\n                case 'D': {\n                    ind = 1;\n                    break;\n                }\n                case 'L': {\n                    ind = 2;\n                    break;\n                }\n                case 'R': {\n                    ind = 3;\n                    break;\n                }\n            }\n            point[0] += move[ind][0];\n            point[1] += move[ind][1];\n        }\n        return point[0] == 0 && point[1] == 0;\n    }\n}",
        "content": "\\n```\\nclass Solution {\\n    public boolean judgeCircle(String moves) {\\n        int point[] = {0,0};\\n        int move[][] = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n        for (Character m: moves.toCharArray()) {\\n            int ind = 0;\\n            switch (m)\\n            {\\n                case \\'U\\': {\\n                    ind = 0;\\n                    break;\\n                }\\n                case \\'D\\': {\\n                    ind = 1;\\n                    break;\\n                }\\n                case \\'L\\': {\\n                    ind = 2;\\n                    break;\\n                }\\n                case \\'R\\': {\\n                    ind = 3;\\n                    break;\\n                }\\n            }\\n            point[0] += move[ind][0];\\n            point[1] += move[ind][1];\\n        }\\n        return point[0] == 0 && point[1] == 0;\\n    }\\n}\\n```"
    },
    {
        "slug": "search-insert-position",
        "tags": "java",
        "release_time": 1691612815,
        "code": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int left=0;//here we declare two pointer left and right\n        int right=1;\n        int index=0;//this varible stores the output index.\n\n        while(right<=nums.length ){\n            //for mid \n            if(right<nums.length){ \n//here we again check the right ptr index,otherwise it give arrayindexoutofBoundException.\n            if(nums[left]<target && nums[right]>target ){\n                 index=(left+right+2)/2;//here we add length of left and right pointer left+1 and right+1 ,\n            }\n              else if(nums[right]==target){//this conditon satisfies when target elemnt present in array.\n                index=right;\n            }\n            }\n\n            else if(target>nums[nums.length-1]){ \n//this conditon satisfy when target value is greatet than last value of array.\n                index=nums.length;\n\n          \n            }\n        left++;\n        right++;\n        \n        }   \nreturn index;\n        \n    \n    }\n}",
        "content": "# Intuition\\n\\n\\n# Approach\\nTwo Pointer approch.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int searchInsert(int[] nums, int target) {\\n        int left=0;//here we declare two pointer left and right\\n        int right=1;\\n        int index=0;//this varible stores the output index.\\n\\n        while(right<=nums.length ){\\n            //for mid \\n            if(right<nums.length){ \\n//here we again check the right ptr index,otherwise it give arrayindexoutofBoundException.\\n            if(nums[left]<target && nums[right]>target ){\\n                 index=(left+right+2)/2;//here we add length of left and right pointer left+1 and right+1 ,\\n            }\\n              else if(nums[right]==target){//this conditon satisfies when target elemnt present in array.\\n                index=right;\\n            }\\n            }\\n\\n            else if(target>nums[nums.length-1]){ \\n//this conditon satisfy when target value is greatet than last value of array.\\n                index=nums.length;\\n\\n          \\n            }\\n        left++;\\n        right++;\\n        \\n        }   \\nreturn index;\\n        \\n    \\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-arithmetic-triplets",
        "tags": "java",
        "release_time": 1688291896,
        "code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        int ans =0;\n        for(int i=0; i<nums.length-2;i++){\n            int count =0;\n            for(int j=i+1; j<nums.length; j++){\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\n                    count++;\n                }\n            }\n            if(count >= 2){\n                ans++;\n            }\n        }\n\n        return ans;\n        \n    }\n}",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have to find a triplet of (i, j, k) such that \\ni<j<k , \\nnums[j] - nums[i] == diff, and \\nnums[k] - nums[j] == diff\\n\\nin other word we can also say nums[k]-nums[i]== 2*diff. To reduce the time complexity I use only 2 loop remove the loop for k and include it in j iterartion such that nums[j]-nums[i] == 2*diff. So in every iterartion of j we will get 2 condition nums[j]-nums[i] == diff and nums[j]-nums[i] == 2*diff when these 2 condition get satisfied in j iterartion, We get 1 count as answer. So for every iteration when count>=2 we add 1 to ans and at last return it.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        int ans =0;\\n        for(int i=0; i<nums.length-2;i++){\\n            int count =0;\\n            for(int j=i+1; j<nums.length; j++){\\n                if(nums[j]-nums[i]==diff || nums[j]-nums[i]==2*diff){\\n                    count++;\\n                }\\n            }\\n            if(count >= 2){\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "reformat-phone-number",
        "tags": "java",
        "release_time": 1692113726,
        "code": "class Solution{\n    public String reformatNumber(String nm){\n        StringBuilder s = new StringBuilder(\"\");\n        for(int i=0; i<nm.length(); i++){\n            if(nm.charAt(i)!=' ' && nm.charAt(i)!='-') s.append(nm.charAt(i));\n        }\n        int n = s.length();\n\n        if(n%3==0){\n            StringBuilder ans = new StringBuilder(\"\");\n            for(int i=0; i<s.length(); i+=3){\n                ans.append(s.substring(i, i+3));\n                ans.append(\"-\");\n            }\n            return ans.substring(0, ans.length()-1).toString();\n        }\n\n        else if(n%3==1){\n            StringBuilder ans = new StringBuilder(\"\");\n            StringBuilder s1 = new StringBuilder(\"\");\n            s1.append(s.substring(0, s.length()-4));\n            for(int i=0; i<s1.length(); i+=3){\n                ans.append(s1.substring(i, i+3));\n                ans.append(\"-\");\n            }\n            ans.append(s.substring(s.length()-4, s.length()-2));\n            ans.append(\"-\");\n            ans.append(s.substring(s.length()-2));\n            return ans.toString();\n        }\n        \n        else if(n%3==2){\n            StringBuilder ans = new StringBuilder(\"\");\n            StringBuilder s1 = new StringBuilder(\"\");\n            s1.append(s.substring(0, s.length()-2));\n            for(int i=0; i<s1.length(); i+=3){\n                ans.append(s1.substring(i, i+3));\n                ans.append(\"-\");\n            }\n            ans.append(s.substring(s.length()-2));\n            return ans.toString();\n        }\n        return null;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution{\\n    public String reformatNumber(String nm){\\n        StringBuilder s = new StringBuilder(\"\");\\n        for(int i=0; i<nm.length(); i++){\\n            if(nm.charAt(i)!=\\' \\' && nm.charAt(i)!=\\'-\\') s.append(nm.charAt(i));\\n        }\\n        int n = s.length();\\n\\n        if(n%3==0){\\n            StringBuilder ans = new StringBuilder(\"\");\\n            for(int i=0; i<s.length(); i+=3){\\n                ans.append(s.substring(i, i+3));\\n                ans.append(\"-\");\\n            }\\n            return ans.substring(0, ans.length()-1).toString();\\n        }\\n\\n        else if(n%3==1){\\n            StringBuilder ans = new StringBuilder(\"\");\\n            StringBuilder s1 = new StringBuilder(\"\");\\n            s1.append(s.substring(0, s.length()-4));\\n            for(int i=0; i<s1.length(); i+=3){\\n                ans.append(s1.substring(i, i+3));\\n                ans.append(\"-\");\\n            }\\n            ans.append(s.substring(s.length()-4, s.length()-2));\\n            ans.append(\"-\");\\n            ans.append(s.substring(s.length()-2));\\n            return ans.toString();\\n        }\\n        \\n        else if(n%3==2){\\n            StringBuilder ans = new StringBuilder(\"\");\\n            StringBuilder s1 = new StringBuilder(\"\");\\n            s1.append(s.substring(0, s.length()-2));\\n            for(int i=0; i<s1.length(); i+=3){\\n                ans.append(s1.substring(i, i+3));\\n                ans.append(\"-\");\\n            }\\n            ans.append(s.substring(s.length()-2));\\n            return ans.toString();\\n        }\\n        return null;\\n    }\\n}\\n```"
    },
    {
        "slug": "employee-importance",
        "tags": "java",
        "release_time": 1655279531,
        "code": "class Solution {\n    public int getImportance(List<Employee> employees, int id) {\n        Map<Integer, Employee> inputMap = new HashMap<>();\n\t\t// Construct HashMap as getting the employee from id is difficult in a list\n\t\tfor(Employee e : employees) {\n\t\t\tinputMap.put(e.id, e);\n\t\t}\n\t\treturn helper(inputMap, id);\n\t}\n\n\tprivate static int helper(Map<Integer, Employee> inputMap, int id) {\n\t\t//Get the importance of the employee\n\t\tint imp = inputMap.get(id).importance;\n\t\t\n\t\t//Add importance of subordinates to employee importance\n\t\tfor(int subId : inputMap.get(id).subordinates) {\n\t\t\timp += helper(inputMap, subId);\n\t\t}\n\t\t\n\t\treturn imp;\n\t}\n}",
        "content": "```\\nclass Solution {\\n    public int getImportance(List<Employee> employees, int id) {\\n        Map<Integer, Employee> inputMap = new HashMap<>();\\n\\t\\t// Construct HashMap as getting the employee from id is difficult in a list\\n\\t\\tfor(Employee e : employees) {\\n\\t\\t\\tinputMap.put(e.id, e);\\n\\t\\t}\\n\\t\\treturn helper(inputMap, id);\\n\\t}\\n\\n\\tprivate static int helper(Map<Integer, Employee> inputMap, int id) {\\n\\t\\t//Get the importance of the employee\\n\\t\\tint imp = inputMap.get(id).importance;\\n\\t\\t\\n\\t\\t//Add importance of subordinates to employee importance\\n\\t\\tfor(int subId : inputMap.get(id).subordinates) {\\n\\t\\t\\timp += helper(inputMap, subId);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn imp;\\n\\t}\\n}\\n```"
    },
    {
        "slug": "minimum-falling-path-sum-ii",
        "tags": "java",
        "release_time": 1668185090,
        "code": "class Solution {\n    int m;\n    int n;\n    Integer memo[][];\n\n    public int minFallingPathSum(int[][] grid) {   \n         m=grid.length;\n         n=grid[0].length;\n        //<<---------------for Recursive Soln--------------->>\n         memo=new Integer[m][n];//memo [][]\n\n         int recRes=Integer.MAX_VALUE;\n\n         //iterate over the 1st rows col \n        //  for(int col=0;col<n;col++)\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\n\n      //<<---------------for Recursive Soln--------------->>\n        //  return recRes;\n\n          //<<---------------for Tabulation  Soln--------------->>\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\n         return Tabulation_Ans;\n    }\n\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\n            \n            if(j<0 || j>=n || i<0 || i>=m)\n                           return Integer.MAX_VALUE;\n\n            if(i==m-1)\n                     return grid[i][j];\n\n            if(memo[i][j]!=null)\n                        return memo[i][j];\n\n            int lowerLeftSum=Integer.MAX_VALUE;\n            int lowerRightSum=Integer.MAX_VALUE;\n\n            for(int col=0;col<=j-1;col++)\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\n\n            for(int col=j+1;col<=n-1;col++)\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\n\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n\n     }//rec--->>memorization\n\n\n\n\n     int minFallingPathSum_Tabulation(int[][] grid){\n          int dp[][]=new int[m][n];\n\n          for(int i=m-1;i>=0;i--){\n              for(int j=n-1;j>=0;j--){\n                    \n                    if(i==m-1)\n                     {\n                         dp[i][j]=grid[i][j];\n                         continue;\n                     }//base case : if the last row \n                \n                int lowerLeftSum=Integer.MAX_VALUE;\n                int lowerRightSum=Integer.MAX_VALUE;\n                //for lower left sum calculation \n                for(int col=0;col<=j-1;col++){\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\n                }\n                \n                //for lower right sum calculation \n                for(int col=j+1;col<=n-1;col++){\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\n                \n                }\n                \n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\n              \n              }//inner \n          }//ouer \n           \n\n          int Ans=Integer.MAX_VALUE;\n\n          for(int COL=0;COL<n;COL++){\n              Ans=Math.min(Ans,dp[0][COL]);\n          }\n          \n          return Ans;\n     \n     }//tabulation soln:derived from the recursive soln \n}",
        "content": "# Intuition\\nat any particular cell grid(i,j) we need the minm of all cells of f(i+1,{0 to j-1}) and all minm of cells of f(i+1,{j+1 to n-1})\\n\\n\\n# I have shared both recursive/memo code and alternate tabulation code on same code space . Have a look into the soln and do let me know if any confusion . Please do upvote if you find the soln helpful \\uD83D\\uDE80\\n\\n# Code\\n```\\nclass Solution {\\n    int m;\\n    int n;\\n    Integer memo[][];\\n\\n    public int minFallingPathSum(int[][] grid) {   \\n         m=grid.length;\\n         n=grid[0].length;\\n        //<<---------------for Recursive Soln--------------->>\\n         memo=new Integer[m][n];//memo [][]\\n\\n         int recRes=Integer.MAX_VALUE;\\n\\n         //iterate over the 1st rows col \\n        //  for(int col=0;col<n;col++)\\n        //            recRes=Math.min(recRes,minFallingPathSum_Rec(grid,0,col));\\n\\n      //<<---------------for Recursive Soln--------------->>\\n        //  return recRes;\\n\\n          //<<---------------for Tabulation  Soln--------------->>\\n         int Tabulation_Ans=minFallingPathSum_Tabulation(grid);\\n         return Tabulation_Ans;\\n    }\\n\\n    public int minFallingPathSum_Rec(int[][] grid,int i,int j){\\n            \\n            if(j<0 || j>=n || i<0 || i>=m)\\n                           return Integer.MAX_VALUE;\\n\\n            if(i==m-1)\\n                     return grid[i][j];\\n\\n            if(memo[i][j]!=null)\\n                        return memo[i][j];\\n\\n            int lowerLeftSum=Integer.MAX_VALUE;\\n            int lowerRightSum=Integer.MAX_VALUE;\\n\\n            for(int col=0;col<=j-1;col++)\\n                    lowerLeftSum=Math.min(lowerLeftSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n            for(int col=j+1;col<=n-1;col++)\\n                    lowerRightSum=Math.min(lowerRightSum,minFallingPathSum_Rec(grid,i+1,col));\\n\\n          return memo[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n\\n     }//rec--->>memorization\\n\\n\\n\\n\\n     int minFallingPathSum_Tabulation(int[][] grid){\\n          int dp[][]=new int[m][n];\\n\\n          for(int i=m-1;i>=0;i--){\\n              for(int j=n-1;j>=0;j--){\\n                    \\n                    if(i==m-1)\\n                     {\\n                         dp[i][j]=grid[i][j];\\n                         continue;\\n                     }//base case : if the last row \\n                \\n                int lowerLeftSum=Integer.MAX_VALUE;\\n                int lowerRightSum=Integer.MAX_VALUE;\\n                //for lower left sum calculation \\n                for(int col=0;col<=j-1;col++){\\n                    lowerLeftSum=Math.min(lowerLeftSum,((col<0)?Integer.MAX_VALUE:dp[i+1][col]));\\n                }\\n                \\n                //for lower right sum calculation \\n                for(int col=j+1;col<=n-1;col++){\\n                    lowerRightSum=Math.min(lowerRightSum,((col>=n)?Integer.MAX_VALUE:dp[i+1][col]));\\n                \\n                }\\n                \\n                dp[i][j]=Math.min(lowerLeftSum,lowerRightSum)+grid[i][j];\\n              \\n              }//inner \\n          }//ouer \\n           \\n\\n          int Ans=Integer.MAX_VALUE;\\n\\n          for(int COL=0;COL<n;COL++){\\n              Ans=Math.min(Ans,dp[0][COL]);\\n          }\\n          \\n          return Ans;\\n     \\n     }//tabulation soln:derived from the recursive soln \\n}\\n```"
    },
    {
        "slug": "delete-columns-to-make-sorted",
        "tags": "java",
        "release_time": 1672726665,
        "code": "class Solution {\n    public int minDeletionSize(String[] strs) {\n        int count = 0;\n        for(int i=0;i<strs[0].length();i++) {\n        \tint temp = 0;\n        \tfor(int j=0;j<strs.length;j++) {\n        \t\tint a = strs[j].charAt(i);\n        \t\tif(a>=temp) {\n        \t\t\ttemp = a;\n        \t\t}else {\n        \t\t\tcount++;\n        \t\t\tbreak;\n        \t\t}\n        \t}\n        }\n        return count;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBased on the Aschii values we can justify wether it is sorted or not.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere i have created a count varibale for storing the answer value and a for loop for each coloum and then declared a temp variable which stores the temperory value of previous aschi value of the character, with this \\'temp\\' i have chechked whether the present character value is greater then the previous one. In case of failure the loop is terminated and the count value is increased.\\n# Complexity\\n- Time complexity: 5 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 42.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minDeletionSize(String[] strs) {\\n        int count = 0;\\n        for(int i=0;i<strs[0].length();i++) {\\n        \\tint temp = 0;\\n        \\tfor(int j=0;j<strs.length;j++) {\\n        \\t\\tint a = strs[j].charAt(i);\\n        \\t\\tif(a>=temp) {\\n        \\t\\t\\ttemp = a;\\n        \\t\\t}else {\\n        \\t\\t\\tcount++;\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "the-number-of-weak-characters-in-the-game",
        "tags": "java",
        "release_time": 1662691692,
        "code": "class Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\n        int count = 0, max = 0;\n        for(int[] arr: properties){\n            if(arr[1] < max)    count++;\n            max = Math.max(max, arr[1]);\n        }\n        return count;\n    }\n}",
        "content": "**Time Complexity : O(n*logn)**\\n**Java**\\n```\\nclass Solution {\\n    public int numberOfWeakCharacters(int[][] properties) {\\n        Arrays.sort(properties, (a,b) -> (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]));\\n        int count = 0, max = 0;\\n        for(int[] arr: properties){\\n            if(arr[1] < max)    count++;\\n            max = Math.max(max, arr[1]);\\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar numberOfWeakCharacters = function(properties) {\\n    properties.sort((a,b) => (a[0] == b[0]) ? (a[1]-b[1]) : (b[0]-a[0]))\\n    let count = 0, max = 0\\n    for(let arr of properties){\\n        if(arr[1] < max)    count++\\n        max = Math.max(max, arr[1])\\n    }\\n    return count\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def numberOfWeakCharacters(self, properties):\\n        properties.sort(key = lambda x: (-x[0], x[1]))\\n        count, mx = 0, 0\\n        for arr in properties:\\n            if arr[1] < mx:\\n                count += 1\\n            mx = max(mx, arr[1])\\n        return count\\n```"
    },
    {
        "slug": "subrectangle-queries",
        "tags": "java",
        "release_time": 1691178896,
        "code": "class SubrectangleQueries {\n    int[][] ans;\n    public SubrectangleQueries(int[][] rectangle) {\n        ans = rectangle;\n    }\n    \n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\n        for(int i=row1; i<=row2; i++){\n            for(int j=col1; j<=col2; j++){\n                ans[i][j] = newValue;\n            }\n        }\n    }\n    \n    public int getValue(int row, int col) {\n        int val = ans[row][col];\n        return val;\n    }\n}\n\n/**\n * Your SubrectangleQueries object will be instantiated and called as such:\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\n * int param_2 = obj.getValue(row,col);\n */",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The constructor initializes a 2D array \\'ans\\' to store the rectangle.\\n2. The \\'updateSubrectangle\\' function updates the subrectangle with the given \\'newValue\\' by iterating over the specified range and updating each element.\\n3. The \\'getValue\\' function retrieves the value at the specified row and column in \\'ans\\'.\\n\\n# Complexity\\n- Time complexity: O((row2 - row1 + 1) * (col2 - col1 + 1))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass SubrectangleQueries {\\n    int[][] ans;\\n    public SubrectangleQueries(int[][] rectangle) {\\n        ans = rectangle;\\n    }\\n    \\n    public void updateSubrectangle(int row1, int col1, int row2, int col2, int newValue) {\\n        for(int i=row1; i<=row2; i++){\\n            for(int j=col1; j<=col2; j++){\\n                ans[i][j] = newValue;\\n            }\\n        }\\n    }\\n    \\n    public int getValue(int row, int col) {\\n        int val = ans[row][col];\\n        return val;\\n    }\\n}\\n\\n/**\\n * Your SubrectangleQueries object will be instantiated and called as such:\\n * SubrectangleQueries obj = new SubrectangleQueries(rectangle);\\n * obj.updateSubrectangle(row1,col1,row2,col2,newValue);\\n * int param_2 = obj.getValue(row,col);\\n */\\n```"
    },
    {
        "slug": "largest-3-same-digit-number-in-string",
        "tags": "java",
        "release_time": 1672085177,
        "code": "class Solution {\n    public String largestGoodInteger(String num) {\n         if (num.length() <= 1)\n            return \"\";\n\n        Map<Integer, String> stringMap = new HashMap<>();\n\n        for (int i = 0; i < num.length() - 2; i++) {\n            if (num.charAt(i) == num.charAt(i + 2) && num.charAt(i) == num.charAt(i + 1))\n                stringMap.putIfAbsent(num.charAt(i) - '0', num.substring(i, i + 3));\n        }\n\n        for (int i = 9; i >=0; i--)\n            if (stringMap.containsKey(i))\n                return stringMap.get(i);\n\n        return \"\";\n    }\n}",
        "content": "# Intuition\\nLoop and return  the answer but 65 test case filed then used HashMap\\n\\n# Approach\\nLoop over the string for every three strings ans store them in HashMap if it satisfies the condition. Why HashMap because it store element in Order wise. \\nThen loop over the HashMap and print the last entry in the Map.\\n\\n# Complexity\\n- Time complexity:\\n     $$O(n)$$ \\n\\n- Space complexity:\\n     $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\n    public String largestGoodInteger(String num) {\\n         if (num.length() <= 1)\\n            return \"\";\\n\\n        Map<Integer, String> stringMap = new HashMap<>();\\n\\n        for (int i = 0; i < num.length() - 2; i++) {\\n            if (num.charAt(i) == num.charAt(i + 2) && num.charAt(i) == num.charAt(i + 1))\\n                stringMap.putIfAbsent(num.charAt(i) - \\'0\\', num.substring(i, i + 3));\\n        }\\n\\n        for (int i = 9; i >=0; i--)\\n            if (stringMap.containsKey(i))\\n                return stringMap.get(i);\\n\\n        return \"\";\\n    }\\n}\\n```"
    },
    {
        "slug": "three-consecutive-odds",
        "tags": "java",
        "release_time": 1670908898,
        "code": "class Solution {\n    public boolean threeConsecutiveOdds(int[] arr) {\n        for (int i = 0; i < arr.length - 2; i++) {\n            boolean isOdd1 = arr[i] % 2 == 1;\n            boolean isOdd2 = arr[i + 1] % 2 == 1;\n            boolean isOdd3 = arr[i + 2] % 2 == 1;\n            if (isOdd1 && isOdd2 && isOdd3) return true;\n        }\n        return false;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public boolean threeConsecutiveOdds(int[] arr) {\\n        for (int i = 0; i < arr.length - 2; i++) {\\n            boolean isOdd1 = arr[i] % 2 == 1;\\n            boolean isOdd2 = arr[i + 1] % 2 == 1;\\n            boolean isOdd3 = arr[i + 2] % 2 == 1;\\n            if (isOdd1 && isOdd2 && isOdd3) return true;\\n        }\\n        return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "combination-sum",
        "tags": "java",
        "release_time": 1692131867,
        "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> currentSubset = new ArrayList<>();\n\n        findCombination(0, target, candidates, currentSubset, result);\n        return result;\n    }\n\n    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {\n        // checks if we have explored all the elements of array\n        if(index == candidates.length) {\n            if(target == 0) {\n                result.add(new ArrayList<>(currentSubset));\n            }\n            return;\n        }\n\n        if(candidates[index] <= target) {\n            currentSubset.add(candidates[index]);\n            \n            // After adding the element of curr index, iterate the left path until the base condition is met\n            findCombination(index, target - candidates[index], candidates, currentSubset, result);\n        \n            // this is required because when the above recursion call \n            // is executed then the Data structure still has curr index element so we need to remove it\n            currentSubset.remove(currentSubset.size() - 1);\n        }\n\n        // check for the next element of array\n        findCombination(index + 1, target, candidates, currentSubset, result);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to explore all the options for each element and find a combination such that sum of the combination is equal to target. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nat each index we have two options\\n1) pick the element (left path)\\n2) dont pick the element (right path)\\n\\n- now when we pick the element (the left path), then we add that element in our data structure and reduce the target value.\\n    \\nLets consider the following\\n \\n    structure of the function F() - \\n\\n            F(index, target - arr[index], empty Data Structure)\\n\\n    arr -   [2,   3,   6,   7]  \\ttarget = 7\\n            (0), (1), (2), (3)\\n\\n                                F(0, 7, [])\\n                                   /   \\\\\\n                                  /     \\\\\\n                                 /       \\\\\\n              (1-left)->  F(0, 5, [2])    F(1, 7, [])  <-(1-right)\\n                             /   \\\\      \\t     \\n                            /     \\\\ \\t  \\n                           /       \\\\        \\n    (2-left)->  F(0, 3, [2,2])    F(1, 5, [2])   <-(2-right)\\n\\nat Step`(1-left)`we took the element at index 0, added it to the data structure and then reduced the value of target to`7 - 2 = 5`\\n\\nLet\\'s say that we explored all the paths of`(2-left)`so now when the path backtracks to`(1-left)`we remove the last added value in the data structure i.e.`2`and then again try to explore the right path i.e.`(2-right)`.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> currentSubset = new ArrayList<>();\\n\\n        findCombination(0, target, candidates, currentSubset, result);\\n        return result;\\n    }\\n\\n    public static void findCombination(int index, int target, int[] candidates, List<Integer> currentSubset, List<List<Integer>> result) {\\n        // checks if we have explored all the elements of array\\n        if(index == candidates.length) {\\n            if(target == 0) {\\n                result.add(new ArrayList<>(currentSubset));\\n            }\\n            return;\\n        }\\n\\n        if(candidates[index] <= target) {\\n            currentSubset.add(candidates[index]);\\n            \\n            // After adding the element of curr index, iterate the left path until the base condition is met\\n            findCombination(index, target - candidates[index], candidates, currentSubset, result);\\n        \\n            // this is required because when the above recursion call \\n            // is executed then the Data structure still has curr index element so we need to remove it\\n            currentSubset.remove(currentSubset.size() - 1);\\n        }\\n\\n        // check for the next element of array\\n        findCombination(index + 1, target, candidates, currentSubset, result);\\n    }\\n}\\n```"
    },
    {
        "slug": "merge-two-2d-arrays-by-summing-values",
        "tags": "java",
        "release_time": 1677788157,
        "code": "class Solution {\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\n        \n        Map<Integer, Integer> map = new TreeMap<>();\n        int l1 = nums1.length;\n        int l2 = nums2.length;\n\n        for (int i = 0; i < l1; i++) {\n            if (!map.containsKey(nums1[i][0])) {\n                map.put(nums1[i][0], nums1[i][1]);\n            }\n            else {\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\n            }\n            \n        }\n\n        for (int i = 0; i < l2; i++) {\n            if (!map.containsKey(nums2[i][0])) {\n                map.put(nums2[i][0], nums2[i][1]);\n            }\n            else {\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\n            }\n            \n        }\n\n        int count = 0;\n        int[][] ans = new int[map.size()][2];\n\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            ans[count][0] = entry.getKey();\n            ans[count][1] = entry.getValue();\n            count++;\n        }\n        \n        return ans;\n    }\n}",
        "content": "# Java\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] mergeArrays(int[][] nums1, int[][] nums2) {\\n        \\n        Map<Integer, Integer> map = new TreeMap<>();\\n        int l1 = nums1.length;\\n        int l2 = nums2.length;\\n\\n        for (int i = 0; i < l1; i++) {\\n            if (!map.containsKey(nums1[i][0])) {\\n                map.put(nums1[i][0], nums1[i][1]);\\n            }\\n            else {\\n                map.put(nums1[i][0], (map.get(nums1[i][0]) + nums1[i][1]));\\n            }\\n            \\n        }\\n\\n        for (int i = 0; i < l2; i++) {\\n            if (!map.containsKey(nums2[i][0])) {\\n                map.put(nums2[i][0], nums2[i][1]);\\n            }\\n            else {\\n                map.put(nums2[i][0], (map.get(nums2[i][0]) + nums2[i][1]));\\n            }\\n            \\n        }\\n\\n        int count = 0;\\n        int[][] ans = new int[map.size()][2];\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            ans[count][0] = entry.getKey();\\n            ans[count][1] = entry.getValue();\\n            count++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "sort-even-and-odd-indices-independently",
        "tags": "java",
        "release_time": 1691504783,
        "code": "class Solution {\n    public int[] sortEvenOdd(int[] nums) {\n        int n = nums.length;\n        int[] even = new int[(n + 1) / 2];\n        int[] odd = new int[n / 2];\n        int iE = 0;\n        int iO = 0;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                even[iE++] = nums[i];\n            } else {\n                odd[iO++] = nums[i];\n            }\n        }\n\n        Arrays.sort(even);\n        Arrays.sort(odd);\n        iE = 0;\n        iO = n / 2 - 1;\n\n        for(int i = 0; i < n; i++) {\n            if(i % 2 == 0) {\n                nums[i] = even[iE++];\n            } else {\n                nums[i] = odd[iO--];\n            }\n        }\n\n        return nums;\n    }\n}",
        "content": "# Approach\\nLet\\'s break down the approach and logic used in the provided solution:\\n\\n1. **Array Splitting:**\\n   The solution begins by splitting the input array `nums` into two separate arrays: one for even indices and one for odd indices. This is done to simplify the sorting process for each set of values.\\n\\n2. **Filling Even and Odd Arrays:**\\n   The loop iterates through the `nums` array. If the current index `i` is even, the corresponding value is added to the `even` array; if `i` is odd, the value is added to the `odd` array. This way, the even values are stored in one array and the odd values in another.\\n\\n3. **Sorting Arrays:**\\n   After filling the `even` and `odd` arrays, both arrays are sorted. The `Arrays.sort()` function is used to sort the elements in ascending order.\\n\\n4. **Reconstruction of `nums` Array:**\\n   After sorting the two arrays, the solution now reconstructs the `nums` array. It uses two index pointers `iE` and `iO` for the `even` and `odd` arrays, respectively.\\n\\n   The loop iterates through the `nums` array again, and if the current index `i` is even, it assigns the value from the `even` array using the `iE` pointer. Similarly, if `i` is odd, it assigns the value from the `odd` array using the `iO` pointer.\\n\\n   Notably, the values from the `odd` array are assigned in reverse order (`iO` decreases while traversing odd indices) because we sorted the odd values in non-increasing order.\\n\\n5. **Returning the Result:**\\n   Finally, the `nums` array is fully reconstructed according to the rules specified in the problem, and this sorted array is returned as the result.\\n\\nThe key idea here is to separate even and odd indices, sort the respective values independently, and then reconstruct the original array while following the given rules for sorting even and odd indices.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] sortEvenOdd(int[] nums) {\\n        int n = nums.length;\\n        int[] even = new int[(n + 1) / 2];\\n        int[] odd = new int[n / 2];\\n        int iE = 0;\\n        int iO = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                even[iE++] = nums[i];\\n            } else {\\n                odd[iO++] = nums[i];\\n            }\\n        }\\n\\n        Arrays.sort(even);\\n        Arrays.sort(odd);\\n        iE = 0;\\n        iO = n / 2 - 1;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(i % 2 == 0) {\\n                nums[i] = even[iE++];\\n            } else {\\n                nums[i] = odd[iO--];\\n            }\\n        }\\n\\n        return nums;\\n    }\\n}\\n```"
    },
    {
        "slug": "lexicographically-smallest-equivalent-string",
        "tags": "java",
        "release_time": 1673736567,
        "code": "class Solution {\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        \n        UFDS dsu = new UFDS(26);\n        for(int i = 0; i < s1.length(); i++){\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\n        }\n\n        StringBuilder sb = new StringBuilder(); \n\n        for(int i = 0; i < baseStr.length(); i++){\n            int root = dsu.root(baseStr.charAt(i) - 97);\n            sb.append((char)(dsu.min[root] + 97));\n\n        }\n        return sb.toString();\n    }\n    \n    class UFDS{\n        \n        int[] id;\n        int[] size;\n        int[] min;\n        \n        public UFDS(int N){\n            \n            id = new int[N];\n            size = new int[N];\n            min = new int[N];\n            for(int i = 0; i < N; i++){\n                id[i] = i;\n                size[i] = 1;\n                min[i] = i;\n            }\n        }\n        \n        private int root(int i){\n            while (i != id[i]){\n                id[i] = id[id[i]];\n                i = id[i];\n            }\n            return i;\n        }\n        \n        public void union(int p, int q){\n            \n            int i = root(p);\n            int j = root(q);\n            if(i == j)return;\n            if(size[i] < size[j]){\n                id[i] = id[j];\n                size[j] += size[i];\n                min[j] = Math.min(min[i],min[j]);\n            }\n            else{\n                id[j] = id[i];\n                size[i] += size[j];\n                min[i] = Math.min(min[i],min[j]);\n            }\n        }\n\n    }   \n}",
        "content": "# Intuition\\nThis is as straight forward of a DSU/UFDS problem as they come. One could think of equivalent characters as elements belonging to the same set. If a certain character of one set is found to be equivalent to be the character of some other set, a union of those two sets has to be performed. Also, the smallest character in each set has to be tracked so as to finally construct our answer.\\n\\n# Approach\\nStart by initialsing a UFDS class with 26 elements (elements being the characters of a set). Take union of two equivalent characters a/c to String S1 and S2, while taking union, keep tracking the minimum element of the sets involved using an extra \\'min\\' array. To finally construct the answer, find the min character for each set a character of the baseStr String belongs to. \\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\\n        \\n        UFDS dsu = new UFDS(26);\\n        for(int i = 0; i < s1.length(); i++){\\n            dsu.union(s1.charAt(i)-97,s2.charAt(i)-97);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(); \\n\\n        for(int i = 0; i < baseStr.length(); i++){\\n            int root = dsu.root(baseStr.charAt(i) - 97);\\n            sb.append((char)(dsu.min[root] + 97));\\n\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UFDS{\\n        \\n        int[] id;\\n        int[] size;\\n        int[] min;\\n        \\n        public UFDS(int N){\\n            \\n            id = new int[N];\\n            size = new int[N];\\n            min = new int[N];\\n            for(int i = 0; i < N; i++){\\n                id[i] = i;\\n                size[i] = 1;\\n                min[i] = i;\\n            }\\n        }\\n        \\n        private int root(int i){\\n            while (i != id[i]){\\n                id[i] = id[id[i]];\\n                i = id[i];\\n            }\\n            return i;\\n        }\\n        \\n        public void union(int p, int q){\\n            \\n            int i = root(p);\\n            int j = root(q);\\n            if(i == j)return;\\n            if(size[i] < size[j]){\\n                id[i] = id[j];\\n                size[j] += size[i];\\n                min[j] = Math.min(min[i],min[j]);\\n            }\\n            else{\\n                id[j] = id[i];\\n                size[i] += size[j];\\n                min[i] = Math.min(min[i],min[j]);\\n            }\\n        }\\n\\n    }   \\n}\\n```"
    },
    {
        "slug": "account-balance-after-rounded-purchase",
        "tags": "java",
        "release_time": 1691437848,
        "code": "class Solution {\n    public int accountBalanceAfterPurchase(int amt) {\n        if(amt%10 == 0)\n        {\n            return 100-amt;\n        }\n        int ans=100-amt;\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int accountBalanceAfterPurchase(int amt) {\\n        if(amt%10 == 0)\\n        {\\n            return 100-amt;\\n        }\\n        int ans=100-amt;\\n        return amt%10 >= 5 ? (ans/10)*10 : ((ans/10)+1)*10;\\n    }\\n}\\n```"
    },
    {
        "slug": "matrix-block-sum",
        "tags": "java",
        "release_time": 1682501669,
        "code": "class Solution {\n    public int[][] matrixBlockSum(int[][] mat, int k) {\n        int[][] answer = new int[mat.length][mat[0].length];\n\n        for(int i = 0; i < mat.length; i++) {\n            for(int j = 0; j < mat[0].length; j++) {\n                int rowStart = i-k;\n                int rowEnd = i+k;\n                int colStart = j-k;\n                int colEnd = j+k;\n\n                if(rowStart < 0) {\n                    rowStart = 0;\n                }\n\n                if(rowEnd >= mat.length) {\n                    rowEnd = mat.length - 1;\n                }\n\n                if(colStart < 0) {\n                    colStart = 0;\n                }\n\n                if(colEnd >= mat[0].length) {\n                    colEnd = mat[0].length - 1;\n                }\n\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\n            }\n        }\n\n        return answer;\n    }\n\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int sum = 0;\n\n        for(int i = rowStart; i <= rowEnd; i++) {\n            for(int j = colStart; j <= colEnd; j++) {\n                sum += mat[i][j];\n            }\n        }\n        return sum;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int[][] matrixBlockSum(int[][] mat, int k) {\\n        int[][] answer = new int[mat.length][mat[0].length];\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                int rowStart = i-k;\\n                int rowEnd = i+k;\\n                int colStart = j-k;\\n                int colEnd = j+k;\\n\\n                if(rowStart < 0) {\\n                    rowStart = 0;\\n                }\\n\\n                if(rowEnd >= mat.length) {\\n                    rowEnd = mat.length - 1;\\n                }\\n\\n                if(colStart < 0) {\\n                    colStart = 0;\\n                }\\n\\n                if(colEnd >= mat[0].length) {\\n                    colEnd = mat[0].length - 1;\\n                }\\n\\n                answer[i][j] = blockSum(mat, rowStart, rowEnd, colStart, colEnd);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n\\n    private int blockSum(int[][] mat, int rowStart, int rowEnd, int colStart, int colEnd) {\\n        int sum = 0;\\n\\n        for(int i = rowStart; i <= rowEnd; i++) {\\n            for(int j = colStart; j <= colEnd; j++) {\\n                sum += mat[i][j];\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "daily-temperatures",
        "tags": "java",
        "release_time": 1667472111,
        "code": "class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n        int[] arr = new int[temperatures.length]; \n        \n        ArrayDeque<int[]> st = new ArrayDeque<>(); \n        \n        int i=0, j=temperatures.length-1 ; \n        \n        while( j >= 0){\n            \n            if(st.size()==0){\n                arr[i++] = 0;\n            }\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\n            {\n                arr[i++]=1;\n            } \n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\n            \n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\n                    st.pop();\n                    \n                }\n            if(st.size()==0){\n                arr[i++]=0;\n            }\n            else{\n                arr[i++]=st.peek()[1]-j;\n            }\n            } \n        st.push(new int[]{temperatures[j],j}); \n        j--;\n        }\n        \n      \n        int[] ans = new int[temperatures.length]; int k=0;\n        for(i=arr.length-1; i>=0; i--){\n            ans[k++]=arr[i];\n        }\n        return ans;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] dailyTemperatures(int[] temperatures) {\\n        \\n        int[] arr = new int[temperatures.length]; \\n        \\n        ArrayDeque<int[]> st = new ArrayDeque<>(); \\n        \\n        int i=0, j=temperatures.length-1 ; \\n        \\n        while( j >= 0){\\n            \\n            if(st.size()==0){\\n                arr[i++] = 0;\\n            }\\n            else  if (st.size()>0 && st.peek()[0]>temperatures[j])\\n            {\\n                arr[i++]=1;\\n            } \\n            else if (st.size()>0 && st.peek()[0]<=temperatures[j])\\n            \\n            {  while(st.size()>0 && st.peek()[0]<=temperatures[j]){\\n                    st.pop();\\n                    \\n                }\\n            if(st.size()==0){\\n                arr[i++]=0;\\n            }\\n            else{\\n                arr[i++]=st.peek()[1]-j;\\n            }\\n            } \\n        st.push(new int[]{temperatures[j],j}); \\n        j--;\\n        }\\n        \\n      \\n        int[] ans = new int[temperatures.length]; int k=0;\\n        for(i=arr.length-1; i>=0; i--){\\n            ans[k++]=arr[i];\\n        }\\n        return ans;\\n    }\\n}"
    },
    {
        "slug": "queens-that-can-attack-the-king",
        "tags": "java",
        "release_time": 1604566770,
        "code": "class Solution {\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\n        boolean[][] q = new boolean[8][8];\n\t\t//Mark all the positions of queen on a 8 X 8 board.\n        for (int[] queen: queens) {\n            q[queen[0]][queen[1]] = true;\n        }\n        List<List<Integer>> output = new ArrayList<>();\n\t\t//Specify all the moves of the queen\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\n        for(int i = 0; i < moves.length; i++){\n            int k = king[0] + moves[i][0];\n            int l = king[1] + moves[i][1];\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\n                if(q[k][l]){\n                    List<Integer> pair = new ArrayList<>();\n                    pair.add(k);\n                    pair.add(l);\n                    output.add(pair);\n                    break;\n                }\n                k = k + moves[i][0];\n                l = l + moves[i][1];\n            }\n        }\n        \n        return output;\n    }\n}",
        "content": "The basic idea here is to move to all the 8 possible directions from king and see if any of the spot is occupied by a queen. If occupied then add that position to output and don\\'t move in that direction since all other queens in that direction will be blocked by this queen.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> queensAttacktheKing(int[][] queens, int[] king) {\\n        boolean[][] q = new boolean[8][8];\\n\\t\\t//Mark all the positions of queen on a 8 X 8 board.\\n        for (int[] queen: queens) {\\n            q[queen[0]][queen[1]] = true;\\n        }\\n        List<List<Integer>> output = new ArrayList<>();\\n\\t\\t//Specify all the moves of the queen\\n        int[][] moves = {{-1,-1}, {0,-1}, {1,-1},{1,0}, {1,1}, {0,1}, {-1,1}, {-1,0}};\\n        for(int i = 0; i < moves.length; i++){\\n            int k = king[0] + moves[i][0];\\n            int l = king[1] + moves[i][1];\\n            while(k >= 0 && l >=0 && k < 8 && l < 8){\\n                if(q[k][l]){\\n                    List<Integer> pair = new ArrayList<>();\\n                    pair.add(k);\\n                    pair.add(l);\\n                    output.add(pair);\\n                    break;\\n                }\\n                k = k + moves[i][0];\\n                l = l + moves[i][1];\\n            }\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "largest-triangle-area",
        "tags": "java",
        "release_time": 1676911137,
        "code": "class Solution {\n    public double largestTriangleArea(int[][] points) {\n        double ans = 0;\n        int n = points.length;\n\n        for(int i =0; i<n; i++)\n            for(int j =i+1; j<n; j++)\n                for(int k =j+1; k<n; k++)\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\n        return ans;\n    }\n    public static double area(int[] x1, int[] x2, int[] x3)\n    {\n        int t1 = x1[0] * ( x2[1] - x3[1]);\n        int t2 = x2[0] * ( x3[1] - x1[1]);\n        int t3 = x3[0] * ( x1[1] - x2[1]);\n        return (double)( t1 + t2 + t3 )/2;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Calculate area of each data points and return the data points having maximum area.\\n- To Calculate the area of a triangle having vertices as *(x1,y1), (x2,y2) and (x3,y3)* we use the formula:\\n$$S=[x1(y2\\u2212y3)+x2(y3\\u2212y1)+x3(y1\\u2212y2)]/2$$\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double largestTriangleArea(int[][] points) {\\n        double ans = 0;\\n        int n = points.length;\\n\\n        for(int i =0; i<n; i++)\\n            for(int j =i+1; j<n; j++)\\n                for(int k =j+1; k<n; k++)\\n                    ans = Math.max(ans , Math.abs(area(points[i], points[j], points[k])));\\n        return ans;\\n    }\\n    public static double area(int[] x1, int[] x2, int[] x3)\\n    {\\n        int t1 = x1[0] * ( x2[1] - x3[1]);\\n        int t2 = x2[0] * ( x3[1] - x1[1]);\\n        int t3 = x3[0] * ( x1[1] - x2[1]);\\n        return (double)( t1 + t2 + t3 )/2;\\n    }\\n}\\n```"
    },
    {
        "slug": "increasing-decreasing-string",
        "tags": "java",
        "release_time": 1676313293,
        "code": "class Solution {\n    public String sortString(String s) {\n        int[] arr = new int[27];\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\n//Find the number of occurrences of each letter in the text S and \n//place it in an array\n        for(int i=0;i<s.length();i++){\n            int num = str.indexOf((s.charAt(i)));\n            arr[++num]=arr[num]+1;\n        }\n\n        int len = s.length();\n        int count=0;\n        StringBuilder ans = new StringBuilder();\n        \n        while(count<len){\n            for(int i=1;i<27;i++){\n                if(arr[i]>0){\n                    ans.append(str.charAt(i - 1));\n                    arr[i]=arr[i]-1;\n                    count++;\n                }\n            }\n            for(int j=26;j>=1;j--){\n                if(arr[j]>0){\n                    ans.append(str.charAt(j - 1));\n                    arr[j]=arr[j]-1;\n                    count++;\n                }\n            }\n        }\n        return new String(ans);\n    }\n}",
        "content": "# Intuition\\n[Java] Finding solutions in an easy, understandable and fast way\\n\\n# Approach\\nThe goal is to find a solution to the example using only while and for operators\\n\\n# Complexity\\n- Time complexity:\\nRuntime: 5 ms       Beats :47.73%\\nMemory:  42.1 MB    Beats :91.92%\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String sortString(String s) {\\n        int[] arr = new int[27];\\n        String str = \"abcdefghijklmnopqrstuvwxyz\";\\n//Find the number of occurrences of each letter in the text S and \\n//place it in an array\\n        for(int i=0;i<s.length();i++){\\n            int num = str.indexOf((s.charAt(i)));\\n            arr[++num]=arr[num]+1;\\n        }\\n\\n        int len = s.length();\\n        int count=0;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        while(count<len){\\n            for(int i=1;i<27;i++){\\n                if(arr[i]>0){\\n                    ans.append(str.charAt(i - 1));\\n                    arr[i]=arr[i]-1;\\n                    count++;\\n                }\\n            }\\n            for(int j=26;j>=1;j--){\\n                if(arr[j]>0){\\n                    ans.append(str.charAt(j - 1));\\n                    arr[j]=arr[j]-1;\\n                    count++;\\n                }\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}\\n```"
    },
    {
        "slug": "print-in-order",
        "tags": "java",
        "release_time": 1662361771,
        "code": "class Foo {\n    private volatile int num = 1;\n    public Foo() {\n\n    }\n\n    public void first(Runnable printFirst) throws InterruptedException {\n        while(num != 1){\n        }\n\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\n        printFirst.run();\n        num++;\n    }\n\n    public void second(Runnable printSecond) throws InterruptedException {\n        while(num != 2){\n        }\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\n        printSecond.run();\n        num++;\n    }\n\n    public void third(Runnable printThird) throws InterruptedException {\n        while(num != 3){\n        }\n        // printThird.run() outputs \"third\". Do not change or remove this line.\n        printThird.run();\n        num++;\n    }\n}",
        "content": "```\\nclass Foo {\\n    private volatile int num = 1;\\n    public Foo() {\\n\\n    }\\n\\n    public void first(Runnable printFirst) throws InterruptedException {\\n        while(num != 1){\\n        }\\n\\n        // printFirst.run() outputs \"first\". Do not change or remove this line.\\n        printFirst.run();\\n        num++;\\n    }\\n\\n    public void second(Runnable printSecond) throws InterruptedException {\\n        while(num != 2){\\n        }\\n        // printSecond.run() outputs \"second\". Do not change or remove this line.\\n        printSecond.run();\\n        num++;\\n    }\\n\\n    public void third(Runnable printThird) throws InterruptedException {\\n        while(num != 3){\\n        }\\n        // printThird.run() outputs \"third\". Do not change or remove this line.\\n        printThird.run();\\n        num++;\\n    }\\n}\\n```"
    },
    {
        "slug": "earliest-possible-day-of-full-bloom",
        "tags": "java",
        "release_time": 1677868965,
        "code": "class Solution {\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\n       int max = 0;\n       for (int i : growTime){\n           if(max < i){\n               max = i;\n           }\n       }\n\n       int len = max;\n       int[] arr = new int[len + 1];\n       int tmp = 0;\n       int minTime = 0;\n       \n       for (int i = 0; i < plantTime.length; i++) {\n           arr[growTime[i]] += plantTime[i];\n       }\n\n       for (int i = len; i > 0; i--) {\n            if (arr[i] != 0) {\n                tmp = tmp + arr[i];\n                minTime = Math.max(minTime, tmp + i);\n            }\n       }\n\n       return minTime;\n    }\n}",
        "content": "![image.png](https://assets.leetcode.com/users/images/98855a88-cdb5-4c6f-ba41-3ba577588b51_1678010575.6496518.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int earliestFullBloom(int[] plantTime, int[] growTime) {\\n       int max = 0;\\n       for (int i : growTime){\\n           if(max < i){\\n               max = i;\\n           }\\n       }\\n\\n       int len = max;\\n       int[] arr = new int[len + 1];\\n       int tmp = 0;\\n       int minTime = 0;\\n       \\n       for (int i = 0; i < plantTime.length; i++) {\\n           arr[growTime[i]] += plantTime[i];\\n       }\\n\\n       for (int i = len; i > 0; i--) {\\n            if (arr[i] != 0) {\\n                tmp = tmp + arr[i];\\n                minTime = Math.max(minTime, tmp + i);\\n            }\\n       }\\n\\n       return minTime;\\n    }\\n}\\n\\n\\n```"
    },
    {
        "slug": "sum-of-left-leaves",
        "tags": "java",
        "release_time": 1689484464,
        "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    static int result;\n\n    public int sumOfLeftLeaves(TreeNode root) {\n        result=0;\n\n        task(root.left, true);\n\n        task(root.right, false);\n\n        return result;\n    }\n\n    static void task(TreeNode root, boolean flag){\n        if(root == null) return;\n\n        if(flag && root.left==null && root.right==null) result+=root.val;\n\n        task(root.left, true);\n        task(root.right, false);\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    static int result;\\n\\n    public int sumOfLeftLeaves(TreeNode root) {\\n        result=0;\\n\\n        task(root.left, true);\\n\\n        task(root.right, false);\\n\\n        return result;\\n    }\\n\\n    static void task(TreeNode root, boolean flag){\\n        if(root == null) return;\\n\\n        if(flag && root.left==null && root.right==null) result+=root.val;\\n\\n        task(root.left, true);\\n        task(root.right, false);\\n    }\\n}\\n```"
    },
    {
        "slug": "longest-word-in-dictionary",
        "tags": "java",
        "release_time": 1671996425,
        "code": "class Solution {\n    public String longestWord(String[] words) {\n        Set<String> set = new HashSet<>();\n\n        for(int i = 0; i < words.length; i++){\n            set.add(words[i]);\n        }\n\n        Queue<String> q = new LinkedList<>();\n\n        q.add(\"\");\n        String prev = \"\";\n\n        while(!q.isEmpty()){\n            String s = q.poll();\n            prev = s;\n            for(int i = 25; i >=0 ; i--){\n                String key = s + String.valueOf((char) ('a' + i));\n                if(set.contains(key)){\n                    q.add(key);;\n                }\n            }\n        }\n        return prev;\n    }\n}",
        "content": "\\n# Approach\\n- Find words in dictionary, adding 1 character at a time. Add such words to queue and iterate. If the queue gets empty we can\\'t move forward anymore by 1 character, then return answer. Adding characters z->a, to get lexicographically smaller word.\\n\\n# Complexity\\n- Time complexity:\\nO(n) :  For each word in the array, we iterate 26 times to find words in dictionary adding 1 character. Therefor it will be run in O(26n) ~ O(n). \\n\\n- Space complexity:\\nO(n) for HashSet.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestWord(String[] words) {\\n        Set<String> set = new HashSet<>();\\n\\n        for(int i = 0; i < words.length; i++){\\n            set.add(words[i]);\\n        }\\n\\n        Queue<String> q = new LinkedList<>();\\n\\n        q.add(\"\");\\n        String prev = \"\";\\n\\n        while(!q.isEmpty()){\\n            String s = q.poll();\\n            prev = s;\\n            for(int i = 25; i >=0 ; i--){\\n                String key = s + String.valueOf((char) (\\'a\\' + i));\\n                if(set.contains(key)){\\n                    q.add(key);;\\n                }\\n            }\\n        }\\n        return prev;\\n    }\\n}\\n```"
    },
    {
        "slug": "rectangle-overlap",
        "tags": "java",
        "release_time": 1679422504,
        "code": "class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        int left = Math.max(rec1[0],rec2[0]);\n        int right = Math.min(rec1[2], rec2[2]);\n        int top = Math.min(rec1[3],rec2[3]);\n        int bottom = Math.max(rec1[1], rec2[1]);\n        if(left < right && bottom < top)\n        return true;\n        return false;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\\n        int left = Math.max(rec1[0],rec2[0]);\\n        int right = Math.min(rec1[2], rec2[2]);\\n        int top = Math.min(rec1[3],rec2[3]);\\n        int bottom = Math.max(rec1[1], rec2[1]);\\n        if(left < right && bottom < top)\\n        return true;\\n        return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "di-string-match",
        "tags": "java",
        "release_time": 1665853972,
        "code": "class Solution {\n    public int[] diStringMatch(String s) {\n        int low = 0;\n        int size = s.length();\n        int high = size;\n        int[] output = new int[size+1];\n        char[] arr = s.toCharArray();\n        for(int i=0;i<size;i++){\n            if(arr[i] == 'I'){\n                output[i] = low;\n                low++;\n            }\n            else{\n                output[i] = high;\n                high--;\n            }\n        }\n        output[size] = high;\n        return output;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public int[] diStringMatch(String s) {\\n        int low = 0;\\n        int size = s.length();\\n        int high = size;\\n        int[] output = new int[size+1];\\n        char[] arr = s.toCharArray();\\n        for(int i=0;i<size;i++){\\n            if(arr[i] == \\'I\\'){\\n                output[i] = low;\\n                low++;\\n            }\\n            else{\\n                output[i] = high;\\n                high--;\\n            }\\n        }\\n        output[size] = high;\\n        return output;\\n    }\\n}\\n```"
    },
    {
        "slug": "can-make-arithmetic-progression-from-sequence",
        "tags": "java",
        "release_time": 1686057547,
        "code": "class Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        Arrays.sort(arr);\n        int diff=arr[1]-arr[0];\n        boolean temp=true;\n        for(int i=1;i<arr.length-1;i++){\n            if(arr[i+1]-arr[i]==diff){\n                continue;\n            }else{\n                temp=false;\n            }\n        }\n        if(temp==true){\n            return true;\n        }else{\n            return false;\n        }\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code is an implementation of a method named canMakeArithmeticProgression, which determines whether the given array arr can be rearranged to form an arithmetic progression.\\n\\nHere\\'s how the code works:\\n\\nThe arr array is sorted using the Arrays.sort() method. Sorting the array is important because in an arithmetic progression, the elements are arranged in a specific order.\\n\\nThe variable diff is initialized as the difference between the second element (arr[1]) and the first element (arr[0]). This will be the common difference for the arithmetic progression.\\n\\nThe variable temp is set to true. It will be used to keep track of whether all the adjacent element differences match the common difference.\\n\\nA loop iterates from the second element (i=1) to the second-to-last element (i<arr.length-1). This loop compares the difference between the current element (arr[i+1]) and the previous element (arr[i]) with the common difference (diff).\\n\\nIf the difference between the current and previous elements matches the common difference, the loop continues to the next iteration using the continue statement.\\n\\nIf the difference does not match the common difference, temp is set to false, indicating that the array cannot form an arithmetic progression.\\n\\nFinally, after the loop, the value of temp is checked. If it is still true, the method returns true indicating that the array can form an arithmetic progression. Otherwise, it returns false.\\n\\nIn summary, the code checks if the given array can be sorted into an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, it returns true; otherwise, it returns false.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the given code can be summarized as follows:\\n\\nSort the array in ascending order using the Arrays.sort() method. Sorting the array helps in identifying the order of the elements in an arithmetic progression.\\n\\nCalculate the common difference (diff) between the second element (arr[1]) and the first element (arr[0]).\\n\\nIterate through the array starting from the second element (i=1) up to the second-to-last element (i<arr.length-1).\\n\\nFor each iteration, check if the difference between the current element (arr[i+1]) and the previous element (arr[i]) is equal to the common difference (diff).\\n\\nIf the difference matches, continue to the next iteration.\\n\\nIf the difference does not match, set the temp variable to false, indicating that the array cannot form an arithmetic progression.\\n\\nAfter the loop, check the value of the temp variable. If it is still true, return true to indicate that the array can form an arithmetic progression. Otherwise, return false.\\n\\nIn summary, the code checks if the given array can be rearranged to form an arithmetic progression by comparing the differences between adjacent elements. If all the differences match the common difference, the code returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean canMakeArithmeticProgression(int[] arr) {\\n        Arrays.sort(arr);\\n        int diff=arr[1]-arr[0];\\n        boolean temp=true;\\n        for(int i=1;i<arr.length-1;i++){\\n            if(arr[i+1]-arr[i]==diff){\\n                continue;\\n            }else{\\n                temp=false;\\n            }\\n        }\\n        if(temp==true){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n```"
    },
    {
        "slug": "rearrange-characters-to-make-target-string",
        "tags": "java",
        "release_time": 1673614634,
        "code": "class Solution {\n    public int rearrangeCharacters(String s, String target) {\n        int[] cnt1 = new int[26];\n        int[] cnt2 = new int[26];\n        for (int i = 0; i < s.length(); ++i) {\n            ++cnt1[s.charAt(i) - 'a'];\n        }\n        for (int i = 0; i < target.length(); ++i) {\n            ++cnt2[target.charAt(i) - 'a'];\n        }\n        int ans = 100;\n        for (int i = 0; i < 26; ++i) {\n            if (cnt2[i] > 0) {\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\n            }\n        }\n        return ans;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public int rearrangeCharacters(String s, String target) {\\n        int[] cnt1 = new int[26];\\n        int[] cnt2 = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt1[s.charAt(i) - \\'a\\'];\\n        }\\n        for (int i = 0; i < target.length(); ++i) {\\n            ++cnt2[target.charAt(i) - \\'a\\'];\\n        }\\n        int ans = 100;\\n        for (int i = 0; i < 26; ++i) {\\n            if (cnt2[i] > 0) {\\n                ans = Math.min(ans, cnt1[i] / cnt2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "continuous-subarray-sum",
        "tags": "java",
        "release_time": 1683570789,
        "code": "class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        HashMap<Integer,Integer> hm  = new HashMap<>();\n        hm.put(0,0);\n        \n        int sum = 0;\n        // hm.put(0,-1);\n        for( int  i = 0;i < nums.length; i++){\n            int num = nums[i];\n            sum+=num;\n      \n            if(hm.containsKey(sum%k)){\n                if(hm.get(sum%k)  < i )\n                    return true;\n            }else\n                hm.put(sum%k, i+1);\n            \n        }\n        return false;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public boolean checkSubarraySum(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm  = new HashMap<>();\\n        hm.put(0,0);\\n        \\n        int sum = 0;\\n        // hm.put(0,-1);\\n        for( int  i = 0;i < nums.length; i++){\\n            int num = nums[i];\\n            sum+=num;\\n      \\n            if(hm.containsKey(sum%k)){\\n                if(hm.get(sum%k)  < i )\\n                    return true;\\n            }else\\n                hm.put(sum%k, i+1);\\n            \\n        }\\n        return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "design-an-ordered-stream",
        "tags": "java",
        "release_time": 1605412886,
        "code": "class OrderedStream {\n    int ptr;\n    String[] res;\n    \n    public OrderedStream(int n) {\n        ptr = 0;\n        res = new String[n];\n    }\n    \n    public List<String> insert(int id, String value) {\n        List<String> list = new ArrayList<>();\n        \n        res[id - 1] = value;\n        while (ptr < res.length && res[ptr] != null) {\n            list.add(res[ptr]);\n            ptr++;\n        }\n        \n        return list;\n    }\n}",
        "content": "Well, the problem statement is not very clear even there is a GIF, although I work it out. The problem statement makes it feel as a medium problem, I guess. \\n\\nBasically, the idea is that you need to return a longest list that start at index of ptr. if ptr is not pointing an element, you need to return a empty list.\\n```\\nclass OrderedStream {\\n    int ptr;\\n    String[] res;\\n    \\n    public OrderedStream(int n) {\\n        ptr = 0;\\n        res = new String[n];\\n    }\\n    \\n    public List<String> insert(int id, String value) {\\n        List<String> list = new ArrayList<>();\\n        \\n        res[id - 1] = value;\\n        while (ptr < res.length && res[ptr] != null) {\\n            list.add(res[ptr]);\\n            ptr++;\\n        }\\n        \\n        return list;\\n    }\\n}\\n```"
    },
    {
        "slug": "minimum-time-to-visit-a-cell-in-a-grid",
        "tags": "java",
        "release_time": 1677384057,
        "code": "class Solution {\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\n    public int minimumTime(int[][] grid) {\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\n            return -1;\n        }\n        \n        int m = grid.length;\n        int n = grid[0].length;\n        \n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\n        \n        boolean[][] visited = new boolean[m][n];\n        \n        while (!heap.isEmpty()) {\n            int[] entry = heap.poll();\n            int row = entry[0];\n            int col = entry[1];\n            int time = entry[2];\n            if (row == m - 1 && col == n - 1) {\n                return time;\n            }\n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n                \n            for (int[] dir : DIRS) {\n                int r = row + dir[0];\n                int c = col + dir[1];\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\n                    continue;\n                }\n                \n                if (grid[r][c] <= time + 1) {\n                    // if it is possible to move to neighbor, do it\n                    heap.offer(new int[] { r, c, time + 1 });\n                } else {\n                    // If we cant move to neighbor yet, we can hop to the previous cell\n                    // and back to current cell as many times as we need to until\n                    // sufficient time has passed.\n                    // The trick here is that if the difference between the current time\n                    // and the time we need is even, we will arrive back at the current cell\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\n                    // the minimum neighbor time.\n                    int diff = grid[r][c] - time;\n                    if (diff % 2 == 1) {\n                        heap.offer(new int[] { r, c, grid[r][c] });\n                    } else {\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\n                    }\n                }\n            }\n        }\n        return -1; // will never reach here\n    }\n}",
        "content": "```\\nclass Solution {\\n    private static final int[][] DIRS = new int[][] { { 1, 0 }, { -1, 0}, { 0, 1 }, { 0, -1 } };\\n    public int minimumTime(int[][] grid) {\\n        if (grid[0][1] > 1 && grid[1][0] > 1) {\\n            return -1;\\n        }\\n        \\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[2] - b[2]);\\n        heap.offer(new int[] { 0, 0, 0 }); // row, col, time\\n        \\n        boolean[][] visited = new boolean[m][n];\\n        \\n        while (!heap.isEmpty()) {\\n            int[] entry = heap.poll();\\n            int row = entry[0];\\n            int col = entry[1];\\n            int time = entry[2];\\n            if (row == m - 1 && col == n - 1) {\\n                return time;\\n            }\\n            if (visited[row][col]) {\\n                continue;\\n            }\\n            visited[row][col] = true;\\n                \\n            for (int[] dir : DIRS) {\\n                int r = row + dir[0];\\n                int c = col + dir[1];\\n                if (r < 0 || r == m || c < 0 || c == n || visited[r][c]) {\\n                    continue;\\n                }\\n                \\n                if (grid[r][c] <= time + 1) {\\n                    // if it is possible to move to neighbor, do it\\n                    heap.offer(new int[] { r, c, time + 1 });\\n                } else {\\n                    // If we cant move to neighbor yet, we can hop to the previous cell\\n                    // and back to current cell as many times as we need to until\\n                    // sufficient time has passed.\\n                    // The trick here is that if the difference between the current time\\n                    // and the time we need is even, we will arrive back at the current cell\\n                    // 1 second \"late\" and so we will move to the neighbor 1 second after\\n                    // the minimum neighbor time.\\n                    int diff = grid[r][c] - time;\\n                    if (diff % 2 == 1) {\\n                        heap.offer(new int[] { r, c, grid[r][c] });\\n                    } else {\\n                        heap.offer(new int[] { r, c, grid[r][c] + 1 });\\n                    }\\n                }\\n            }\\n        }\\n        return -1; // will never reach here\\n    }\\n}\\n```"
    },
    {
        "slug": "erect-the-fence",
        "tags": "java",
        "release_time": 1668873110,
        "code": "class Solution {\n    \n    public int[][] outerTrees(int[][] trees) {\n        if(trees.length == 3){\n            return trees;\n        }\n        Stack<int[]> upper = new Stack<>();\n        Stack<int[]> lower = new Stack<>();\n        \n        Arrays.sort(trees,(p,q) ->\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\n        \n        for(int i = 0 ; i < trees.length ; i++){\n            int size = trees.length;\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\n                upper.pop();  \n                }\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\n                 lower.pop();  \n              }\n            upper.push(trees[i]);\n            lower.push(trees[i]);\n        }\n        \n        \n        Set<int[]> res= new HashSet<>(lower);\n        res.addAll(upper);\n        return res.toArray(new int[res.size()][]);\n    }\n    \n    public int angle(int[] A , int[] B , int[] C){\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    public int[][] outerTrees(int[][] trees) {\\n        if(trees.length == 3){\\n            return trees;\\n        }\\n        Stack<int[]> upper = new Stack<>();\\n        Stack<int[]> lower = new Stack<>();\\n        \\n        Arrays.sort(trees,(p,q) ->\\n                  q[0]-p[0]==0?q[1]-p[1]:q[0]-p[0]);\\n        \\n        for(int i = 0 ; i < trees.length ; i++){\\n            int size = trees.length;\\n            while(upper.size() >= 2 && angle(upper.get(upper.size() - 2),upper.get(upper.size() - 1),trees[i]) > 0){\\n                upper.pop();  \\n                }\\n            while(lower.size() >= 2 && angle(lower.get(lower.size() - 2),lower.get(lower.size() - 1),trees[i]) < 0){\\n                 lower.pop();  \\n              }\\n            upper.push(trees[i]);\\n            lower.push(trees[i]);\\n        }\\n        \\n        \\n        Set<int[]> res= new HashSet<>(lower);\\n        res.addAll(upper);\\n        return res.toArray(new int[res.size()][]);\\n    }\\n    \\n    public int angle(int[] A , int[] B , int[] C){\\n        return (C[0] - A[0]) * (B[1] - A[1]) - (B[0] - A[0]) * (C[1] - A[1]);\\n    }\\n}\\n```\\n\\n**Upvote Please**"
    },
    {
        "slug": "rotating-the-box",
        "tags": "java",
        "release_time": 1628288363,
        "code": "class Solution {\n     public char[][] rotateTheBox(char[][] box) {\n         int row = box.length, col = box[0].length;\n         char[][] res = new char[col][row];\n         // rotate first, then drop\n         for (int i = 0; i < row; i++) {\n             for (int j = 0; j < col; j++) {\n                 res[j][i] = box[row-1-i][j];\n             }\n         }\n        \n\t\tfor (int i = col - 1; i >= 0; i--) {\n             for (int j = 0; j < row; j++) {\n                 if (res[i][j] == '#') {\n                     int curRow = i;\n                     while (curRow+1 < col && res[curRow+1][j] == '.') {\n                         curRow++;\n                     }\n                     if (curRow != i) {\n                         res[curRow][j] = '#';\n                         res[i][j] = '.';\n                     }\n                 }\n             }\n         }\n         return res;\n     }\n }",
        "content": "**Option 1:**\\nFirst we rotate the original matrix, then drop the stones.\\n![image](https://assets.leetcode.com/users/images/0e1bad47-9fd3-43b6-9f52-bc900ae9d2b2_1628288206.3706853.png)\\n\\n```\\n class Solution {\\n     public char[][] rotateTheBox(char[][] box) {\\n         int row = box.length, col = box[0].length;\\n         char[][] res = new char[col][row];\\n         // rotate first, then drop\\n         for (int i = 0; i < row; i++) {\\n             for (int j = 0; j < col; j++) {\\n                 res[j][i] = box[row-1-i][j];\\n             }\\n         }\\n        \\n\\t\\tfor (int i = col - 1; i >= 0; i--) {\\n             for (int j = 0; j < row; j++) {\\n                 if (res[i][j] == \\'#\\') {\\n                     int curRow = i;\\n                     while (curRow+1 < col && res[curRow+1][j] == \\'.\\') {\\n                         curRow++;\\n                     }\\n                     if (curRow != i) {\\n                         res[curRow][j] = \\'#\\';\\n                         res[i][j] = \\'.\\';\\n                     }\\n                 }\\n             }\\n         }\\n         return res;\\n     }\\n }\\n```\\n\\n\\n<br>\\n\\n**Option 2:**\\nFirst we move the stones to its furthest right (if there are empty spaces on the right), then rotate the altered matrix.\\n![image](https://assets.leetcode.com/users/images/5095bfc4-33f4-48b0-9135-93c8f1781d7f_1628288262.448106.png)\\n\\n```\\nclass Solution {\\n    public char[][] rotateTheBox(char[][] box) {\\n        int row = box.length, col = box[0].length;\\n        char[][] res = new char[col][row];\\n        // move right then rotate\\n        for (int i = 0; i < row; i++) {\\n            for (int j = col-1; j >= 0; j--) {\\n                if (box[i][j] == \\'#\\') {\\n                    int curCol = j;\\n                    while (curCol+1 < col && box[i][curCol+1] == \\'.\\') {\\n                        curCol++;\\n                    }\\n                    if (curCol != j) {\\n                        box[i][curCol] = \\'#\\';\\n                        box[i][j] = \\'.\\';\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                res[j][i] = box[row-1-i][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "most-frequent-subtree-sum",
        "tags": "java",
        "release_time": 1663541881,
        "code": "class Solution{\n    public int[] findFrequentTreeSum(TreeNode root) {\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        helper(root, map);\n        List<Integer> list = new ArrayList();\n        \n        int max = (Collections.max(map.values()));\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\n            if(entry.getValue() == max){\n                list.add(entry.getKey());\n            }\n        }\n        \n        int[] arr = new int[list.size()];\n        for(int i=0; i<list.size(); i++){\n            arr[i] = list.get(i);\n        }\n        \n        return arr;\n    }\n    public int helper(TreeNode root, Map<Integer, Integer> map){\n        if(root==null) return 0;\n        int left = helper(root.left, map);\n        int right = helper(root.right, map);\n        \n        int sum = root.val+left+right;\n        if(map.containsKey(sum)){\n            map.put(sum, map.get(sum)+1);\n        }else{\n            map.put(sum, 1);\n        }\n        \n        return sum;\n    }\n}",
        "content": "```\\nclass Solution{\\n    public int[] findFrequentTreeSum(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        helper(root, map);\\n        List<Integer> list = new ArrayList();\\n        \\n        int max = (Collections.max(map.values()));\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            if(entry.getValue() == max){\\n                list.add(entry.getKey());\\n            }\\n        }\\n        \\n        int[] arr = new int[list.size()];\\n        for(int i=0; i<list.size(); i++){\\n            arr[i] = list.get(i);\\n        }\\n        \\n        return arr;\\n    }\\n    public int helper(TreeNode root, Map<Integer, Integer> map){\\n        if(root==null) return 0;\\n        int left = helper(root.left, map);\\n        int right = helper(root.right, map);\\n        \\n        int sum = root.val+left+right;\\n        if(map.containsKey(sum)){\\n            map.put(sum, map.get(sum)+1);\\n        }else{\\n            map.put(sum, 1);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "number-of-arithmetic-triplets",
        "tags": "java",
        "release_time": 1671050315,
        "code": "class Solution {\n    public int arithmeticTriplets(int[] nums, int diff) {\n        \n        int count=0;\n        for(int i=0;i<nums.length;i++){\n            for(int j=i+1;j<nums.length;j++){\n                for(int k=j+1;k<nums.length;k++){\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\n                        count++;\n                    }\n                }\n            }\n        }\n        \n        return count;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int arithmeticTriplets(int[] nums, int diff) {\\n        \\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[j]-nums[i]==diff && nums[k] - nums[j] == diff){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "binary-search-tree-to-greater-sum-tree",
        "tags": "java",
        "release_time": 1679216759,
        "code": "class Solution {\n    private int ans = 0;\n    public TreeNode bstToGst(TreeNode root) {\n        if (root != null) {\n            bstToGst(root.right);\n            ans += root.val;\n            root.val = ans;\n            bstToGst(root.left);\n        }\n        return root;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    private int ans = 0;\\n    public TreeNode bstToGst(TreeNode root) {\\n        if (root != null) {\\n            bstToGst(root.right);\\n            ans += root.val;\\n            root.val = ans;\\n            bstToGst(root.left);\\n        }\\n        return root;\\n    }\\n}\\n```"
    },
    {
        "slug": "design-graph-with-shortest-path-calculator",
        "tags": "java",
        "release_time": 1681574555,
        "code": "class Graph {\n    List<List<int[]>> adj=new ArrayList<>();\n    int n;\n    public Graph(int n, int[][] edges) {\n        for(int i=0;i<n;i++){\n            adj.add(new ArrayList<>());\n        }\n        this.n=n;\n        for(int edge[]: edges){\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n        }\n    }\n    \n    public void addEdge(int[] edge) {\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\n    }\n    \n    public int shortestPath(int node1, int node2) {\n        int dist[]=new int[n+1];\n        Arrays.fill(dist,Integer.MAX_VALUE);\n        dist[node1]=0;\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\n        pq.add(new int[]{node1,0});\n        while(!pq.isEmpty()){\n            int u=pq.poll()[0];\n            for(int p[]: adj.get(u)){\n                int v=p[0];\n                int w=p[1];\n                if(dist[v]>dist[u]+w){\n                    dist[v]=dist[u]+w;\n                    pq.add(new int[]{v,dist[v]});\n                }\n            }\n        }\n        if(dist[node2]==Integer.MAX_VALUE){\n                return -1;\n        }\n        return dist[node2];\n    }\n    \n}\n\n/**\n * Your Graph object will be instantiated and called as such:\n * Graph obj = new Graph(n, edges);\n * obj.addEdge(edge);\n * int param_2 = obj.shortestPath(node1,node2);\n */",
        "content": "\\n\\n# Code\\n```\\nclass Graph {\\n    List<List<int[]>> adj=new ArrayList<>();\\n    int n;\\n    public Graph(int n, int[][] edges) {\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        this.n=n;\\n        for(int edge[]: edges){\\n            adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n        }\\n    }\\n    \\n    public void addEdge(int[] edge) {\\n        adj.get(edge[0]).add(new int[]{edge[1],edge[2]});\\n    }\\n    \\n    public int shortestPath(int node1, int node2) {\\n        int dist[]=new int[n+1];\\n        Arrays.fill(dist,Integer.MAX_VALUE);\\n        dist[node1]=0;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((a,b)->a[1]-b[1]);\\n        pq.add(new int[]{node1,0});\\n        while(!pq.isEmpty()){\\n            int u=pq.poll()[0];\\n            for(int p[]: adj.get(u)){\\n                int v=p[0];\\n                int w=p[1];\\n                if(dist[v]>dist[u]+w){\\n                    dist[v]=dist[u]+w;\\n                    pq.add(new int[]{v,dist[v]});\\n                }\\n            }\\n        }\\n        if(dist[node2]==Integer.MAX_VALUE){\\n                return -1;\\n        }\\n        return dist[node2];\\n    }\\n    \\n}\\n\\n/**\\n * Your Graph object will be instantiated and called as such:\\n * Graph obj = new Graph(n, edges);\\n * obj.addEdge(edge);\\n * int param_2 = obj.shortestPath(node1,node2);\\n */"
    },
    {
        "slug": "clone-graph",
        "tags": "java",
        "release_time": 1680964761,
        "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public void dfs(Node node, HashMap<Node, Node> dict)\n    {\n        for (Node nd : node.neighbors) {\n            if (!dict.containsKey(nd))\n                dict.put(nd, new Node(nd.val));\n            dict.get(node).neighbors.add(dict.get(nd));\n        }\n        for (Node nd : node.neighbors)\n        {\n            if (dict.get(nd).neighbors.size() == 0)\n                dfs(nd, dict);\n        }\n    }\n    public Node cloneGraph(Node node) {\n        HashMap<Node, Node> dict = new HashMap<>();\n        if (node != null) {\n            dict.put(node, new Node(node.val));\n            dfs(node, dict);\n            return dict.get(node);\n        }\n        return null;\n    }\n}",
        "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public List<Node> neighbors;\\n    public Node() {\\n        val = 0;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val) {\\n        val = _val;\\n        neighbors = new ArrayList<Node>();\\n    }\\n    public Node(int _val, ArrayList<Node> _neighbors) {\\n        val = _val;\\n        neighbors = _neighbors;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public void dfs(Node node, HashMap<Node, Node> dict)\\n    {\\n        for (Node nd : node.neighbors) {\\n            if (!dict.containsKey(nd))\\n                dict.put(nd, new Node(nd.val));\\n            dict.get(node).neighbors.add(dict.get(nd));\\n        }\\n        for (Node nd : node.neighbors)\\n        {\\n            if (dict.get(nd).neighbors.size() == 0)\\n                dfs(nd, dict);\\n        }\\n    }\\n    public Node cloneGraph(Node node) {\\n        HashMap<Node, Node> dict = new HashMap<>();\\n        if (node != null) {\\n            dict.put(node, new Node(node.val));\\n            dfs(node, dict);\\n            return dict.get(node);\\n        }\\n        return null;\\n    }\\n}\\n```"
    },
    {
        "slug": "destroying-asteroids",
        "tags": "java",
        "release_time": 1680364813,
        "code": "class Solution {\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\n        Arrays.sort(asteroids);\n        int c=0;\n        long s=(long)mass;\n        for(int i=0;i<asteroids.length;i++)\n        {\n            long d=(long)asteroids[i];\n            if(s>=d)\n            {\n                c+=1;\n                s+=d;\n            }\n        }\n        if(c==asteroids.length)return true;\n        else return false;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean asteroidsDestroyed(int mass, int[] asteroids) {\\n        Arrays.sort(asteroids);\\n        int c=0;\\n        long s=(long)mass;\\n        for(int i=0;i<asteroids.length;i++)\\n        {\\n            long d=(long)asteroids[i];\\n            if(s>=d)\\n            {\\n                c+=1;\\n                s+=d;\\n            }\\n        }\\n        if(c==asteroids.length)return true;\\n        else return false;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-number-of-fish-in-a-grid",
        "tags": "java",
        "release_time": 1682784060,
        "code": "class Solution {\n    public int findMaxFish(int[][] grid) {\n        int sum=0;\n        for(int i=0;i<grid.length;i++)\n        {\n            for(int j=0;j<grid[0].length;j++)\n            {\n                if(grid[i][j]!=0)\n                {\n                    int a[]=new int[1];\n                    task(grid,i,j,a);\n                    sum=Math.max(sum,a[0]);\n                }\n            }\n        }\n        return sum;\n    }\n    public void task(int grid[][], int i, int j, int a[])\n    {\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\n        {\n            return;\n        }\n        a[0]+=grid[i][j];\n        grid[i][j]=0;\n        task(grid,i+1,j,a);\n        task(grid,i-1,j,a);\n        task(grid,i,j+1,a);\n        task(grid,i,j-1,a);\n    }\n}",
        "content": "# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(m*n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMaxFish(int[][] grid) {\\n        int sum=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                {\\n                    int a[]=new int[1];\\n                    task(grid,i,j,a);\\n                    sum=Math.max(sum,a[0]);\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n    public void task(int grid[][], int i, int j, int a[])\\n    {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]==0)\\n        {\\n            return;\\n        }\\n        a[0]+=grid[i][j];\\n        grid[i][j]=0;\\n        task(grid,i+1,j,a);\\n        task(grid,i-1,j,a);\\n        task(grid,i,j+1,a);\\n        task(grid,i,j-1,a);\\n    }\\n}\\n```"
    },
    {
        "slug": "word-ladder-ii",
        "tags": "java",
        "release_time": 1692205615,
        "code": "class Solution {\n    String b;\n\n    // Create a hashmap of type word->level to get the idea \n    // on which level the word comes after the transformations.\n\n    HashMap < String, Integer > mpp;\n\n    // A list for storing the final answer.\n    List < List < String >> ans;\n    private void dfs(String word, List < String > seq) {\n\n        // Function for implementing backtracking using the created map\n        // in reverse order to find the transformation sequence in less time.\n\n        // Base condition :\n        // If word equals beginWord, we\\u2019ve found one of the sequences\n        // simply reverse the sequence and return. \n        if (word.equals(b)) {\n\n            // Since java works with reference, create\n            // a duplicate and store the reverse of it\n            List < String > dup = new ArrayList < > (seq);\n            Collections.reverse(dup);\n            ans.add(dup);\n            return;\n        }\n        int steps = mpp.get(word);\n        int sz = word.length();\n\n        // Replace each character of the word with letters from a-z \n        // and check whether the transformed word is present in the map\n        // and at the previous level or not.\n        for (int i = 0; i < sz; i++) {\n\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                char replacedCharArray[] = word.toCharArray();\n                replacedCharArray[i] = ch;\n                String replacedWord = new String(replacedCharArray);\n                if (mpp.containsKey(replacedWord) &&\n                    mpp.get(replacedWord) + 1 == steps) {\n\n                    seq.add(replacedWord);\n                    dfs(replacedWord, seq);\n\n                    // pop the current word from the back of the queue\n                    // to traverse other possibilities.\n                    seq.remove(seq.size() - 1);\n                }\n            }\n        }\n    }\n    public List < List < String >> findLadders(String beginWord, String endWord,\n        List < String > wordList) {\n\n        // Push all values of wordList into a set\n        // to make deletion from it easier and in less time complexity.\n        Set < String > st = new HashSet < String > ();\n        int len = wordList.size();\n        for (int i = 0; i < len; i++) {\n            st.add(wordList.get(i));\n        }\n\n        // Perform BFS traversal and push the string in the queue\n        // as soon as they\\u2019re found in the wordList.\n        Queue < String > q = new LinkedList < > ();\n        b = beginWord;\n        q.add(beginWord);\n        mpp = new HashMap < > ();\n\n        // beginWord initialised with level 1.\n        mpp.put(beginWord, 1);\n        int sizee = beginWord.length();\n        st.remove(beginWord);\n        while (!q.isEmpty()) {\n            String word = q.peek();\n            int steps = mpp.get(word);\n            q.remove();\n\n            // Break out if the word matches the endWord.\n            if (word.equals(endWord)) break;\n\n            // Replace each character of the word with letters from a-z \n            // and check whether the transformed word is present in the \n            // wordList or not, if yes then push to queue\n            for (int i = 0; i < sizee; i++) {\n\n                for (char ch = 'a'; ch <= 'z'; ch++) {\n                    char replacedCharArray[] = word.toCharArray();\n                    replacedCharArray[i] = ch;\n                    String replacedWord = new String(replacedCharArray);\n                    if (st.contains(replacedWord) == true) {\n                        q.add(replacedWord);\n                        st.remove(replacedWord);\n\n                        // push the word along with its level\n                        // in the map data structure.\n                        mpp.put(replacedWord, steps + 1);\n                    }\n                }\n\n\n            }\n        }\n        ans = new ArrayList < > ();\n\n        // If we reach the endWord, we stop and move to step-2\n        // that is to perform reverse dfs traversal.\n        if (mpp.containsKey(endWord) == true) {\n            List < String > seq = new ArrayList < > ();\n            seq.add(endWord);\n            dfs(endWord, seq);\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/1ea15e79-7ca5-4594-83b4-88b42dc1e6e7_1692205611.608349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    String b;\\n\\n    // Create a hashmap of type word->level to get the idea \\n    // on which level the word comes after the transformations.\\n\\n    HashMap < String, Integer > mpp;\\n\\n    // A list for storing the final answer.\\n    List < List < String >> ans;\\n    private void dfs(String word, List < String > seq) {\\n\\n        // Function for implementing backtracking using the created map\\n        // in reverse order to find the transformation sequence in less time.\\n\\n        // Base condition :\\n        // If word equals beginWord, we\\u2019ve found one of the sequences\\n        // simply reverse the sequence and return. \\n        if (word.equals(b)) {\\n\\n            // Since java works with reference, create\\n            // a duplicate and store the reverse of it\\n            List < String > dup = new ArrayList < > (seq);\\n            Collections.reverse(dup);\\n            ans.add(dup);\\n            return;\\n        }\\n        int steps = mpp.get(word);\\n        int sz = word.length();\\n\\n        // Replace each character of the word with letters from a-z \\n        // and check whether the transformed word is present in the map\\n        // and at the previous level or not.\\n        for (int i = 0; i < sz; i++) {\\n\\n            for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                char replacedCharArray[] = word.toCharArray();\\n                replacedCharArray[i] = ch;\\n                String replacedWord = new String(replacedCharArray);\\n                if (mpp.containsKey(replacedWord) &&\\n                    mpp.get(replacedWord) + 1 == steps) {\\n\\n                    seq.add(replacedWord);\\n                    dfs(replacedWord, seq);\\n\\n                    // pop the current word from the back of the queue\\n                    // to traverse other possibilities.\\n                    seq.remove(seq.size() - 1);\\n                }\\n            }\\n        }\\n    }\\n    public List < List < String >> findLadders(String beginWord, String endWord,\\n        List < String > wordList) {\\n\\n        // Push all values of wordList into a set\\n        // to make deletion from it easier and in less time complexity.\\n        Set < String > st = new HashSet < String > ();\\n        int len = wordList.size();\\n        for (int i = 0; i < len; i++) {\\n            st.add(wordList.get(i));\\n        }\\n\\n        // Perform BFS traversal and push the string in the queue\\n        // as soon as they\\u2019re found in the wordList.\\n        Queue < String > q = new LinkedList < > ();\\n        b = beginWord;\\n        q.add(beginWord);\\n        mpp = new HashMap < > ();\\n\\n        // beginWord initialised with level 1.\\n        mpp.put(beginWord, 1);\\n        int sizee = beginWord.length();\\n        st.remove(beginWord);\\n        while (!q.isEmpty()) {\\n            String word = q.peek();\\n            int steps = mpp.get(word);\\n            q.remove();\\n\\n            // Break out if the word matches the endWord.\\n            if (word.equals(endWord)) break;\\n\\n            // Replace each character of the word with letters from a-z \\n            // and check whether the transformed word is present in the \\n            // wordList or not, if yes then push to queue\\n            for (int i = 0; i < sizee; i++) {\\n\\n                for (char ch = \\'a\\'; ch <= \\'z\\'; ch++) {\\n                    char replacedCharArray[] = word.toCharArray();\\n                    replacedCharArray[i] = ch;\\n                    String replacedWord = new String(replacedCharArray);\\n                    if (st.contains(replacedWord) == true) {\\n                        q.add(replacedWord);\\n                        st.remove(replacedWord);\\n\\n                        // push the word along with its level\\n                        // in the map data structure.\\n                        mpp.put(replacedWord, steps + 1);\\n                    }\\n                }\\n\\n\\n            }\\n        }\\n        ans = new ArrayList < > ();\\n\\n        // If we reach the endWord, we stop and move to step-2\\n        // that is to perform reverse dfs traversal.\\n        if (mpp.containsKey(endWord) == true) {\\n            List < String > seq = new ArrayList < > ();\\n            seq.add(endWord);\\n            dfs(endWord, seq);\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "n-repeated-element-in-size-2n-array",
        "tags": "java",
        "release_time": 1679196910,
        "code": "class Solution {\n    public int repeatedNTimes(int[] nums) {\n        HashSet<Integer>set=new HashSet<>();\n        for(int n:nums){\n            if(!set.contains(n)){\n                set.add(n);\n            }else{\n                return n;\n            }\n        }\n        return 0;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int repeatedNTimes(int[] nums) {\\n        HashSet<Integer>set=new HashSet<>();\\n        for(int n:nums){\\n            if(!set.contains(n)){\\n                set.add(n);\\n            }else{\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```"
    },
    {
        "slug": "jump-game-iv",
        "tags": "java",
        "release_time": 1677998298,
        "code": "class Solution {\n    public int minJumps(int[] arr) {\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\n        for(int i=0;i<arr.length;i++){\n            if(hm.containsKey(arr[i])){\n                ArrayList<Integer>al=hm.get(arr[i]);\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n            else{\n                ArrayList<Integer>al=new ArrayList<>();\n                al.add(i);\n                hm.put(arr[i],al);\n            }\n        }\n        boolean vis[]=new boolean[arr.length];\n        Queue<Integer>q=new LinkedList<>();\n        q.add(0);\n        int cnt=0;\n        while(!q.isEmpty()){\n            for(int k=q.size();k>0;k--){\n                int n=q.remove();\n                vis[n]=true;\n                if(n==arr.length-1) return cnt;\n                ArrayList<Integer>al=hm.get(arr[n]);\n                al.add(n-1);\n                al.add(n+1);\n                for(int i:al){\n                    if(i>=0&&i<arr.length&&!vis[i]){\n                        q.add(i);\n                    }\n                }\n                al.clear();\n            }\n            cnt++;\n        }\n        return 0;\n    }\n}",
        "content": "# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH"
    },
    {
        "slug": "find-the-distinct-difference-array",
        "tags": "java",
        "release_time": 1683444191,
        "code": "class Solution {\n    public int[] distinctDifferenceArray(int[] nums) {\n        int n=nums.length;\n        int ans[]=new int[n];\n        \n        for(int i=0;i<n;i++){\n            Set<Integer>set1=new HashSet<>();\n            Set<Integer>set2=new HashSet<>();\n            \n            for(int j=0;j<=i;j++){\n                set1.add(nums[j]);\n            }\n            for(int j=i+1;j<n;j++){\n                set2.add(nums[j]);\n            }\n            \n            ans[i]= set1.size() - set2.size();\n        }\n        return ans;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] distinctDifferenceArray(int[] nums) {\\n        int n=nums.length;\\n        int ans[]=new int[n];\\n        \\n        for(int i=0;i<n;i++){\\n            Set<Integer>set1=new HashSet<>();\\n            Set<Integer>set2=new HashSet<>();\\n            \\n            for(int j=0;j<=i;j++){\\n                set1.add(nums[j]);\\n            }\\n            for(int j=i+1;j<n;j++){\\n                set2.add(nums[j]);\\n            }\\n            \\n            ans[i]= set1.size() - set2.size();\\n        }\\n        return ans;\\n    }\\n}\\n```"
    },
    {
        "slug": "split-message-based-on-limit",
        "tags": "java",
        "release_time": 1668269586,
        "code": "class Solution {\n    public String[] splitMessage(String message, int limit) {\n        int[] stgTable = {\n                (limit - 5) * 9,\n                (limit - 6) * 9 + (limit - 7) * 90,\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\n        };\n        int l = message.length(), stg = 0;\n        while (stg < stgTable.length) {\n            if (stgTable[stg] >= l) break;\n            stg++;\n        }\n        if (stg == stgTable.length) return new String[0];\n        ArrayList<String> list = new ArrayList<>();\n        int idx = 1, strIdx = 0;\n        for (int i = 0; i <= stg; i++) {\n            int size = limit - 5 - stg - i;\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\n                strIdx += size;\n                idx++;\n            }\n        }\n        String[] res = list.toArray(new String[]{});\n        for (int i = 0; i < res.length; i++)\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\n        return res;\n    }\n}",
        "content": "```\\nclass Solution {\\n    public String[] splitMessage(String message, int limit) {\\n        int[] stgTable = {\\n                (limit - 5) * 9,\\n                (limit - 6) * 9 + (limit - 7) * 90,\\n                (limit - 7) * 9 + (limit - 8) * 90 + (limit - 9) * 900,\\n                (limit - 8) * 9 + (limit - 9) * 90 + (limit - 10) * 900 + (limit - 11) * 9000,\\n        };\\n        int l = message.length(), stg = 0;\\n        while (stg < stgTable.length) {\\n            if (stgTable[stg] >= l) break;\\n            stg++;\\n        }\\n        if (stg == stgTable.length) return new String[0];\\n        ArrayList<String> list = new ArrayList<>();\\n        int idx = 1, strIdx = 0;\\n        for (int i = 0; i <= stg; i++) {\\n            int size = limit - 5 - stg - i;\\n            for (int j = 0; j < 9 * Math.pow(10, i) && strIdx < message.length(); j++) {\\n                list.add(message.substring(strIdx, Math.min(message.length(), strIdx + size)) + \"<\" + idx);\\n                strIdx += size;\\n                idx++;\\n            }\\n        }\\n        String[] res = list.toArray(new String[]{});\\n        for (int i = 0; i < res.length; i++)\\n            res[i] = res[i] + \"/\" + (idx - 1) + \">\";\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "convert-sorted-array-to-binary-search-tree",
        "tags": "java",
        "release_time": 1689161763,
        "code": "class Solution {\n    public TreeNode createBST(int arr[], int st, int end){\n        if(st>end){\n            return null;\n        }\n\n        int mid = (st+end)/2;\n        TreeNode root = new TreeNode(arr[mid]);\n        root.left = createBST(arr,st,mid-1);\n        root.right = createBST(arr,mid+1,end);\n\n        return root;\n    }\n    public TreeNode sortedArrayToBST(int[] nums) {\n        int st = 0;\n        int end = nums.length-1;\n        return createBST(nums,st,end);\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInorder Traversal of BST is always sorted.\\nInorder = left, root, right\\nroot = mid of sorted array\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Divide and Conquer and Inorder Traversal**\\n$$Inorder = left, root, right$$ which means root = mid of sorted Array\\nDivide the array into smaller pieces using recursion and assing root = mid \\n$$ mid = (start+end)/2;$$\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public TreeNode createBST(int arr[], int st, int end){\\n        if(st>end){\\n            return null;\\n        }\\n\\n        int mid = (st+end)/2;\\n        TreeNode root = new TreeNode(arr[mid]);\\n        root.left = createBST(arr,st,mid-1);\\n        root.right = createBST(arr,mid+1,end);\\n\\n        return root;\\n    }\\n    public TreeNode sortedArrayToBST(int[] nums) {\\n        int st = 0;\\n        int end = nums.length-1;\\n        return createBST(nums,st,end);\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "reshape-the-matrix",
        "tags": "java",
        "release_time": 1672995256,
        "code": "class Solution {\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\n\n        int oldRow = mat.length;\n        int oldCol = mat[0].length;\n\n\n        //We have to check whether it is possible to construct-\n        //-a new array or not.\n        //we can check it by comparing the total elements.\n        if(oldCol*oldRow != r*c) return mat;\n\n        int [] [] arr = new int[r][c];\n        int i = 0;      // row of new array\n        int j = 0;      // col of new array\n        int k = 0;      // row of old array\n        int l = 0;      // col of old array\n\n        //Traverse the new array and put elements from the old array.\n        for(i = 0; i < r; i++)\n        {\n            for(j = 0; j < c; j++)\n            {\n                arr[i][j] = mat[k][l];\n\n                //We also need to update the indices of the old array.\n                //If column length is reached then increment row\n                // and reset column to 0;\n                l++;\n                if(l == oldCol)\n                {\n                    k++;\n                    l = 0;\n                }\n\n            }\n        }\n        //Finally, return the new array;\n        return arr;\n        \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to arrange the elements of the matrix into new matrix of given row and column.\\nWe have to check whether it is possible to construct a new array or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1. Check the base conditions.\\n    2. Create a new array.\\n    3. Traverse and store the elements.\\nFollow the code below to understand the solution.\\n\\n             **If this solution helped you, give it an up-vote to help others** \\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] matrixReshape(int[][] mat, int r, int c) {\\n\\n        int oldRow = mat.length;\\n        int oldCol = mat[0].length;\\n\\n\\n        //We have to check whether it is possible to construct-\\n        //-a new array or not.\\n        //we can check it by comparing the total elements.\\n        if(oldCol*oldRow != r*c) return mat;\\n\\n        int [] [] arr = new int[r][c];\\n        int i = 0;      // row of new array\\n        int j = 0;      // col of new array\\n        int k = 0;      // row of old array\\n        int l = 0;      // col of old array\\n\\n        //Traverse the new array and put elements from the old array.\\n        for(i = 0; i < r; i++)\\n        {\\n            for(j = 0; j < c; j++)\\n            {\\n                arr[i][j] = mat[k][l];\\n\\n                //We also need to update the indices of the old array.\\n                //If column length is reached then increment row\\n                // and reset column to 0;\\n                l++;\\n                if(l == oldCol)\\n                {\\n                    k++;\\n                    l = 0;\\n                }\\n\\n            }\\n        }\\n        //Finally, return the new array;\\n        return arr;\\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "middle-of-the-linked-list",
        "tags": "java",
        "release_time": 1690528289,
        "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head, fast = head;\n        while(fast != null && fast.next !=null ){\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;    \n    }\n}",
        "content": "# Intuition\\nUse fast and slow pointer to find the middle node of the list;\\n\\n# Approach\\n1. initilize two pointer `fast` and `slow` respectively\\n2. while `fast` is not null and also `fast.next` is not null, move the fast 2 steps ahead and the `slow` one step ahead in each iteration\\n3. after the loop, return the slow which is the middle of the list\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode middleNode(ListNode head) {\\n        ListNode slow = head, fast = head;\\n        while(fast != null && fast.next !=null ){\\n            fast = fast.next.next;\\n            slow = slow.next;\\n        }\\n        return slow;    \\n    }\\n}\\n```"
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "tags": "java",
        "release_time": 1672209386,
        "code": "class Solution {\n    public List<Integer> findLonely(int[] arr) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        ArrayList<Integer> list = new ArrayList<>();\n        \n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\n        return list;\n    }\n}",
        "content": "\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findLonely(int[] arr) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        ArrayList<Integer> list = new ArrayList<>();\\n        \\n        for (int i : arr) map.put(i, map.getOrDefault(i, 0) + 1);\\n        for (int i : arr) if (map.get(i) == 1 && !map.containsKey(i - 1) && !map.containsKey(i + 1)) list.add(i);\\n        return list;\\n    }\\n}\\n```"
    },
    {
        "slug": "relative-ranks",
        "tags": "java",
        "release_time": 1683184626,
        "code": "class Solution {\n    public String[] findRelativeRanks(int[] score) {\n         int n=score.length;\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\n        for(int i=0;i<n;i++) pq.add(i);\n      String[] ans = new String[n];\n                int i=1;\n        while(!pq.isEmpty()){\n            int idx=pq.poll();\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\n         else ans[idx]=Integer.toString(i++);\n        }\n        return ans;  \n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String[] findRelativeRanks(int[] score) {\\n         int n=score.length;\\n        PriorityQueue<Integer> pq=new PriorityQueue<>((a,b)-> score[b]-score[a]);\\n        for(int i=0;i<n;i++) pq.add(i);\\n      String[] ans = new String[n];\\n                int i=1;\\n        while(!pq.isEmpty()){\\n            int idx=pq.poll();\\n         if(i==1)   { ans[idx]=\"Gold Medal\"; i++;}\\n         else if(i==2)   { ans[idx]=\"Silver Medal\"; i++;}\\n         else if(i==3)   { ans[idx]=\"Bronze Medal\"; i++;}\\n         else ans[idx]=Integer.toString(i++);\\n        }\\n        return ans;  \\n    }\\n}\\n```"
    },
    {
        "slug": "repeated-substring-pattern",
        "tags": "java",
        "release_time": 1692607742,
        "code": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        int n = s.length();\n        for (int i = 1; i <= n / 2; i++) {\n            if (n % i == 0) {\n                StringBuilder pattern = new StringBuilder();\n                for (int j = 0; j < n / i; j++) {\n                    pattern.append(s.substring(0, i));\n                }\n                if (s.equals(pattern.toString())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}//TC:O(n\\u22C5n^1/2),SC:O(n)",
        "content": "# Code\\n```\\nclass Solution {\\n    public boolean repeatedSubstringPattern(String s) {\\n        int n = s.length();\\n        for (int i = 1; i <= n / 2; i++) {\\n            if (n % i == 0) {\\n                StringBuilder pattern = new StringBuilder();\\n                for (int j = 0; j < n / i; j++) {\\n                    pattern.append(s.substring(0, i));\\n                }\\n                if (s.equals(pattern.toString())) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}//TC:O(n\\u22C5n^1/2),SC:O(n)\\n```"
    },
    {
        "slug": "reduction-operations-to-make-the-array-elements-equal",
        "tags": "java",
        "release_time": 1679145144,
        "code": "class Solution {\n    public int reductionOperations(int[] nums) {\n        Arrays.sort(nums);\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n        int x = 0;\n        for(Integer num : nums){\n            if(map.containsKey(num)){\n                continue;\n            }\n            map.put(num,x++);\n        }\n        \n        int count = 0;\n        for(int i = 1;i<nums.length;i++){\n            if(nums[i]>nums[0]){\n                count+=map.get(nums[i]);\n            }\n        }\n        return count;\n    }\n}",
        "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public int reductionOperations(int[] nums) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\\n        int x = 0;\\n        for(Integer num : nums){\\n            if(map.containsKey(num)){\\n                continue;\\n            }\\n            map.put(num,x++);\\n        }\\n        \\n        int count = 0;\\n        for(int i = 1;i<nums.length;i++){\\n            if(nums[i]>nums[0]){\\n                count+=map.get(nums[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```"
    },
    {
        "slug": "make-array-empty",
        "tags": "java",
        "release_time": 1682789530,
        "code": "class Solution {\n    public long countOperationsToEmptyArray(int[] a) {\n        HashMap<Integer, Integer> pos = new HashMap<>();\n        long n = a.length, res = n;\n        for (int i = 0; i < n; i++)\n            pos.put(a[i], i);\n        Arrays.sort(a);\n        for (int i = 1; i < n; i++)\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\n                res += n - i;\n        return res;\n    }\n}",
        "content": "# Intuition\\nThe intuition behind the algorithm is that, initially, there are n elements in the array, and at least n operations are required to transform the array to a non-decreasing order. To perform a rotation, n operations are required to move all the elements once.\\n\\nTo implement the algorithm, we first set the result variable to n, which represents the minimum number of operations required to make the array non-decreasing. We then record the positions of all the elements in the array using a dictionary, where pos[A[i]] = i.\\n\\nNext, we iterate through the array from smallest to largest element. If the position of an element decreases compared to the previous element, we know that we need to rotate the remaining elements to the beginning of the array. This brings us back to the original intuition that we need n operations to rotate all the elements once. In this case, we increment the result variable by the number of remaining elements.\\n\\n# Code\\n```\\nclass Solution {\\n    public long countOperationsToEmptyArray(int[] a) {\\n        HashMap<Integer, Integer> pos = new HashMap<>();\\n        long n = a.length, res = n;\\n        for (int i = 0; i < n; i++)\\n            pos.put(a[i], i);\\n        Arrays.sort(a);\\n        for (int i = 1; i < n; i++)\\n            if (pos.get(a[i]) < pos.get(a[i - 1]))\\n                res += n - i;\\n        return res;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-value-at-a-given-index-in-a-bounded-array",
        "tags": "java",
        "release_time": 1686358170,
        "code": "class Solution {\n    public int maxValue(int n, int index, int maxSum) {\n        int left = 0, right = maxSum - n;\n\n        while (left < right) {\n            int middle = (left + right + 1) / 2;\n            if (isPossible(n, index, maxSum - n, middle))\n                left = middle;\n            else\n                right = middle - 1;\n        }\n        return left + 1;\n    }\n\n    private boolean isPossible(int n, int index, int maxSum, int value) {\n        int leftValue = Math.max(value - index, 0);\n        int rightValue = Math.max(value - ((n - 1) - index), 0);\n\n        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;\n        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;\n\n        return sumBefore + sumAfter - value <= maxSum;\n    }\n}",
        "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int n, int index, int maxSum) {\\n        int left = 0, right = maxSum - n;\\n\\n        while (left < right) {\\n            int middle = (left + right + 1) / 2;\\n            if (isPossible(n, index, maxSum - n, middle))\\n                left = middle;\\n            else\\n                right = middle - 1;\\n        }\\n        return left + 1;\\n    }\\n\\n    private boolean isPossible(int n, int index, int maxSum, int value) {\\n        int leftValue = Math.max(value - index, 0);\\n        int rightValue = Math.max(value - ((n - 1) - index), 0);\\n\\n        long sumBefore = (long) (value + leftValue) * (value - leftValue + 1) / 2;\\n        long sumAfter = (long) (value + rightValue) * (value - rightValue + 1) / 2;\\n\\n        return sumBefore + sumAfter - value <= maxSum;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-and-say",
        "tags": "java",
        "release_time": 1666065881,
        "code": "class Solution {\n    String convert(String s)\n    {\n        char prevCh = s.charAt(0);\n        int prevCount = 1; //stores count of consecutive same digits\n        StringBuilder ans = new StringBuilder();\n        for (int i = 1; i < s.length(); i++)\n        {\n            char currCh = s.charAt(i);\n            if (currCh != prevCh)   \n            {\n                ans.append(Integer.toString(prevCount));\n                ans.append(prevCh);\n                prevCount = 1; //reset count\n                prevCh = currCh;\n            }\n            else prevCount++;\n        }\n        ans.append(Integer.toString(prevCount));\n        ans.append(prevCh);\n        return ans.toString();\n    }\n    public String countAndSay(int n) \n    {\n        String prevStr = \"1\";\n        for (int i = 2; i <= n; i++)\n        {\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\n            prevStr = cnsNum; //remember (dp) the previous built string\n        }\n        return prevStr;\n        \n        \n    }\n}",
        "content": "```\\nclass Solution {\\n    String convert(String s)\\n    {\\n        char prevCh = s.charAt(0);\\n        int prevCount = 1; //stores count of consecutive same digits\\n        StringBuilder ans = new StringBuilder();\\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            char currCh = s.charAt(i);\\n            if (currCh != prevCh)   \\n            {\\n                ans.append(Integer.toString(prevCount));\\n                ans.append(prevCh);\\n                prevCount = 1; //reset count\\n                prevCh = currCh;\\n            }\\n            else prevCount++;\\n        }\\n        ans.append(Integer.toString(prevCount));\\n        ans.append(prevCh);\\n        return ans.toString();\\n    }\\n    public String countAndSay(int n) \\n    {\\n        String prevStr = \"1\";\\n        for (int i = 2; i <= n; i++)\\n        {\\n            String cnsNum = convert(prevStr); //cns  = \"count and say Num\"\\n            prevStr = cnsNum; //remember (dp) the previous built string\\n        }\\n        return prevStr;\\n        \\n        \\n    }\\n}\\n```"
    },
    {
        "slug": "find-the-winner-of-the-circular-game",
        "tags": "java",
        "release_time": 1680253276,
        "code": "class Solution {\n    public int findTheWinner(int n, int k) {\n        Queue<Integer> q = new LinkedList();\n\n        for(int i = 1;i<n+1;i++){\n            q.add(i);\n        }\n        while(q.size()!=1){\n            for(int i = k-1;i>0;i--){\n                q.add(q.poll());\n            }\n            q.poll();\n        }\n\n        return q.poll();\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findTheWinner(int n, int k) {\\n        Queue<Integer> q = new LinkedList();\\n\\n        for(int i = 1;i<n+1;i++){\\n            q.add(i);\\n        }\\n        while(q.size()!=1){\\n            for(int i = k-1;i>0;i--){\\n                q.add(q.poll());\\n            }\\n            q.poll();\\n        }\\n\\n        return q.poll();\\n    }\\n}\\n```"
    },
    {
        "slug": "longest-string-chain",
        "tags": "java",
        "release_time": 1682338998,
        "code": "class Solution {\n    public int longestStrChain(String[] words) {\n        // Sort the array in increasing order of word length\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        \n        // Create a map to store the longest chain ending at each word\n        Map<String, Integer> dp = new HashMap<>();\n        int maxChainLength = 1;\n        \n        // Iterate through each word in the array\n        for (String word : words) {\n            // Initialize the longest chain for the current word as 1\n            int longestChain = 1;\n            // Generate all possible predecessor words of the current word\n            for (int i = 0; i < word.length(); i++) {\n                StringBuilder sb = new StringBuilder(word);\n                sb.deleteCharAt(i);\n                String predecessor = sb.toString();\n                // If the predecessor word is in the map, update the longest chain for the current word\n                if (dp.containsKey(predecessor)) {\n                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);\n                }\n            }\n            // Update the map with the longest chain ending at the current word\n            dp.put(word, longestChain);\n            // Update the maximum chain length seen so far\n            maxChainLength = Math.max(maxChainLength, longestChain);\n        }\n        \n        return maxChainLength;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem involves finding the longest chain of words such that each word is the predecessor of the next one. A word is considered to be a predecessor of another word if a single character can be inserted into it to obtain the other word. One way to solve the problem is to use dynamic programming. We can sort the words in ascending order of length and for each word, we can find all the predecessors that have already been processed and update the length of the longest chain that ends with the current word.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the words in increasing order of length.\\n2. Create a HashMap to store the length of the longest chain ending with each word.\\n3. For each word, iterate over all the possible predecessors and update the length of the\\nlongest chain ending with the current word.\\n4. Return the maximum length of any chain.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n * L^2) where n is the number of words in the list and L is the maximum length of a word. This is because for each word, we need to iterate over all its possible predecessors and the length of the predecessors can be at most L.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(n) because we need to store the length of the longest chain ending with each word in a HashMap.\\n# Code\\n```\\nclass Solution {\\n    public int longestStrChain(String[] words) {\\n        // Sort the array in increasing order of word length\\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\\n        \\n        // Create a map to store the longest chain ending at each word\\n        Map<String, Integer> dp = new HashMap<>();\\n        int maxChainLength = 1;\\n        \\n        // Iterate through each word in the array\\n        for (String word : words) {\\n            // Initialize the longest chain for the current word as 1\\n            int longestChain = 1;\\n            // Generate all possible predecessor words of the current word\\n            for (int i = 0; i < word.length(); i++) {\\n                StringBuilder sb = new StringBuilder(word);\\n                sb.deleteCharAt(i);\\n                String predecessor = sb.toString();\\n                // If the predecessor word is in the map, update the longest chain for the current word\\n                if (dp.containsKey(predecessor)) {\\n                    longestChain = Math.max(longestChain, dp.get(predecessor) + 1);\\n                }\\n            }\\n            // Update the map with the longest chain ending at the current word\\n            dp.put(word, longestChain);\\n            // Update the maximum chain length seen so far\\n            maxChainLength = Math.max(maxChainLength, longestChain);\\n        }\\n        \\n        return maxChainLength;\\n    }\\n}\\n\\n```"
    },
    {
        "slug": "set-matrix-zeroes",
        "tags": "java",
        "release_time": 1691675103,
        "code": "class Solution {\n    public void setZeroes(int[][] A) \n    {\n       \n       int row=A.length;\n        int col=A[0].length;\n        int x=1,y=1;\n        for(int i=0;i<col;i++){\n            if(A[0][i]==0){\n                x=0;\n               break;}\n        } \n        for(int i=0;i<row;i++){\n            if(A[i][0]==0){\n                y=0;\n               break;}\n        } \n        //label the top row and column with 0 if there are any 0s\n        for(int i=1;i<row;i++)\n            for(int j=1;j<col;j++)\n            {\n                if(A[i][j]==0)\n                {\n                    A[i][0]=0;\n                    A[0][j]=0;\n                }\n            }\n        \n       for(int j=1;j<col;j++)\n        {\n           if(A[0][j]==0)\n           {\n               for(int i=1;i<row;i++)\n                   A[i][j]=0;\n           }\n        }\n        \n        for(int i=1;i<row;i++)\n        {\n            if(A[i][0]==0)\n            {\n                for(int j=0;j<col;j++)\n                    A[i][j]=0;\n            }\n        }\n        if(x==0)\n        for(int i=0;i<col;i++)\n            A[0][i]=0;\n               \n        if(y==0)\n        for(int i=0;i<row;i++)\n            A[i][0]=0;\n\n        System.gc();\n        //return A;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] A) \\n    {\\n       \\n       int row=A.length;\\n        int col=A[0].length;\\n        int x=1,y=1;\\n        for(int i=0;i<col;i++){\\n            if(A[0][i]==0){\\n                x=0;\\n               break;}\\n        } \\n        for(int i=0;i<row;i++){\\n            if(A[i][0]==0){\\n                y=0;\\n               break;}\\n        } \\n        //label the top row and column with 0 if there are any 0s\\n        for(int i=1;i<row;i++)\\n            for(int j=1;j<col;j++)\\n            {\\n                if(A[i][j]==0)\\n                {\\n                    A[i][0]=0;\\n                    A[0][j]=0;\\n                }\\n            }\\n        \\n       for(int j=1;j<col;j++)\\n        {\\n           if(A[0][j]==0)\\n           {\\n               for(int i=1;i<row;i++)\\n                   A[i][j]=0;\\n           }\\n        }\\n        \\n        for(int i=1;i<row;i++)\\n        {\\n            if(A[i][0]==0)\\n            {\\n                for(int j=0;j<col;j++)\\n                    A[i][j]=0;\\n            }\\n        }\\n        if(x==0)\\n        for(int i=0;i<col;i++)\\n            A[0][i]=0;\\n               \\n        if(y==0)\\n        for(int i=0;i<row;i++)\\n            A[i][0]=0;\\n\\n        System.gc();\\n        //return A;\\n    }\\n}\\n```"
    },
    {
        "slug": "count-largest-group",
        "tags": "java",
        "release_time": 1655802809,
        "code": "class Solution {\n    \n    int countDigits(int n) {\n        if(n == 0) return 0;\n        return n%10 + countDigits(n/10);\n    }\n    \n    public int countLargestGroup(int n) {\n        \n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\n        \n        for(int i=1;i<=n;i++) {\n            int cd = countDigits(i); // count digits\n            list.set(cd, list.get(cd)+1); // update count\n        }\n        \n        return Collections.frequency(list, Collections.max(list));\n    }\n}",
        "content": "```\\nclass Solution {\\n    \\n    int countDigits(int n) {\\n        if(n == 0) return 0;\\n        return n%10 + countDigits(n/10);\\n    }\\n    \\n    public int countLargestGroup(int n) {\\n        \\n        ArrayList<Integer> list = new ArrayList(Collections.nCopies(37, 0));\\n        \\n        for(int i=1;i<=n;i++) {\\n            int cd = countDigits(i); // count digits\\n            list.set(cd, list.get(cd)+1); // update count\\n        }\\n        \\n        return Collections.frequency(list, Collections.max(list));\\n    }\\n}\\n```"
    },
    {
        "slug": "add-two-numbers",
        "tags": "java",
        "release_time": 1646885380,
        "code": "class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0); // creating an dummy list\n        ListNode curr = dummy; // intialising an pointer\n        int carry = 0; // intialising our carry with 0 intiall\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \n\t\t// We will add that as well into our list\n        while(l1 != null || l2 != null || carry == 1){\n            int sum = 0; // intialising our sum\n            if(l1 != null){ // adding l1 to our sum & moving l1\n                sum += l1.val;\n                l1 = l1.next;\n            }\n            if(l2 != null){ // adding l2 to our sum & moving l2\n                sum += l2.val;\n                l2 = l2.next;\n            }\n            sum += carry; // if we have carry then add it into our sum\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\n            ListNode node = new ListNode(sum % 10); // the value we'll get by moduloing it, will become as new node so. add it to our list\n            curr.next = node; // curr will point to that new node if we get\n            curr = curr.next; // update the current every time\n        }\n        return dummy.next; // return dummy.next bcz, we don't want the value we have consider in it intially!!\n    }\n}",
        "content": "How\\'s going, Ladies n Gentlemen, today we are going to solve one of the coolest problem **Add Two Numbers**\\n\\nSo, what the problem statement is saying we have given 2 linkedlist we have to add them and get the sum in another linkedlist.\\n\\nWhat, am saying let\\'s understand with an example:-\\n**Input**: l1 = [1,2,4,3], l2 = [5,4,6]\\n**Output**: [6,6,0,4]\\n\\n![image](https://assets.leetcode.com/users/images/a51e18d1-45de-4ba0-aee9-fbb9c40feef1_1646883355.6593215.png)\\n\\nNow let\\'s create another list in which we will get our sum. So, that list intially we will called as dummy list with any value of your choice present in that. *I\\'ll put 0 as we indian has invented that. <^^>*\\n\\nAnd one more last thing, we\\'ll gonna create one pointer and let\\'s say i\\'ll call it **curr** which is pointing on dummy node and traverse along with it\\n\\n![image](https://assets.leetcode.com/users/images/3345cf32-d7df-4225-9ce5-510398aa489c_1646883682.1670015.png)\\n\\nAlright so, here we go ladies n gentlemen, It\\'s time to sum up these node value, for that we will create one another variable let\\'s called it **sum** and put the sum of **l1 & l2** them into our dummy list. So, we start it from all the way left go to all the way right. Now you will ask, dude what about the carry values we get after sum up.\\nWell, hold on i\\'m coming on that point don\\'t worry.\\n\\nSo, for that what you have to do is, we will intialize one more variable name **carry** if we found carry of let\\'s say 10. First we will modulo it like carry = sum % 10 i.e. carry = 10 % 10 i.e. 0 we will add 0 into our node and after that what we will do is get the carry as carry = sum / 10 i.e. carry = 10 / 10 i.e. 1. Now we are having carry as 1. So, in the next node sum of l1 & l2 we will add carry as well.\\n\\nFor sum we will use this formula :- **sum = l1 + l2 + carry**\\n\\nWe did a lot of talk, let\\'s understand it visually:-\\n* 1st step->\\n![image](https://assets.leetcode.com/users/images/c5e427d5-bcf9-42b4-b926-25771dfa7c54_1646884787.030032.png)\\n\\n* 2nd Step->\\n![image](https://assets.leetcode.com/users/images/fdc5533b-d80f-4b71-b755-b645dc126ff6_1646885015.4167643.png)\\n* 3rd Step->\\n![image](https://assets.leetcode.com/users/images/80247d16-8082-4e54-ad15-ed5cfceb3cfb_1646885221.7208884.png)\\n\\nNow I hope Ladies n Gentlemen, you got the crystal clear idea, what we are doing. So, without any further due ***let\\'s code up***\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0); // creating an dummy list\\n        ListNode curr = dummy; // intialising an pointer\\n        int carry = 0; // intialising our carry with 0 intiall\\n        // while loop will run, until l1 OR l2 not reaches null OR if they both reaches null. But our carry has some value in it. \\n\\t\\t// We will add that as well into our list\\n        while(l1 != null || l2 != null || carry == 1){\\n            int sum = 0; // intialising our sum\\n            if(l1 != null){ // adding l1 to our sum & moving l1\\n                sum += l1.val;\\n                l1 = l1.next;\\n            }\\n            if(l2 != null){ // adding l2 to our sum & moving l2\\n                sum += l2.val;\\n                l2 = l2.next;\\n            }\\n            sum += carry; // if we have carry then add it into our sum\\n            carry = sum/10; // if we get carry, then divide it by 10 to get the carry\\n            ListNode node = new ListNode(sum % 10); // the value we\\'ll get by moduloing it, will become as new node so. add it to our list\\n            curr.next = node; // curr will point to that new node if we get\\n            curr = curr.next; // update the current every time\\n        }\\n        return dummy.next; // return dummy.next bcz, we don\\'t want the value we have consider in it intially!!\\n    }\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0);\\n        ListNode *curr = dummy;\\n        int carry = 0;\\n        \\n        while(l1 != NULL || l2 != NULL || carry == 1){\\n            int sum = 0;\\n            if(l1 != NULL){\\n                sum += l1->val;\\n                l1 = l1->next;\\n            }\\n            if(l2 != NULL){\\n                sum += l2->val;\\n                l2 = l2->next;\\n            }\\n            sum += carry;\\n            carry = sum/10;\\n            ListNode *node = new ListNode(sum % 10);\\n            curr->next = node;\\n            curr = curr->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(max(N, M)) where N is length of l1 & M is length of l2\\n\\n* **Space Complexity :-** BigO(max(N,M))"
    },
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "tags": "java",
        "release_time": 1683098100,
        "code": "class Solution {\n    public int subtractProductAndSum(int n) {\n        \n        int multi=1, sum=0;\n        while(n!=0){\n            int rem=n%10; //take last digit of n\n            sum+=rem;\n            multi*=rem;\n            n=n/10; // dropping last digit of n\n        }\n        // System.out.println(multi+\" \"+sum);\n        return multi - sum;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int subtractProductAndSum(int n) {\\n        \\n        int multi=1, sum=0;\\n        while(n!=0){\\n            int rem=n%10; //take last digit of n\\n            sum+=rem;\\n            multi*=rem;\\n            n=n/10; // dropping last digit of n\\n        }\\n        // System.out.println(multi+\" \"+sum);\\n        return multi - sum;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximal-score-after-applying-k-operations",
        "tags": "java",
        "release_time": 1673150548,
        "code": "class Solution {\n    public long maxKelements(int[] nums, int k) {\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\n        public int compare(Integer a, Integer b) {\n            return b - a;\n        }\n    });\n    \n    for (int num : nums) {\n        pq.add(num);\n    }\n        \n    long score = 0;\n    \n    for (int i = 0; i < k; i++) {\n        // Get the maximum value from the priority queue\n        int max = pq.poll();\n        \n        // Increase the score by the maximum value\n        score += max;\n        \n        // Replace the value with ceil(max / 3)\n        pq.add((int) Math.ceil(max / 3.0));\n    }\n    \n    return score;\n    }\n}",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maxKelements(int[] nums, int k) {\\n    PriorityQueue<Integer> pq = new PriorityQueue<>(new Comparator<Integer>() {\\n        public int compare(Integer a, Integer b) {\\n            return b - a;\\n        }\\n    });\\n    \\n    for (int num : nums) {\\n        pq.add(num);\\n    }\\n        \\n    long score = 0;\\n    \\n    for (int i = 0; i < k; i++) {\\n        // Get the maximum value from the priority queue\\n        int max = pq.poll();\\n        \\n        // Increase the score by the maximum value\\n        score += max;\\n        \\n        // Replace the value with ceil(max / 3)\\n        pq.add((int) Math.ceil(max / 3.0));\\n    }\\n    \\n    return score;\\n    }\\n}\\n```"
    },
    {
        "slug": "maximum-product-of-splitted-binary-tree",
        "tags": "python3",
        "release_time": 1690454881,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        def dfs(node):\n            if node:\n                dfs(node.left)\n                dfs(node.right)\n                if node.left and node.right:\n                    node.val+=node.left.val+node.right.val\n                elif node.left and not node.right:\n                    node.val+=node.left.val\n                elif node.right:\n                    node.val+=node.right.val\n        dfs(root)\n\n        ans,val=0,root.val\n        def f(node):\n            nonlocal ans\n            if node:\n                ans=max(ans,(val-node.val)*node.val)\n                f(node.left)\n                f(node.right)\n        f(root)\n        return ans%1000000007",
        "content": "> Python3 Code\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node):\\n            if node:\\n                dfs(node.left)\\n                dfs(node.right)\\n                if node.left and node.right:\\n                    node.val+=node.left.val+node.right.val\\n                elif node.left and not node.right:\\n                    node.val+=node.left.val\\n                elif node.right:\\n                    node.val+=node.right.val\\n        dfs(root)\\n\\n        ans,val=0,root.val\\n        def f(node):\\n            nonlocal ans\\n            if node:\\n                ans=max(ans,(val-node.val)*node.val)\\n                f(node.left)\\n                f(node.right)\\n        f(root)\\n        return ans%1000000007\\n```"
    },
    {
        "slug": "add-strings",
        "tags": "python3",
        "release_time": 1692165728,
        "code": "class Solution:\n    def addStrings(self, num1: str, num2: str) -> str:\n        sys.set_int_max_str_digits(10000)\n        nattu = int(num1)\n        babu = int(num2)\n        result = str(nattu+babu)\n        return result",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def addStrings(self, num1: str, num2: str) -> str:\\n        sys.set_int_max_str_digits(10000)\\n        nattu = int(num1)\\n        babu = int(num2)\\n        result = str(nattu+babu)\\n        return result\\n\\n```"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "tags": "python3",
        "release_time": 1686193447,
        "code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/."
    },
    {
        "slug": "design-a-stack-with-increment-operation",
        "tags": "python3",
        "release_time": 1674461680,
        "code": "class CustomStack:\n\n    def __init__(self, maxSize: int):\n        self.arr = []\n        self.m = maxSize\n        self.top = -1\n\n    def push(self, x: int) -> None:\n        if self.top < self.m - 1:\n            self.arr.append(x)\n            self.top += 1\n\n    def pop(self) -> int:\n        if self.top == -1: return -1\n        self.top -= 1\n        return(self.arr.pop(-1))\n\n    def increment(self, k: int, val: int) -> None:\n        for i in range(min(k, self.top + 1)): self.arr[i] += val",
        "content": "# Upvote it :)\\n```\\nclass CustomStack:\\n\\n    def __init__(self, maxSize: int):\\n        self.arr = []\\n        self.m = maxSize\\n        self.top = -1\\n\\n    def push(self, x: int) -> None:\\n        if self.top < self.m - 1:\\n            self.arr.append(x)\\n            self.top += 1\\n\\n    def pop(self) -> int:\\n        if self.top == -1: return -1\\n        self.top -= 1\\n        return(self.arr.pop(-1))\\n\\n    def increment(self, k: int, val: int) -> None:\\n        for i in range(min(k, self.top + 1)): self.arr[i] += val\\n```"
    },
    {
        "slug": "spiral-matrix-iv",
        "tags": "python3",
        "release_time": 1675959781,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\n        mat=[[-1 for i in range(n)] for i in range(m)]\n        temp=head\n        d=1\n        rowi,colj=0,0\n        while temp!=None:\n            mat[rowi][colj]=temp.val\n            if d==1:\n                if colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n            elif d==2:\n                if rowi+1<m and mat[rowi+1][colj]==-1:\n                    rowi+=1\n                    d=2\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n            elif d==3:\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\n                    colj-=1\n                    d=3\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n            elif d==4:\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\n                    rowi-=1\n                    d=4\n                elif colj+1<n and mat[rowi][colj+1]==-1:\n                    colj+=1\n                    d=1\n            temp=temp.next\n        return mat",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfollow up direction : right -> down -> left -> up\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncreating a matrix m*n fillup with -1 and traverse throgh list and make update directions according to current directions and values of before cells\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N) (no of Nodes in linkedlist)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+M)\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def spiralMatrix(self, m: int, n: int, head: Optional[ListNode]) -> List[List[int]]:\\n        mat=[[-1 for i in range(n)] for i in range(m)]\\n        temp=head\\n        d=1\\n        rowi,colj=0,0\\n        while temp!=None:\\n            mat[rowi][colj]=temp.val\\n            if d==1:\\n                if colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n                elif rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n            elif d==2:\\n                if rowi+1<m and mat[rowi+1][colj]==-1:\\n                    rowi+=1\\n                    d=2\\n                elif colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n            elif d==3:\\n                if colj-1>=0 and mat[rowi][colj-1]==-1:\\n                    colj-=1\\n                    d=3\\n                elif rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n            elif d==4:\\n                if rowi-1>=0 and mat[rowi-1][colj]==-1:\\n                    rowi-=1\\n                    d=4\\n                elif colj+1<n and mat[rowi][colj+1]==-1:\\n                    colj+=1\\n                    d=1\\n            temp=temp.next\\n        return mat\\n\\n\\n```"
    },
    {
        "slug": "univalued-binary-tree",
        "tags": "python3",
        "release_time": 1680277233,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\n        a = root.val\n        stack = [(root)]\n        while stack:\n            n = stack.pop()\n            if n.val != a: return False\n            if n.left: stack.append(n.left)\n            if n.right: stack.append(n.right)\n        return True",
        "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isUnivalTree(self, root: Optional[TreeNode]) -> bool:\\n        a = root.val\\n        stack = [(root)]\\n        while stack:\\n            n = stack.pop()\\n            if n.val != a: return False\\n            if n.left: stack.append(n.left)\\n            if n.right: stack.append(n.right)\\n        return True\\n        \\n```"
    },
    {
        "slug": "corporate-flight-bookings",
        "tags": "python3",
        "release_time": 1673235303,
        "code": "class Solution:\n    def increment(self, arr, start, end, val):\n        arr[start] += val\n        if end + 1 < len(arr):\n            arr[end+1] -= val\n        \n\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        arr = [0 for _ in range(n)]\n        for book in bookings:\n            start, end ,seat = book\n            self.increment(arr, start-1, end-1, seat)\n            # print(arr)\n        res = [0 for _ in range(n)]\n        res[0] = arr[0]\n        for i in range(1, n):\n            res[i] = res[i-1] + arr[i]\n        # print(res)\n        return res",
        "content": "# Intuition\\nThis is the same problem as range addition. For any booking, we essentially add a number of seats to the specified range. \\n\\n# Approach\\nThere are `n` days in total. So we can create an array with length `n`, representing the difference array (ith entry represents the difference of ith and the (i-1)th entry of the original array). Then, for each booking, we add the `seat` to `arr[start]` and minus `seat` to `arr[end+1]`, so we are adding the number of seat to the days from `start` to `end`. \\n\\n# Complexity\\n- Time complexity:\\nFor each entry, we modify the array two times. So it\\'s $$O(N)$$.\\n\\n- Space complexity:\\nThe `arr` takes $$O(N)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def increment(self, arr, start, end, val):\\n        arr[start] += val\\n        if end + 1 < len(arr):\\n            arr[end+1] -= val\\n        \\n\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n        arr = [0 for _ in range(n)]\\n        for book in bookings:\\n            start, end ,seat = book\\n            self.increment(arr, start-1, end-1, seat)\\n            # print(arr)\\n        res = [0 for _ in range(n)]\\n        res[0] = arr[0]\\n        for i in range(1, n):\\n            res[i] = res[i-1] + arr[i]\\n        # print(res)\\n        return res\\n\\n\\n```"
    },
    {
        "slug": "binary-gap",
        "tags": "python3",
        "release_time": 1675002759,
        "code": "class Solution:\n    def binaryGap(self, n: int) -> int:\n        \n        ans = 0\n        m = -1\n        while n:\n            if 1&n:\n                if m==-1:\n                    m = 1\n                else:\n                    ans = max(ans,m)\n                    m=1\n            else:\n                if m!=-1:\n                    m+=1\n                \n            n = n>>1\n        \n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        \\n        ans = 0\\n        m = -1\\n        while n:\\n            if 1&n:\\n                if m==-1:\\n                    m = 1\\n                else:\\n                    ans = max(ans,m)\\n                    m=1\\n            else:\\n                if m!=-1:\\n                    m+=1\\n                \\n            n = n>>1\\n        \\n        return ans\\n```"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "tags": "python3",
        "release_time": 1671336101,
        "code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False",
        "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```"
    },
    {
        "slug": "number-of-provinces",
        "tags": "python3",
        "release_time": 1685857349,
        "code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = uu\n        elif self.rank[vv] > self.rank[uu]:\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def isConnected(self, u, v, G):\n        return G[u][v] == 1\n\n    def findCircleNum(self, G: List[List[int]]) -> int:\n        n = len(G)\n        uf = DSU(n)\n        if not G:\n            return 0\n        for u in range(n):\n            for v in range(u, n):\n                if self.isConnected(u, v, G):\n                    uf.union(u, v)\n        return len(set([uf.find(i) for i in range(n)]))",
        "content": "\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.rank[uu]:\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def isConnected(self, u, v, G):\\n        return G[u][v] == 1\\n\\n    def findCircleNum(self, G: List[List[int]]) -> int:\\n        n = len(G)\\n        uf = DSU(n)\\n        if not G:\\n            return 0\\n        for u in range(n):\\n            for v in range(u, n):\\n                if self.isConnected(u, v, G):\\n                    uf.union(u, v)\\n        return len(set([uf.find(i) for i in range(n)]))\\n\\n```"
    },
    {
        "slug": "maximum-number-of-achievable-transfer-requests",
        "tags": "python3",
        "release_time": 1688260744,
        "code": "class Solution:\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\n        l=len(requests)\n        for i in range(l,0,-1):\n            for j in combinations(requests,i):\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\n                    return i\n\n        return 0",
        "content": "\\n```\\nclass Solution:\\n    def maximumRequests(self, n: int, requests: List[List[int]]) -> int:\\n        l=len(requests)\\n        for i in range(l,0,-1):\\n            for j in combinations(requests,i):\\n                if Counter(x for x ,y in j)==Counter(y for x,y in j):\\n                    return i\\n\\n        return 0            \\n```"
    }
]