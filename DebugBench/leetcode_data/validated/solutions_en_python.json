[
    {
        "slug": "number-of-subsequences-that-satisfy-the-given-sum-condition",
        "tags": "python3",
        "release_time": 1683361746,
        "code": "class Solution:\n    def numSubseq(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        count = 0\n        mod = 10 ** 9 + 7\n        \n        while left <= right:\n            if nums[left] + nums[right] > target:\n                right -= 1\n            else:\n                count += pow(2, right - left, mod)\n                left += 1\n        \n        return count % mod",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numSubseq(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        left, right = 0, len(nums) - 1\\n        count = 0\\n        mod = 10 ** 9 + 7\\n        \\n        while left <= right:\\n            if nums[left] + nums[right] > target:\\n                right -= 1\\n            else:\\n                count += pow(2, right - left, mod)\\n                left += 1\\n        \\n        return count % mod\\n\\n```"
    },
    {
        "slug": "stock-price-fluctuation",
        "tags": "python3",
        "release_time": 1633838559,
        "code": "class StockPrice:\n\n    def __init__(self):\n        self.mp = {}\n        self.maxp = [] # max-heap \n        self.minp = [] # min-heap \n        self.latest = 0 # latest timestamp\n\n    def update(self, timestamp: int, price: int) -> None:\n        self.mp[timestamp] = price \n        if self.latest <= timestamp: self.latest = timestamp\n        heappush(self.maxp, (-price, timestamp))\n        heappush(self.minp, (price, timestamp))\n\n    def current(self) -> int:\n        return self.mp[self.latest]\n\n    def maximum(self) -> int:\n        while self.mp[self.maxp[0][1]] != -self.maxp[0][0]: heappop(self.maxp)\n        return -self.maxp[0][0]\n\n    def minimum(self) -> int:\n        while self.mp[self.minp[0][1]] != self.minp[0][0]: heappop(self.minp)\n        return self.minp[0][0]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n```\\nclass StockPrice:\\n\\n    def __init__(self):\\n        self.mp = {}\\n        self.maxp = [] # max-heap \\n        self.minp = [] # min-heap \\n        self.latest = 0 # latest timestamp\\n\\n    def update(self, timestamp: int, price: int) -> None:\\n        self.mp[timestamp] = price \\n        if self.latest <= timestamp: self.latest = timestamp\\n        heappush(self.maxp, (-price, timestamp))\\n        heappush(self.minp, (price, timestamp))\\n\\n    def current(self) -> int:\\n        return self.mp[self.latest]\\n\\n    def maximum(self) -> int:\\n        while self.mp[self.maxp[0][1]] != -self.maxp[0][0]: heappop(self.maxp)\\n        return -self.maxp[0][0]\\n\\n    def minimum(self) -> int:\\n        while self.mp[self.minp[0][1]] != self.minp[0][0]: heappop(self.minp)\\n        return self.minp[0][0]\\n```"
    },
    {
        "slug": "all-nodes-distance-k-in-binary-tree",
        "tags": "python3",
        "release_time": 1689040619,
        "code": "class Solution:\n    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\n        adj = defaultdict(list)\n        vis = set()\n        res = []\n\n        def makeGraph(node):\n            if node.left:\n                adj[node].append(node.left)\n                adj[node.left].append(node)\n                makeGraph(node.left)\n            if node.right:\n                adj[node].append(node.right)\n                adj[node.right].append(node)\n                makeGraph(node.right)\n        \n        makeGraph(root)\n        \n        def dfs(node, d):\n            if d < k:\n                vis.add(node)\n                d += 1\n                for u in adj[node]:\n                    if u not in vis:\n                        dfs(u, d)\n            else:\n                res.append(node.val)\n        \n        dfs(target, 0)\n        return res",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def distanceK(self, root: TreeNode, target: TreeNode, k: int) -> List[int]:\\n        adj = defaultdict(list)\\n        vis = set()\\n        res = []\\n\\n        def makeGraph(node):\\n            if node.left:\\n                adj[node].append(node.left)\\n                adj[node.left].append(node)\\n                makeGraph(node.left)\\n            if node.right:\\n                adj[node].append(node.right)\\n                adj[node.right].append(node)\\n                makeGraph(node.right)\\n        \\n        makeGraph(root)\\n        \\n        def dfs(node, d):\\n            if d < k:\\n                vis.add(node)\\n                d += 1\\n                for u in adj[node]:\\n                    if u not in vis:\\n                        dfs(u, d)\\n            else:\\n                res.append(node.val)\\n        \\n        dfs(target, 0)\\n        return res\\n```"
    },
    {
        "slug": "minimum-common-value",
        "tags": "python3",
        "release_time": 1674371805,
        "code": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        i,j=0,0\n        while(i<len(nums1) and j<len(nums2)):\n            if(nums1[i]==nums2[j]):\n                return nums1[i]\n            elif(nums1[i]<nums2[j]):\n                i+=1\n            else:\n                j+=1\n\n        return -1",
        "content": "\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j=0,0\\n        while(i<len(nums1) and j<len(nums2)):\\n            if(nums1[i]==nums2[j]):\\n                return nums1[i]\\n            elif(nums1[i]<nums2[j]):\\n                i+=1\\n            else:\\n                j+=1\\n\\n        return -1\\n```"
    },
    {
        "slug": "reducing-dishes",
        "tags": "python3",
        "release_time": 1680093430,
        "code": "class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        '''\n\n        algo:\n        1. sort dishes lowest -> greatest\n        2. Top down DP looking ofr max satisfaction (dishIndex, timeMult)\n            max(choosing this dish, skipping this dish)\n            \n        Time+ Space Complexity: O(nxn) where n is number of dishes\n        \n        '''\n        satisfaction.sort()\n        @cache\n        def dp(dishIndex, timeMult):\n            if dishIndex == len(satisfaction):\n                return 0\n            # choose to pick or not pick\n            return max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\n                      dp(dishIndex+1, timeMult))\n            \n        \n        return dp(0, 1)",
        "content": "# Intuition\\nKey things to note is if a dish has a lower satisfaction rating you want to wash earlier since it would have a lower multiple. Once you sort the dishes by satisfaction the problem becomes straightforward\\n\\nThen the problem breaks down into iterating thorugh the dishes from least to greatest satisfaction and choosing whether to pick that dish or skip it\\n\\n# Approach\\nThe DP subproblem is DP(dishIndex, timeMultiple) = max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\\ndp(dishIndex+1, timeMult))\\n\\n# Complexity\\n- Time complexity:\\nO(nxn) where n is lenght of satisfaction since there can be a total of n x n states to choose from\\n\\n- Space complexity:\\nsame as time\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\\n        \\'\\'\\'\\n\\n        algo:\\n        1. sort dishes lowest -> greatest\\n        2. Top down DP looking ofr max satisfaction (dishIndex, timeMult)\\n            max(choosing this dish, skipping this dish)\\n            \\n        Time+ Space Complexity: O(nxn) where n is number of dishes\\n        \\n        \\'\\'\\'\\n        satisfaction.sort()\\n        @cache\\n        def dp(dishIndex, timeMult):\\n            if dishIndex == len(satisfaction):\\n                return 0\\n            # choose to pick or not pick\\n            return max((satisfaction[dishIndex] * timeMult) + dp(dishIndex+1, timeMult+1),\\n                      dp(dishIndex+1, timeMult))\\n            \\n        \\n        return dp(0, 1)\\n        \\n```"
    },
    {
        "slug": "most-common-word",
        "tags": "python3",
        "release_time": 1663933249,
        "code": "#Import RegEx\nimport re\n\nclass Solution:\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\n        #List words in paragraph, replacing punctuation with ' ' and all lower case\n        paragraph = re.subn(\"[.,!?;']\", ' ', paragraph.lower())[0].split(' ')\n        \n        #Remove any '' or words in banned from paragraph list\n        paragraph = list(filter(lambda x: x not in banned + [''], paragraph))\n        \n        #Return most common word in filtered list\n        return Counter(paragraph).most_common(1)[0][0]",
        "content": "```\\n#Import RegEx\\nimport re\\n\\nclass Solution:\\n    def mostCommonWord(self, paragraph: str, banned: List[str]) -> str:\\n        #List words in paragraph, replacing punctuation with \\' \\' and all lower case\\n        paragraph = re.subn(\"[.,!?;\\']\", \\' \\', paragraph.lower())[0].split(\\' \\')\\n        \\n        #Remove any \\'\\' or words in banned from paragraph list\\n        paragraph = list(filter(lambda x: x not in banned + [\\'\\'], paragraph))\\n        \\n        #Return most common word in filtered list\\n        return Counter(paragraph).most_common(1)[0][0]"
    },
    {
        "slug": "next-greater-element-i",
        "tags": "python3",
        "release_time": 1673532723,
        "code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        l = []\n        for i in nums1:\n            count=0\n            for j in nums2:\n                if i==j:\n                    for k in range(nums2.index(j)+1,len(nums2)):\n                        if nums2[k]>j:\n                            count+=1\n                            l.append(nums2[k])\n                            break\n                    if count==0:\n                        l.append(-1)\n        return (l)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        l = []\\n        for i in nums1:\\n            count=0\\n            for j in nums2:\\n                if i==j:\\n                    for k in range(nums2.index(j)+1,len(nums2)):\\n                        if nums2[k]>j:\\n                            count+=1\\n                            l.append(nums2[k])\\n                            break\\n                    if count==0:\\n                        l.append(-1)\\n        return (l)\\n                        \\n\\n\\n```"
    },
    {
        "slug": "longest-repeating-character-replacement",
        "tags": "python3",
        "release_time": 1687778319,
        "code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        left = right = 0\n        max_len = 0\n        count = collections.Counter()\n        for right in range(1, len(s) + 1):\n            count[s[right - 1]] += 1\n\n            #find the most frequent character from left to right(window)\n            most = count.most_common()[0][1]\n\n            #replace other characters to maxf character \n            #remain refers to the num of characters to be replaced\n            remain = right - left - most\n            \n            #if the num of characters to be replaced > num of operations\n            #then decrease the size of window => left += 1\n            if remain > k: \n                count[s[left]] -= 1\n                left += 1\n                \n            # right - left => current window size\n            max_len = max(right - left, max_len)\n\n        return max_len",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n        left = right = 0\\n        max_len = 0\\n        count = collections.Counter()\\n        for right in range(1, len(s) + 1):\\n            count[s[right - 1]] += 1\\n\\n            #find the most frequent character from left to right(window)\\n            most = count.most_common()[0][1]\\n\\n            #replace other characters to maxf character \\n            #remain refers to the num of characters to be replaced\\n            remain = right - left - most\\n            \\n            #if the num of characters to be replaced > num of operations\\n            #then decrease the size of window => left += 1\\n            if remain > k: \\n                count[s[left]] -= 1\\n                left += 1\\n                \\n            # right - left => current window size\\n            max_len = max(right - left, max_len)\\n\\n        return max_len\\n\\n\\n\\n\\n        \\n\\n\\n            \\n            \\n\\n```"
    },
    {
        "slug": "longest-arithmetic-subsequence-of-given-difference",
        "tags": "python3",
        "release_time": 1689295566,
        "code": "class Solution:\n    def longestSubsequence(self, arr: List[int], d: int) -> int:\n\n        subseqs = {}\n        for n in arr:\n            cnt_prev = subseqs.get(n, 0)\n            cnt_next = subseqs.get(n+d,0)\n            subseqs[n+d] = max(cnt_prev + 1, cnt_next)\n        \n        return max(subseqs.values())",
        "content": "The key idea here is to maintain a dictionary with:\\n1. **keys** being the numbers that we *expect* to encounter in order to increase subsequence, and \\n2. the respective **values** representing lengths of currently constructed subsequences.\\n\\nEvery time we hit one of the expected numbers `n`, we increase the subsequence by updating the `n+d`-th entry of the dictionary. Notice that multiple subsequences of different length sharing some number may be present. To prevent overwriting of large subsequence length by a smaller value, we store a maximal of these (`max(...)`). \\n\\n```\\nclass Solution:\\n    def longestSubsequence(self, arr: List[int], d: int) -> int:\\n\\n        subseqs = {}\\n        for n in arr:\\n            cnt_prev = subseqs.get(n, 0)\\n            cnt_next = subseqs.get(n+d,0)\\n            subseqs[n+d] = max(cnt_prev + 1, cnt_next)\\n        \\n        return max(subseqs.values())\\n```"
    },
    {
        "slug": "find-a-value-of-a-mysterious-function-closest-to-target",
        "tags": "python3",
        "release_time": 1595299867,
        "code": "class Solution:\n    def closestToTarget(self, arr: List[int], target: int) -> int:\n        ans, seen = inf, set()\n        for x in arr: \n            seen = {ss & x for ss in seen} | {x}\n            ans = min(ans, min(abs(ss - target) for ss in seen))\n        return ans",
        "content": "Algo\\n[Bitwise operations](https://en.wikipedia.org/wiki/Bitwise_operation) can be efficiently carried out in the bit space. Here, the focus is \"bitwise and\", and an important property of \"bitwise and\" is that its result cannot be larger than its operands since no unset bits could be set. Furthermore, given a series of number `x1, x2, ..., xn`, their prefix \"bitwise and\", e..g `x1, x1&x2, x1&x2&x3, ...` can only populate a very small space due to the fact that the bits got unset **sequentially**. For example, if `x1` has `p` set bits, then the above series has at most `p` distinctive numbers. This is a very small set for any numbering system be it 32-bit or 64-bit. \\n\\nUtilizing this property, this question can be solved in `O(N)` time in contrast to the brute force `O(N^2)` like below which I learned from @qqwqert007 in this [post](https://leetcode.com/problems/find-a-value-of-a-mysterious-function-closest-to-target/discuss/743381/Python-6-lines-O(nlogm)-solution). \\n\\n```\\nclass Solution:\\n    def closestToTarget(self, arr: List[int], target: int) -> int:\\n        ans, seen = inf, set()\\n        for x in arr: \\n            seen = {ss & x for ss in seen} | {x}\\n            ans = min(ans, min(abs(ss - target) for ss in seen))\\n        return ans \\n```\\n\\n```\\nclass Solution:\\n    def closestToTarget(self, arr: List[int], target: int) -> int:\\n        ans, seen = inf, set()\\n        for x in arr: \\n            tmp = set() #new set \\n            seen.add(0xffffffff)\\n            for ss in seen:\\n                ss &= x\\n                ans = min(ans, abs(ss - target))\\n                if ss > target: tmp.add(ss) #fine tuning \\n            seen = tmp\\n        return ans \\n```\\n\\nA related question is [201. Bitwise AND of Numbers Range](https://leetcode.com/problems/bitwise-and-of-numbers-range/) for which bitwise and is applied to a range. This again can be computed very efficiently if we focus on the much smaller space of possible bits instead of the vast range of numbers. \\n```\\nclass Solution:\\n    def rangeBitwiseAnd(self, m: int, n: int) -> int:\\n        while n > m: \\n            n &= n-1 #unset last set bit\\n        return n \\n```"
    },
    {
        "slug": "reverse-nodes-in-k-group",
        "tags": "python3",
        "release_time": 1690002884,
        "code": "class Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        \n        dummy = ListNode(0, head)\n        currGroup = dummy\n\n        while True:\n            kth = self.getKth(currGroup, k)\n            if not kth:\n                break\n            nextGroup =  kth.next\n\n            # reverse the currGroup\n            prev, curr = kth.next, currGroup.next\n            while curr != nextGroup:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            currGroup.next, currGroup = kth, currGroup.next\n\n        return dummy.next\n\n\n    def getKth(self, node, k):\n        while node and k:\n            node = node.next\n            k -= 1\n        return node",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(0, head)\\n        currGroup = dummy\\n\\n        while True:\\n            kth = self.getKth(currGroup, k)\\n            if not kth:\\n                break\\n            nextGroup =  kth.next\\n\\n            # reverse the currGroup\\n            prev, curr = kth.next, currGroup.next\\n            while curr != nextGroup:\\n                tmp = curr.next\\n                curr.next = prev\\n                prev = curr\\n                curr = tmp\\n\\n            currGroup.next, currGroup = kth, currGroup.next\\n\\n        return dummy.next\\n\\n\\n    def getKth(self, node, k):\\n        while node and k:\\n            node = node.next\\n            k -= 1\\n        return node\\n\\n```"
    },
    {
        "slug": "build-array-from-permutation",
        "tags": "python3",
        "release_time": 1690363385,
        "code": "class Solution:\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]",
        "content": "\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[i] for i in nums]\\n```"
    },
    {
        "slug": "4sum-ii",
        "tags": "python3",
        "release_time": 1672741417,
        "code": "class Solution:\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\n        dictionary = defaultdict(int)\n        for n1 in nums1:\n            for n2 in nums2:\n                numberNeeded = -(n1 + n2)\n                dictionary[numberNeeded] += 1\n                \n        numberOfTuples = 0\n        for n3 in nums3:\n            for n4 in nums4:\n                numberOfTuples += dictionary[n3 + n4]\n            \n        return numberOfTuples",
        "content": "```\\nclass Solution:\\n    def fourSumCount(self, nums1: List[int], nums2: List[int], nums3: List[int], nums4: List[int]) -> int:\\n        dictionary = defaultdict(int)\\n        for n1 in nums1:\\n            for n2 in nums2:\\n                numberNeeded = -(n1 + n2)\\n                dictionary[numberNeeded] += 1\\n                \\n        numberOfTuples = 0\\n        for n3 in nums3:\\n            for n4 in nums4:\\n                numberOfTuples += dictionary[n3 + n4]\\n            \\n        return numberOfTuples\\n```"
    },
    {
        "slug": "dice-roll-simulation",
        "tags": "python3",
        "release_time": 1671546235,
        "code": "class Solution:\n    def dieSimulator(self, n, A):\n        dp = [[0] * 7 for _ in range(n + 1)]\n        dp[0][-1] = 1\n        for i in range(1, n + 1):\n            for j in range(6):\n                dp[i][j] = dp[i - 1][-1]\n                if i > A[j]: dp[i][j] -= dp[i - A[j] - 1][-1] - dp[i - A[j] - 1][j]\n            dp[i][-1] = sum(dp[i]) % (10 ** 9 + 7)\n        return dp[-1][-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Solution 1\\n```\\nclass Solution:\\n    def dieSimulator(self, n, A):\\n        dp = [[0] * 7 for _ in range(n + 1)]\\n        dp[0][-1] = 1\\n        for i in range(1, n + 1):\\n            for j in range(6):\\n                dp[i][j] = dp[i - 1][-1]\\n                if i > A[j]: dp[i][j] -= dp[i - A[j] - 1][-1] - dp[i - A[j] - 1][j]\\n            dp[i][-1] = sum(dp[i]) % (10 ** 9 + 7)\\n        return dp[-1][-1]\\n```\\n\\n# Solution 2\\n```\\nclass Solution:\\n    def dieSimulator(self, n, A):\\n        dp = [[0] * 6 + [1]]\\n        for i in range(n):\\n            dp.append([dp[i][-1] - (dp[i - A[j]][-1] - dp[i - A[j]][j] if i >= A[j] else 0) for j in range(6)])\\n            dp[-1].append(sum(dp[-1]) % (10 ** 9 + 7))\\n        return dp[-1][-1]\\n```"
    },
    {
        "slug": "maximum-sum-queries",
        "tags": "python3",
        "release_time": 1686457004,
        "code": "import math\nfrom typing import List\nimport bisect\n\n\nclass Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        def buildSparseTable(arr, n):\n            k = int(math.log2(n))\n            st = [[None for j in range(n)] for i in range(k + 1)]\n            for i in range(k + 1):\n                for j in range(n - (1 << i) + 1):\n                    if i == 0:\n                        st[i][j] = arr[j]\n                    else:\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\n            return st\n\n        def getMax(st, l, r):\n            i = int(math.log2(r - l + 1))\n            return max(st[i][l], st[i][r - (1 << i) + 1])\n\n        n = len(nums1)\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\n        max_y = [v[1] for v in a]\n        for i in range(n - 2, -1, -1):\n            max_y[i] = max(max_y[i], max_y[i + 1])\n        _sum = [v[0] + v[1] for v in a]\n        st_max_sum = buildSparseTable(_sum, n)\n        res = []\n        for x, y in queries:\n            i = bisect.bisect_left(a, [x, y])\n            if i == n or max_y[i] < y:\n                res.append(-1)\n                continue\n            left, right = i, n - 1\n            while left < right:\n                m = (left + right + 1) // 2\n                if max_y[m] >= y:\n                    left = m\n                else:\n                    right = m - 1\n            j = right\n            res.append(getMax(st_max_sum, i, j))\n        return res",
        "content": "* Approach:\\n1. Sort array (num1[i], nums2[i]), called array \\'a\\'\\n2. build max_y table max_y[i]= max(a[i][1], a[i+1][1])\\n3. build sparse table max of array [sum(a[i][0], a[i][1]) , i from 1 to n]\\n4. using binarysearch to get range i, j satisfy queries\\n5. using sparse table to get max of range\\n* Sparse table Ref:\\nhttps://cp-algorithms.com/data_structures/sparse-table.html\\n* Code\\n```\\nimport math\\nfrom typing import List\\nimport bisect\\n\\n\\nclass Solution:\\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        def buildSparseTable(arr, n):\\n            k = int(math.log2(n))\\n            st = [[None for j in range(n)] for i in range(k + 1)]\\n            for i in range(k + 1):\\n                for j in range(n - (1 << i) + 1):\\n                    if i == 0:\\n                        st[i][j] = arr[j]\\n                    else:\\n                        st[i][j] = max(st[i - 1][j], st[i - 1][j + (1 << (i - 1))])\\n            return st\\n\\n        def getMax(st, l, r):\\n            i = int(math.log2(r - l + 1))\\n            return max(st[i][l], st[i][r - (1 << i) + 1])\\n\\n        n = len(nums1)\\n        a = sorted([[nums1[i], nums2[i]] for i in range(n)])\\n        max_y = [v[1] for v in a]\\n        for i in range(n - 2, -1, -1):\\n            max_y[i] = max(max_y[i], max_y[i + 1])\\n        _sum = [v[0] + v[1] for v in a]\\n        st_max_sum = buildSparseTable(_sum, n)\\n        res = []\\n        for x, y in queries:\\n            i = bisect.bisect_left(a, [x, y])\\n            if i == n or max_y[i] < y:\\n                res.append(-1)\\n                continue\\n            left, right = i, n - 1\\n            while left < right:\\n                m = (left + right + 1) // 2\\n                if max_y[m] >= y:\\n                    left = m\\n                else:\\n                    right = m - 1\\n            j = right\\n            res.append(getMax(st_max_sum, i, j))\\n        return res\\n```"
    },
    {
        "slug": "sum-of-subarray-ranges",
        "tags": "python3",
        "release_time": 1639283898,
        "code": "class Solution:\n    def subArrayRanges(self, nums: List[int]) -> int:\n        \n        def fn(op): \n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\n            ans = 0 \n            stack = []\n            for i in range(len(nums) + 1): \n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \n                    mid = stack.pop()\n                    ii = stack[-1] if stack else -1 \n                    ans += nums[mid] * (i - mid) * (mid - ii)\n                stack.append(i)\n            return ans \n        \n        return fn(lt) - fn(gt)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def subArrayRanges(self, nums: List[int]) -> int:\\n        \\n        def fn(op): \\n            \"\"\"Return min sum (if given gt) or max sum (if given lt).\"\"\"\\n            ans = 0 \\n            stack = []\\n            for i in range(len(nums) + 1): \\n                while stack and (i == len(nums) or op(nums[stack[-1]], nums[i])): \\n                    mid = stack.pop()\\n                    ii = stack[-1] if stack else -1 \\n                    ans += nums[mid] * (i - mid) * (mid - ii)\\n                stack.append(i)\\n            return ans \\n        \\n        return fn(lt) - fn(gt)\\n```\\n\\n**Related problems**\\n[907. Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/949064/Python3-stack-O(N))"
    },
    {
        "slug": "find-first-palindromic-string-in-the-array",
        "tags": "python3",
        "release_time": 1689502465,
        "code": "class Solution:\n    def firstPalindrome(self, words: List[str]) -> str:\n        for i in words:\n            if i==i[::-1]:\n                return i\n        return \"\"",
        "content": "# Code\\n```\\nclass Solution:\\n    def firstPalindrome(self, words: List[str]) -> str:\\n        for i in words:\\n            if i==i[::-1]:\\n                return i\\n        return \"\"\\n```"
    },
    {
        "slug": "maximize-the-minimum-powered-city",
        "tags": "python3",
        "release_time": 1673114604,
        "code": "class Solution:\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\n        start, end = min(stations), sum(stations) + k\n        while start + 1 < end:\n            mid = (start + end) // 2\n            if self.check(stations, r, k, mid):\n                start = mid\n            else:\n                end = mid\n        if self.check(stations, r, k, end):\n            return end\n        else:\n            return start\n    \n    def check(self, stations, r, k, target):\n            n = len(stations)\n            ans = True\n            newStations = defaultdict(int)\n            power = sum(stations[ : r])\n            for i in range(n):\n                if i + r < n:\n                    power += stations[i + r]\n                if i - r - 1 >= 0:\n                    power -= stations[i - r - 1]\n                if power >= target:\n                    continue\n                elif power + k < target:\n                    ans = False\n                    break\n                else:\n                    diff = target - power\n                    power = target\n                    stations[min(i + r, n - 1)] += diff\n                    k -= diff\n                    newStations[min(i + r, n - 1)] += diff\n            for i in newStations:\n                stations[i] -= newStations[i]\n            return ans",
        "content": "# Approach\\nWe perform a binary search on the possible answer space by checking whether the given `target` (maximum possible minimum power) is valid or not. For each given `target`, we utilize a sliding window algorithm to check its validity in linear time.\\n\\n# Complexity\\n- Time complexity: `O(NlogA)`, where `A` is the range of `[min(stations), sum(stations) + k]`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`, for the use of a hashmap to record the addition of new stations temporarily.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPower(self, stations: List[int], r: int, k: int) -> int:\\n        start, end = min(stations), sum(stations) + k\\n        while start + 1 < end:\\n            mid = (start + end) // 2\\n            if self.check(stations, r, k, mid):\\n                start = mid\\n            else:\\n                end = mid\\n        if self.check(stations, r, k, end):\\n            return end\\n        else:\\n            return start\\n    \\n    def check(self, stations, r, k, target):\\n            n = len(stations)\\n            ans = True\\n            newStations = defaultdict(int)\\n            power = sum(stations[ : r])\\n            for i in range(n):\\n                if i + r < n:\\n                    power += stations[i + r]\\n                if i - r - 1 >= 0:\\n                    power -= stations[i - r - 1]\\n                if power >= target:\\n                    continue\\n                elif power + k < target:\\n                    ans = False\\n                    break\\n                else:\\n                    diff = target - power\\n                    power = target\\n                    stations[min(i + r, n - 1)] += diff\\n                    k -= diff\\n                    newStations[min(i + r, n - 1)] += diff\\n            for i in newStations:\\n                stations[i] -= newStations[i]\\n            return ans\\n```"
    },
    {
        "slug": "maximum-number-of-visible-points",
        "tags": "python3",
        "release_time": 1665071079,
        "code": "class Solution:\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\n        t = Solution.t\n        to_angle = Solution.to_angle            \n        \n        points_at_location = 0\n        angles = []\n        for point in points:\n            x1,y1 = t(*point, *location)\n            if x1 == 0 and y1 == 0:\n                points_at_location += 1\n                continue\n            ang = to_angle(x1,y1) \n            angles.append(ang)\n\n            if ang >= 0 and ang < angle:\n                angles.append(ang+360)\n        angles = sorted(angles)\n        max_s = 0\n        j = 0\n        for i in range(0, len(angles)):\n            \n            while angles[i]-angles[j] > angle:\n                j += 1\n\n            max_s = max(i-j+1, max_s)\n        return max_s + points_at_location\n\n\n    def t(x,y, x0,y0):\n        x1 = x-x0\n        y1 = y-y0\n        return x1,y1\n    \n    def to_angle(x,y):\n        angle = (math.atan2(y,x)/(math.pi))*180 \n        if angle < 0:\n            angle += 360\n        return angle",
        "content": "# Intuition\\nThe maximum number of points within the given Field Of View (FOV) is the maximum of the number of points contained in the interval window $$[\\\\theta, \\\\theta+ FOV]$$ of size $$FOV$$, which starts at angle $$x$$ and considers the angle range up to $$x+FOV$$ inclusive.\\nTo attain this, every point has to be represented by its angle with respect to the x-axis relative to the observer (horizontal axis).\\nSince the problem assumes that we are able to observe:\\n- all points in the interval FOV up to infinity\\n- all points which are behind others in the same line of sight\\n\\nThen we do not care about the distance of any point from the observer location. Only the angle at which is located is relevant so solve the problem   \\n# Real world application\\nThis problem provides a simplified setting in which points captured by a LiDAR sensor have to be filtered so as to consider only the ones falling within the field of view of a given RGB camera sensor.\\nE.g. to obtian occupancy maps of the environment for an autonomous driving application.\\n\\n## Simplified algorithm\\nNote: the below simplified algorithm gives only a simple intuition about a sliding window solution which is then refined in the actual approach. \\nThis one would give \"off by 1\" or \"off by 2 errors\" due to the rounding of angles to integers. Nevertheless, it gives a proper intuition about the refinement steps.\\n1. Represent all points with respect to the observer location (perform a translation) \\n2. Transform all points to polar coordinates such that they are represented by distance(not needed for this problem) and an integer angle with respect to the observer.\\n3. Create a count vector of size $360+FOV$, with index that represents the angle and value the frequency (e.g. number of points) represented by that angle (ignore points exactly at observer location). Note that the array considers also FOV bonus locations in order to evaluate all possible windows that are placed in an interval that crosses angle 360 and 0 (which represent the same angular location).\\n4. Given the obtained counts, transform such array to a prefix sum array.\\n5. Compute number of points within window of size $FOV$ starting at \\n  $x \\\\in [0,360]$ by means of the prefix sum computedbefore $cur\\\\_count = prefix\\\\_sum[x+FOV]-prefix\\\\_sum[x-1] $\\n6. Return $max_{i}(cur\\\\_count_i) + K$, where K is the number of previously ignored points.\\n\\n# Approach\\nNote: this will be an in depth explanation that covers deeply all concepts.\\nJust glance through it if you want to just see the code.\\nFurthermore, the general setting of this problem is that of an engineering problem more than a CS one.\\nSo you might need a bit more math knowledge for this.\\n\\n#### Three concepts are fundamental to fully understand this problem:\\n* **Calculus**: any point x,y in cartesian coordinates can be mapped to another set of coordinates u,v.\\nSince the field of view (FOV for short) is here represented by an angle, it would  be neat **to have points and FOV in the same unit of measurement e.g. angles**. **Polar coordinates** allow to map a point **x,y in cartesian coordinates (x,y) to polar(radius,angle)**.\\nThis is achieved as follows:\\n. $$radius = (x^2+y^2)^{\\\\frac{1}{2}}$$\\n. $$angle=arctan(y/x)$$\\n\\nRead here for more details https://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates ). Here radius is not relevant since the problem states that you can \"see\" behind points on the same line of sight, otherwise you would need it.  \\n\\n\\n* **Sliding window**: Now that the field of view and the points are represent both as angles, we can\\nconceptualize the field of view as a window/interval/range which has size equal to the provided field of view angle ). Hence the problem is reduced to finding the sliding window that contains the maximum number of points. \\nStill, where should we slide the window that represents the field of view?\\nIt should be slid by placing it at any of the points x,y represented by their angle $\\\\theta$, and considering the FOV area after it: this is represented by the interval $[\\\\theta, \\\\theta + FOV]$, in which $FOV$ is basically the sliding window size.\\n\\n* **Coordinate translation**: \\npoints have to be represented with respect to the observer location, since the field of view has to be considered based on that position. \\nUp to now, the location of the observer (given in the problem as \"location\")\\nhas not been taken into account when considering angles and sliding windows. Indeed the data is given to us with respect to the origin of the plane. \\nHowever, as stated in the problem, we need to determine all quantities with respect to the observer\\'s field of view.\\nThis can be solved by simply translating all points such that they are represented with respect to the observer location, rather than the origin of the axis.\\nAs an example, if the observer is located at location=$(x_{obs}=1,y_{obs}=1)$ (with respect to the origin $(0,0)$), a point $(x=1,y=0)$ (also with respect to the origin), \\nthe observer would see it exactly below its location, thus at \\n$(x_{new}=0,y_{new}=-1)$. Therefore to achieve this result, every point has to be represented relative to the observer location.\\nThis is mathematically achieved by a simple translation:\\n. $$x_{new}=x-x_{obs}$$\\n. $$y_{new}=y-y_{obs}$$\\n\\n* **Edge cases**\\n  All points that after the translations are exactly below the observer are deemed at angle 0 (because $arctan(0)=0$) with respect to it. Still, any points located exactly at the observer location has to be considered as visible by any field of view sliding window. Thus, these are excluded and added back to the result after all computations are performed.\\n\\n# Complexity\\nN = number of points\\n- Time complexity:\\n$$O(N \\\\log N)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n# Code\\n```\\n\\n\\nclass Solution:\\n    def visiblePoints(self, points: List[List[int]], angle: int, location: List[int]) -> int:\\n        t = Solution.t\\n        to_angle = Solution.to_angle            \\n        \\n        points_at_location = 0\\n        angles = []\\n        for point in points:\\n            x1,y1 = t(*point, *location)\\n            if x1 == 0 and y1 == 0:\\n                points_at_location += 1\\n                continue\\n            ang = to_angle(x1,y1) \\n            angles.append(ang)\\n\\n            if ang >= 0 and ang < angle:\\n                angles.append(ang+360)\\n        angles = sorted(angles)\\n        max_s = 0\\n        j = 0\\n        for i in range(0, len(angles)):\\n            \\n            while angles[i]-angles[j] > angle:\\n                j += 1\\n\\n            max_s = max(i-j+1, max_s)\\n        return max_s + points_at_location\\n\\n\\n    def t(x,y, x0,y0):\\n        x1 = x-x0\\n        y1 = y-y0\\n        return x1,y1\\n    \\n    def to_angle(x,y):\\n        angle = (math.atan2(y,x)/(math.pi))*180 \\n        if angle < 0:\\n            angle += 360\\n        return angle\\n```"
    },
    {
        "slug": "find-servers-that-handled-most-number-of-requests",
        "tags": "python3",
        "release_time": 1614661226,
        "code": "class Solution:\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\n        busy = [] # min-heap\n        free = list(range(k)) # min-heap \n        freq = [0]*k\n        \n        for i, (ta, tl) in enumerate(zip(arrival, load)): \n            while busy and busy[0][0] <= ta: \n                _, ii = heappop(busy)\n                heappush(free, i + (ii - i) % k) # circularly relocate it\n            if free: \n                ii = heappop(free) % k \n                freq[ii] += 1\n                heappush(busy, (ta+tl, ii))\n        \n        mx = max(freq)\n        return [i for i, x in enumerate(freq) if x == mx]",
        "content": "**Approach 1** - heap only \\nI was completely amazed to learn this solution from @warmr0bot in this [post](https://leetcode.com/problems/find-servers-that-handled-most-number-of-requests/discuss/876883/Python-using-only-heaps). Here, the trick is to relocate a freed server to a later place by circularly adjusting its index. In this way, when we are looking server `ii` at position `i` where `ii < i`, we will free `ii` to a place `ii + x*k` where `x` is enough so that `ii+x*k` bearly passes `i`. Mathematically, `i + (ii-i)%k` does the trick. \\n\\nImplementation \\n```\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        busy = [] # min-heap\\n        free = list(range(k)) # min-heap \\n        freq = [0]*k\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                heappush(free, i + (ii - i) % k) # circularly relocate it\\n            if free: \\n                ii = heappop(free) % k \\n                freq[ii] += 1\\n                heappush(busy, (ta+tl, ii))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 2** - Fenwick tree\\nThis is my original approach, but it is really slow (8000+ms). Here, we use a Fenwick tree to label free servers and use binary search to locate the left-most free servers past a give index `i`. \\n\\n```\\nclass Fenwick: \\n\\tdef __init__(self, n: int):\\n\\t\\tself.nums = [0]*(n+1)\\n\\n\\tdef sum(self, k: int) -> int: \\n\\t\\t\"\"\"Return the sum of nums[:k].\"\"\"\\n\\t\\tans = 0\\n\\t\\twhile k:\\n\\t\\t\\tans += self.nums[k]\\n\\t\\t\\tk -= k & -k # unset last set bit \\n\\t\\treturn ans\\n\\n\\tdef add(self, k: int, x: int) -> None: \\n\\t\\tk += 1\\n\\t\\twhile k < len(self.nums): \\n\\t\\t\\tself.nums[k] += x\\n\\t\\t\\tk += k & -k \\n    \\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k # counter \\n        pq = [] # min-heap \\n        \\n        fw = Fenwick(k) # count of available servers \\n        for i in range(k): fw.add(i, 1) \\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            i %= k \\n            while pq and pq[0][0] <= ta: \\n                _, ii = heappop(pq) # release servers \\n                fw.add(ii, 1)\\n            \\n            if fw.sum(k):\\n                if fw.sum(k) - fw.sum(i): lo, hi, x = i, k, fw.sum(i)\\n                else: lo, hi, x = 0, i, 0\\n                \\n                while lo < hi: \\n                    mid = lo + hi >> 1\\n                    if fw.sum(mid) - x: hi = mid\\n                    else: lo = mid + 1\\n                fw.add(lo-1, -1)\\n                freq[lo-1] += 1\\n                heappush(pq, (ta+tl, lo-1))\\n                \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```\\n\\n**Approach 3** - SortedList\\n`SortedList` is an interesting data structure of `sortedcontainers` which is an external library and doesn\\'t come with Python by default. I believe the underlying data structure is a balanced bst. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def busiestServers(self, k: int, arrival: List[int], load: List[int]) -> List[int]:\\n        freq = [0]*k\\n        busy = [] # min-heap \\n        free = SortedList(range(k)) # balanced bst\\n        \\n        for i, (ta, tl) in enumerate(zip(arrival, load)): \\n            while busy and busy[0][0] <= ta: \\n                _, ii = heappop(busy)\\n                free.add(ii)\\n            \\n            if free: \\n                ii = free.bisect_left(i%k) % len(free)\\n                server = free.pop(ii)\\n                freq[server] += 1\\n                heappush(busy, (ta+tl, server))\\n        \\n        mx = max(freq)\\n        return [i for i, x in enumerate(freq) if x == mx]\\n```"
    },
    {
        "slug": "maximum-elegance-of-a-k-length-subsequence",
        "tags": "python3",
        "release_time": 1691294879,
        "code": "class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        dico=defaultdict(list)\n        for profit,category in items:\n            dico[category].append(profit)\n        categories=[]\n        for category in dico:\n            categories.append(sorted(dico[category]))\n        categories.sort(key=lambda x:x[-1],reverse=True)\n        def elegance (distinct):\n            res=0\n            rest=[]\n            for i in range (distinct):\n                res+=categories[i][-1]\n                for j in range (len(categories[i])-1):\n                    rest.append(categories[i][j])\n            rest.sort(reverse=True)\n            if len(rest)<k-distinct:\n                return -1\n            return res+sum(rest[:k-distinct])+distinct**2\n        l,r=1,min(len(categories)-1,k-1)\n        mid=(l+r)//2\n        while l<r:\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\n                l=mid+1\n            else:\n                r=mid\n            mid=(l+r)//2\n        return max(elegance(mid),elegance(mid+1))",
        "content": "[Edit : This worked on all testcases during contest but @canlong found a testcase that my algorithm does not work on]\\n\\n# Intuition\\nThe elegance as a function of the number of distinct categories should look like a mountain with a peak.\\n\\n# Approach\\nBinary search the number of distinct categories by checking the elegance of p distinct categories and p+1 distinct categories.\\n\\nFor each number of distinct category p, take the categories with the p highest values, then add the greatest values of these p categories that are not the maximum. If there are not enough elements to reach k elements, we need to take additional categories.\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\\n        dico=defaultdict(list)\\n        for profit,category in items:\\n            dico[category].append(profit)\\n        categories=[]\\n        for category in dico:\\n            categories.append(sorted(dico[category]))\\n        categories.sort(key=lambda x:x[-1],reverse=True)\\n        def elegance (distinct):\\n            res=0\\n            rest=[]\\n            for i in range (distinct):\\n                res+=categories[i][-1]\\n                for j in range (len(categories[i])-1):\\n                    rest.append(categories[i][j])\\n            rest.sort(reverse=True)\\n            if len(rest)<k-distinct:\\n                return -1\\n            return res+sum(rest[:k-distinct])+distinct**2\\n        l,r=1,min(len(categories)-1,k-1)\\n        mid=(l+r)//2\\n        while l<r:\\n            if elegance(mid+1)>elegance(mid) or elegance(mid+1)==-1:\\n                l=mid+1\\n            else:\\n                r=mid\\n            mid=(l+r)//2\\n        return max(elegance(mid),elegance(mid+1))\\n            \\n                \\n                \\n                \\n```"
    },
    {
        "slug": "plates-between-candles",
        "tags": "python3",
        "release_time": 1689465278,
        "code": "class Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\n        \n        def bns(x: int) -> int:\n            l, r = 0, len(candies) - 1\n            while l <= r:\n                m = (l + r) // 2\n                if candies[m] < x: l = m + 1\n                else: r = m - 1\n            return l\n\n        ans = []\n        for a, b in queries:\n            l, r = bns(a), bns(b + 1) - 1\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. Binary Search\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        candies = [i for i, c in enumerate(s) if c == \"|\"]\\n        \\n        def bns(x: int) -> int:\\n            l, r = 0, len(candies) - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                if candies[m] < x: l = m + 1\\n                else: r = m - 1\\n            return l\\n\\n        ans = []\\n        for a, b in queries:\\n            l, r = bns(a), bns(b + 1) - 1\\n            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)\\n        return ans\\n```\\n- TC: $$O(NlogN)$$\\n- SC: $$O(N)$$\\n\\n2. Prefix Sum\\n```\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        psum, next, prev = [0] * (len(s) + 1), [float(\"inf\")] * (len(s) + 1), [0] * (len(s) + 1)\\n        res = []\\n        for i, ch in enumerate(s):\\n            psum[i + 1] = psum[i] + (ch == \\'|\\')\\n            prev[i + 1] = i if ch == \\'|\\' else prev[i]\\n        for i, ch in reversed(list(enumerate(s))):\\n            next[i] = i if ch == \\'|\\' else next[i + 1]\\n        for q in queries:\\n            l, r = next[q[0]], prev[q[1] + 1]\\n            res.append(r - l - (psum[r] - psum[l]) if l < r else 0)\\n        return res\\n```\\n- TC: $$O(N)$$\\n- SC: $$O(N)$$"
    },
    {
        "slug": "largest-positive-integer-that-exists-with-its-negative",
        "tags": "python3",
        "release_time": 1665895358,
        "code": "class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        nums=sorted(nums,reverse=True)\n        s=set(nums)\n        for i in range(len(nums)):\n            if 0-nums[i] in s:\n                return nums[i]\n        return -1",
        "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxK(self, nums: List[int]) -> int:\\n        nums=sorted(nums,reverse=True)\\n        s=set(nums)\\n        for i in range(len(nums)):\\n            if 0-nums[i] in s:\\n                return nums[i]\\n        return -1\\n\\n```"
    },
    {
        "slug": "restore-ip-addresses",
        "tags": "python3",
        "release_time": 1674285009,
        "code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        res=[]\n        cur=[]\n        def backtrack(i):\n            if i==len(s) and len(cur)==4:\n                res.append(\".\".join(cur))\n                return\n            if len(cur)>4 or i>=len(s):\n                return\n            if s[i]=='0':\n                cur.append(s[i])\n                backtrack(i+1)\n                cur.pop()\n                return\n            j=0\n            while j<4 and i+j<len(s):\n                if int(s[i:i+j+1])<256:\n                    cur.append(s[i:i+j+1])\n                    backtrack(i+j+1)\n                    cur.pop()\n                j+=1\n        backtrack(0)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\njust take care with the processing number should be lower than len(s) and the length of current stack should be lower or equal 4.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(4)\\n# Code\\n```\\nclass Solution:\\n    def restoreIpAddresses(self, s: str) -> List[str]:\\n        res=[]\\n        cur=[]\\n        def backtrack(i):\\n            if i==len(s) and len(cur)==4:\\n                res.append(\".\".join(cur))\\n                return\\n            if len(cur)>4 or i>=len(s):\\n                return\\n            if s[i]==\\'0\\':\\n                cur.append(s[i])\\n                backtrack(i+1)\\n                cur.pop()\\n                return\\n            j=0\\n            while j<4 and i+j<len(s):\\n                if int(s[i:i+j+1])<256:\\n                    cur.append(s[i:i+j+1])\\n                    backtrack(i+j+1)\\n                    cur.pop()\\n                j+=1\\n        backtrack(0)\\n        return res\\n\\n```"
    },
    {
        "slug": "jump-game",
        "tags": "python3",
        "release_time": 1679198703,
        "code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        I=len(nums)-1\n        if I == 0:\n            return True\n        for i in nums[-2::-1]:\n            I -= 1\n            L=len(nums)\n            #print(L)\n            if i+I>= L-1:\n                nums = nums[0:I+1]\n            #print(i,I,nums)\n            if I == 0:\n                #print(i,I,nums,L)\n                if i >= L-1:\n                    return True\n                if i < L-1:\n                    return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        I=len(nums)-1\\n        if I == 0:\\n            return True\\n        for i in nums[-2::-1]:\\n            I -= 1\\n            L=len(nums)\\n            #print(L)\\n            if i+I>= L-1:\\n                nums = nums[0:I+1]\\n            #print(i,I,nums)\\n            if I == 0:\\n                #print(i,I,nums,L)\\n                if i >= L-1:\\n                    return True\\n                if i < L-1:\\n                    return False\\n\\n```"
    },
    {
        "slug": "minimum-common-value",
        "tags": "python3",
        "release_time": 1686011709,
        "code": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        while len(nums1)>0 and len(nums2)>0:\n            if nums1[0]==nums2[0]:\n                return nums1[0]\n            elif nums1[0]<nums2[0]:\n                nums1.pop(0)\n            else:\n                nums2.pop(0)\n        return -1",
        "content": "# Intuition\\nThe intuition behind the solution is that since the arrays are sorted in non-decreasing order, the minimum common integer must be the smallest value that appears in both arrays. Therefore, by comparing the first elements of both arrays, we can determine if they are equal, smaller in nums1, or smaller in nums2, and accordingly, we can move the pointers to the next elements in the respective arrays.\\n\\n\\n# Approach\\nThe solution iterates over the arrays using a while loop, and as long as both arrays have elements remaining, it compares the first elements of both arrays. If they are equal, it means that the minimum common integer has been found, so it is returned. If the element in nums1 is smaller, it means that the minimum common integer must be greater than that element, so the pointer in nums1 is moved to the next element. Similarly, if the element in nums2 is smaller, the pointer in nums2 is moved to the next element. If the loop finishes without finding a common integer, it means that there is no common integer, so -1 is returned.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is determined by the length of the shorter array between nums1 and nums2. In the worst case, the while loop will iterate until one of the arrays is exhausted. Therefore, the time complexity is O(min(N, M)), where N and M are the lengths of nums1 and nums2, respectively.\\n\\n\\n- Space complexity:\\nThe space complexity of the solution is O(1) since it only uses a constant amount of additional space to store the indices and temporary variables for comparisons.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        while len(nums1)>0 and len(nums2)>0:\\n            if nums1[0]==nums2[0]:\\n                return nums1[0]\\n            elif nums1[0]<nums2[0]:\\n                nums1.pop(0)\\n            else:\\n                nums2.pop(0)\\n        return -1\\n```"
    },
    {
        "slug": "maximum-performance-of-a-team",
        "tags": "python3",
        "release_time": 1691737203,
        "code": "class Solution:\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\n        MOD = 10**9 + 7\n\n        top_k_speeds = []\n        res, top_k_sum = 0, 0\n\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\n        for e, s in sorted(pairs, reverse = True):\n            heapq.heappush(top_k_speeds, s)\n            top_k_sum += s\n\n            if len(top_k_speeds) > k:\n                top_k_sum -= heapq.heappop(top_k_speeds)\n\n            res = max(res, e * top_k_sum)\n        \n        return res % MOD",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each any given efficiency $e_i$, the optimal performance we can get with $e_i$ as the minimum efficiency is $e_i$ times the sum of the largest $k$ speeds $s_j$ where $e_j \\\\ge e_i$ (ensuring that $e_i$ is the minimum efficiency). \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe should find this optimal performance for every efficiency in the array and return our global maximum. An $O(n^2)$solution won\\'t work due to our constraints, so we need to optimize somehow.\\n\\nIf we sort efficiencies and speed pairs in reverse order, when we iterate through, at any index $i$ we know $e_i$ is the minimum efficiency, and $s_0, s_1, ..., s_i$ are the available speeds that we can select $k$ speeds from.\\n\\nWe can maintain the top $k$ elements and sum using a multiset (`SortedList` in Python) or a heap, however, a multiset typically has worse overhead and heap has average $O(1)$ insertion. \\n\\nA similar problem uses this same method: https://leetcode.com/problems/kth-largest-element-in-a-stream/\\n\\n# Complexity\\nTime and space complexity are dominated by the sorting of the list. \\n\\nTime complexity: $O(n\\\\log{n})$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxPerformance(self, n: int, speed: List[int], efficiency: List[int], k: int) -> int:\\n        MOD = 10**9 + 7\\n\\n        top_k_speeds = []\\n        res, top_k_sum = 0, 0\\n\\n        pairs = [(e, s) for e, s in zip(efficiency, speed)]\\n        for e, s in sorted(pairs, reverse = True):\\n            heapq.heappush(top_k_speeds, s)\\n            top_k_sum += s\\n\\n            if len(top_k_speeds) > k:\\n                top_k_sum -= heapq.heappop(top_k_speeds)\\n\\n            res = max(res, e * top_k_sum)\\n        \\n        return res % MOD\\n```"
    },
    {
        "slug": "exclusive-time-of-functions",
        "tags": "python3",
        "release_time": 1656213971,
        "code": "class Solution:\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\n\t    # Store total time of fid\n        res = [0 for _ in range(n)]\n\t\t# stack\n        s = []\n\t\t# store the current time\n        currt = 0\n\t\t\n\t\t# iterate through the logs\n        for log in logs: \n                \n\t\t\t# Get thefid , state and timestamp from the log\t\n            fid, state, timestamp = log.split(\":\")\n            \n            fid = int(fid)\n            timestamp = int(timestamp)\n            \n            if state == \"end\":\n\t\t\t\t# since the process is ended, we pop out its start log\n                s.pop()\n\t\t\t\t# Update the time of the log. We add **+1** as the process gets over at the end of timestamp. \n\t\t\t\t# So adding that **1**\n                res[fid] += timestamp - currt+1\n\t\t\t\t# updating the current time\n                currt = timestamp + 1\n            else:\n                if (s):\n\t\t\t\t     # if another process is strating before the previious process has been ended, \n\t\t\t\t\t # we get the fid anf time of previouse proces\n                    fidprev,time = s[-1]\n\t\t\t\t\t# add the time taken by previouse process till now before a new process is spawned\n                    res[fidprev] += timestamp - currt\n\t\t\t\t# add the start log to the stack \n                s.append((fid,timestamp))\n\t\t\t\t# update the current time\n                currt = timestamp\n            \n        return res",
        "content": "In this solution, we calculate the time in place rather than waiting for the **endtime** of the process. \\n\\nWe always keep track of current time **currt**\\n\\n\\nWhenever a new process is started, we calculate the time taken by the previus process till now ( **timestamp -currt**) and and add that to the stack along with its **fid**. \\n\\nWhenever a process ends, we pop the the previous element from the stack(which is its starttime log) and update the **res[fid]** with **time -currt + 1**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution:\\n    def exclusiveTime(self, n: int, logs: List[str]) -> List[int]:\\n\\t    # Store total time of fid\\n        res = [0 for _ in range(n)]\\n\\t\\t# stack\\n        s = []\\n\\t\\t# store the current time\\n        currt = 0\\n\\t\\t\\n\\t\\t# iterate through the logs\\n        for log in logs: \\n                \\n\\t\\t\\t# Get thefid , state and timestamp from the log\\t\\n            fid, state, timestamp = log.split(\":\")\\n            \\n            fid = int(fid)\\n            timestamp = int(timestamp)\\n            \\n            if state == \"end\":\\n\\t\\t\\t\\t# since the process is ended, we pop out its start log\\n                s.pop()\\n\\t\\t\\t\\t# Update the time of the log. We add **+1** as the process gets over at the end of timestamp. \\n\\t\\t\\t\\t# So adding that **1**\\n                res[fid] += timestamp - currt+1\\n\\t\\t\\t\\t# updating the current time\\n                currt = timestamp + 1\\n            else:\\n                if (s):\\n\\t\\t\\t\\t     # if another process is strating before the previious process has been ended, \\n\\t\\t\\t\\t\\t # we get the fid anf time of previouse proces\\n                    fidprev,time = s[-1]\\n\\t\\t\\t\\t\\t# add the time taken by previouse process till now before a new process is spawned\\n                    res[fidprev] += timestamp - currt\\n\\t\\t\\t\\t# add the start log to the stack \\n                s.append((fid,timestamp))\\n\\t\\t\\t\\t# update the current time\\n                currt = timestamp\\n            \\n        return res\\n```\\n\\nTC: O(N)\\nSC: O(N)\\n\\n"
    },
    {
        "slug": "satisfiability-of-equality-equations",
        "tags": "python3",
        "release_time": 1672762507,
        "code": "class Disjoint:\n    def __init__(self):\n        self.rank=[0]*26\n        self.parent=[i for i in range(26)]\n\n    def finduPar(self,node):\n        if self.parent[node]==node:\n            return node\n        self.parent[node]=self.finduPar(self.parent[node])\n        return self.parent[node]\n\n    def byrank(self,u,v):\n        ulp_u=self.finduPar(u)\n        ulp_v=self.finduPar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n\n\nclass Solution:\n    def equationsPossible(self, equations: List[str]) -> bool:\n        disjoint=Disjoint()\n        nq=[]\n        n=len(equations)\n        for i in range(n):\n            if equations[i][1]=='!':\n                if equations[i][0]==equations[i][-1]:\n                    return False\n                else:\n                    nq.append(equations[i])\n            else:\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\n        for i in range(len(nq)):\n            x=ord(nq[i][0])-97\n            y=ord(nq[i][-1])-97\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\n                return False\n        return True",
        "content": "# Intuition\\nWE WOULD MAKE ALL alphabet that are equal in same component. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUNION DISJOINT\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self):\\n        self.rank=[0]*26\\n        self.parent=[i for i in range(26)]\\n\\n    def finduPar(self,node):\\n        if self.parent[node]==node:\\n            return node\\n        self.parent[node]=self.finduPar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byrank(self,u,v):\\n        ulp_u=self.finduPar(u)\\n        ulp_v=self.finduPar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_u]<self.rank[ulp_v]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n\\n\\nclass Solution:\\n    def equationsPossible(self, equations: List[str]) -> bool:\\n        disjoint=Disjoint()\\n        nq=[]\\n        n=len(equations)\\n        for i in range(n):\\n            if equations[i][1]==\\'!\\':\\n                if equations[i][0]==equations[i][-1]:\\n                    return False\\n                else:\\n                    nq.append(equations[i])\\n            else:\\n                disjoint.byrank(ord(equations[i][0])-97,ord(equations[i][-1])-97)\\n        for i in range(len(nq)):\\n            x=ord(nq[i][0])-97\\n            y=ord(nq[i][-1])-97\\n            if disjoint.finduPar(x)==disjoint.finduPar(y):\\n                return False\\n        return True\\n```"
    },
    {
        "slug": "check-if-one-string-swap-can-make-strings-equal",
        "tags": "python3",
        "release_time": 1690179451,
        "code": "class Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n        if s1==s2:\n            return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False",
        "content": "\\n\\n# Approach\\nAs per the question it is given that you can only make 1 swap so iterate any word and store the different elememt in a list and make sure that the length of the list is 2 and both of these are reverse of each other \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\\n        if len(s1)!=len(s2):\\n            return False\\n        if s1==s2:\\n            return True\\n        diff=[]\\n        for i in range(len(s1)):\\n            if s1[i]!=s2[i]:\\n                diff.append([s1[i],s2[i]])\\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\\n            return True\\n        else:\\n            return False\\n            \\n        \\n```"
    },
    {
        "slug": "sum-of-matrix-after-queries",
        "tags": "python3",
        "release_time": 1685853374,
        "code": "class Solution:\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\n\n        # make dictionary with default value of [1,1] where first\n        # value represents whether type 0 is processed or not.\n        # Similarly, second value represents whether type 1 is\n        # processed or not\n        d = defaultdict(lambda: [1,1])\n\n        # stores the summation of vlaues of matrix entries\n        ans = 0\n\n        # cr, cc denotes number of rows / columns processed\n        cr, cc = 0, 0\n\n        # start query from reversed fashion as we know the fact we can overwrite the\n        # values\n        for x, y, z in reversed(queries):\n\n            # For index = y and type = x, process the matrix and\n            # later, make the value to 0.\n            # (Remember, we move in reversed manner)\n            # Eg. for a particular query with index y and type 0,\n            # we made d[y] = [0,1], so that we've liabilty to process\n            # index y with type 1 as it is set to 1\n            if d[y][x]:\n                # x = 0 means type 0, so increment row's count\n                if x == 0:\n                    cr += 1\n                # x = 1 means type 1, so increment col's count\n                else:\n                    cc += 1\n\n                # while processing yth row, we've to remove those columns which are\n                # already processed\n                if x == 0:\n                    remaining = n - cc\n                # while processing yth col, we've to remove those rows which are\n                # already processed\n                else:\n                    remaining = n - cr\n\n                # multiply with value to get the desired result and add to variable ans    \n                ans += remaining * z\n\n                # since, we process the yth row / col depend upon type i.e. x, we can\n                # now mark to 0 (Remember, we move in reversed manner)\n                d[y][x] = 0\n\n        return ans",
        "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def matrixSumQueries(self, n: int, queries: List[List[int]]) -> int:\\n\\n        # make dictionary with default value of [1,1] where first\\n        # value represents whether type 0 is processed or not.\\n        # Similarly, second value represents whether type 1 is\\n        # processed or not\\n        d = defaultdict(lambda: [1,1])\\n\\n        # stores the summation of vlaues of matrix entries\\n        ans = 0\\n\\n        # cr, cc denotes number of rows / columns processed\\n        cr, cc = 0, 0\\n\\n        # start query from reversed fashion as we know the fact we can overwrite the\\n        # values\\n        for x, y, z in reversed(queries):\\n\\n            # For index = y and type = x, process the matrix and\\n            # later, make the value to 0.\\n            # (Remember, we move in reversed manner)\\n            # Eg. for a particular query with index y and type 0,\\n            # we made d[y] = [0,1], so that we\\'ve liabilty to process\\n            # index y with type 1 as it is set to 1\\n            if d[y][x]:\\n                # x = 0 means type 0, so increment row\\'s count\\n                if x == 0:\\n                    cr += 1\\n                # x = 1 means type 1, so increment col\\'s count\\n                else:\\n                    cc += 1\\n\\n                # while processing yth row, we\\'ve to remove those columns which are\\n                # already processed\\n                if x == 0:\\n                    remaining = n - cc\\n                # while processing yth col, we\\'ve to remove those rows which are\\n                # already processed\\n                else:\\n                    remaining = n - cr\\n\\n                # multiply with value to get the desired result and add to variable ans    \\n                ans += remaining * z\\n\\n                # since, we process the yth row / col depend upon type i.e. x, we can\\n                # now mark to 0 (Remember, we move in reversed manner)\\n                d[y][x] = 0\\n\\n        return ans\\n```"
    },
    {
        "slug": "filter-restaurants-by-vegan-friendly-price-and-distance",
        "tags": "python3",
        "release_time": 1631685617,
        "code": "class Solution:\n    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        def f(x):\n            if (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance):\n                return True\n            else:\n                return False\n        y = list(filter(f,restaurants))\n        y.sort(key=lambda a:a[0],reverse=True)\n        y.sort(key=lambda a:a[1],reverse=True)\n        return [i[0] for i in y]",
        "content": "```\\nclass Solution:\\n    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\\n        def f(x):\\n            if (veganFriendly == 1 and x[2] == 1 and x[3] <= maxPrice and x[4] <= maxDistance) or (veganFriendly == 0 and x[3] <= maxPrice and x[4] <= maxDistance):\\n                return True\\n            else:\\n                return False\\n        y = list(filter(f,restaurants))\\n        y.sort(key=lambda a:a[0],reverse=True)\\n        y.sort(key=lambda a:a[1],reverse=True)\\n        return [i[0] for i in y]\\n```\\n**If you like this solution, please upvote for this**"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "tags": "python3",
        "release_time": 1669419936,
        "code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        stack = []\n        res = 0\n        arr = [float('-inf')] + arr + [float('-inf')]\n        for i, num in enumerate(arr):\n            while stack and arr[stack[-1]] > num:\n                cur = stack.pop()\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\n            stack.append(i)\n        return res % (10**9 + 7)",
        "content": "Maintain a stack of indexes of subarrays, \\nwhich would have the minimum number at the top of the stack.\\n \\nUse following logic to compute the sum(i):\\n- If arr[i] is small, then arr[i] is minimum for all subarrays \\nstarting at arr[i].\\n- If arr[i] is greater, then find the smallest element from the top of stack which is bigger than arr[i]. \\n- Let the index of the smallest element be on top. \\n- Now, arr[i] is minimum for all subarrays starting at arr[top+1]. \\n\\nWe already know the value of sum(top), so add sum(top) + arr[i] * (i \\u2013 top) to result. Finally, push the index of arr[i] to stack.\\n\\n# Complexity\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        stack = []\\n        res = 0\\n        arr = [float(\\'-inf\\')] + arr + [float(\\'-inf\\')]\\n        for i, num in enumerate(arr):\\n            while stack and arr[stack[-1]] > num:\\n                cur = stack.pop()\\n                res += arr[cur] * (i - cur) * (cur - stack[-1])\\n            stack.append(i)\\n        return res % (10**9 + 7)\\n\\n```"
    },
    {
        "slug": "kth-largest-element-in-an-array",
        "tags": "python3",
        "release_time": 1691989741,
        "code": "class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        return sorted(nums)[-k]",
        "content": "# Approach\\n- Sorting\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthLargest(self, nums: List[int], k: int) -> int:\\n        return sorted(nums)[-k]\\n```"
    },
    {
        "slug": "count-asterisks",
        "tags": "python3",
        "release_time": 1689442256,
        "code": "class Solution:\n    def countAsterisks(self, s: str) -> int:\n        c=0\n        flag=False\n        for i in s:\n            if (i=='|'):\n                flag=not(flag)\n            if(i=='*' and flag==False):\n                c=c+1\n        return c",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the string and whenever \\'|\\' encounter in string reverse the flag value. And If the flag value is Flase i only count those \\'*\\'.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAsterisks(self, s: str) -> int:\\n        c=0\\n        flag=False\\n        for i in s:\\n            if (i==\\'|\\'):\\n                flag=not(flag)\\n            if(i==\\'*\\' and flag==False):\\n                c=c+1\\n        return c\\n```"
    },
    {
        "slug": "compare-strings-by-frequency-of-the-smallest-character",
        "tags": "python3",
        "release_time": 1680369832,
        "code": "class Solution:\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n        ans = []\n        word_freqs = [f(word) for word in words]\n        known = {}\n\n        for queri in queries:\n            queri_freq = f(queri)\n\n            if queri_freq in known: \n                ans.append(known[queri_freq])\n                continue\n\n            count = 0\n            for word_freq in word_freqs:\n                count += word_freq>queri_freq\n\n            known[queri_freq] = count\n            ans.append(count)\n\n        return ans\n\ndef f(word): return word.count(min(word))",
        "content": "# Approach\\nIt is a optimalized brute force.\\n\\nIn beggining, we just go throught all queries and then throught all words and compare frequencies.\\n\\nBut we dont need to calculate the word frequencies every time again so they are saved in `word_freqs`. Similiarly, once we know the `count` for one `queri_freq` and we see the same frequenci again it is not necessary to calculate it again.\\n\\n# Complexity\\nIn worst case when all queri frequencies are different $$O(n*m + m)$$\\nIn the best case when all queri frequencies are same $$O(n + m)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\\n        ans = []\\n        word_freqs = [f(word) for word in words]\\n        known = {}\\n\\n        for queri in queries:\\n            queri_freq = f(queri)\\n\\n            if queri_freq in known: \\n                ans.append(known[queri_freq])\\n                continue\\n\\n            count = 0\\n            for word_freq in word_freqs:\\n                count += word_freq>queri_freq\\n\\n            known[queri_freq] = count\\n            ans.append(count)\\n\\n        return ans\\n\\ndef f(word): return word.count(min(word))\\n```"
    },
    {
        "slug": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
        "tags": "python3",
        "release_time": 1682855744,
        "code": "class DSU:\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n    \n    def find(self, node):\n        if self.par[node] != node:\n            self.par[node] = self.find(self.par[node])\n        return self.par[node]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if self.rank[px] > self.rank[py]: # py to px\n            self.par[py] = px\n            self.rank[px] += self.rank[py]\n        else: # px to py\n            self.par[px] = py\n            self.rank[py] += self.rank[px]\n\nclass Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        import collections\n        type2edge = collections.defaultdict(list)\n        for ty, u, v in edges:\n            type2edge[ty].append([u, v])\n        \n        ans = 0\n\n        # alice\n        dsua = DSU(n+1)\n        for u, v in type2edge[3]: # join common\n            if dsua.find(u) == dsua.find(v):\n                ans += 1\n            else:\n                dsua.union(u, v)\n        for u, v in type2edge[1]:\n            if dsua.find(u) == dsua.find(v):\n                ans += 1\n            else:\n                dsua.union(u, v)\n        \n        for i in range(n):\n            dsua.find(i)\n        if len(set(dsua.par[1:])) > 1: # diff groups\n            return -1\n        \n        # bob\n        dsub = DSU(n+1)\n        for u, v in type2edge[3]:\n            if dsub.find(u) != dsub.find(v):\n                dsub.union(u, v)\n        for u, v in type2edge[2]:\n            if dsub.find(u) == dsub.find(v):\n                ans += 1\n            else:\n                dsub.union(u, v)\n        \n        for i in range(n):\n            dsub.find(i)\n        if len(set(dsub.par[1:])) > 1:\n            return -1\n        \n        return ans",
        "content": "# Intuition\\nAs long as you know DSU, this question is quite straghtforward.\\n\\nProcess edges in 2 parts:\\n- Join all type 3 edges and then type 1 edges. This denotes all Alice edges. And edges with the same parent can be removed.\\n- Same process will be done by using type 2 edges instead of type 1.\\n\\nCheck if all nodes belong to the same parent finally to see if any nodes cannot be reached.\\n\\n# Approach\\nDSU\\n\\n# Complexity\\n- Time complexity:\\nO(n * alpha(n)) -> DSU operation on input edges list\\n\\n- Space complexity:\\nO(n) -> DSU structure\\'s sc\\n\\n# Code\\n```\\nclass DSU:\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n    \\n    def find(self, node):\\n        if self.par[node] != node:\\n            self.par[node] = self.find(self.par[node])\\n        return self.par[node]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if self.rank[px] > self.rank[py]: # py to px\\n            self.par[py] = px\\n            self.rank[px] += self.rank[py]\\n        else: # px to py\\n            self.par[px] = py\\n            self.rank[py] += self.rank[px]\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        import collections\\n        type2edge = collections.defaultdict(list)\\n        for ty, u, v in edges:\\n            type2edge[ty].append([u, v])\\n        \\n        ans = 0\\n\\n        # alice\\n        dsua = DSU(n+1)\\n        for u, v in type2edge[3]: # join common\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        for u, v in type2edge[1]:\\n            if dsua.find(u) == dsua.find(v):\\n                ans += 1\\n            else:\\n                dsua.union(u, v)\\n        \\n        for i in range(n):\\n            dsua.find(i)\\n        if len(set(dsua.par[1:])) > 1: # diff groups\\n            return -1\\n        \\n        # bob\\n        dsub = DSU(n+1)\\n        for u, v in type2edge[3]:\\n            if dsub.find(u) != dsub.find(v):\\n                dsub.union(u, v)\\n        for u, v in type2edge[2]:\\n            if dsub.find(u) == dsub.find(v):\\n                ans += 1\\n            else:\\n                dsub.union(u, v)\\n        \\n        for i in range(n):\\n            dsub.find(i)\\n        if len(set(dsub.par[1:])) > 1:\\n            return -1\\n        \\n        return ans\\n```"
    },
    {
        "slug": "sequential-digits",
        "tags": "python3",
        "release_time": 1679044521,
        "code": "class Solution:\n    def sequentialDigits(self, low, high):\n        out = []\n        queue = deque(range(1,10))\n        while queue:\n            elem = queue.popleft()\n            if low <= elem <= high:\n                out.append(elem)\n            last = elem % 10\n            if last < 9: queue.append(elem*10 + last + 1)\n                    \n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low, high):\\n        out = []\\n        queue = deque(range(1,10))\\n        while queue:\\n            elem = queue.popleft()\\n            if low <= elem <= high:\\n                out.append(elem)\\n            last = elem % 10\\n            if last < 9: queue.append(elem*10 + last + 1)\\n                    \\n        return out\\n```"
    },
    {
        "slug": "edit-distance",
        "tags": "python3",
        "release_time": 1680104140,
        "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n ,m = len(word1),len(word2)\n        #converting word1 to word2 \n        @lru_cache(None)\n        def rec(i,j):\n            if(i==n and j==m): return 0;\n            elif(i==n):        return m-j\n            elif(j==m):        return n-i\n            elif(word1[i]==word2[j]):\n                 return rec(i+1,j+1)\n            else:\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2's\n            return res\n        return rec(0,0)",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        n ,m = len(word1),len(word2)\\n        #converting word1 to word2 \\n        @lru_cache(None)\\n        def rec(i,j):\\n            if(i==n and j==m): return 0;\\n            elif(i==n):        return m-j\\n            elif(j==m):        return n-i\\n            elif(word1[i]==word2[j]):\\n                 return rec(i+1,j+1)\\n            else:\\n                res = 1+ rec(i,j+1) #  inserting a character from w2 \\n                res = min(res,1+ rec(i+1,j)) # deleting character from w1\\n                res = min( res, 1+ rec(i+1,j+1)) # replacing char of w1 with w2\\'s\\n            return res\\n        return rec(0,0)\\n```"
    },
    {
        "slug": "minimum-subsequence-in-non-increasing-order",
        "tags": "python3",
        "release_time": 1679055285,
        "code": "class Solution:\n    def minSubsequence(self, nums: List[int]) -> List[int]:\n        total = sum(nums)\n        nums.sort(reverse = True)\n        sub_sum, sub_seq = 0, []\n        for x in nums:\n            sub_sum += x\n            total -= x\n            sub_seq.append(x)\n            if sub_sum > total:\n                return sub_seq",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSubsequence(self, nums: List[int]) -> List[int]:\\n        total = sum(nums)\\n        nums.sort(reverse = True)\\n        sub_sum, sub_seq = 0, []\\n        for x in nums:\\n            sub_sum += x\\n            total -= x\\n            sub_seq.append(x)\\n            if sub_sum > total:\\n                return sub_seq\\n```"
    },
    {
        "slug": "maximum-units-on-a-truck",
        "tags": "python3",
        "release_time": 1664769281,
        "code": "class Solution:\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\n            boxTypes = sorted(boxTypes, key = lambda x:x[1],reverse = True)\n            sum = 0\n            i = 0\n            \n            while truckSize: \n                if i >= len(boxTypes):\n                    break \n                sum = sum + boxTypes[i][1]\n                \n                boxTypes[i][0] = boxTypes[i][0]-1\n                if boxTypes[i][0] == 0:\n                    i = i+1\n                truckSize = truckSize - 1\n\n                \n            return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumUnits(self, boxTypes: List[List[int]], truckSize: int) -> int:\\n            boxTypes = sorted(boxTypes, key = lambda x:x[1],reverse = True)\\n            sum = 0\\n            i = 0\\n            \\n            while truckSize: \\n                if i >= len(boxTypes):\\n                    break \\n                sum = sum + boxTypes[i][1]\\n                \\n                boxTypes[i][0] = boxTypes[i][0]-1\\n                if boxTypes[i][0] == 0:\\n                    i = i+1\\n                truckSize = truckSize - 1\\n\\n                \\n            return sum \\n\\n\\n\\n\\n\\n        \\n```"
    },
    {
        "slug": "lexicographically-smallest-palindrome",
        "tags": "python3",
        "release_time": 1684850284,
        "code": "class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        before = 0\n        after = len(s)-1\n        l = [i for i in s]\n        while before <= len(s)/2:\n            l[before] = min(l[before], l[after])\n            l[after] = l[before]\n            before+=1\n            after-=1\n        return \"\".join(l)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 214 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 16.5 MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def makeSmallestPalindrome(self, s: str) -> str:\\n        before = 0\\n        after = len(s)-1\\n        l = [i for i in s]\\n        while before <= len(s)/2:\\n            l[before] = min(l[before], l[after])\\n            l[after] = l[before]\\n            before+=1\\n            after-=1\\n        return \"\".join(l)\\n```"
    },
    {
        "slug": "minimum-total-cost-to-make-arrays-unequal",
        "tags": "python3",
        "release_time": 1670688279,
        "code": "class Solution:\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\n        n=len(nums1)\n        z=Counter(nums1)\n        z1=Counter(nums2)\n        for i in z:\n            if(n-z1[i]<z[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        for i in z1:\n            if(n-z[i]<z1[i]):\n                return -1\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\n                return -1\n        z=Counter([])\n        ans=0\n        flag=0\n        d=defaultdict(list)\n        vis=[0 for i in range(n)]\n        for i in range(n):\n            if(nums1[i]==nums2[i]):\n                z[nums2[i]]+=1\n                ans+=i\n                flag=1\n                d[nums2[i]].append(i)\n        t=0\n        l=z.most_common(len(z))\n        a=0\n        for i in range(1,len(l)):\n            a+=l[i][1]\n            for j in d[l[i][0]]:\n                vis[j]=1\n            z[l[i][0]]=0\n        if(l and a>=l[0][1]):\n            return ans\n        x=0\n        if(l):\n            x=l[0][1]-a\n            z[l[0][0]]=x\n        print(z,ans)\n        for j in z:\n            if(z[j]):\n                for i in range(n):\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\n                        if(flag):\n                            ans+=i\n                            x-=1\n        return ans",
        "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n    O(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalCost(self, nums1: List[int], nums2: List[int]) -> int:\\n        n=len(nums1)\\n        z=Counter(nums1)\\n        z1=Counter(nums2)\\n        for i in z:\\n            if(n-z1[i]<z[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        for i in z1:\\n            if(n-z[i]<z1[i]):\\n                return -1\\n            if(z[i]>=n//2+1 and z1[i]>=n//2+1):\\n                return -1\\n        z=Counter([])\\n        ans=0\\n        flag=0\\n        d=defaultdict(list)\\n        vis=[0 for i in range(n)]\\n        for i in range(n):\\n            if(nums1[i]==nums2[i]):\\n                z[nums2[i]]+=1\\n                ans+=i\\n                flag=1\\n                d[nums2[i]].append(i)\\n        t=0\\n        l=z.most_common(len(z))\\n        a=0\\n        for i in range(1,len(l)):\\n            a+=l[i][1]\\n            for j in d[l[i][0]]:\\n                vis[j]=1\\n            z[l[i][0]]=0\\n        if(l and a>=l[0][1]):\\n            return ans\\n        x=0\\n        if(l):\\n            x=l[0][1]-a\\n            z[l[0][0]]=x\\n        print(z,ans)\\n        for j in z:\\n            if(z[j]):\\n                for i in range(n):\\n                    if(vis[i]==0 and nums1[i]!=j and nums2[i]!=j and x):\\n                        if(flag):\\n                            ans+=i\\n                            x-=1\\n        return ans\\n```"
    },
    {
        "slug": "combinations",
        "tags": "python3",
        "release_time": 1690865172,
        "code": "class Solution:\n    def combine(self, n: int, k: int) -> List[List[int]]:\n        ans = []\n        def recur(cur, i):\n            #found one! len(cur) == k\n            if len(cur) == k:\n                ans.append(cur)\n                return\n            #here's the \\uD83D\\uDD11\n            #if current string plus remaining numbers is less than k-1\n            #we don't have enough numbers remaining to make it to k!\n            #so just quit\n            if len(cur)+(n-i) < k-1:\n                return\n            for j in range(i, n+1):\n                recur(cur[::]+[j], j+1)\n        recur([], 1)\n        return ans",
        "content": "# Intuition\\nIntuition here is that since we must return every single pair, we must go visit them all and backtrack. What makes this solution faster than the other ones is that we stop when we realize there isn\\'t enough numbers left!\\n\\n# Code\\n```\\nclass Solution:\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        ans = []\\n        def recur(cur, i):\\n            #found one! len(cur) == k\\n            if len(cur) == k:\\n                ans.append(cur)\\n                return\\n            #here\\'s the \\uD83D\\uDD11\\n            #if current string plus remaining numbers is less than k-1\\n            #we don\\'t have enough numbers remaining to make it to k!\\n            #so just quit\\n            if len(cur)+(n-i) < k-1:\\n                return\\n            for j in range(i, n+1):\\n                recur(cur[::]+[j], j+1)\\n        recur([], 1)\\n        return ans\\n            \\n```"
    },
    {
        "slug": "find-smallest-letter-greater-than-target",
        "tags": "python3",
        "release_time": 1686295064,
        "code": "class Solution:\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\n        for letter in letters:\n            if letter > target:\n                return letter\n        return letters[0]",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def nextGreatestLetter(self, letters: List[str], target: str) -> str:\\n        for letter in letters:\\n            if letter > target:\\n                return letter\\n        return letters[0]\\n```"
    },
    {
        "slug": "number-of-music-playlists",
        "tags": "python3",
        "release_time": 1691281666,
        "code": "class Solution:\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (goal + 1) for _ in range(n+1)]\n        dp[0][0] = 1\n\n        for i in range(1, n + 1):\n            for j in range(1, goal + 1):\n                dp[i][j] = (dp[i-1][j-1] * (n - i + 1) + dp[i][j-1] * max(i-k, 0)) % MOD\n\n        return dp[n][goal]",
        "content": "Hello **Tenno Leetcoders**, \\n\\nFor this problem, we have a music player containing n different songs, and you want to listen to goal songs during your trip. To avoid boredom, you need to create a playlist with the following conditions:\\n\\n1) Every song is played at least once\\n2) A song can only be played again if k other songs have been played since it was last played\\n    \\n    \\nYou are required to find the number of possible playlists that you can create under these conditions. \\n\\nSince the answer can be very large, we should return it modulo 10^9 + 7.\\n\\n\\n### Explanation\\n\\nSince, we want to find the number of possible playlists we can create, we can use `Bottom-up DP`. \\n\\n#### Base case\\n\\nwhen goal is 0. In this case, there\\'s only one possible playlist of an empty playlist. Therefore, our base case will be `dp[0][0] = 1`.\\n\\n#### Recurrence relation\\n\\n- Using our 2D Array denoted as `dp[i][j]` as the number of possible playlists with i distinct songs chosen out of the n available songs, and the playlist length is j. We need to consider two options, when calculating `dp[i][j]`\\n\\n     1) We can choose a new song\\n     \\n         - To select a new song from the remaining `n - i + 1` songs (since i songs are already chosen). Then, we need to update the playlist length to `j - 1`.\\n         \\n     2) If we choose a song that has already been played\\n     \\n         - We can select a song from the i songs already chosen (since they are distinct). However, to satisfy the condition, we can only choose this song if `j is greater than or equal to k + 1`. In this case, we can update the playlist length to `j - 1`.\\n         \\n- Therefore, our recurrence relation is ` dp[i][j] = (dp[i-1][j-1] * (n - i + 1) + dp[i][j-1] * max(i-k, 0)) % MOD`\\n\\n\\n#### Bottom up\\n\\n- Traverse and fill our DP array using nested loop\\n\\n    1) The outer loop i iterates over the number of distinct songs chosen (from 1 to n)\\n    \\n    2) The inner loop j iterates over the playlist length (from 1 to goal).\\n\\n- Using nested loop, we calculate the possible playlist with our recurrence relation\\n\\n\\n- Return `dp[n][goal]`, which represents the number of possible playlists with `n` distinct songs and a playlist length of `goal`\\n\\n\\n# Code\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def numMusicPlaylists(self, n: int, goal: int, k: int) -> int:\\n        MOD = 10**9 + 7\\n        dp = [[0] * (goal + 1) for _ in range(n+1)]\\n        dp[0][0] = 1\\n\\n        for i in range(1, n + 1):\\n            for j in range(1, goal + 1):\\n                dp[i][j] = (dp[i-1][j-1] * (n - i + 1) + dp[i][j-1] * max(i-k, 0)) % MOD\\n\\n        return dp[n][goal]\\n```\\n\\n**JavaScript**\\n```\\n/**\\n * @param {number} n\\n * @param {number} goal\\n * @param {number} k\\n * @return {number}\\n */\\nvar numMusicPlaylists = function(n, goal, k) {\\n    const MOD = 10**9 + 7\\n    const dp = Array(n + 1).fill(0).map(() => Array(goal + 1).fill(0))\\n    dp[0][0] = 1\\n\\n    for (let i = 1; i <= n; i++){\\n        for (let j = 1; j <= goal; j++){\\n            dp[i][j] = (dp[i-1][j-1] * (n - i + 1) + dp[i][j - 1] * Math.max(i - k, 0)) % MOD\\n        }\\n    }\\n\\n    return dp[n][goal]\\n};\\n```\\n### Time Complexity:  O(n * goal)    \\n### Space Complexity: O(n * goal)\\n\\n***Warframe\\'s Darvo wants you to upvote this post  \\uD83D\\uDE4F\\uD83C\\uDFFB \\u2764\\uFE0F\\u200D\\uD83D\\uDD25***\\n\\n![image](https://assets.leetcode.com/users/images/814f5668-c966-46d7-ba42-e5435c4c1761_1675302761.3081913.gif)\\n"
    },
    {
        "slug": "find-xor-beauty-of-array",
        "tags": "python3",
        "release_time": 1673113863,
        "code": "class Solution:\n    def xorBeauty(self, nums: List[int]) -> int:\n\t\n        s = 0\n        for x in nums:\n            s^=x\n        return s",
        "content": "All the numbers will get cancelled out because of XOR, except the numbers themselves.\\n\\nSo, XOR of the numbers will give the answer\\n\\n```\\nclass Solution:\\n    def xorBeauty(self, nums: List[int]) -> int:\\n\\t\\n        s = 0\\n        for x in nums:\\n            s^=x\\n        return s"
    },
    {
        "slug": "special-permutations",
        "tags": "python3",
        "release_time": 1687061962,
        "code": "class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        MOD = 10 ** 9 + 7\n        n = len(nums)\n        \n        g = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(i+1, n):\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\n                    g[i].append(j)\n                    g[j].append(i)\n\n        @cache\n        def count(src, vst, k):\n            if k == 0:\n                return 1\n            vst |= (1 << src)\n            res = 0\n            for v in g[src]:\n                if not (vst & (1 << v)):\n                    res += count(v, vst, k - 1)\n                    res %= MOD\n            return res\n        \n        ans = 0\n        for i in range(n):\n            ans += count(i, 0, n-1)\n            ans %= MOD\n        return ans",
        "content": "# Intuition & Approach\\n- Construct an undirected graph with `n` nodes (from `0` to `n - 1`).\\n- Two indices `i, j` form an edge if `nums[i]` and `nums[j]` can be adjacent in a permutation.\\n- Run DFS on each source `0 <= i < n` to find the number of paths of length `n - 1`, starting with source `i`.\\n\\n# Code\\n```\\nclass Solution:\\n    def specialPerm(self, nums: List[int]) -> int:\\n        MOD = 10 ** 9 + 7\\n        n = len(nums)\\n        \\n        g = [[] for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                if nums[i] % nums[j] == 0 or nums[j] % nums[i] == 0:\\n                    g[i].append(j)\\n                    g[j].append(i)\\n\\n        @cache\\n        def count(src, vst, k):\\n            if k == 0:\\n                return 1\\n            vst |= (1 << src)\\n            res = 0\\n            for v in g[src]:\\n                if not (vst & (1 << v)):\\n                    res += count(v, vst, k - 1)\\n                    res %= MOD\\n            return res\\n        \\n        ans = 0\\n        for i in range(n):\\n            ans += count(i, 0, n-1)\\n            ans %= MOD\\n        return ans\\n    \\n```"
    },
    {
        "slug": "reverse-bits",
        "tags": "python3",
        "release_time": 1691409836,
        "code": "class Solution:\n    def f(self,n,r,count):\n        if n<1:return r<<(32-count)\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def f(self,n,r,count):\\n        if n<1:return r<<(32-count)\\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\\n    def reverseBits(self, n: int) -> int:return self.f(n,0,0)\\n```"
    },
    {
        "slug": "find-missing-observations",
        "tags": "python3",
        "release_time": 1687268962,
        "code": "class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        curSum=sum(rolls)\n        obv=n+len(rolls)\n        missSum=mean*obv-curSum\n        if missSum>6*n or missSum<0 or missSum<n:\n            return []\n        x=missSum//n\n        res=[x]*n\n        remain=missSum-x*n\n        if remain>0:\n            more=6-x\n            add=remain//more\n            res=res[add:]+[6]*add\n            final=remain%more\n            res[0]+=final\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        curSum=sum(rolls)\\n        obv=n+len(rolls)\\n        missSum=mean*obv-curSum\\n        if missSum>6*n or missSum<0 or missSum<n:\\n            return []\\n        x=missSum//n\\n        res=[x]*n\\n        remain=missSum-x*n\\n        if remain>0:\\n            more=6-x\\n            add=remain//more\\n            res=res[add:]+[6]*add\\n            final=remain%more\\n            res[0]+=final\\n        return res\\n        \\n```"
    },
    {
        "slug": "minimum-operations-to-make-the-array-increasing",
        "tags": "python3",
        "release_time": 1679332435,
        "code": "class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        ans=0\n        for i in range(len(nums)-1):\n            if nums[i]>=nums[i+1]:\n                ans=ans+nums[i]-nums[i+1]+1\n                nums[i+1]=nums[i]+1\n            else:\n                ans+=0\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        ans=0\\n        for i in range(len(nums)-1):\\n            if nums[i]>=nums[i+1]:\\n                ans=ans+nums[i]-nums[i+1]+1\\n                nums[i+1]=nums[i]+1\\n            else:\\n                ans+=0\\n        return ans\\n\\n\\n```"
    },
    {
        "slug": "find-the-value-of-the-partition",
        "tags": "python3",
        "release_time": 1687111553,
        "code": "class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n           \n        nums.sort()\n        min_diff = float('inf')\n        \n        for i in range(1,len(nums)):\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\n            \n        return min_diff",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. The problem tells us that we must make a partition where nums1 and nums2 are non empty. \\n\\n2. If we sort the array, we can make a partition between each pair of adajacent elements where the left element would always be the max of nums1 and the right element in the pair will always be the min of nums2.\\n3. In this way, we can check all possible partitions, save the min as we go, and return it once were through every pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. initialize a min variable to save the min partition value\\n2. sort nums\\n3. iterate over nums array from 1->len(nums)\\n4. compare each adajacent pair with the calculation given in the problem: abs(nums[i] - nums[i-1])\\n5. return the min diff\\n\\n~If this was helpful please upvote! \\n~Thanks for reading :)\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe sort nums and then iterate over nums which is bounded by nlogn for sorting.\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur only additional space comes from min_diff\\n# Code\\n```\\nclass Solution:\\n    def findValueOfPartition(self, nums: List[int]) -> int:\\n           \\n        nums.sort()\\n        min_diff = float(\\'inf\\')\\n        \\n        for i in range(1,len(nums)):\\n            min_diff = min(min_diff, abs(nums[i] - nums[i-1]))\\n            \\n        return min_diff\\n```"
    },
    {
        "slug": "minimum-time-to-complete-trips",
        "tags": "python3",
        "release_time": 1678177862,
        "code": "class Solution:\n    def satisfiesTrip(self,mid, time, totalTrip):\n        trip = 0\n        for t in time:\n            trip += mid//t\n            if trip >= totalTrip:\n                return True\n        return False\n\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\n        time.sort(reverse=True)\n        minimum = min(time)\n        left = minimum\n        right = minimum*totalTrips\n        while left < right:\n            mid = (left+ right)//2\n\n            if self.satisfiesTrip(mid, time, totalTrips):\n                right = mid\n            else:\n                left = mid + 1\n        return right",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```"
    },
    {
        "slug": "fibonacci-number",
        "tags": "python3",
        "release_time": 1687050164,
        "code": "class Solution:\n    def fib(self, n: int) -> int:\n        def fib(n):\n            if Fib[n] != -1:\n                return Fib[n]\n            Fib[n] = fib(n-1) + fib(n-2)\n            return Fib[n]\n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        Fib = [-1 for _ in range(n+1)]\n        Fib[0] = 0\n        Fib[1] = 1\n        return fib(n)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        def fib(n):\\n            if Fib[n] != -1:\\n                return Fib[n]\\n            Fib[n] = fib(n-1) + fib(n-2)\\n            return Fib[n]\\n        if n == 0:\\n            return 0\\n        if n == 1:\\n            return 1\\n        Fib = [-1 for _ in range(n+1)]\\n        Fib[0] = 0\\n        Fib[1] = 1\\n        return fib(n)\\n\\n```"
    },
    {
        "slug": "x-of-a-kind-in-a-deck-of-cards",
        "tags": "python3",
        "release_time": 1669647083,
        "code": "class Solution:\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\n        count = collections.Counter(deck)\n        val = count.values()\n        import math\n        m = math.gcd(*val)\n        if m >= 2:\n            return True \n        else:\n            return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def hasGroupsSizeX(self, deck: List[int]) -> bool:\\n        count = collections.Counter(deck)\\n        val = count.values()\\n        import math\\n        m = math.gcd(*val)\\n        if m >= 2:\\n            return True \\n        else:\\n            return False\\n\\n```"
    },
    {
        "slug": "super-palindromes",
        "tags": "python3",
        "release_time": 1674484457,
        "code": "class Solution:\n    def superpalindromesInRange(self, left: str, right: str) -> int:\n        l = [1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002, 10000001, 10011001, 10100101, 10111101, 11000011, 11011011, 11100111, 11111111, 20000002, 100000001, 100010001, 100020001, 100101001, 100111001, 100121001, 101000101, 101010101, 101020101, 101101101, 101111101, 110000011, 110010011, 110020011, 110101011, 110111011, 111000111, 111010111, 111101111, 111111111, 200000002, 200010002]\n\n        return len([i for i in l if math.sqrt(int(left)) <= i <= math.sqrt(int(right))])",
        "content": "# Approach\\nThe list of palindromic numbers was precalculated.\\nWe just find the numbers in between \\'left\\' and \\'right\\', and return the number of numbers.\\n\\n# Code\\n```\\nclass Solution:\\n    def superpalindromesInRange(self, left: str, right: str) -> int:\\n        l = [1, 2, 3, 11, 22, 101, 111, 121, 202, 212, 1001, 1111, 2002, 10001, 10101, 10201, 11011, 11111, 11211, 20002, 20102, 100001, 101101, 110011, 111111, 200002, 1000001, 1001001, 1002001, 1010101, 1011101, 1012101, 1100011, 1101011, 1102011, 1110111, 1111111, 2000002, 2001002, 10000001, 10011001, 10100101, 10111101, 11000011, 11011011, 11100111, 11111111, 20000002, 100000001, 100010001, 100020001, 100101001, 100111001, 100121001, 101000101, 101010101, 101020101, 101101101, 101111101, 110000011, 110010011, 110020011, 110101011, 110111011, 111000111, 111010111, 111101111, 111111111, 200000002, 200010002]\\n\\n        return len([i for i in l if math.sqrt(int(left)) <= i <= math.sqrt(int(right))])\\n```\\n\\nThe list was calculated from:\\n```\\nfrom math import sqrt\\ndef isPalindrome(num: int) -> bool:\\n    return (n := str(num)) == n[::-1]\\n\\ndef Palindromes(lower_limit: int, upper_limit: int) -> List[int]:\\n    # lower_limit = 1\\n    # upper_limit = (10**18) - 1\\n\\n    nums = []\\n    for i in range(int(math.sqrt(lower_limit)), int(sqrt(upper_limit)) + 1):\\n        if isPalindrome(i):\\n            if isPalindrome(i*i):\\n                nums.append(i)\\n\\n    return nums\\n```"
    },
    {
        "slug": "number-of-ways-to-split-array",
        "tags": "python3",
        "release_time": 1687160167,
        "code": "class Solution:\n    def waysToSplitArray(self, nums: List[int]) -> int:\n        cnt=0\n        left=nums[0]\n        right=sum(nums[1:])\n        if left>=right:\n            cnt+=1\n        for i in range(1,len(nums)-1):\n            left+=nums[i]\n            right-=nums[i]\n            if left>=right:\n                cnt+=1\n        return cnt",
        "content": "# Code\\n```\\nclass Solution:\\n    def waysToSplitArray(self, nums: List[int]) -> int:\\n        cnt=0\\n        left=nums[0]\\n        right=sum(nums[1:])\\n        if left>=right:\\n            cnt+=1\\n        for i in range(1,len(nums)-1):\\n            left+=nums[i]\\n            right-=nums[i]\\n            if left>=right:\\n                cnt+=1\\n        return cnt\\n\\n```\\n\\n***Please Upvote***"
    },
    {
        "slug": "magnetic-force-between-two-balls",
        "tags": "python3",
        "release_time": 1678996971,
        "code": "class Solution:\n    def maxDistance(self, position: List[int], m: int) -> int:\n        # Sort the position array in ascending order\n        position.sort()\n        \n        # Set the left and right bounds for the binary search\n        left, right = 1, position[-1] - position[0]\n\n        # Perform binary search to find the maximum possible minimum magnetic force\n        while left <= right:\n            # Calculate the midpoint of the search range\n            mid = (left + right) // 2\n            \n            # Initialize variables for tracking the number of balls placed and the previous position\n            balls_placed, prev_pos = 1, position[0]\n\n            # Iterate through the remaining baskets and check if we can place the remaining balls\n            for i in range(1, len(position)):\n                if position[i] - prev_pos >= mid:\n                    # If the current basket is far enough from the previous one, place a ball\n                    balls_placed += 1\n                    prev_pos = position[i]\n\n            # If we can place all the balls with the given magnetic force, increase the force\n            if balls_placed >= m:\n                left = mid + 1\n                max_force = mid\n            # Otherwise, decrease the force\n            else:\n                right = mid - 1\n\n        # Return the maximum possible minimum magnetic force\n        return max_force",
        "content": "Please upvote if you like my solution. Let me know in the comments if you have any suggestions to increase performance or readability.\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, position: List[int], m: int) -> int:\\n        # Sort the position array in ascending order\\n        position.sort()\\n        \\n        # Set the left and right bounds for the binary search\\n        left, right = 1, position[-1] - position[0]\\n\\n        # Perform binary search to find the maximum possible minimum magnetic force\\n        while left <= right:\\n            # Calculate the midpoint of the search range\\n            mid = (left + right) // 2\\n            \\n            # Initialize variables for tracking the number of balls placed and the previous position\\n            balls_placed, prev_pos = 1, position[0]\\n\\n            # Iterate through the remaining baskets and check if we can place the remaining balls\\n            for i in range(1, len(position)):\\n                if position[i] - prev_pos >= mid:\\n                    # If the current basket is far enough from the previous one, place a ball\\n                    balls_placed += 1\\n                    prev_pos = position[i]\\n\\n            # If we can place all the balls with the given magnetic force, increase the force\\n            if balls_placed >= m:\\n                left = mid + 1\\n                max_force = mid\\n            # Otherwise, decrease the force\\n            else:\\n                right = mid - 1\\n\\n        # Return the maximum possible minimum magnetic force\\n        return max_force\\n```\\nIn conclusion:\\nI\\'m sure there are many more approaches. I\\'m interested in the thoughts people have on which is best in an interview!\\nHappy coding!\\n"
    },
    {
        "slug": "self-dividing-numbers",
        "tags": "python3",
        "release_time": 1691392822,
        "code": "class Solution:\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\n        res=[]\n        for i in range(left,right+1 ):\n            ch=True\n            for j in str(i):\n                if j!='0':\n                    if i%int(j)!=0:\n                        ch=False\n                else:\n                    ch=False\n                    break   \n            if ch:\n                res.append(i)\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def selfDividingNumbers(self, left: int, right: int) -> List[int]:\\n        res=[]\\n        for i in range(left,right+1 ):\\n            ch=True\\n            for j in str(i):\\n                if j!=\\'0\\':\\n                    if i%int(j)!=0:\\n                        ch=False\\n                else:\\n                    ch=False\\n                    break   \\n            if ch:\\n                res.append(i)\\n        return res\\n```"
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "tags": "python3",
        "release_time": 1692254547,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        preorder_idx=0\n\n        def treeHelper(left, right):\n            nonlocal preorder_idx\n            if left>right:\n                return None\n\n            node_val = preorder[preorder_idx]\n            root=TreeNode(node_val)\n            preorder_idx+=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.left = treeHelper(left, inorder_index-1 )\n            root.right = treeHelper(inorder_index+1, right)\n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:. $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:. $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        preorder_idx=0\\n\\n        def treeHelper(left, right):\\n            nonlocal preorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = preorder[preorder_idx]\\n            root=TreeNode(node_val)\\n            preorder_idx+=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.left = treeHelper(left, inorder_index-1 )\\n            root.right = treeHelper(inorder_index+1, right)\\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```"
    },
    {
        "slug": "ambiguous-coordinates",
        "tags": "python3",
        "release_time": 1605299983,
        "code": "class Solution:\n    def ambiguousCoordinates(self, s: str) -> List[str]:\n        s = s.strip(\"(\").strip(\")\")\n        \n        def fn(s): \n            \"\"\"Return valid numbers from s.\"\"\"\n            if len(s) == 1: return [s]\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\n            if s.endswith(\"0\"): return [s]\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\n        \n        ans = []\n        for i in range(1, len(s)): \n            for x in fn(s[:i]):\n                for y in fn(s[i:]): \n                    ans.append(f\"({x}, {y})\")\n        return ans",
        "content": "Algo\\nThe key is to deal with extraneous zeros. Below rule gives the what\\'s required\\n1) if a string has length 1, return it;\\n2) if a string with length larger than 1 and starts and ends with 0, it cannot contain valid number;\\n3) if a string starts with 0, return `0.xxx`;\\n4) if a string ends with 0, return `xxx0`;\\n5) otherwise, put decimal point in the `n-1` places. \\n\\nImplementation \\n```\\nclass Solution:\\n    def ambiguousCoordinates(self, s: str) -> List[str]:\\n        s = s.strip(\"(\").strip(\")\")\\n        \\n        def fn(s): \\n            \"\"\"Return valid numbers from s.\"\"\"\\n            if len(s) == 1: return [s]\\n            if s.startswith(\"0\") and s.endswith(\"0\"): return []\\n            if s.startswith(\"0\"): return [s[:1] + \".\" + s[1:]]\\n            if s.endswith(\"0\"): return [s]\\n            return [s[:i] + \".\" + s[i:] for i in range(1, len(s))] + [s]\\n        \\n        ans = []\\n        for i in range(1, len(s)): \\n            for x in fn(s[:i]):\\n                for y in fn(s[i:]): \\n                    ans.append(f\"({x}, {y})\")\\n        return ans  \\n```"
    },
    {
        "slug": "bulls-and-cows",
        "tags": "python3",
        "release_time": 1675275739,
        "code": "class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        dic=Counter(secret)-Counter(guess)\n        cnt=0\n        for i in range(len(secret)):\n            if secret[i]==guess[i]:\n                cnt+=1\n        cnt2=len(secret)-sum(dic.values())-cnt\n        return str(cnt)+\"A\"+str(cnt2)+\"B\"",
        "content": "# Code\\n```\\nclass Solution:\\n    def getHint(self, secret: str, guess: str) -> str:\\n        dic=Counter(secret)-Counter(guess)\\n        cnt=0\\n        for i in range(len(secret)):\\n            if secret[i]==guess[i]:\\n                cnt+=1\\n        cnt2=len(secret)-sum(dic.values())-cnt\\n        return str(cnt)+\"A\"+str(cnt2)+\"B\"\\n```"
    },
    {
        "slug": "invalid-transactions",
        "tags": "python3",
        "release_time": 1667938900,
        "code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        invalid = []\n        txn = collections.defaultdict(list)\n        \n        for trn in transactions:\n            name, time, amount, city = trn.split(\",\")\n            txn[name].append([time,amount,city])\n        \n        for trans in range(len(transactions)):\n            name, time, amount, city = transactions[trans].split(\",\")\n            if int(amount) > 1000:\n                invalid.append(transactions[trans])\n            else:\n                for trn in txn[name]:\n                    time_i, _, city_i = trn\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\n                        invalid.append(transactions[trans])\n                        break\n\n        return invalid",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecords all transactions in a hashmap with default value as list, where the hashing key is the name of the transaction. Now in the second pass, it goes through each transaction and checks if amount is > 1000 else it searches all transactions with the same name in O(1) time and loops through it in O(n) time. If it finds a transaction with the conditions i.e. different city and absolute time difference <= 60. It will append it to the final list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        invalid = []\\n        txn = collections.defaultdict(list)\\n        \\n        for trn in transactions:\\n            name, time, amount, city = trn.split(\",\")\\n            txn[name].append([time,amount,city])\\n        \\n        for trans in range(len(transactions)):\\n            name, time, amount, city = transactions[trans].split(\",\")\\n            if int(amount) > 1000:\\n                invalid.append(transactions[trans])\\n            else:\\n                for trn in txn[name]:\\n                    time_i, _, city_i = trn\\n                    if city != city_i and abs(int(time) - int(time_i)) <= 60:\\n                        invalid.append(transactions[trans])\\n                        break\\n\\n        return invalid\\n```"
    },
    {
        "slug": "reconstruct-original-digits-from-english",
        "tags": "python3",
        "release_time": 1673745897,
        "code": "class Solution:\n    def originalDigits(self, s: str) -> str:\n        from collections import Counter\n        c = Counter(s)\n        nums = [0] * 10\n        nums[0] = c['z']\n        nums[2] = c['w']\n        nums[4] = c['u']\n        nums[6] = c['x']\n        nums[8] = c['g']\n        nums[1] = c['o'] - nums[0] - nums[2] - nums[4]\n        nums[3] = c['h'] - nums[8]\n        nums[5] = c['f'] - nums[4]\n        nums[7] = c['s'] - nums[6]\n        nums[9] = c['i'] - nums[5] - nums[6] - nums[8]\n        return ''.join(str(i) * n for i, n in enumerate(nums))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the unique digits in the given string by counting the number of occurrences of each letter in the string and using that information to deduce the number of each digit.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a counter to count the number of occurrences of each letter in the string. We can then use this information to deduce the number of each digit by subtracting the number of occurrences of other letters that are used in the formation of that digit. For example, the number of occurrences of the letter \\'o\\' can be used to deduce the number of occurrences of the digit \\'1\\' and \\'0\\' since \\'1\\' and \\'0\\' both use the letter \\'o\\'. We can then construct the final string by concatenating the digit with the number of occurrences of that digit.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere n is the length of the input string. We are iterating through the string once to count the occurrences of each letter and then again to construct the final string.\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe only need a fixed number of variables to store the occurrences of each digit and the counter.\\n# Code\\n```\\nclass Solution:\\n    def originalDigits(self, s: str) -> str:\\n        from collections import Counter\\n        c = Counter(s)\\n        nums = [0] * 10\\n        nums[0] = c[\\'z\\']\\n        nums[2] = c[\\'w\\']\\n        nums[4] = c[\\'u\\']\\n        nums[6] = c[\\'x\\']\\n        nums[8] = c[\\'g\\']\\n        nums[1] = c[\\'o\\'] - nums[0] - nums[2] - nums[4]\\n        nums[3] = c[\\'h\\'] - nums[8]\\n        nums[5] = c[\\'f\\'] - nums[4]\\n        nums[7] = c[\\'s\\'] - nums[6]\\n        nums[9] = c[\\'i\\'] - nums[5] - nums[6] - nums[8]\\n        return \\'\\'.join(str(i) * n for i, n in enumerate(nums))\\n\\n```"
    },
    {
        "slug": "as-far-from-land-as-possible",
        "tags": "python3",
        "release_time": 1676052421,
        "code": "class Solution:\n    def maxDistance(self, grid: List[List[int]]) -> int:\n        n, land, stack= len(grid), 0, []\n\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j]:\n                    land+= 1\n                    stack.append((i, j, 0))\n\n        if land== n* n or not stack: return -1\n\n        for i, j, distance in stack:\n            for x, y in ((i, j+ 1), (i, j- 1), (i+ 1, j), (i- 1, j)):\n                if 0<= x< n and 0<= y< n and grid[x][y]== 0:\n                    grid[x][y]= 1\n                    stack.append((x, y, distance+ 1))\n        \n        return stack[-1][-1]",
        "content": "# Intuition\\n- Get all the index of land, check if there is only land if no, then one-by-one convert all adjacent indices(Breadth-First-Search approach) to land while incrementing the distance. At last return the last distance of land.\\n\\n# Approach\\n1. Initializing,\\n    - `n` for matrix of `n x n`\\n    - `land` to check count of land\\n    - `stack` for getting index of land and distance\\n2. Get all the indices of land in the matrix while appending it to stack with distance and incrementing `land` count.\\n3. Check if count of land is not equal to all of matrix or an empty stack, which show the absence of water, thus returning `-1`.\\n4. Iterating through the stack and one-by-one we convert the adjacent indices(Breadth-First-Search approach) to `land` and incrementing the distance. The converted indices are also added to the stack.\\n5. Finally the last element\\'s `distance` in stack is returned.\\n\\n# Complexity\\n- Time complexity : $$O(2n^2)$$\\n- Space complexity : $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, grid: List[List[int]]) -> int:\\n        n, land, stack= len(grid), 0, []\\n\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    land+= 1\\n                    stack.append((i, j, 0))\\n\\n        if land== n* n or not stack: return -1\\n\\n        for i, j, distance in stack:\\n            for x, y in ((i, j+ 1), (i, j- 1), (i+ 1, j), (i- 1, j)):\\n                if 0<= x< n and 0<= y< n and grid[x][y]== 0:\\n                    grid[x][y]= 1\\n                    stack.append((x, y, distance+ 1))\\n        \\n        return stack[-1][-1]\\n```\\n---\\n\\n### Happy Coding \\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\n\\n---\\n\\n### If this solution helped you then do consider Upvoting \\u2B06.\\n#### Lets connect on LinkedIn : [Om Anand](https://www.linkedin.com/in/om-anand-38341a1ba/) \\uD83D\\uDD90\\uD83D\\uDE00\\n---\\n\\n#### Comment your views/corrections \\uD83D\\uDE0A\\n"
    },
    {
        "slug": "single-element-in-a-sorted-array",
        "tags": "python3",
        "release_time": 1676982058,
        "code": "class Solution:\n    def singleNonDuplicate(self, nums: List[int]) -> int:\n        s=0\n        n=len(nums)\n        e=len(nums)-1\n        while(s<=e):\n            mid=s+(e-s)//2\n            if((mid-1)>=0 and nums[mid]==nums[mid-1] ):\n                period=n-1-(mid)\n                if(period%2==1):\n                    s=mid+1\n                else:\n                    e=mid-2                \n            elif((mid+1)<n and nums[mid]==nums[mid+1]):\n                period=n-1-(mid+1)\n                if(period%2==1):\n                    s=mid+2\n                else:\n                    e=mid-1\n            else:\n                return nums[mid]\n        return nums[mid]",
        "content": "# Intuition\\n![image.png](https://assets.leetcode.com/users/images/79bd31ec-9e26-48b2-a0fa-5c9c7cc86f6b_1676982820.2412057.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. start the binary search with start=0 and end=n-1. \\n2. At each step find \\'mid\\' and check if it is the one, present only once, if so return it.\\n3. if mid and mid-1 are having same values,go to 3.1\\n3.1 calculate number of elements remaining from mid to n-1\\n3.2 if this number is even, then the desired ans, is not in this range, thus make :end=mid-2\\n3.3 if odd, the desired ans is in this range, thus make: start=mid+1\\n4. if mid and mid+1 are having same values,go to 4.1\\n4.1 calculate number of elements remaining from mid+1 to n-1\\n4.2 if this number is even, then the desired ans, is not in this range, thus make :end=mid-1\\n4.3 if odd, the desired ans is in this range, thus make: start=mid+2\\n5. repeat step 2,3,4 for the modified start,end till start<=end \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinary search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(N))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def singleNonDuplicate(self, nums: List[int]) -> int:\\n        s=0\\n        n=len(nums)\\n        e=len(nums)-1\\n        while(s<=e):\\n            mid=s+(e-s)//2\\n            if((mid-1)>=0 and nums[mid]==nums[mid-1] ):\\n                period=n-1-(mid)\\n                if(period%2==1):\\n                    s=mid+1\\n                else:\\n                    e=mid-2                \\n            elif((mid+1)<n and nums[mid]==nums[mid+1]):\\n                period=n-1-(mid+1)\\n                if(period%2==1):\\n                    s=mid+2\\n                else:\\n                    e=mid-1\\n            else:\\n                return nums[mid]\\n        return nums[mid]\\n\\n```"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "tags": "python3",
        "release_time": 1691129463,
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        ans=2\n        for i in range(2,len(nums)):\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/7d40d8c6-78b0-4c5f-83f3-e20650fbd9e8_1691129420.0068429.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        ans=2\\n        for i in range(2,len(nums)):\\n            if nums[i]!=nums[ans-2]:nums[ans]=nums[i];ans+=1\\n        return ans\\n```"
    },
    {
        "slug": "find-pivot-index",
        "tags": "python3",
        "release_time": 1690854978,
        "code": "class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        lSum = 0\n        rSum = sum(nums)\n\n        for i in range(len(nums)):\n            rSum -= nums[i]\n            if lSum == rSum:\n                return i\n            lSum += nums[i]\n\n        return -1",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeep count of the left Sum and right Sum. Increase left Sum and decrease Right sum as you traverse the array and return the index when they are equal.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def pivotIndex(self, nums: List[int]) -> int:\\n        lSum = 0\\n        rSum = sum(nums)\\n\\n        for i in range(len(nums)):\\n            rSum -= nums[i]\\n            if lSum == rSum:\\n                return i\\n            lSum += nums[i]\\n\\n        return -1\\n\\n```"
    },
    {
        "slug": "maximum-trailing-zeros-in-a-cornered-path",
        "tags": "python3",
        "release_time": 1677887910,
        "code": "class Solution:\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n\n        m, n = len(grid)+1, len(grid[0])+1\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\n\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\n        \n            val = grid[row][col]\n            for f2 in range(19):\n                if val%2: break\n                val//= 2\n   \n            for f5 in range(6):\n                if val%5: break\n                val//= 5\n        \n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\n        \n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\n            \n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \n\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\n\n        for r in range(1,m):\n            for c in range(1,n):grid[r][c] = pref(r,c)\n\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))",
        "content": "- We construct a prefix sum of 4-tuples, writing over`grid`as we go. For each cell, we determine `(up2, up5, left2, right5)`, the accummulated factors of two and five for the up-direction and the left-direction respectively.\\n\\n- We use the transformed`grid`to determine for each cell the count of zeros over the four paths: up-left, down-left, up-right, down-right.\\n- We determine the max zeros for each cell along the four paths, and then determine the overall max from those cell maxs.\\n```\\nclass Solution:\\n    def maxTrailingZeros(self, grid: list[list[int]]) -> int:\\n\\n        m, n = len(grid)+1, len(grid[0])+1\\n        grid = [[(0,0,0,0)]*n]+[[(0,0,0,0)]+row for row in grid]\\n\\n        def pref(row: int,col: int)-> tuple:        # <-- prefix for each cell\\n        \\n            val = grid[row][col]\\n            for f2 in range(19):\\n                if val%2: break\\n                val//= 2\\n   \\n            for f5 in range(6):\\n                if val%5: break\\n                val//= 5\\n        \\n            (u2, u5, _,_), (_,_, l2, l5) = grid[row-1][col], grid[row][col-1]\\n            return (f2 + u2, f5 + u5, f2 + l2, f5 + l5)\\n        \\n        def countZeros(r: int,c: int)-> int:        #  <--Count the zeros    \\n            up2   ,up5    = grid[r][c][0],grid[r][c][1]\\n            down2 ,down5  = grid[m-1][c][0]-grid[r-1][c][0],grid[m-1][c][1]-grid[r-1][c][1]\\n            \\n            left2 ,left5  = grid[r][c-1][2],grid[r][c-1][3]\\n            right2,right5 = grid[r][n-1][2]-grid[r][c][2],grid[r][n-1][3]-grid[r][c][3] \\n\\n            return max(min(up2+left2 ,up5+left5 ), min(down2+left2 ,down5+left5 ),\\n                       min(up2+right2,up5+right5), min(down2+right2,down5+right5))\\n\\n        for r in range(1,m):\\n            for c in range(1,n):grid[r][c] = pref(r,c)\\n\\n        return max(countZeros(r,c) for c in range(1,n) for r in range(1,m))\\n```\\n[https://leetcode.com/problems/maximum-trailing-zeros-in-a-cornered-path/submissions/908601238/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) (wnere*N* is *mn* and space complexity is probably *O*(*N*) but maybe *O*(1). I\\'m just not sure.\\n"
    },
    {
        "slug": "maximum-distance-between-a-pair-of-values",
        "tags": "python3",
        "release_time": 1681830538,
        "code": "class Solution:\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\n        def binary(left, right, num):\n            farthestPos = 0\n            while left < right:\n                mid = (left + right) // 2\n                if nums2[mid] < num:\n                    right = mid\n                else:\n                    farthestPos = max(farthestPos, mid)\n                    left = mid + 1\n            if nums2[left] >= num:\n                farthestPos = max(farthestPos, left)\n            return farthestPos\n        maxDiff = 0\n        for i in range(min(len(nums1), len(nums2))):\n            if nums1[i] > nums2[i]:\n                continue\n            else:\n                j = binary(i, len(nums2)-1, nums1[i])\n                maxDiff = max(maxDiff, (j-i))\n        return maxDiff",
        "content": "# Intuition\\nThrough the given problem we have few conditions\\n`1. j >= i`\\n`2. nums2[j] > nums1[i]`\\n\\nNow to satisfy these conditions for every element in of nums1 we have to iterate over nums2(i, len(nums2))\\n\\nso we will use **binary search** having the above range always\\nnow if we find *nums[mid] < nums1[i] => we can\\'t consider* this thus shift ur right\\n\\nif *nums[mid] >= nums1[i] => we know the array is in descending order so store this mid index values as farthestSeen* now and shift left pointer.\\n\\n`why not return here?` Because to get the farthest position we have to find element > nums1[i] as far as possible from i\\n\\nCalculate the diff(j-i) and return the maxDiff as your ans :)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxDistance(self, nums1: List[int], nums2: List[int]) -> int:\\n        def binary(left, right, num):\\n            farthestPos = 0\\n            while left < right:\\n                mid = (left + right) // 2\\n                if nums2[mid] < num:\\n                    right = mid\\n                else:\\n                    farthestPos = max(farthestPos, mid)\\n                    left = mid + 1\\n            if nums2[left] >= num:\\n                farthestPos = max(farthestPos, left)\\n            return farthestPos\\n        maxDiff = 0\\n        for i in range(min(len(nums1), len(nums2))):\\n            if nums1[i] > nums2[i]:\\n                continue\\n            else:\\n                j = binary(i, len(nums2)-1, nums1[i])\\n                maxDiff = max(maxDiff, (j-i))\\n        return maxDiff\\n```"
    },
    {
        "slug": "stone-game",
        "tags": "python3",
        "release_time": 1692045615,
        "code": "class Solution:\n    def stoneGame(self, piles: List[int]) -> bool:\n        return True",
        "content": "# Intuition\\nAll the time Alice take the first number. So if alice isn\\'t stupid  she takes the big number of the list. Alice never lose the game.\\n\\n# Approach\\nWrite to the return True\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGame(self, piles: List[int]) -> bool:\\n        return True\\n```"
    },
    {
        "slug": "maximum-twin-sum-of-a-linked-list",
        "tags": "python3",
        "release_time": 1691649359,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def pairSum(self, head: Optional[ListNode]) -> int:\n        def reverse(head):\n            if head==None or head.next==None:\n                return head\n            rh = reverse(head.next)\n            head.next.next=head\n            head.next=None\n            return rh\n        slow = head\n        fast = head\n        while(fast!=None and fast.next!=None):\n            slow=slow.next\n            fast=fast.next.next\n        sh=reverse(slow)\n        curr=head\n        ans=0\n        while(sh!=None):\n            ans=max(ans,curr.val+sh.val)\n            curr=curr.next\n            sh=sh.next\n        return ans",
        "content": "# Intuition\\nThe given solution implements the pairSum function to find the maximum twin sum of a linked list. The concept of twins is defined based on the indices of the nodes in the linked list.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst we will find the middle of the list then we can reverse the list from mid to the last node and after completing these operations we just want to use the slow and fast two pointers approach that works in O(n) Time complexity.\\n\\n**SLOW N FAST POINTERS APPROACH:**\\nTaking slow pointer as head and fast will be pointing to the last node of the respective linked list, (that can be done by reversing the list from middle and simply pointing to the first node of the reversed linkned list). \\nHence, by this approach you can get a time optimized two pointers approach for this respective question.\\n\\n**THANK YOU**\\n\\n\\n*IF YOU LIKE MY APPROACH AND EXPLANATION PLEASE UP VOTE*\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def pairSum(self, head: Optional[ListNode]) -> int:\\n        def reverse(head):\\n            if head==None or head.next==None:\\n                return head\\n            rh = reverse(head.next)\\n            head.next.next=head\\n            head.next=None\\n            return rh\\n        slow = head\\n        fast = head\\n        while(fast!=None and fast.next!=None):\\n            slow=slow.next\\n            fast=fast.next.next\\n        sh=reverse(slow)\\n        curr=head\\n        ans=0\\n        while(sh!=None):\\n            ans=max(ans,curr.val+sh.val)\\n            curr=curr.next\\n            sh=sh.next\\n        return ans\\n```"
    },
    {
        "slug": "rearrange-array-to-maximize-prefix-score",
        "tags": "python3",
        "release_time": 1678598048,
        "code": "class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        \n        nums.sort(reverse=True)\n        \n        return sum(n > 0 for n in accumulate(nums))",
        "content": "```\\nclass Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        \\n        nums.sort(reverse=True)\\n        \\n        return sum(n > 0 for n in accumulate(nums)) \\n```\\n[https://leetcode.com/problems/rearrange-array-to-maximize-prefix-score/submissions/1007225500/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*).\\n"
    },
    {
        "slug": "find-all-good-indices",
        "tags": "python3",
        "release_time": 1677988610,
        "code": "class Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        leftIndices=[]\n        rightIndices=collections.deque()\n        ref = float('inf')\n        init=0\n        for i in range(0,len(nums)):\n            if nums[i]<=ref:\n                leftIndices.append(init)\n            else:\n                init=i\n                leftIndices.append(init)\n            ref=nums[i]\n\n        ref = -float('inf')\n        init=len(nums)-1\n        #print(leftIndices)\n        for i in range(len(nums)-1,-1,-1):\n\n            if nums[i]>ref:\n                init=i\n                rightIndices.appendleft(init)\n            else:\n                rightIndices.appendleft(init)\n            ref = nums[i]\n        #print(rightIndices)\n        ans=[]\n        for i in range(0+k,len(nums)-k):\n            if leftIndices[i-1]<=i-k and rightIndices[i+1]>=i+k:\n                ans.append(i)\n\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        leftIndices=[]\\n        rightIndices=collections.deque()\\n        ref = float(\\'inf\\')\\n        init=0\\n        for i in range(0,len(nums)):\\n            if nums[i]<=ref:\\n                leftIndices.append(init)\\n            else:\\n                init=i\\n                leftIndices.append(init)\\n            ref=nums[i]\\n\\n        ref = -float(\\'inf\\')\\n        init=len(nums)-1\\n        #print(leftIndices)\\n        for i in range(len(nums)-1,-1,-1):\\n\\n            if nums[i]>ref:\\n                init=i\\n                rightIndices.appendleft(init)\\n            else:\\n                rightIndices.appendleft(init)\\n            ref = nums[i]\\n        #print(rightIndices)\\n        ans=[]\\n        for i in range(0+k,len(nums)-k):\\n            if leftIndices[i-1]<=i-k and rightIndices[i+1]>=i+k:\\n                ans.append(i)\\n\\n\\n        return ans\\n\\n\\n\\n\\n\\n        \\n```"
    },
    {
        "slug": "corporate-flight-bookings",
        "tags": "python3",
        "release_time": 1658328675,
        "code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        res = [0]*n\n        for first, last, seat in bookings:\n            res[first - 1] += seat\n            if last < n:\n                res[last] -= seat\n        return accumulate(res)",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n        res = [0]*n\\n        for first, last, seat in bookings:\\n            res[first - 1] += seat\\n            if last < n:\\n                res[last] -= seat\\n        return accumulate(res)\\n```"
    },
    {
        "slug": "number-of-ways-of-cutting-a-pizza",
        "tags": "python3",
        "release_time": 1680234826,
        "code": "class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        self.r = len(pizza)\n        self.c = len(pizza[0])\n        \n        # Step 1, pre-process the apple array and get the prefix sum\n        tot_apples = 0\n        self.pfsum_row = []\n        self.pfsum_col = []\n        \n        for i in range(self.r):\n            pfr = 0\n            pfs_r = [0] * self.c\n            pfs_c = [0] * self.c\n            for j in range(self.c):\n                if i > 0:\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\n                if pizza[i][j] == 'A':\n                    pfr += 1\n                    pfs_c[j] += 1\n                    tot_apples += 1\n                pfs_r[j] = pfr\n            self.pfsum_row.append(pfs_r)\n            self.pfsum_col.append(pfs_c)\n        \n        if tot_apples < k:\n            return 0\n        \n        if k == 1:\n            return 1\n        \n        return self.getWays(0, 0, k) % (1000000007)\n    \n    \n    @cache\n    def getWays(self, i, j, k):\n        if k == 1:\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\n            found = False\n            for c in range(j, self.c):\n                apple_in_region = self.pfsum_col[self.r - 1][c]\n                if i > 0:\n                     apple_in_region -= self.pfsum_col[i - 1][c]\n                if apple_in_region:\n                    found = True\n                    break\n            if found:\n                return 1\n            return 0\n        else:\n            # horizontally cut\n            cannot_cut = True\n            nr = i\n            t_cnt = 0\n            while nr < self.r - 1:\n                # find the first row that we can start cutting\n                while nr < self.r - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\n                    if j > 0:\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nr += 1\n                        \n                if nr < self.r - 1:\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\n                nr += 1\n                \n            # vertically cut\n            cannot_cut = True\n            nc = j\n            while nc < self.c - 1:\n                # find the first col that we can start cutting\n                while nc < self. c - 1 and cannot_cut:\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\n                    if i > 0:\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\n                    if apple_in_region:\n                        cannot_cut = False\n                    else:\n                        nc += 1\n                \n                if nc < self.c - 1:\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\n                nc += 1\n            \n            return t_cnt",
        "content": "The key to this problem is how to count the number of apples on the region we want to cut.\\n\\nWe can simply use the prefix sum that help to identify the number of apples between any two index.\\n\\nTherefore, we need to pre-process the input array, get the prefix sum horizatonally and vertically.\\n\\nWith the prefix sum array, we can create a dp funtion that get the number of cuts in the region (i, j) to (row - 1, col - 1)\\n\\n\\n```\\nclass Solution:\\n    def ways(self, pizza: List[str], k: int) -> int:\\n        self.r = len(pizza)\\n        self.c = len(pizza[0])\\n        \\n        # Step 1, pre-process the apple array and get the prefix sum\\n        tot_apples = 0\\n        self.pfsum_row = []\\n        self.pfsum_col = []\\n        \\n        for i in range(self.r):\\n            pfr = 0\\n            pfs_r = [0] * self.c\\n            pfs_c = [0] * self.c\\n            for j in range(self.c):\\n                if i > 0:\\n                    pfs_c[j] += self.pfsum_col[i - 1][j]\\n                if pizza[i][j] == \\'A\\':\\n                    pfr += 1\\n                    pfs_c[j] += 1\\n                    tot_apples += 1\\n                pfs_r[j] = pfr\\n            self.pfsum_row.append(pfs_r)\\n            self.pfsum_col.append(pfs_c)\\n        \\n        if tot_apples < k:\\n            return 0\\n        \\n        if k == 1:\\n            return 1\\n        \\n        return self.getWays(0, 0, k) % (1000000007)\\n    \\n    \\n    @cache\\n    def getWays(self, i, j, k):\\n        if k == 1:\\n            # if only left one piece for cutting, we just need to check if there is any apple in the region\\n            found = False\\n            for c in range(j, self.c):\\n                apple_in_region = self.pfsum_col[self.r - 1][c]\\n                if i > 0:\\n                     apple_in_region -= self.pfsum_col[i - 1][c]\\n                if apple_in_region:\\n                    found = True\\n                    break\\n            if found:\\n                return 1\\n            return 0\\n        else:\\n            # horizontally cut\\n            cannot_cut = True\\n            nr = i\\n            t_cnt = 0\\n            while nr < self.r - 1:\\n                # find the first row that we can start cutting\\n                while nr < self.r - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_row[nr][self.c - 1]\\n                    if j > 0:\\n                        apple_in_region -= self.pfsum_row[nr][j - 1]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nr += 1\\n                        \\n                if nr < self.r - 1:\\n                    t_cnt += self.getWays(nr + 1, j, k - 1)\\n                nr += 1\\n                \\n            # vertically cut\\n            cannot_cut = True\\n            nc = j\\n            while nc < self.c - 1:\\n                # find the first col that we can start cutting\\n                while nc < self. c - 1 and cannot_cut:\\n                    apple_in_region = self.pfsum_col[self.r - 1][nc]\\n                    if i > 0:\\n                        apple_in_region -= self.pfsum_col[i - 1][nc]\\n                    if apple_in_region:\\n                        cannot_cut = False\\n                    else:\\n                        nc += 1\\n                \\n                if nc < self.c - 1:\\n                    t_cnt += self.getWays(i, nc + 1, k - 1)\\n                nc += 1\\n            \\n            return t_cnt\\n\\n```"
    },
    {
        "slug": "reveal-cards-in-increasing-order",
        "tags": "python3",
        "release_time": 1667400873,
        "code": "class Solution:\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\n        def reveal(n):\n            lst = list(range(n))\n            ans = []\n            i = 0\n            while lst:\n                if not i&1: ans.append(lst.pop(0))\n                else: lst.append(lst.pop(0))\n                i += 1\n            return ans\n        ans = reveal(len(deck))\n        ans = sorted([v, i] for i, v in enumerate(ans))\n        deck.sort()\n        return (deck[j] for i,j in ans)",
        "content": "# Code\\n```\\nclass Solution:\\n    def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:\\n        def reveal(n):\\n            lst = list(range(n))\\n            ans = []\\n            i = 0\\n            while lst:\\n                if not i&1: ans.append(lst.pop(0))\\n                else: lst.append(lst.pop(0))\\n                i += 1\\n            return ans\\n        ans = reveal(len(deck))\\n        ans = sorted([v, i] for i, v in enumerate(ans))\\n        deck.sort()\\n        return (deck[j] for i,j in ans)\\n```"
    },
    {
        "slug": "find-words-that-can-be-formed-by-characters",
        "tags": "python3",
        "release_time": 1670168918,
        "code": "class Solution:\n    def countCharacters(self, words: List[str], chars: str) -> int:\n        ans=[]\n        d1=Counter(chars)\n        for i in range(len(words)):\n            w=[j for j in words[i]]\n            d2=Counter(w)\n        #print(dc)\n        #print(dw)\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n                ans.append(len(w))\n        return sum(ans)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countCharacters(self, words: List[str], chars: str) -> int:\\n        ans=[]\\n        d1=Counter(chars)\\n        for i in range(len(words)):\\n            w=[j for j in words[i]]\\n            d2=Counter(w)\\n        #print(dc)\\n        #print(dw)\\n            if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\\n                ans.append(len(w))\\n        return sum(ans)\\n       \\n```"
    },
    {
        "slug": "root-equals-sum-of-children",
        "tags": "python3",
        "release_time": 1689877766,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        if root.val==root.left.val+root.right.val:\n            return True\n        else:\n            return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/d16f0b89-7c41-4ab2-8a87-436262395422_1689877762.281462.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```"
    },
    {
        "slug": "delete-greatest-value-in-each-row",
        "tags": "python3",
        "release_time": 1670732887,
        "code": "class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for i in range(0, len(grid)):\n            grid[i].sort()\n        n = len(grid[0])\n        res = 0\n        for j in range(0, n):\n            ans = 0\n            for i in range(0, len(grid)):\n                ans = max(ans, grid[i].pop())\n            res += ans\n            \n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```"
    },
    {
        "slug": "check-if-there-is-a-valid-partition-for-the-array",
        "tags": "python3",
        "release_time": 1691945158,
        "code": "class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n\n        checks = (True, False, nums[0] == nums[1])\n\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\n\n            checks  = (checks[1], checks[2],                        # <-- slide the window\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \n\n        return checks[2]",
        "content": "We use a sliding window of fixed length 3, checking element by element, whether any one of the three conditions is satisfied.\\n```\\nclass Solution:\\n    def validPartition(self, nums: List[int]) -> bool:\\n\\n        checks = (True, False, nums[0] == nums[1])\\n\\n        for curr, prev1, prev2 in zip(nums[2:], nums[1:], nums):\\n\\n            checks  = (checks[1], checks[2],                        # <-- slide the window\\n                      (checks[1] and curr == prev1) or              # <-- conditiion 1\\n                      (checks[0] and curr == prev1 == prev2) or     # <-- conditiion 2\\n                      (checks[0] and curr == prev1+1 == prev2+2))   # <-- conditiion 3    \\n\\n        return checks[2]\\n```\\n[https://leetcode.com/problems/check-if-there-is-a-valid-partition-for-the-array/submissions/1020355801/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums)`."
    },
    {
        "slug": "make-k-subarray-sums-equal",
        "tags": "python3",
        "release_time": 1680365297,
        "code": "class Solution:\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\n        lA = len(A)\n        g = gcd(lA, K)\n        retV = 0\n        for i in range(g):\n            med = int(median(A[i::g]))\n            retV += sum(abs(a-med) for a in A[i::g])\n            \n        return retV",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, A: List[int], K: int) -> int:\\n        lA = len(A)\\n        g = gcd(lA, K)\\n        retV = 0\\n        for i in range(g):\\n            med = int(median(A[i::g]))\\n            retV += sum(abs(a-med) for a in A[i::g])\\n            \\n        return retV            \\n```"
    },
    {
        "slug": "majority-element-ii",
        "tags": "python3",
        "release_time": 1691765924,
        "code": "class Solution:\n    def majorityElement(self, nums: List[int]) -> List[int]:\n        n = list(set(nums))\n        l = len(nums)//3\n        res = []\n\n        for i in n:\n            if nums.count(i) > l:\n                res.append(i)\n        \n        return res",
        "content": "# Intuition\\n\\nThe given code uses the **Boyer-Moore Majority Vote** algorithm to find elements in an array that appear more than n/3 times (where n is the length of the array). This algorithm efficiently tracks two potential majority elements while traversing the array twice. It cancels out non-majority elements and validates the candidates\\' counts to determine the final result. This approach provides a linear time solution with minimal space usage, making it effective for solving problems involving finding elements with a certain frequency threshold.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n1. Initialize two potential majority elements (candidate1 and candidate2) and their respective counts (count1 and count2) as 0.\\n\\n2. Loop through the array:\\n\\n* If the current element matches either candidate, increase its count.\\n* If neither candidate has a count, set candidate1 to the current element and initialize count1 to 1.\\n* If neither candidate has a count but the current element is different, set candidate2 and count2.\\n3. Loop through the array again to validate counts:\\n\\n* Count occurrences of candidate1 and candidate2.\\n * If the count of candidate1 exceeds n/3, it\\'s a valid majority element, add it to the result.\\n\\n* If the count of candidate2 exceeds n/3 and it\\'s distinct from candidate1, add it to the result.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def majorityElement(self, nums: List[int]) -> List[int]:\\n        n = list(set(nums))\\n        l = len(nums)//3\\n        res = []\\n\\n        for i in n:\\n            if nums.count(i) > l:\\n                res.append(i)\\n        \\n        return res\\n```"
    },
    {
        "slug": "number-of-unequal-triplets-in-array",
        "tags": "python3",
        "release_time": 1668977607,
        "code": "class Solution:\n    def unequalTriplets(self, nums: List[int]) -> int:\n        from collections import Counter\n        num_count = Counter()\n        n_invalid_pairs = 0\n        n_invalid_triplets = 0\n        for (i, num) in enumerate(nums):\n            n_invalid_triplets += (i-num_count.get(num, 0)) * num_count.get(num, 0)\n            n_invalid_triplets += n_invalid_pairs\n            n_invalid_pairs += num_count[num]\n            num_count[num] += 1\n        n_nums = len(nums)\n        return n_nums * (n_nums-1) * (n_nums-2) // 6 - n_invalid_triplets",
        "content": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        num_count = Counter()\\n        n_invalid_pairs = 0\\n        n_invalid_triplets = 0\\n        for (i, num) in enumerate(nums):\\n            n_invalid_triplets += (i-num_count.get(num, 0)) * num_count.get(num, 0)\\n            n_invalid_triplets += n_invalid_pairs\\n            n_invalid_pairs += num_count[num]\\n            num_count[num] += 1\\n        n_nums = len(nums)\\n        return n_nums * (n_nums-1) * (n_nums-2) // 6 - n_invalid_triplets\\n```"
    },
    {
        "slug": "next-greater-element-iv",
        "tags": "python3",
        "release_time": 1667071080,
        "code": "class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        ans = [-1] * len(nums)\n        s, ss = [], []\n        for i, x in enumerate(nums): \n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\n            buff = []\n            while s and nums[s[-1]] < x: buff.append(s.pop())\n            while buff: ss.append(buff.pop())\n            s.append(i)\n        return ans",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/a90ca3f9de0f99297262514c111f27700c24c04a) for solutions of biweekly 90. \\n\\n```\\nclass Solution:\\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\\n        ans = [-1] * len(nums)\\n        s, ss = [], []\\n        for i, x in enumerate(nums): \\n            while ss and nums[ss[-1]] < x: ans[ss.pop()] = x\\n            buff = []\\n            while s and nums[s[-1]] < x: buff.append(s.pop())\\n            while buff: ss.append(buff.pop())\\n            s.append(i)\\n        return ans \\n```"
    },
    {
        "slug": "construct-quad-tree",
        "tags": "python3",
        "release_time": 1677459150,
        "code": "class Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        level = len(grid)\n        root = None\n        if level >= 1:\n            root = self.buildTree(grid, 0, level, 0, level, level)\n        return root\n        \n        \n    def buildTree(self, grid, rs, re, cs, ce, level):\n        if level == 1:\n            # this is a leaf node:\n            return Node(grid[rs][cs], True, None, None, None, None)\n        \n        next_level = level // 2\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\n        \n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\n            if tl.val == tr.val == bl.val == br.val:\n                new_node = Node(tl.val, True, None, None, None, None)\n            else:\n                new_node = Node(tl.val, False, tl, tr, bl, br)\n        else:\n            new_node = Node(tl.val, False, tl, tr, bl, br)\n            \n        return new_node",
        "content": "This is a simple recursion problem.\\n\\nWe can go from top to bottom (i.e., 2 ^ n -->  1) and build the tree based on the return value of the four children.\\n\\n(1) if the number of element in the grid region is 1, this is a leaf node, we build a new node and return it;\\n(2) check the four children, if they all are leaf nodes and have the same value, we can merge the four nodes by create a new leaf node;\\n(3) otherwise, just build a new node from the four children.\\n\\n\\n```\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        level = len(grid)\\n        root = None\\n        if level >= 1:\\n            root = self.buildTree(grid, 0, level, 0, level, level)\\n        return root\\n        \\n        \\n    def buildTree(self, grid, rs, re, cs, ce, level):\\n        if level == 1:\\n            # this is a leaf node:\\n            return Node(grid[rs][cs], True, None, None, None, None)\\n        \\n        next_level = level // 2\\n        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)\\n        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)\\n        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)\\n        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)\\n        \\n        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf:\\n            if tl.val == tr.val == bl.val == br.val:\\n                new_node = Node(tl.val, True, None, None, None, None)\\n            else:\\n                new_node = Node(tl.val, False, tl, tr, bl, br)\\n        else:\\n            new_node = Node(tl.val, False, tl, tr, bl, br)\\n            \\n        return new_node\\n```"
    },
    {
        "slug": "count-pairs-of-nodes",
        "tags": "python3",
        "release_time": 1615054127,
        "code": "class Solution:\n    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\n        degree = [0]*n\n        freq = defaultdict(int)\n        for u, v in edges: \n            degree[u-1] += 1\n            degree[v-1] += 1\n            freq[min(u-1, v-1), max(u-1, v-1)] += 1\n        \n        vals = sorted(degree)\n        \n        ans = []\n        for query in queries: \n            cnt = 0 \n            lo, hi = 0, n-1\n            while lo < hi: \n                if query < vals[lo] + vals[hi]: \n                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid\n                    hi -= 1\n                else: lo += 1\n            for u, v in freq: \n                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1\n            ans.append(cnt)\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\\n        degree = [0]*n\\n        freq = defaultdict(int)\\n        for u, v in edges: \\n            degree[u-1] += 1\\n            degree[v-1] += 1\\n            freq[min(u-1, v-1), max(u-1, v-1)] += 1\\n        \\n        vals = sorted(degree)\\n        \\n        ans = []\\n        for query in queries: \\n            cnt = 0 \\n            lo, hi = 0, n-1\\n            while lo < hi: \\n                if query < vals[lo] + vals[hi]: \\n                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid\\n                    hi -= 1\\n                else: lo += 1\\n            for u, v in freq: \\n                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1\\n            ans.append(cnt)\\n        return ans\\n```"
    },
    {
        "slug": "count-nodes-with-the-highest-score",
        "tags": "python3",
        "release_time": 1672559597,
        "code": "class Solution:\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\n        n = len(parents)\n        scores = [1] * n\n        graph = [[] for _ in range(n)]\n        for e, i in enumerate(parents):\n            if e: graph[i].append(e)\n        def dfs(i):\n            res = 1\n            for j in graph[i]:\n                val = dfs(j)\n                res += val\n                scores[i] *= val\n            if i: scores[i] *= (n - res)\n            return res\n        dfs(0)\n        return scores.count(max(scores))",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        n = len(parents)\\n        scores = [1] * n\\n        graph = [[] for _ in range(n)]\\n        for e, i in enumerate(parents):\\n            if e: graph[i].append(e)\\n        def dfs(i):\\n            res = 1\\n            for j in graph[i]:\\n                val = dfs(j)\\n                res += val\\n                scores[i] *= val\\n            if i: scores[i] *= (n - res)\\n            return res\\n        dfs(0)\\n        return scores.count(max(scores))\\n```"
    },
    {
        "slug": "sum-multiples",
        "tags": "python3",
        "release_time": 1692096949,
        "code": "class Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        sum1=0\n       \n        for i in range(1,n+1):  \n            if i%3==0 or i%5==0 or i%7==0:\n                sum1+=i\n        return sum1",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfMultiples(self, n: int) -> int:\\n        sum1=0\\n       \\n        for i in range(1,n+1):  \\n            if i%3==0 or i%5==0 or i%7==0:\\n                sum1+=i\\n        return sum1\\n\\n```"
    },
    {
        "slug": "stone-game-vii",
        "tags": "python3",
        "release_time": 1673221624,
        "code": "class Solution:\n    def stoneGameVII(self, stones: List[int]) -> int:\n\n        pref = list(accumulate(stones, initial = 0))\n        \n        @lru_cache(2000)\n        def dp(l: int, r: int)->int:\n\n            return 0 if l == r else max(pref[r  ] - pref[l+1] - dp(l+1, r), \n                                        pref[r-1] - pref[l  ] - dp(l, r-1))\n\n        return dp(0, len(stones))",
        "content": "I had trouble with TLE, even with `@lru_cache(None)`. Someone under the Discussion tab said resetting it to `2000` would help, and it did!\\n```\\nclass Solution:\\n    def stoneGameVII(self, stones: List[int]) -> int:\\n\\n        pref = list(accumulate(stones, initial = 0))\\n        \\n        @lru_cache(2000)\\n        def dp(l: int, r: int)->int:\\n\\n            return 0 if l == r else max(pref[r  ] - pref[l+1] - dp(l+1, r), \\n                                        pref[r-1] - pref[l  ] - dp(l, r-1))\\n\\n        return dp(0, len(stones))\\n```\\n[https://leetcode.com/problems/stone-game-vii/submissions/874367058/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*^2) / *O*(*N*log*N*).\\n"
    },
    {
        "slug": "binary-gap",
        "tags": "python3",
        "release_time": 1667859186,
        "code": "class Solution:\n    def binaryGap(self, n: int) -> int:\n        binary = bin(n)\n        binary= binary[2:]\n        found = False\n        max_count =0\n        for i in range(len(binary)):\n             if(binary[i]=='1' and found ==False):\n                 start= i\n                 found = True\n             elif(binary[i]=='1' and found==True):\n                 count = i- start\n                 start= i\n                 if(count>max_count):\n                     max_count= count\n        return max_count",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def binaryGap(self, n: int) -> int:\\n        binary = bin(n)\\n        binary= binary[2:]\\n        found = False\\n        max_count =0\\n        for i in range(len(binary)):\\n             if(binary[i]==\\'1\\' and found ==False):\\n                 start= i\\n                 found = True\\n             elif(binary[i]==\\'1\\' and found==True):\\n                 count = i- start\\n                 start= i\\n                 if(count>max_count):\\n                     max_count= count\\n        return max_count\\n\\n             \\n```"
    },
    {
        "slug": "handling-sum-queries-after-update",
        "tags": "python3",
        "release_time": 1676740082,
        "code": "class Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        # get nums1 as the binary representation of some number\n        n1 = int(''.join([str(d) for d in nums1]), 2)\n        res = []\n        key = False\n        # calculate sum of nums1 and nums2\n        sum1, sum2 = n1.bit_count(), sum(nums2)\n        for t, left, right in queries:\n            if t == 1:\n                # make xor of nums1 to flip corresponding bits\n                temp = '1'*(right - left + 1) + '0'*(len(nums1) - right - 1)\n                n1 ^= int(temp, 2)\n                key = True\n            if t == 2:\n                # we don't recalculate sum1 when it isn't necessary\n                if key:\n                    sum1 = n1.bit_count()\n                    key = False\n\n                sum2 += left*sum1      \n            if t == 3:\n                res.append(sum2)\n        \n        return res",
        "content": "# Intuition and Description of Algorithm\\nBecause of the size of the input, we need a solution with runtime complexity like $$\\\\mathcal{O}(n)$$. Therefore, we are considering `nums1` as the binary representation of some number. Each time having a query of 1st type we make XOR of `nums1` and $$x=\\\\underbrace{11...11}_{r - l + 1}\\\\underbrace{0...0}_{k}$$, where $$k=$$`len(nums1)-r-1`(i.e. $x$ has ones in the range where we want to flip bits of `nums1`).\\n\\nBesides, a crucial ingredient is the efficient counting of non-zero bits via `bit_count()`.\\n\\nSee details in the code snippet below.\\n\\n---\\n\\n**Please upvote \\u2B06\\uFE0F**\\n\\n---\\n\\n# Complexity\\n- Time complexity: $$\\\\mathcal{O}(n)$$\\n\\n- Space complexity: $$\\\\mathcal{O}(n)$$\\n\\n---\\n\\n# Code\\n```\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        # get nums1 as the binary representation of some number\\n        n1 = int(\\'\\'.join([str(d) for d in nums1]), 2)\\n        res = []\\n        key = False\\n        # calculate sum of nums1 and nums2\\n        sum1, sum2 = n1.bit_count(), sum(nums2)\\n        for t, left, right in queries:\\n            if t == 1:\\n                # make xor of nums1 to flip corresponding bits\\n                temp = \\'1\\'*(right - left + 1) + \\'0\\'*(len(nums1) - right - 1)\\n                n1 ^= int(temp, 2)\\n                key = True\\n            if t == 2:\\n                # we don\\'t recalculate sum1 when it isn\\'t necessary\\n                if key:\\n                    sum1 = n1.bit_count()\\n                    key = False\\n\\n                sum2 += left*sum1      \\n            if t == 3:\\n                res.append(sum2)\\n        \\n        return res                   \\n```"
    },
    {
        "slug": "swim-in-rising-water",
        "tags": "python3",
        "release_time": 1673085608,
        "code": "class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        ROWS = len(grid)\n        COLS = len(grid[0])\n        ref = [[float(\"inf\") for i in range(COLS)] for j in range(ROWS)]\n        hq = [[(grid[ROWS-1][COLS-1]),ROWS-1,COLS-1]]\n        iter = [[-1,0],[1,0],[0,-1],[0,1]]\n        while hq:\n            curr_big,idx_x,idx_y = heapq.heappop(hq)\n            if ref[idx_x][idx_y]>curr_big:\n                ref[idx_x][idx_y] = curr_big\n                for x1,y1 in iter:\n                    x,y = idx_x+x1,idx_y+y1\n                    if x>=0 and x<ROWS and y>=0 and y<COLS:\n                        if (x,y)==(0,0):\n                            print(f'reached')\n                            return max(curr_big,grid[x][y])\n                        \n                        if ref[x][y]>curr_big:\n                            heapq.heappush(hq,[max(curr_big,grid[x][y]),x,y])\n        return ref[0][0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Brute force approach is to start from (0,0) traverse through every item in grid and return the smallest elevation value when we reach n-1,n-1. However this approach could possibly take O(N^N). \\n\\nhence we need a way to take smallest route at any point in time. Using a priority queue instead of a normal queue help us with that\\n\\n# Approach\\n\\n- maintain a priority queue to pick up the smallest elevation point.\\n- maintain a reference of highest elevation value seen for each (x,y), initialize the reference to inf.\\n- start from n-1, n-1 and traverse up to 0,0.\\n- as the traversal is 4-directional,it is possible that we may visit the same (x,y) coordinates again. we should avoid it. we can avoid it by a condition that we step into a x,y only if reference value is greater than the biggest elevation seen in a path. this means we reach a x,y with a lesser elevation value than before. \\n- push the neighbours of the x,y if they are valid\\n- keep updating the reference until we reach 0,0\\n- the first time we reach (0,0), that is the smallest elevation point we could achieve, hence we dont have to traverse any further.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nComplexity to maintain min heap - $$O(n^2 log(n^2))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nreference is a 2D grid as same as size of input array, hence $$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def swimInWater(self, grid: List[List[int]]) -> int:\\n        ROWS = len(grid)\\n        COLS = len(grid[0])\\n        ref = [[float(\"inf\") for i in range(COLS)] for j in range(ROWS)]\\n        hq = [[(grid[ROWS-1][COLS-1]),ROWS-1,COLS-1]]\\n        iter = [[-1,0],[1,0],[0,-1],[0,1]]\\n        while hq:\\n            curr_big,idx_x,idx_y = heapq.heappop(hq)\\n            if ref[idx_x][idx_y]>curr_big:\\n                ref[idx_x][idx_y] = curr_big\\n                for x1,y1 in iter:\\n                    x,y = idx_x+x1,idx_y+y1\\n                    if x>=0 and x<ROWS and y>=0 and y<COLS:\\n                        if (x,y)==(0,0):\\n                            print(f\\'reached\\')\\n                            return max(curr_big,grid[x][y])\\n                        \\n                        if ref[x][y]>curr_big:\\n                            heapq.heappush(hq,[max(curr_big,grid[x][y]),x,y])\\n        return ref[0][0] \\n```"
    },
    {
        "slug": "sort-colors",
        "tags": "python3",
        "release_time": 1688138300,
        "code": "class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        low=mid=0\n        high=len(nums)-1\n        while mid<=high:\n            if nums[mid]==0:\n                nums[low],nums[mid]=nums[mid],nums[low]\n                low+=1\n                mid+=1\n            elif nums[mid]==1:\n                mid+=1\n            else:\n                nums[mid],nums[high]=nums[high],nums[mid]\n                high-=1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f5772358-db82-4340-9282-42f9009586dd_1688138290.4675047.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def sortColors(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        low=mid=0\\n        high=len(nums)-1\\n        while mid<=high:\\n            if nums[mid]==0:\\n                nums[low],nums[mid]=nums[mid],nums[low]\\n                low+=1\\n                mid+=1\\n            elif nums[mid]==1:\\n                mid+=1\\n            else:\\n                nums[mid],nums[high]=nums[high],nums[mid]\\n                high-=1\\n                \\n        \\n\\n            \\n```"
    },
    {
        "slug": "isomorphic-strings",
        "tags": "python3",
        "release_time": 1681628917,
        "code": "class Solution:\n    def isIsomorphic(self, s: str, t: str) -> bool:\n        return len(set(s))==len(set(t))==len(set(zip(s,t)))",
        "content": "# One Line of Code Python Solution\\n```\\nclass Solution:\\n    def isIsomorphic(self, s: str, t: str) -> bool:\\n        return len(set(s))==len(set(t))==len(set(zip(s,t)))\\n```\\n# please upvote me it would encourage me alot\\n\\n```\\nclass Solution:\\n    def isIsomorphic(self, s: str, t: str) -> bool:\\n        dic1,dic2={},{}\\n        for s1,t1 in zip(s,t):\\n            if (s1 in dic1 and dic1[s1]!=t1) or ( t1 in dic2 and dic2[t1]!=s1):\\n                return False\\n            dic1[s1]=t1\\n            dic2[t1]=s1\\n        return True\\n        \\n```\\n# please upvote me it would encourage me alot\\n"
    },
    {
        "slug": "sum-of-nodes-with-even-valued-grandparent",
        "tags": "python3",
        "release_time": 1679723688,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\n        def dfs(root,dad,gp):\n            if not root:\n                return 0\n            x=0\n            if(gp%2==0):\n                x=root.val\n            x+=dfs(root.left,root.val,dad)\n            x+=dfs(root.right,root.val,dad)\n            return x\n\n        return dfs(root,1,1)",
        "content": "![image.png](https://assets.leetcode.com/users/images/6081c989-8823-44d5-bec6-b3295d39c846_1679723623.5277226.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n# Python3\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sumEvenGrandparent(self, root: TreeNode) -> int:\\n        def dfs(root,dad,gp):\\n            if not root:\\n                return 0\\n            x=0\\n            if(gp%2==0):\\n                x=root.val\\n            x+=dfs(root.left,root.val,dad)\\n            x+=dfs(root.right,root.val,dad)\\n            return x\\n\\n        return dfs(root,1,1)\\n```"
    },
    {
        "slug": "minimum-cost-homecoming-of-a-robot-in-a-grid",
        "tags": "python3",
        "release_time": 1691687733,
        "code": "class Solution:\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\n        i,j=startPos\n        a,b=homePos\n        cost=0\n        if i<a:\n            for k in range(i,a):\n                cost+=rowCosts[k+1]\n        else:\n            for m in range(a,i):\n                cost+=rowCosts[m]\n        if j<b:\n            for l in range(j,b):\n                cost+=colCosts[l+1]\n        else:\n            for n in range(b,j):\n                cost+=colCosts[n]\n            \n        return cost",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the question asks about the minimum cost, You just have to go straight to the Home without any extra moves, by directly changing the position of Robot to required Row and Column accordingly. Do refer to the Hint if you don\\'t understand what I mean.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach was to simply traverse through the rows and columns between the Start and Home locations and add the cost of corresponding rows and columns to the `cost` variable.\\n- When the Robot starts at a lower indexed row than the Home, We have to add the cost of the indexes starting from the index of Start\\'s next row, since the Robot is moving to that particular index, including the index of Home\\'s row.\\n- On the contrary, if the Robot starts at a higher indexed row than the Home,We have to add the cost of the indexes starting from the index of the Home to the index of the row, which is just above the Start. The point of this is that the Robot will start to move to the row just above the Home and continue moving upto Home\\'s row. So we are adding the costs of this, just in the Reverse way.\\n- The logic is pretty much same for the Columns.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, startPos: List[int], homePos: List[int], rowCosts: List[int], colCosts: List[int]) -> int:\\n        i,j=startPos\\n        a,b=homePos\\n        cost=0\\n        if i<a:\\n            for k in range(i,a):\\n                cost+=rowCosts[k+1]\\n        else:\\n            for m in range(a,i):\\n                cost+=rowCosts[m]\\n        if j<b:\\n            for l in range(j,b):\\n                cost+=colCosts[l+1]\\n        else:\\n            for n in range(b,j):\\n                cost+=colCosts[n]\\n            \\n        return cost\\n\\n```"
    },
    {
        "slug": "check-if-every-row-and-column-contains-all-numbers",
        "tags": "python3",
        "release_time": 1667568355,
        "code": "class Solution:\n    def checkValid(self, matrix: List[List[int]]) -> bool:\n\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\n                    return False\n                dp_row[i][matrix[i][j]-1] = True\n                dp_col[j][matrix[i][j]-1] = True\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValid(self, matrix: List[List[int]]) -> bool:\\n\\n        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if dp_row[i][matrix[i][j]-1] or dp_col[j][matrix[i][j]-1]:\\n                    return False\\n                dp_row[i][matrix[i][j]-1] = True\\n                dp_col[j][matrix[i][j]-1] = True\\n        return True\\n\\n\\n```"
    },
    {
        "slug": "check-if-word-equals-summation-of-two-words",
        "tags": "python3",
        "release_time": 1687982555,
        "code": "class Solution:\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\n        count_first=''\n        count_sec=''\n        count_target=''\n        for i in firstWord:\n            count_first+=str(ord(i)-97)  \n        for i in secondWord:\n            count_sec+=str(ord(i)-97)\n        for i in targetWord:\n            count_target+=str(ord(i)-97)\n        if int(count_first)+int(count_sec)==int(count_target):\n            return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/142b74d7-ca50-4bd6-9686-d3f7dacc703f_1687982551.3256118.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def isSumEqual(self, firstWord: str, secondWord: str, targetWord: str) -> bool:\\n        count_first=\\'\\'\\n        count_sec=\\'\\'\\n        count_target=\\'\\'\\n        for i in firstWord:\\n            count_first+=str(ord(i)-97)  \\n        for i in secondWord:\\n            count_sec+=str(ord(i)-97)\\n        for i in targetWord:\\n            count_target+=str(ord(i)-97)\\n        if int(count_first)+int(count_sec)==int(count_target):\\n            return True\\n        return False\\n\\n```"
    },
    {
        "slug": "h-index",
        "tags": "python3",
        "release_time": 1686006776,
        "code": "class Solution:\n    def hIndex(self, c: List[int]) -> int:\n        c.sort(reverse=True)\n        if len(c)==1 and c[0]>0:\n            return 1\n        if c[-1]>=len(c):\n            return len(c)\n        for i in range(len(c)):\n            if c[i]<i+1:\n                return i\n        return 0",
        "content": "# Intuition\\nThe problem asks for the h-index of a researcher based on the number of citations received for their papers. The h-index is the maximum value of h such that the researcher has published at least h papers that have each been cited at least h times. To find the h-index, we need to sort the array of citations in descending order and identify the largest h-value that satisfies the given condition.\\n\\n\\n# Approach\\nThe solution begins by sorting the array of citations in reverse order, ensuring that the papers with the highest citation counts are at the beginning. Next, several conditions are checked to determine the h-index. First, if the array contains only one element and it is greater than zero, the h-index is 1. If the smallest value in the sorted array is greater than or equal to the length of the array, the h-index is equal to the array length. Otherwise, the array is traversed, and for each index i, the value at that index is compared to i+1. If the value is less than i+1, i is returned as the h-index. If none of the conditions are met, the h-index is 0.\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution primarily depends on the sorting operation, which has a time complexity of O(n log n), where n is the length of the input array. The subsequent iterations through the array and the condition checks have a linear time complexity of O(n). Therefore, the overall time complexity is O(n log n).\\n\\n\\n- Space complexity:\\nThe solution has a space complexity of O(1) since it only uses a constant amount of extra space to store variables and does not depend on the input size. No additional data structures are employed, and the sorting operation is performed in-place.\\n\\n# Code\\n```\\nclass Solution:\\n    def hIndex(self, c: List[int]) -> int:\\n        c.sort(reverse=True)\\n        if len(c)==1 and c[0]>0:\\n            return 1\\n        if c[-1]>=len(c):\\n            return len(c)\\n        for i in range(len(c)):\\n            if c[i]<i+1:\\n                return i\\n        return 0\\n```"
    },
    {
        "slug": "ways-to-split-array-into-three-subarrays",
        "tags": "python3",
        "release_time": 1609646866,
        "code": "class Solution:\n    def waysToSplit(self, nums: List[int]) -> int:\n        prefix = [0]\n        for x in nums: prefix.append(prefix[-1] + x)\n        \n        ans = 0\n        for i in range(1, len(nums)): \n            j = bisect_left(prefix, 2*prefix[i])\n            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)\n            ans += max(0, min(len(nums), k) - max(i+1, j))\n        return ans % 1_000_000_007",
        "content": "**Algo**\\nCompute prefix array of `nums`. Any at index `i`, you want to find index `j` such at \\n`prefix[i] <= prefix[j] - prefix[i] <= prefix[-1] - prefix[j]`\\nThe rest comes out naturally. \\n\\n**Implementation** \\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = 0\\n        for i in range(1, len(nums)): \\n            j = bisect_left(prefix, 2*prefix[i])\\n            k = bisect_right(prefix, (prefix[i] + prefix[-1])//2)\\n            ans += max(0, min(len(nums), k) - max(i+1, j))\\n        return ans % 1_000_000_007\\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nEdit\\nAdding two pointers approach `O(N)` time\\n```\\nclass Solution:\\n    def waysToSplit(self, nums: List[int]) -> int:\\n        prefix = [0]\\n        for x in nums: prefix.append(prefix[-1] + x)\\n        \\n        ans = j = k = 0 \\n        for i in range(1, len(nums)): \\n            j = max(j, i+1)\\n            while j < len(nums) and 2*prefix[i] > prefix[j]: j += 1\\n            k = max(k, j)\\n            while k < len(nums) and 2*prefix[k] <= prefix[i] + prefix[-1]: k += 1\\n            ans += k - j \\n        return ans % 1_000_000_007\\n```"
    },
    {
        "slug": "count-equal-and-divisible-pairs-in-an-array",
        "tags": "python3",
        "release_time": 1675013059,
        "code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        count=0\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i<j and nums[i]==nums[j] and (i*j)%k==0:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i<j and nums[i]==nums[j] and (i*j)%k==0:\\n                    count+=1\\n        return count\\n```"
    },
    {
        "slug": "number-of-black-blocks",
        "tags": "python3",
        "release_time": 1688880048,
        "code": "from typing import  *\nfrom  collections import *\n\n\nclass Solution:\n\tdef countBlackBlocks(self, n: int, m: int, coordinates: List[List[int]]) -> List[int]:\n\t\tst=set([(x,y) for x,y in coordinates])\n\t\ttot=(n-1)*(m-1)\n\t\tdeg=defaultdict(int)\n\t\tfor x,y in st:\n\t\t\t# deg[(x,y)]+=1\n\t\t\tfor dx,dy in [(-1,-1),(1,1),(-1,1),(1,-1)]:\n\t\t\t\ta,b=x+dx,y+dy\n\t\t\t\tmp=(abs(a+x)//2,abs(b+y)//2)\n\t\t\t\tif a>=0 and b>=0 and a<n and b<m:\n\t\t\t\t\tdeg[mp]+=1\n\t\tans=[0]*5\n\t\t# print(deg)\n\t\tfor i in deg:\n\t\t\tans[deg[i]]+=1\n\t\tans[0]=tot-sum(ans)\n\t\treturn ans",
        "content": "\\n# Code\\n```\\nfrom typing import  *\\nfrom  collections import *\\n\\n\\nclass Solution:\\n\\tdef countBlackBlocks(self, n: int, m: int, coordinates: List[List[int]]) -> List[int]:\\n\\t\\tst=set([(x,y) for x,y in coordinates])\\n\\t\\ttot=(n-1)*(m-1)\\n\\t\\tdeg=defaultdict(int)\\n\\t\\tfor x,y in st:\\n\\t\\t\\t# deg[(x,y)]+=1\\n\\t\\t\\tfor dx,dy in [(-1,-1),(1,1),(-1,1),(1,-1)]:\\n\\t\\t\\t\\ta,b=x+dx,y+dy\\n\\t\\t\\t\\tmp=(abs(a+x)//2,abs(b+y)//2)\\n\\t\\t\\t\\tif a>=0 and b>=0 and a<n and b<m:\\n\\t\\t\\t\\t\\tdeg[mp]+=1\\n\\t\\tans=[0]*5\\n\\t\\t# print(deg)\\n\\t\\tfor i in deg:\\n\\t\\t\\tans[deg[i]]+=1\\n\\t\\tans[0]=tot-sum(ans)\\n\\t\\treturn ans\\n\\n\\n```"
    },
    {
        "slug": "number-of-laser-beams-in-a-bank",
        "tags": "python3",
        "release_time": 1689806859,
        "code": "class Solution:\n    def numberOfBeams(self, bank: List[str]) -> int:\n        su = 0\n        a = []\n        for i in range(len(bank)):\n            count = 0\n            for j in range(len(bank[i])):\n                if bank[i][j]=='1':\n                    count+=1\n            if count>0:\n                a.append(count)\n        if len(a)<=1:\n            return 0\n        else:\n            for i in range(len(a)-1):\n                su+=a[i]*a[i+1]\n        return su",
        "content": "```\\nclass Solution:\\n    def numberOfBeams(self, bank: List[str]) -> int:\\n        su = 0\\n        a = []\\n        for i in range(len(bank)):\\n            count = 0\\n            for j in range(len(bank[i])):\\n                if bank[i][j]==\\'1\\':\\n                    count+=1\\n            if count>0:\\n                a.append(count)\\n        if len(a)<=1:\\n            return 0\\n        else:\\n            for i in range(len(a)-1):\\n                su+=a[i]*a[i+1]\\n        return su\\n```"
    },
    {
        "slug": "minimum-cost-to-merge-stones",
        "tags": "python3",
        "release_time": 1671760301,
        "code": "class Solution:\n    def mergeStones(self, stones, k):\n        n = len(stones)\n\n        if (n-1)%(k-1): return -1\n\n        ans = [0]\n\n        for i in range(n):\n            ans.append(ans[-1] + stones[i])\n\n        @lru_cache(None)\n        def dfs(lo,hi):\n            if hi-lo+1 < k:\n                return 0\n\n            res = min(dfs(lo,i) + dfs(i+1,hi) for i in range(lo,hi,k-1))\n\n            if (hi-lo)%(k-1) == 0:\n                res += ans[hi+1] - ans[lo]\n\n            return res\n\n        return dfs(0,n-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeStones(self, stones, k):\\n        n = len(stones)\\n\\n        if (n-1)%(k-1): return -1\\n\\n        ans = [0]\\n\\n        for i in range(n):\\n            ans.append(ans[-1] + stones[i])\\n\\n        @lru_cache(None)\\n        def dfs(lo,hi):\\n            if hi-lo+1 < k:\\n                return 0\\n\\n            res = min(dfs(lo,i) + dfs(i+1,hi) for i in range(lo,hi,k-1))\\n\\n            if (hi-lo)%(k-1) == 0:\\n                res += ans[hi+1] - ans[lo]\\n\\n            return res\\n\\n        return dfs(0,n-1)\\n\\n\\n\\n\\n\\n\\n```"
    },
    {
        "slug": "maximum-bags-with-full-capacity-of-rocks",
        "tags": "python3",
        "release_time": 1672116798,
        "code": "import heapq\n\nclass Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        missing_rocks = []\n        num_full_bags = 0\n        \n        for idx, bag in enumerate(capacity):\n            heapq.heappush(missing_rocks, bag - rocks[idx])\n        \n        while missing_rocks:\n            additionalRocks -= heapq.heappop(missing_rocks)\n            if additionalRocks >= 0:\n                num_full_bags += 1\n        \n        return num_full_bags",
        "content": "We just need to calculate the number of missing rocks for each of the bag;\\nPlace the additional rocks into the bag that need the least number of rocks.\\n\\nWe can use a min heap/priority queue to sort the bags based on the missing rocks.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        missing_rocks = []\\n        num_full_bags = 0\\n        \\n        for idx, bag in enumerate(capacity):\\n            heapq.heappush(missing_rocks, bag - rocks[idx])\\n        \\n        while missing_rocks:\\n            additionalRocks -= heapq.heappop(missing_rocks)\\n            if additionalRocks >= 0:\\n                num_full_bags += 1\\n        \\n        return num_full_bags\\n```"
    },
    {
        "slug": "powx-n",
        "tags": "python3",
        "release_time": 1690224460,
        "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n\n        if n < 0: n, x = -n, 1/x\n\n        stack, ans = deque(), 1\n        \n        while n:\n            n, bit = divmod(n,2)\n            stack.append(bit)    \n\n        while stack:\n            bit = stack.pop()\n            ans*= ans\n            if bit: ans*=x\n\n        return ans",
        "content": "With stack:\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n\\n        if n < 0: n, x = -n, 1/x\\n\\n        stack, ans = deque(), 1\\n        \\n        while n:\\n            n, bit = divmod(n,2)\\n            stack.append(bit)    \\n\\n        while stack:\\n            bit = stack.pop()\\n            ans*= ans\\n            if bit: ans*=x\\n\\n        return ans\\n\\n```\\nWith bits:\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int, ans = 1) -> float:\\n\\n        if n < 0: n, x = -n, 1/x\\n\\n        for i in range(n.bit_length()-1,-1,-1):\\n            ans*= ans\\n            if n & (1<<i): ans*=x\\n\\n        return ans\\n```\\n\\n[https://leetcode.com/problems/powx-n/submissions/1002873438/](http://)\\n\\n\\n\\nI could be wrong, but I think that for each solution, the time complexity is *O*(log*N*) and the space complexity is *O*(1), in which *N* ~ `n`."
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "tags": "python3",
        "release_time": 1682922615,
        "code": "class BIT():\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0] * (n + 1)\n\n    def sum(self, i):\n        ans = 0\n        i += 1\n        while i > 0:\n            ans += self.tree[i]\n            i -= (i & (-i))\n        return ans\n\n    def update(self, i, value):\n        i += 1\n        while i <= self.n:\n            self.tree[i] += value\n            i += (i & (-i))\n\n\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool:\n        if Counter(s)!=Counter(t):\n            return False\n        ind = defaultdict(deque)\n        for id, i in enumerate(t):\n            ind[i].append(id)\n        a = []\n        for i in s:\n            a.append(ind[i].popleft())\n        n=len(a)\n        bt=BIT(n+1)\n        ind=defaultdict(lambda :-1)\n        for i in range(n):\n            inv=bt.sum(n)-bt.sum(a[i])\n            bt.update(a[i],1)\n            for dig in range(int(s[i])-1,-1,-1):\n                if ind[dig]>=i-inv:\n                    return False\n            ind[int(s[i])]=i-inv\n        return True",
        "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n    def __init__(self, n):\\n        self.n = n\\n        self.tree = [0] * (n + 1)\\n\\n    def sum(self, i):\\n        ans = 0\\n        i += 1\\n        while i > 0:\\n            ans += self.tree[i]\\n            i -= (i & (-i))\\n        return ans\\n\\n    def update(self, i, value):\\n        i += 1\\n        while i <= self.n:\\n            self.tree[i] += value\\n            i += (i & (-i))\\n\\n\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool:\\n        if Counter(s)!=Counter(t):\\n            return False\\n        ind = defaultdict(deque)\\n        for id, i in enumerate(t):\\n            ind[i].append(id)\\n        a = []\\n        for i in s:\\n            a.append(ind[i].popleft())\\n        n=len(a)\\n        bt=BIT(n+1)\\n        ind=defaultdict(lambda :-1)\\n        for i in range(n):\\n            inv=bt.sum(n)-bt.sum(a[i])\\n            bt.update(a[i],1)\\n            for dig in range(int(s[i])-1,-1,-1):\\n                if ind[dig]>=i-inv:\\n                    return False\\n            ind[int(s[i])]=i-inv\\n        return True\\n\\n\\n```"
    },
    {
        "slug": "lexicographically-smallest-string-after-substring-operation",
        "tags": "python3",
        "release_time": 1687376944,
        "code": "class Solution:\n    def smallestString(self, s: str) -> str:\n        \n        if len(check:=set(s))==1 and check != {'a'}: \n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\n        contiguous,change,ct1,ct2 = True,False,0,0\n\n        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.\n            if i == 'a':ct1+=1                                                  \n            else:break\n        ans='' + 'a' * ct1\n        s = s[ct1:]\n     \n        for cha in s:\n            ct2+=1\n            if cha != 'a':\n                ans+=chr(ord(cha)-1)\n                change=True                               # record operation at least once.\n                continue\n            else:\n                ans+=cha                                  # because 'a' can't converted to 'z'\n                if change:                                # once the change has been made, you can stop when you encounter 'a'\n                    contiguous = False\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\n                break\n        return ans+s[ct2:] if change else ans[:-1]+'z'    # check if it consists entirely of the letter \"a.\"  'aaaa' > 'aaaz'",
        "content": "![image.png](https://assets.leetcode.com/users/images/87e1aa4c-6441-4d67-b2fb-846fc3897b29_1687376176.900977.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestString(self, s: str) -> str:\\n        \\n        if len(check:=set(s))==1 and check != {\\'a\\'}: \\n            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz\\n        contiguous,change,ct1,ct2 = True,False,0,0\\n\\n        for i in s:                                       # deal with begin string = \\'aaaa....\\', speed up the traversal speed.\\n            if i == \\'a\\':ct1+=1                                                  \\n            else:break\\n        ans=\\'\\' + \\'a\\' * ct1\\n        s = s[ct1:]\\n     \\n        for cha in s:\\n            ct2+=1\\n            if cha != \\'a\\':\\n                ans+=chr(ord(cha)-1)\\n                change=True                               # record operation at least once.\\n                continue\\n            else:\\n                ans+=cha                                  # because \\'a\\' can\\'t converted to \\'z\\'\\n                if change:                                # once the change has been made, you can stop when you encounter \\'a\\'\\n                    contiguous = False\\n            if not contiguous:                            # then break , add the remaining string to the end of the ans.\\n                break\\n        return ans+s[ct2:] if change else ans[:-1]+\\'z\\'    # check if it consists entirely of the letter \"a.\"  \\'aaaa\\' > \\'aaaz\\'\\n```\\n\\nMy English may not be very good, but I hope I can still assist you. :>\\n\\n\\n\\n\\n"
    },
    {
        "slug": "linked-list-cycle",
        "tags": "python3",
        "release_time": 1692180651,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        a=b=head\n        while(a!=None and a.next!=None):\n            b=b.next\n            a=a.next.next\n            if(a==b):\n                return True\n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\\n        a=b=head\\n        while(a!=None and a.next!=None):\\n            b=b.next\\n            a=a.next.next\\n            if(a==b):\\n                return True\\n        return False\\n```"
    },
    {
        "slug": "word-subsets",
        "tags": "python3",
        "release_time": 1659140727,
        "code": "class Solution:\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\n        w2 = reduce(operator.or_, map(Counter, words2))\n        return [w1 for w1 in words1 if Counter(w1) >= w2]",
        "content": "```\\nclass Solution:\\n    def wordSubsets(self, words1: List[str], words2: List[str]) -> List[str]:\\n        w2 = reduce(operator.or_, map(Counter, words2))\\n        return [w1 for w1 in words1 if Counter(w1) >= w2]\\n```"
    },
    {
        "slug": "minimum-operations-to-make-a-uni-value-grid",
        "tags": "python3",
        "release_time": 1633838534,
        "code": "class Solution:\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\n        vals = [x for row in grid for x in row]\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\n        return sum(abs(val - median)//x for val in vals)",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        vals = [x for row in grid for x in row]\\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\\n        return sum(abs(val - median)//x for val in vals)\\n```"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "tags": "python3",
        "release_time": 1686416191,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        queue=deque()\n        queue.append(root)\n        lst=[]\n        while queue:\n            levels=[]\n            for i in range(len(queue)):\n                tmp=queue.popleft()\n                if tmp:\n                    levels.append(tmp.val)\n                    queue.append(tmp.left)\n                    queue.append(tmp.right)\n\n            if levels:\n                lst.append(levels)\n        return lst[::-1]",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        queue=deque()\\n        queue.append(root)\\n        lst=[]\\n        while queue:\\n            levels=[]\\n            for i in range(len(queue)):\\n                tmp=queue.popleft()\\n                if tmp:\\n                    levels.append(tmp.val)\\n                    queue.append(tmp.left)\\n                    queue.append(tmp.right)\\n\\n            if levels:\\n                lst.append(levels)\\n        return lst[::-1]\\n```"
    },
    {
        "slug": "minimum-lines-to-represent-a-line-chart",
        "tags": "python3",
        "release_time": 1686912577,
        "code": "class Solution:\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\n        stockPrices.sort()\n        line=1\n        if len(stockPrices)==1:\n            return 0\n        for i in range(1,len(stockPrices)-1):\n            if (stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i+1][0]-stockPrices[i][0])!=(stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]):\n                line+=1\n        return line",
        "content": "# Code\\n```\\nclass Solution:\\n    def minimumLines(self, stockPrices: List[List[int]]) -> int:\\n        stockPrices.sort()\\n        line=1\\n        if len(stockPrices)==1:\\n            return 0\\n        for i in range(1,len(stockPrices)-1):\\n            if (stockPrices[i][1]-stockPrices[i-1][1])*(stockPrices[i+1][0]-stockPrices[i][0])!=(stockPrices[i+1][1]-stockPrices[i][1])*(stockPrices[i][0]-stockPrices[i-1][0]):\\n                line+=1\\n        return line\\n```"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "tags": "python3",
        "release_time": 1687714805,
        "code": "class Solution:\n    def numberOfGoodSubarraySplits(self, N, m = 10**9+7):\n        return any(N)*prod(b-a for a,b in pairwise(i for i,x in enumerate(N) if x))%m",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe multiply difference of indexes of consecutive 1\\'s in the array because we can split the array in one of these indexes. \\n\\nIf we don\\'t have any 1 in the array we should return 0. \\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, N, m = 10**9+7):\\n        return any(N)*prod(b-a for a,b in pairwise(i for i,x in enumerate(N) if x))%m\\n```\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->"
    },
    {
        "slug": "maximum-number-of-groups-with-increasing-length",
        "tags": "python3",
        "release_time": 1690127817,
        "code": "class Solution:\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\n         \n        def good(target):\n\n            current = 0\n\n            for i in range(1, target + 1):\n                current += prefix[i]\n\n                if current < target - i + 1:\n                    return False\n\n                current -= target - i + 1\n\n            return True\n            \n            \n        \n            \n        N = len(usageLimits)\n        l, r = 0, N\n\n\n        prefix = [0] * (N + 1)\n\n        for x in usageLimits:\n            prefix[min(x, N)] += 1\n\n        for i in range(N - 1, -1 , -1):\n            prefix[i] += prefix[i + 1]\n\n        print(prefix)\n        \n    \n        while l < r:  \n            mid = (l + r + 1) // 2\n                \n            if good(mid):\n                l = mid\n                    \n            else:\n                r = mid - 1\n                    \n                    \n        return l",
        "content": "```\\nclass Solution:\\n    def maxIncreasingGroups(self, usageLimits: List[int]) -> int:\\n         \\n        def good(target):\\n\\n            current = 0\\n\\n            for i in range(1, target + 1):\\n                current += prefix[i]\\n\\n                if current < target - i + 1:\\n                    return False\\n\\n                current -= target - i + 1\\n\\n            return True\\n            \\n            \\n        \\n            \\n        N = len(usageLimits)\\n        l, r = 0, N\\n\\n\\n        prefix = [0] * (N + 1)\\n\\n        for x in usageLimits:\\n            prefix[min(x, N)] += 1\\n\\n        for i in range(N - 1, -1 , -1):\\n            prefix[i] += prefix[i + 1]\\n\\n        print(prefix)\\n        \\n    \\n        while l < r:  \\n            mid = (l + r + 1) // 2\\n                \\n            if good(mid):\\n                l = mid\\n                    \\n            else:\\n                r = mid - 1\\n                    \\n                    \\n        return l\\n        \\n        \\n        \\n        \\n        \\n```"
    },
    {
        "slug": "find-subarrays-with-equal-sum",
        "tags": "python3",
        "release_time": 1677612798,
        "code": "class Solution:\n    def findSubarrays(self, nums: List[int]) -> bool:\n        list1=[]\n        for i in range(len(nums)-1):\n            list1.append(sum(nums[i:i+2%(len(nums))]))\n        return sorted(set(list1))!=sorted(list1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubarrays(self, nums: List[int]) -> bool:\\n        list1=[]\\n        for i in range(len(nums)-1):\\n            list1.append(sum(nums[i:i+2%(len(nums))]))\\n        return sorted(set(list1))!=sorted(list1)\\n\\n```"
    },
    {
        "slug": "linked-list-components",
        "tags": "python3",
        "release_time": 1672176390,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\n        my=set([])\n        for i in nums:\n            my.add(i)\n        curr=head\n        # flag=False\n        count=0\n        while curr!=None:\n            flag=False\n            while curr!=None and curr.val in my:\n                flag=True\n                curr=curr.next\n            if flag==True:\n                count+=1\n            if curr!=None and curr.next!=None:\n                curr=curr.next\n            else:\n                break\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```"
    },
    {
        "slug": "camelcase-matching",
        "tags": "python3",
        "release_time": 1669215776,
        "code": "class Solution:\n    def match(self, query, pattern):\n        pidx = 0\n        for i in range(len(query)):\n            if query[i].isupper():\n                if query[i]==pattern[pidx]:\n                    pidx+=1\n                else:\n                    return False\n            else:\n                if query[i]==pattern[pidx]:\n                    pidx+=1  \n            if pidx==len(pattern):\n                for j in range(i+1, len(query)):\n                    if query[j].isupper():\n                        return False\n                return True\n\n            \n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        ans = [False for _ in range(len(queries))]\n        for i in range(len(queries)):\n            if self.match(queries[i], pattern):\n                ans[i]=True\n        return ans",
        "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def match(self, query, pattern):\\n        pidx = 0\\n        for i in range(len(query)):\\n            if query[i].isupper():\\n                if query[i]==pattern[pidx]:\\n                    pidx+=1\\n                else:\\n                    return False\\n            else:\\n                if query[i]==pattern[pidx]:\\n                    pidx+=1  \\n            if pidx==len(pattern):\\n                for j in range(i+1, len(query)):\\n                    if query[j].isupper():\\n                        return False\\n                return True\\n\\n            \\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\\n        ans = [False for _ in range(len(queries))]\\n        for i in range(len(queries)):\\n            if self.match(queries[i], pattern):\\n                ans[i]=True\\n        return ans\\n\\n\\n```"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "tags": "python3",
        "release_time": 1687730663,
        "code": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n       \n        if 1 not in nums: return 0\n\n        nums = ''.join(map(str,nums)).strip('0').split(\"1\")\n\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007",
        "content": "```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n       \\n        if 1 not in nums: return 0\\n\\n        nums = \\'\\'.join(map(str,nums)).strip(\\'0\\').split(\"1\")\\n\\n        return reduce(mul,list(map(lambda x: 1+len(x),nums))) %1000000007\\n```\\n[https://leetcode.com/problems/ways-to-split-array-into-good-subarrays/submissions/979589101/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`."
    },
    {
        "slug": "subtract-the-product-and-sum-of-digits-of-an-integer",
        "tags": "python3",
        "release_time": 1689614414,
        "code": "class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        summ=0\n        prod=1\n        for i in str(n):\n            summ+=int(i)\n            prod*=int(i)\n        return prod-summ",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntravering the number by making it a string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subtractProductAndSum(self, n: int) -> int:\\n        summ=0\\n        prod=1\\n        for i in str(n):\\n            summ+=int(i)\\n            prod*=int(i)\\n        return prod-summ\\n\\n```"
    },
    {
        "slug": "palindrome-partitioning-iv",
        "tags": "python3",
        "release_time": 1668398578,
        "code": "class Solution:\n    def checkPartitioning(self, S):\n        N = len(S)\n        dp = [1] + [0] * N\n        for i in range(2 * N - 1):\n            l = i // 2\n            r = l + (i & 1)\n            while 0 <= l and r < N and S[l] == S[r]:\n                dp[r + 1] |= (dp[l] << 1)\n                l -= 1\n                r += 1\n        return bool(dp[-1] & (1 << 3))",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def checkPartitioning(self, S):\\n        N = len(S)\\n        dp = [1] + [0] * N\\n        for i in range(2 * N - 1):\\n            l = i // 2\\n            r = l + (i & 1)\\n            while 0 <= l and r < N and S[l] == S[r]:\\n                dp[r + 1] |= (dp[l] << 1)\\n                l -= 1\\n                r += 1\\n        return bool(dp[-1] & (1 << 3))\\n```"
    },
    {
        "slug": "rotate-string",
        "tags": "python3",
        "release_time": 1669618423,
        "code": "class Solution:\n    def rotateString(self, s: str, goal: str) -> bool:\n        if s == goal:\n            return True\n\n        s, goal = [*s], [*goal] \n\n        # unpacking the strings (creates list)\n        # ex: 'hello' -> ['h','e','l','l','o']\n\n\n        for x in range(len(s)):\n            a = s[0]\n            s.pop(0); s.append(a)\n            # rotate the string by saving the first character then removing it and then adding it to the end\n\n            if s == goal:\n                return True\n            # checking if the rotated string is the same as the goal\n\n        return False",
        "content": "# Info:\\n\\n![image.png](https://assets.leetcode.com/users/images/ef565030-5995-4081-a8ca-d8c16d1eeb8d_1669609235.0746536.png)\\n\\n# Approach:\\n- Check if `s == goal` at the start\\n- If it isnt, then start rotating the string until you either find `goal` or if you cant, just return `False`\\n\\n# Code:\\n```\\nclass Solution:\\n    def rotateString(self, s: str, goal: str) -> bool:\\n        if s == goal:\\n            return True\\n\\n        s, goal = [*s], [*goal] \\n\\n        # unpacking the strings (creates list)\\n        # ex: \\'hello\\' -> [\\'h\\',\\'e\\',\\'l\\',\\'l\\',\\'o\\']\\n\\n\\n        for x in range(len(s)):\\n            a = s[0]\\n            s.pop(0); s.append(a)\\n            # rotate the string by saving the first character then removing it and then adding it to the end\\n\\n            if s == goal:\\n                return True\\n            # checking if the rotated string is the same as the goal\\n\\n        return False\\n```"
    },
    {
        "slug": "move-zeroes",
        "tags": "python3",
        "release_time": 1585994303,
        "code": "class Solution:\n    def moveZeroes(self, nums: list) -> None:\n        slow = 0\n        for fast in range(len(nums)):\n            if nums[fast] != 0 and nums[slow] == 0:\n                nums[slow], nums[fast] = nums[fast], nums[slow]\n\n            # wait while we find a non-zero element to\n            # swap with you\n            if nums[slow] != 0:\n                slow += 1",
        "content": "Hi there! Here is my solution to this problem that uses two pointers technique.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def moveZeroes(self, nums: list) -> None:\\n        slow = 0\\n        for fast in range(len(nums)):\\n            if nums[fast] != 0 and nums[slow] == 0:\\n                nums[slow], nums[fast] = nums[fast], nums[slow]\\n\\n            # wait while we find a non-zero element to\\n            # swap with you\\n            if nums[slow] != 0:\\n                slow += 1\\n```\\n\\n**Algorithm complexity:**\\n*Time complexity: O(n)*. Our fast pointer does not visit the same spot twice.\\n*Space complexity: O(1)*. All operations are made in-place\\n\\nIf you like my solution, I will really appreciate your upvoting. It will help other python-developers to find it faster. And as always, I wish you an enjoyable time on LeetCode.\\n\\n**Special thanks for the next comments:**\\n[**stanley98745**](https://leetcode.com/problems/move-zeroes/discuss/562911/two-pointers-technique-python-on-time-o1-space/513985)"
    },
    {
        "slug": "distribute-coins-in-binary-tree",
        "tags": "python3",
        "release_time": 1679030850,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\n        # ************ without using dp ************ \n        ans = [0]\n        def postorder(node):\n            if node==None:\n                return (0,0)\n            l = postorder(node.left)\n            r = postorder(node.right)\n            ans[0]+=(abs(l[0]-l[1])+abs(r[0]-r[1]))\n            return (l[0]+r[0]+1,l[1]+r[1]+node.val)\n        temp =root\n        postorder(temp)\n        return ans[0]\n        # ****************** using dp *******************\n        d = dict()\n        ans = [0]\n        def postorder(node):\n            if node==None:\n                return (0,0)\n            l = postorder(node.left)\n            r = postorder(node.right)\n            if id(node) not in d:\n                d[id(node)] = [[l[0],l[1]],[r[0],r[1]]]\n                \n            return (l[0]+r[0]+1,l[1]+r[1]+node.val)\n        temp =root\n        postorder(temp)\n        # print(d)\n        for i,[[a,b],[c,d]] in d.items():\n            ans[0]+=abs(b-a)\n            ans[0]+=abs(c-d)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![leetcode_sol.png](https://assets.leetcode.com/users/images/c5a7b910-cfed-433a-b413-19e5acca573e_1679030504.431541.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirstly create a map to store values of leftNodes, leftCoins, rightNodes and rightCoins for every node as shown in above image.\\n\\nkey in map -> node\\nvalue in map -> [[leftNodes,leftCoins], [rightNodes,rightCoins]]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\\n        # ************ without using dp ************ \\n        ans = [0]\\n        def postorder(node):\\n            if node==None:\\n                return (0,0)\\n            l = postorder(node.left)\\n            r = postorder(node.right)\\n            ans[0]+=(abs(l[0]-l[1])+abs(r[0]-r[1]))\\n            return (l[0]+r[0]+1,l[1]+r[1]+node.val)\\n        temp =root\\n        postorder(temp)\\n        return ans[0]\\n        # ****************** using dp *******************\\n        d = dict()\\n        ans = [0]\\n        def postorder(node):\\n            if node==None:\\n                return (0,0)\\n            l = postorder(node.left)\\n            r = postorder(node.right)\\n            if id(node) not in d:\\n                d[id(node)] = [[l[0],l[1]],[r[0],r[1]]]\\n                \\n            return (l[0]+r[0]+1,l[1]+r[1]+node.val)\\n        temp =root\\n        postorder(temp)\\n        # print(d)\\n        for i,[[a,b],[c,d]] in d.items():\\n            ans[0]+=abs(b-a)\\n            ans[0]+=abs(c-d)\\n        return ans[0]\\n            \\n        \\n        \\n```"
    },
    {
        "slug": "number-of-longest-increasing-subsequence",
        "tags": "python3",
        "release_time": 1689914359,
        "code": "class Solution:\n    def findNumberOfLIS(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[1, 1] for _ in range(n)] # length, cnt\n        max_length = 0\n        for i in range(n):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    if dp[j][0] + 1 > dp[i][0]:\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\n                    elif dp[j][0] + 1 == dp[i][0]:\n                        dp[i][1] = dp[i][1] + dp[j][1]\n            max_length = max(max_length, dp[i][0])\n        res = 0\n        for idx, (length, cnt) in enumerate(dp):\n            if length == max_length:\n                res += cnt\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use dynamic programming to break down the problem into smaller subproblems, find the length and count of LIS ending at each index, and then combine this information to find the total number of longest increasing subsequences in the given array \\'nums\\'.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The function findNumberOfLIS takes an array nums as input and returns the number of longest increasing subsequences.\\n2. We initialize a variable n to store the length of the input array nums.\\n3. The variable dp is a 2D list to store the dynamic programming results. Each element dp[i] represents the information for the subsequence ending at index i. It is a list containing two values: [length, cnt], where length represents the length of the longest increasing subsequence ending at index i, and cnt represents the count of such subsequences.\\n4. We initialize max_length to 0 to keep track of the length of the longest increasing subsequence found so far.\\n5. We iterate over each index i in the range [0, n-1]:\\n    - Initialize dp[i] as [1, 1] (length 1 and count 1) because every element is an LIS of length 1 by itself.\\n    - For each index j in the range [0, i-1]:\\n        - If the element at j is less than the element at i (nums[j] < nums[i]), we have found a potential longer subsequence.\\n        - Compare the length of the LIS ending at j with the current length of LIS ending at i. If dp[j][0] + 1 is greater than dp[i][0], it means we have found a longer subsequence ending at i, so we update dp[i] accordingly. If dp[j][0] + 1 is equal to dp[i][0], it means we have found another subsequence with the same length as the current longest one, so we increment the count dp[i][1] by dp[j][1].\\n    - Update max_length to be the maximum of the current max_length and the length of the LIS ending at index i.\\n6. After finding the max_length, we iterate over dp again to count the number of longest increasing subsequences. We add the count dp[i][1] to res for each index i where the length of LIS is equal to max_length.\\n7. Finally, we return the value of res, which represents the number of longest increasing subsequences.\\n\\n### Time Complexity:\\n- The outer loop runs for n iterations, and the inner loop runs for at most i iterations for each index i. Therefore, the total number of comparisons and updates done in the inner loop is roughly proportional to the sum of the first n positive integers, which is O(n^2).\\n- The subsequent loop that counts the number of longest increasing subsequences also runs in O(n) time.\\n- Overall, the time complexity of the algorithm is O(n^2).\\n\\n### Space Complexity:\\n- The space complexity is O(n) to store the dp list.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findNumberOfLIS(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [[1, 1] for _ in range(n)] # length, cnt\\n        max_length = 0\\n        for i in range(n):\\n            for j in range(i):\\n                if nums[j] < nums[i]:\\n                    if dp[j][0] + 1 > dp[i][0]:\\n                        dp[i] = [dp[j][0] + 1, dp[j][1]]\\n                    elif dp[j][0] + 1 == dp[i][0]:\\n                        dp[i][1] = dp[i][1] + dp[j][1]\\n            max_length = max(max_length, dp[i][0])\\n        res = 0\\n        for idx, (length, cnt) in enumerate(dp):\\n            if length == max_length:\\n                res += cnt\\n        return res\\n```"
    },
    {
        "slug": "replace-elements-in-an-array",
        "tags": "python3",
        "release_time": 1687932229,
        "code": "class Solution:\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\n    index_map = defaultdict(int)\n    for i, n in enumerate(nums):\n      index_map[n] = i\n    \n    for op in operations:\n      n1, n2 = op\n      nums[index_map[n1]] = n2\n      index_map[n2] = index_map[n1]\n    \n    return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def arrayChange(self, nums: List[int], operations: List[List[int]]) -> List[int]:\\n    index_map = defaultdict(int)\\n    for i, n in enumerate(nums):\\n      index_map[n] = i\\n    \\n    for op in operations:\\n      n1, n2 = op\\n      nums[index_map[n1]] = n2\\n      index_map[n2] = index_map[n1]\\n    \\n    return nums\\n\\n```"
    },
    {
        "slug": "number-of-ways-to-reach-a-position-after-exactly-k-steps",
        "tags": "python3",
        "release_time": 1674906437,
        "code": "class Solution:\n\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n        mod = 10**9+7\n        def nCr(n: int, r:int) ->int:\n            if(r == 0):\n                return 1\n            v = [0] * (n+1)\n            v[0] = 1\n            for i in range(1, n+1):\n                for j in range(r, 0, -1):\n                    v[j] = ((v[j] % mod) + (v[j-1] % mod)) % mod\n            return v[r]\n        diff = abs(startPos -  endPos)\n        if(diff > k or diff + k & 1):\n            return 0\n        r = (diff + k)//2\n        return(nCr(k, r))",
        "content": "\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\\n        mod = 10**9+7\\n        def nCr(n: int, r:int) ->int:\\n            if(r == 0):\\n                return 1\\n            v = [0] * (n+1)\\n            v[0] = 1\\n            for i in range(1, n+1):\\n                for j in range(r, 0, -1):\\n                    v[j] = ((v[j] % mod) + (v[j-1] % mod)) % mod\\n            return v[r]\\n        diff = abs(startPos -  endPos)\\n        if(diff > k or diff + k & 1):\\n            return 0\\n        r = (diff + k)//2\\n        return(nCr(k, r))\\n```"
    },
    {
        "slug": "difference-between-maximum-and-minimum-price-sum",
        "tags": "python3",
        "release_time": 1673930294,
        "code": "class Solution:\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\n        # it is the same problem as the finding the maximum path sum of a tree\n        \n        # step 1, build the graph\n        self.G = collections.defaultdict(list)\n        for s, e in edges:\n            self.G[s].append(e)\n            self.G[e].append(s)\n\n        self.visited = set()\n        self.price = price\n        self.ans = 0\n\n        # step 2, start from a random node and DFS traverse the graph\n        #   the maximum path sum will be updated during the traversal, and we can\n        #   return the result after the traversal is done.\n        self.dfs(0)\n        \n        # Since we are using the min heap to track the maximum, we need to return - self.ans\n        return -self.ans\n\n    \n    def dfs(self, idx):\n        self.visited.add(idx)\n\n        ps_f_list, ps_p_list = [], []\n\n        for nidx in self.G[idx]:\n            # for each visiting child we need to get:\n            # (1) the maximum path sum with the end node\n            # (2) the maximum path sum without the end node\n            # We are calculating the difference between maximum path sum and minimum path sum,\n            # the price is always postive, therefore, the minimum path sum is always the root value. When we find a path sum, the maximum difference is the path sum - root value.\n            # The root value can be at any end of this path.\n            # Thus, we need to track two path sum: one is with the end node value, one is not.\n            if nidx not in self.visited:\n                ps_full, ps_partial = self.dfs(nidx)\n                heapq.heappush(ps_f_list, (ps_full, nidx))\n                heapq.heappush(ps_p_list, (ps_partial, nidx))\n\n        max_val = 0\n        if len(ps_f_list) == 1:\n            ps_f_max, _ = heapq.heappop(ps_f_list)\n            ps_p_max, _ = heapq.heappop(ps_p_list)\n            max_val = min(ps_f_max, ps_p_max - self.price[idx])\n            fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\n        elif len(ps_f_list) > 1:\n            ps_f_max, fm_idx = heapq.heappop(ps_f_list)\n            ps_p_max, pm_idx = heapq.heappop(ps_p_list)\n            if fm_idx != pm_idx:\n                max_val = ps_f_max + ps_p_max - self.price[idx]\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\n            else:\n                # get the second bigest price\n                ps_f_max_2, _ = heapq.heappop(ps_f_list)\n                ps_p_max_2, _ = heapq.heappop(ps_p_list)\n                max_val = min(ps_f_max + ps_p_max_2, ps_f_max_2 + ps_p_max) - self.price[idx]\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\n        else:\n            fp_max, pp_max = -self.price[idx], 0\n\n        if max_val < self.ans:\n            self.ans = max_val\n\n        return fp_max, pp_max",
        "content": "This problem is similar to the \"maximum path sum\" problem.\\n\\nWe pick any node, and DFS traverse the graph.\\n\\nFor each of the visiting node, we need to get **(1) the maximum path sum with the end node value; and (2) the maximum path sum without the end value**.\\n\\nSee the details in code:\\n\\n```\\nclass Solution:\\n    def maxOutput(self, n: int, edges: List[List[int]], price: List[int]) -> int:\\n        # it is the same problem as the finding the maximum path sum of a tree\\n        \\n        # step 1, build the graph\\n        self.G = collections.defaultdict(list)\\n        for s, e in edges:\\n            self.G[s].append(e)\\n            self.G[e].append(s)\\n\\n        self.visited = set()\\n        self.price = price\\n        self.ans = 0\\n\\n        # step 2, start from a random node and DFS traverse the graph\\n        #   the maximum path sum will be updated during the traversal, and we can\\n        #   return the result after the traversal is done.\\n        self.dfs(0)\\n        \\n        # Since we are using the min heap to track the maximum, we need to return - self.ans\\n        return -self.ans\\n\\n    \\n    def dfs(self, idx):\\n        self.visited.add(idx)\\n\\n        ps_f_list, ps_p_list = [], []\\n\\n        for nidx in self.G[idx]:\\n            # for each visiting child we need to get:\\n            # (1) the maximum path sum with the end node\\n            # (2) the maximum path sum without the end node\\n            # We are calculating the difference between maximum path sum and minimum path sum,\\n            # the price is always postive, therefore, the minimum path sum is always the root value. When we find a path sum, the maximum difference is the path sum - root value.\\n            # The root value can be at any end of this path.\\n            # Thus, we need to track two path sum: one is with the end node value, one is not.\\n            if nidx not in self.visited:\\n                ps_full, ps_partial = self.dfs(nidx)\\n                heapq.heappush(ps_f_list, (ps_full, nidx))\\n                heapq.heappush(ps_p_list, (ps_partial, nidx))\\n\\n        max_val = 0\\n        if len(ps_f_list) == 1:\\n            ps_f_max, _ = heapq.heappop(ps_f_list)\\n            ps_p_max, _ = heapq.heappop(ps_p_list)\\n            max_val = min(ps_f_max, ps_p_max - self.price[idx])\\n            fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        elif len(ps_f_list) > 1:\\n            ps_f_max, fm_idx = heapq.heappop(ps_f_list)\\n            ps_p_max, pm_idx = heapq.heappop(ps_p_list)\\n            if fm_idx != pm_idx:\\n                max_val = ps_f_max + ps_p_max - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n            else:\\n                # get the second bigest price\\n                ps_f_max_2, _ = heapq.heappop(ps_f_list)\\n                ps_p_max_2, _ = heapq.heappop(ps_p_list)\\n                max_val = min(ps_f_max + ps_p_max_2, ps_f_max_2 + ps_p_max) - self.price[idx]\\n                fp_max, pp_max = ps_f_max - self.price[idx], ps_p_max - self.price[idx]\\n        else:\\n            fp_max, pp_max = -self.price[idx], 0\\n\\n        if max_val < self.ans:\\n            self.ans = max_val\\n\\n        return fp_max, pp_max\\n```"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "tags": "python3",
        "release_time": 1672563712,
        "code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n\n        if k < 10: return len(s) if k >= int(max(s)) else -1\n        \n        k, ans = str(k), 0\n        digits = len(k)\n\n        while s:\n            s = s[digits:] if s[:digits] <= k else s[digits-1:]\n            ans+= 1\n\n        return ans",
        "content": "```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n\\n        if k < 10: return len(s) if k >= int(max(s)) else -1\\n        \\n        k, ans = str(k), 0\\n        digits = len(k)\\n\\n        while s:\\n            s = s[digits:] if s[:digits] <= k else s[digits-1:]\\n            ans+= 1\\n\\n        return ans"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "tags": "python3",
        "release_time": 1671336101,
        "code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        graph = defaultdict(set)\n        for a, b in edges:\n            graph[a].add(b)\n            graph[b].add(a)\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\n        if not odds:\n            return True\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\n            return False\n        elif len(odds) == 2:\n            a, b = odds[0], odds[1]\n            if a not in graph[b]:\n                return True\n            for i in range(1, n + 1):\n                if i not in graph[a] and i not in graph[b]:\n                    return True\n            return False\n        else:\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\n            if a not in graph[b] and c not in graph[d]:\n                return True\n            if a not in graph[c] and b not in graph[d]:\n                return True\n            if a not in graph[d] and b not in graph[c]:\n                return True\n            return False",
        "content": "**Observation**\\nThe key is to note that we can add **at most** two additional edges (possibly none) to the graph.\\n\\n**Implementation**\\nStep 1: Build the graph by going through all edges.\\nStep 2: Find every node with an odd degree.\\nStep 3: Consider each of the case where the number of the nodes with an odd degree is 0, 1, 2, 3, 4, and > 4.\\n\\n**Solution**\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        odds = [a for a in graph if len(graph[a]) % 2 == 1]\\n        if not odds:\\n            return True\\n        elif len(odds) > 4 or len(odds) == 1 or len(odds) == 3:\\n            return False\\n        elif len(odds) == 2:\\n            a, b = odds[0], odds[1]\\n            if a not in graph[b]:\\n                return True\\n            for i in range(1, n + 1):\\n                if i not in graph[a] and i not in graph[b]:\\n                    return True\\n            return False\\n        else:\\n            a, b, c, d = odds[0], odds[1], odds[2], odds[3]\\n            if a not in graph[b] and c not in graph[d]:\\n                return True\\n            if a not in graph[c] and b not in graph[d]:\\n                return True\\n            if a not in graph[d] and b not in graph[c]:\\n                return True\\n            return False\\n```"
    },
    {
        "slug": "maximum-product-of-two-elements-in-an-array",
        "tags": "python3",
        "release_time": 1665401239,
        "code": "class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        lst = sorted(nums)\n        return (lst[-1]-1)*(lst[-2]-1)",
        "content": "```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        lst = sorted(nums)\\n        return (lst[-1]-1)*(lst[-2]-1)\\n```\\n\\n**In case of improvement and suggestion, please let me know**\\n\\nImproved solution\\n```\\n\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        largest_num = float(\\'-inf\\')\\n        second_num = float(\\'-inf\\')\\n        \\n        for num in nums:\\n            if largest_num <= num:\\n                second_num = largest_num\\n                largest_num = num \\n                \\n            if num < largest_num and num > second_num:\\n                second_num = num\\n        return (largest_num-1)*(second_num - 1)\\n```\\n\\n```\\nclass Solution:\\n    def maxProduct(self, nums: List[int]) -> int:\\n        largest_num = float(\\'-inf\\')\\n        second_num = float(\\'-inf\\')        \\n        for num in lst:\\n            if largest_num <= num:\\n                second_num  = largest_num\\n                largest_num  = num\\n        \\n            if num < largest_num and num > second_num:\\n                second_num = num\\n        \\n        return (largest_num-1)*(second_num - 1)\\n```\\n\\n\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxProduct = function(nums) {\\n    let largest = 0, second=0;\\n    for(const num of nums){\\n        if(num > largest){\\n           [second,largest] = [largest,num]\\n           console.log(largest,second)\\n        }\\n        else if(num > second){\\n            second = num\\n        }\\n\\n    }\\n    console.log(largest,second)\\n    return (largest-1)*(second-1)\\n};\\n```\\n\\n"
    },
    {
        "slug": "largest-number-after-mutating-substring",
        "tags": "python3",
        "release_time": 1627185674,
        "code": "class Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n        for i, ch in enumerate(num): \n            x = int(ch)\n            if x < change[x]: \n                on = True\n                num[i] = str(change[x])\n            elif x > change[x] and on: break\n        return \"\".join(num)",
        "content": "\\n```\\nclass Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n```"
    },
    {
        "slug": "largest-element-in-an-array-after-merge-operations",
        "tags": "python3",
        "release_time": 1690655397,
        "code": "class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        ans,sum_ = -inf,nums.pop()\n        while nums:\n            if nums[-1] <= sum_:\n                ans=max(ans,(sum_:=sum_+nums.pop()))\n            else:\n                sum_=nums.pop()\n        return max(ans,sum_)",
        "content": "![image.png](https://assets.leetcode.com/users/images/613a2a8a-1b1b-43d1-af59-6cecf094b567_1690655311.0281165.png)\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxArrayValue(self, nums: List[int]) -> int:\\n        ans,sum_ = -inf,nums.pop()\\n        while nums:\\n            if nums[-1] <= sum_:\\n                ans=max(ans,(sum_:=sum_+nums.pop()))\\n            else:\\n                sum_=nums.pop()\\n        return max(ans,sum_)\\n            \\n            \\n```"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "tags": "python3",
        "release_time": 1676664650,
        "code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        left=0\n        right=len(nums)-1\n        total=0\n        while left<=right:\n            if left<right:\n                total+=int(str(nums[left])+str(nums[right]))\n            else:\n                total+=nums[left]\n            left+=1\n            right-=1\n        return total",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        left=0\\n        right=len(nums)-1\\n        total=0\\n        while left<=right:\\n            if left<right:\\n                total+=int(str(nums[left])+str(nums[right]))\\n            else:\\n                total+=nums[left]\\n            left+=1\\n            right-=1\\n        return total\\n```"
    },
    {
        "slug": "fizz-buzz",
        "tags": "python3",
        "release_time": 1691410928,
        "code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                arr.append(\"FizzBuzz\")\n            elif i%3==0:\n                arr.append(\"Fizz\")\n            elif i%5==0:\n                arr.append(\"Buzz\")\n            else:\n                arr.append(str(i))\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                arr.append(\"FizzBuzz\")\\n            elif i%3==0:\\n                arr.append(\"Fizz\")\\n            elif i%5==0:\\n                arr.append(\"Buzz\")\\n            else:\\n                arr.append(str(i))\\n        return arr\\n\\n\\n```"
    },
    {
        "slug": "combination-sum-ii",
        "tags": "python3",
        "release_time": 1682780809,
        "code": "import itertools\nimport math\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n\n        candidates = sorted(candidates)\n        return self.rec_combinations([], candidates, target)\n\n    def rec_combinations(self, comb, candidates, target):\n        res = []\n        if sum(candidates) < target:\n            return res\n        if target == 0:\n            res = [comb]\n            return res\n        \n        for i, c in enumerate(candidates):\n            if i > 0 and candidates[i-1] == c:\n                continue\n\n            if c <= target:\n                res += self.rec_combinations(comb+[c], candidates[i+1:], target-c)\n            if c > target:\n                break\n        \n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA recursive approch for the problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport itertools\\nimport math\\n\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n\\n        candidates = sorted(candidates)\\n        return self.rec_combinations([], candidates, target)\\n\\n    def rec_combinations(self, comb, candidates, target):\\n        res = []\\n        if sum(candidates) < target:\\n            return res\\n        if target == 0:\\n            res = [comb]\\n            return res\\n        \\n        for i, c in enumerate(candidates):\\n            if i > 0 and candidates[i-1] == c:\\n                continue\\n\\n            if c <= target:\\n                res += self.rec_combinations(comb+[c], candidates[i+1:], target-c)\\n            if c > target:\\n                break\\n        \\n        return res\\n\\n\\n```"
    },
    {
        "slug": "count-the-number-of-square-free-subsets",
        "tags": "python3",
        "release_time": 1676929087,
        "code": "class Solution:\n    def squareFreeSubsets(self, nums):\n\n        prefix = (( 2, 1), ( 3, 2), ( 6, 3), ( 5, 4), (10, 5),  # <-- These are 'prefix elements,' the fourteen \n                  (15, 6), (30, 7), ( 7, 8), (14, 9), (21,10),  #     elements of nums, tupled along with their masks,  \n                  (11,16), (13,32), (22,17), (26,33))           #     that could potentially contribute to a square\n                                                                #     factor. We use a tuple of tuples instead of a dict  \n                                                                #     for the iteration below.\n\n        suffix = {1,17,19,23,29}                                # <-- The 'suffix' elements\n\n        nums, cnt = Counter(nums), defaultdict(int)\n\n        for n, p in prefix:\n                                                                # <-- This is the standard stuff, except we use\n            for k in list(cnt):                                 #     Counter to do each like value together instead\n                if not p & k: cnt[p|k] += cnt[k]*nums[n]        #     of iterating thru nums element by element.\n                                                                #\n            cnt[p]+= nums[n]                                    #\n\n        ans = (sum(cnt.values())+1)*pow(2,nums[1])-1            # <-- We mutiply the prefix count by the number of \n                                                                #     potential 1s that may be appended to any prefix.\n        \n        for n in (17,19,23,29): ans = (ans+1)*(nums[n]+1) - 1   # <-- The other suffix elements. These factors differ\n                                                                #      from the 1s because including more than one \n                                                                #      will produce a square factor\n        return ans % (10 ** 9 + 7)",
        "content": "This approach is pretty much the same as many already posted, but we try to optimize in two ways:\\n1. Using `Counter` to reduce the amount of repetative work, and\\n2. Divide the integers `1,2,3, ..., 29,30` into those elements that could contribute to a square factor(`prefix`), and those that cannot(`suffix`). Those that already have a square factor are ignored in the`Counter`.\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums):\\n\\n        prefix = (( 2, 1), ( 3, 2), ( 6, 3), ( 5, 4), (10, 5),  # <-- These are \\'prefix elements,\\' the fourteen \\n                  (15, 6), (30, 7), ( 7, 8), (14, 9), (21,10),  #     elements of nums, tupled along with their masks,  \\n                  (11,16), (13,32), (22,17), (26,33))           #     that could potentially contribute to a square\\n                                                                #     factor. We use a tuple of tuples instead of a dict  \\n                                                                #     for the iteration below.\\n\\n        suffix = {1,17,19,23,29}                                # <-- The \\'suffix\\' elements\\n\\n        nums, cnt = Counter(nums), defaultdict(int)\\n\\n        for n, p in prefix:\\n                                                                # <-- This is the standard stuff, except we use\\n            for k in list(cnt):                                 #     Counter to do each like value together instead\\n                if not p & k: cnt[p|k] += cnt[k]*nums[n]        #     of iterating thru nums element by element.\\n                                                                #\\n            cnt[p]+= nums[n]                                    #\\n\\n        ans = (sum(cnt.values())+1)*pow(2,nums[1])-1            # <-- We mutiply the prefix count by the number of \\n                                                                #     potential 1s that may be appended to any prefix.\\n        \\n        for n in (17,19,23,29): ans = (ans+1)*(nums[n]+1) - 1   # <-- The other suffix elements. These factors differ\\n                                                                #      from the 1s because including more than one \\n                                                                #      will produce a square factor\\n        return ans % (10 ** 9 + 7)\\n```\\n[https://leetcode.com/problems/count-the-number-of-square-free-subsets/submissions/901832329/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*)  and space complexity is *O*(*N*).\\n"
    },
    {
        "slug": "kth-missing-positive-number",
        "tags": "python3",
        "release_time": 1678126197,
        "code": "class Solution:\n    def findKthPositive(self, arr: List[int], k: int) -> int:\n        l,h=0,len(arr)\n        while l<h:\n            mid=(h+l)//2\n            if arr[mid]-mid>k:h=mid\n            else: l=mid+1\n        return l+k",
        "content": "# Code\\n```\\nclass Solution:\\n    def findKthPositive(self, arr: List[int], k: int) -> int:\\n        l,h=0,len(arr)\\n        while l<h:\\n            mid=(h+l)//2\\n            if arr[mid]-mid>k:h=mid\\n            else: l=mid+1\\n        return l+k\\n```"
    },
    {
        "slug": "maximum-points-you-can-obtain-from-cards",
        "tags": "python3",
        "release_time": 1673730599,
        "code": "class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        if k >= len(cardPoints):\n            return sum(cardPoints)\n\n        left,right,mini,tot = 0,0, sum(cardPoints), 0\n\n        while right < len(cardPoints):\n            while right - left + 1 <= len(cardPoints) - k:\n                tot += cardPoints[right]\n                if right - left + 1 == len(cardPoints) - k:\n                    mini = min(tot,mini)\n                right += 1\n\n            while right - left + 1 > len(cardPoints) - k:\n                tot -= cardPoints[left]\n                left += 1\n\n        return sum(cardPoints) - mini",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\\n        if k >= len(cardPoints):\\n            return sum(cardPoints)\\n\\n        left,right,mini,tot = 0,0, sum(cardPoints), 0\\n\\n        while right < len(cardPoints):\\n            while right - left + 1 <= len(cardPoints) - k:\\n                tot += cardPoints[right]\\n                if right - left + 1 == len(cardPoints) - k:\\n                    mini = min(tot,mini)\\n                right += 1\\n\\n            while right - left + 1 > len(cardPoints) - k:\\n                tot -= cardPoints[left]\\n                left += 1\\n\\n        return sum(cardPoints) - mini                      \\n```"
    },
    {
        "slug": "lexicographical-numbers",
        "tags": "python3",
        "release_time": 1673196351,
        "code": "class Solution:\n    def lexicalOrder(self, n: int) -> List[int]:\n        lst=[str(i) for i in range(1,n+1)]\n        lst.sort()\n        return [int(i) for i in lst]",
        "content": "\\n```\\nclass Solution:\\n    def lexicalOrder(self, n: int) -> List[int]:\\n        lst=[str(i) for i in range(1,n+1)]\\n        lst.sort()\\n        return [int(i) for i in lst]\\n        \\n```"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "tags": "python3",
        "release_time": 1691696076,
        "code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        def steps(n, n1, n2):\n            count = 0\n            while n1 <= n:\n                count += min(n + 1, n2) - n1\n                n1 *= 10\n                n2 *= 10\n            return count\n        \n        curr = 1\n        k -= 1\n        while k > 0:\n            count = steps(n, curr, curr + 1)\n            if count <= k:\n                curr += 1\n                k -= count\n            else:\n                curr *= 10\n                k -= 1\n        return curr",
        "content": "# Intuition\\nThe lexicographical order of numbers can be thought of as a preorder traversal of a 10-ary tree (a tree where each node has up to 10 children). At the top level, we have numbers from 1 to 9 (we exclude 0 because numbers don\\'t start with 0). Each of these numbers can be considered as the root of a subtree that represents all numbers that have that prefix. For instance, under the number 1, we have numbers 10 to 19, under 2 we have numbers 20 to 29, and so on.\\n# Approach\\n1. Tree Traversal:\\n- We can traverse this tree in a depth-first manner. Starting from 1, we go as deep as possible by multiplying the current number by 10 until we exceed the limit n. This represents exploring the subtree under each number.\\n- Once we exceed n or reach the maximum depth for a particular subtree, we move to the next sibling by adding 1 to the current number.\\n- The challenge is to efficiently skip over subtrees that don\\'t contain the kth smallest number. This is where the steps function comes into play.\\n2. Calculate Steps:\\n- The steps function calculates how many numbers are there between two given numbers, say a and b, in the lexicographical order under the limit n. For instance, between 1 and 2, we have the numbers [1, 10, 11, ...].\\n- If the number of steps from the current number to the next is less than k, it means the kth number is not in the current subtree. We can safely move to the next subtree.\\n- Otherwise, we delve deeper into the current subtree by multiplying the current number by 10.\\n1. Termination:\\n- The traversal stops once k becomes 0, which means we\\'ve reached the kth number in the sequence.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity is O(log 10n). This is because in each iteration, we either multiply the current number by 10 (going deeper into the tree) or add 1 to it (moving to the next sibling). The depth of this tree is logarithmic with respect to n.\\n- Space complexity:\\nThe space complexity is O(1) since we are using a constant amount of space.\\n\\n# Code\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        def steps(n, n1, n2):\\n            count = 0\\n            while n1 <= n:\\n                count += min(n + 1, n2) - n1\\n                n1 *= 10\\n                n2 *= 10\\n            return count\\n        \\n        curr = 1\\n        k -= 1\\n        while k > 0:\\n            count = steps(n, curr, curr + 1)\\n            if count <= k:\\n                curr += 1\\n                k -= count\\n            else:\\n                curr *= 10\\n                k -= 1\\n        return curr\\n```"
    },
    {
        "slug": "course-schedule",
        "tags": "python3",
        "release_time": 1689214588,
        "code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n\n        pre = defaultdict(list)\n\n        for course, p in prerequisites:\n            pre[course].append(p)\n        \n        taken = set()\n\n        def dfs(course):\n            if not pre[course]:\n                return True\n            \n            if course in taken:\n                return False\n            \n            taken.add(course)\n\n            for p in pre[course]:\n                if not dfs(p): return False\n            \n            pre[course] = []\n            return True\n        \n        for course in range(numCourses):\n            if not dfs(course):\n                return False\n\n        return True",
        "content": "# Video solution\\n\\nhttps://youtu.be/-Me_If-_jRs\\n\\n\\u25A0 Please subscribe to my channel from here. I have more than 200 Leetcode videos.\\nhttps://www.youtube.com/@KeetCodeExAmazon\\n\\n---\\n\\n# Approach\\n\\n1. Create a class named `Solution` (assuming it is part of a larger program).\\n2. Define a method within the `Solution` class called `canFinish` that takes in two parameters: `numCourses` (an integer representing the total number of courses) and `prerequisites` (a list of lists representing the prerequisites for each course).\\n3. Create an empty dictionary called `pre` using the `defaultdict` class from the `collections` module. This dictionary will store the prerequisites for each course.\\n4. Iterate over each pair `(course, p)` in the `prerequisites` list:\\n   a. Append `p` to the list of prerequisites for the course `course` in the `pre` dictionary.\\n5. Create an empty set called `taken`. This set will keep track of the courses that have been visited during the depth-first search (DFS) traversal.\\n6. Define an inner function called `dfs` that takes in a parameter `course`. This function will perform the DFS traversal to check if the course can be finished.\\n7. If the list of prerequisites for the current `course` is empty (i.e., there are no remaining prerequisites), return `True` since the course can be finished.\\n8. If the `course` is already present in the `taken` set, return `False` since there is a cycle in the course dependencies.\\n9. Add the `course` to the `taken` set to mark it as visited.\\n10. Iterate over each prerequisite `p` for the current `course` in the `pre` dictionary:\\n    a. If the DFS traversal returns `False` for any prerequisite `p`, return `False` since the course cannot be finished.\\n11. Set the list of prerequisites for the current `course` in the `pre` dictionary to an empty list, indicating that all the prerequisites have been satisfied.\\n12. Return `True` at the end of the `dfs` function since all the prerequisites for the `course` have been satisfied.\\n13. Iterate over each `course` in the range from 0 to `numCourses` (exclusive) using a `for` loop.\\n14. If the DFS traversal of the current `course` returns `False`, it means the course cannot be finished, so return `False` from the `canFinish` method.\\n15. If the loop completes without returning `False`, it means all the courses can be finished, so return `True` from the `canFinish` method.\\n\\nIn summary, the algorithm performs a depth-first search to check if it is possible to finish all the courses given their prerequisites. It uses a dictionary to store the prerequisites for each course and a set to keep track of the visited courses during the traversal. If there is a cycle in the course dependencies or if any course cannot be finished, it returns `False`; otherwise, it returns `True`.\\n\\n# Python\\n```\\nclass Solution:\\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\\n\\n        pre = defaultdict(list)\\n\\n        for course, p in prerequisites:\\n            pre[course].append(p)\\n        \\n        taken = set()\\n\\n        def dfs(course):\\n            if not pre[course]:\\n                return True\\n            \\n            if course in taken:\\n                return False\\n            \\n            taken.add(course)\\n\\n            for p in pre[course]:\\n                if not dfs(p): return False\\n            \\n            pre[course] = []\\n            return True\\n        \\n        for course in range(numCourses):\\n            if not dfs(course):\\n                return False\\n\\n        return True\\n```"
    },
    {
        "slug": "permutations-ii",
        "tags": "python3",
        "release_time": 1690978512,
        "code": "from itertools import permutations\nclass Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        return set(list(permutations(nums)))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:12ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:11mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        return set(list(permutations(nums)))\\n```"
    },
    {
        "slug": "minimum-operations-to-halve-array-sum",
        "tags": "python3",
        "release_time": 1672244605,
        "code": "class Solution:\n    def halveArray(self, nums: List[int]) -> int:\n        heap = []\n        for num in nums:\n            heappush(heap,-1 * num)\n\n        initalSum = sum(nums)\n        targetSum = initalSum / 2\n        k = 0\n\n        while  initalSum > targetSum:\n            val = heappop(heap)\n            heappush(heap,val / 2)\n            initalSum -= (-1 * (val / 2))\n            k = k + 1\n            \n        return k",
        "content": "# Complexity\\n- Time complexity:\\nO(N logN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def halveArray(self, nums: List[int]) -> int:\\n        heap = []\\n        for num in nums:\\n            heappush(heap,-1 * num)\\n\\n        initalSum = sum(nums)\\n        targetSum = initalSum / 2\\n        k = 0\\n\\n        while  initalSum > targetSum:\\n            val = heappop(heap)\\n            heappush(heap,val / 2)\\n            initalSum -= (-1 * (val / 2))\\n            k = k + 1\\n            \\n        return k\\n```"
    },
    {
        "slug": "maximum-of-absolute-value-expression",
        "tags": "python3",
        "release_time": 1669133768,
        "code": "class Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n            val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\\n        \\'\\'\\'\\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\\n        total 2(+ or -)**(no. of modules) == 2**3 cases\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\\n\\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\\n        \\n        ...etc\\n        \\'\\'\\'\\n        val1,val2,val3,val4=[],[],[],[]\\n        for i in range(len(arr1)):\\n            val1.append(i+arr1[i]+arr2[i])\\n            val2.append(i+arr1[i]-arr2[i])\\n            val3.append(i-arr1[i]+arr2[i])\\n            val4.append(i-arr1[i]-arr2[i])\\n        ans=0\\n        ans=max(ans,max(val1)-min(val1))\\n        ans=max(ans,max(val2)-min(val2))\\n        ans=max(ans,max(val3)-min(val3))\\n        ans=max(ans,max(val4)-min(val4))\\n        return ans\\n```"
    },
    {
        "slug": "queue-reconstruction-by-height",
        "tags": "python3",
        "release_time": 1690405203,
        "code": "class Solution:\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\n        people.sort(key=lambda x: (-x[0], x[1]))\n        ans = []\n        \n        for person in people:\n            ans.insert(person[1], person)\n            \n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution:\\n    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:\\n        people.sort(key=lambda x: (-x[0], x[1]))\\n        ans = []\\n        \\n        for person in people:\\n            ans.insert(person[1], person)\\n            \\n        return ans\\n\\n```"
    },
    {
        "slug": "fibonacci-number",
        "tags": "python3",
        "release_time": 1690911388,
        "code": "class Solution:\n    def fib(self, n: int) -> int:\n        a,b,s = 0, 1, 0\n        if n>1:\n            for i in range(1,n):\n                s = a+b\n                a = b\n                b = s \n            return s\n        elif n == 1:\n            return 1\n        else:\n            return 0",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFib Sir developed Series with summation of the previous and next integer to get the next numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple Swapping and looping will get you to it.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fib(self, n: int) -> int:\\n        a,b,s = 0, 1, 0\\n        if n>1:\\n            for i in range(1,n):\\n                s = a+b\\n                a = b\\n                b = s \\n            return s\\n        elif n == 1:\\n            return 1\\n        else:\\n            return 0\\n            \\n\\n```"
    },
    {
        "slug": "all-ancestors-of-a-node-in-a-directed-acyclic-graph",
        "tags": "python3",
        "release_time": 1658785219,
        "code": "class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        #Use Kahn's algorithm of toposort using a queue and bfs!\n        graph = [[] for _ in range(n)]\n        indegrees = [0] * n\n        \n        #Time: O(n^2)\n        #Space: O(n^2 + n + n) -> O(n^2)\n        \n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\n        for edge in edges:\n            src, dest = edge[0], edge[1]\n            graph[src].append(dest)\n            indegrees[dest] += 1\n        \n        \n        queue = deque()\n        ans = [set() for _ in range(n)]\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\n        for i in range(len(indegrees)):\n            if(indegrees[i] == 0):\n                queue.append(i)\n        \n        #Kahn's algorithm initiation!\n        #while loop will run for each and every node in graph!\n        #in worst case, adjacency list for one particular node may contain all other vertices!\n        while queue:\n            cur = queue.pop()\n            \n            #for each neighbor\n            for neighbor in graph[cur]:\n                #current node is ancestor to each and every neighboring node!\n                ans[neighbor].add(cur)\n                #every ancestor of current node is also an ancestor to the neighboring node!\n                ans[neighbor].update(ans[cur])\n                indegrees[neighbor] -= 1\n                if(indegrees[neighbor] == 0):\n                    queue.append(neighbor)\n        \n        #at the end, we should have set of ancestors for each and every node!\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\n        ans = [(sorted(list(s))) for s in ans]\n        return ans",
        "content": "```\\nclass Solution:\\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\\n        #Use Kahn\\'s algorithm of toposort using a queue and bfs!\\n        graph = [[] for _ in range(n)]\\n        indegrees = [0] * n\\n        \\n        #Time: O(n^2)\\n        #Space: O(n^2 + n + n) -> O(n^2)\\n        \\n        #1st step: build adjacency list grpah and update the initial indegrees of every node!\\n        for edge in edges:\\n            src, dest = edge[0], edge[1]\\n            graph[src].append(dest)\\n            indegrees[dest] += 1\\n        \\n        \\n        queue = deque()\\n        ans = [set() for _ in range(n)]\\n        #2nd step: go through the indegrees array and add to queue for any node that has no ancestor!\\n        for i in range(len(indegrees)):\\n            if(indegrees[i] == 0):\\n                queue.append(i)\\n        \\n        #Kahn\\'s algorithm initiation!\\n        #while loop will run for each and every node in graph!\\n        #in worst case, adjacency list for one particular node may contain all other vertices!\\n        while queue:\\n            cur = queue.pop()\\n            \\n            #for each neighbor\\n            for neighbor in graph[cur]:\\n                #current node is ancestor to each and every neighboring node!\\n                ans[neighbor].add(cur)\\n                #every ancestor of current node is also an ancestor to the neighboring node!\\n                ans[neighbor].update(ans[cur])\\n                indegrees[neighbor] -= 1\\n                if(indegrees[neighbor] == 0):\\n                    queue.append(neighbor)\\n        \\n        #at the end, we should have set of ancestors for each and every node!\\n        #in worst case, set s for ith node could have all other vertices be ancestor to node i !\\n        ans = [(sorted(list(s))) for s in ans]\\n        return ans"
    },
    {
        "slug": "ones-and-zeroes",
        "tags": "python3",
        "release_time": 1692310436,
        "code": "class Solution:\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\n        d = []\n        for s in strs:\n            cnts = [0,0]\n            for char in s:\n                if char == '0': \n                    cnts[0] +=1\n                else:\n                    cnts[1] += 1\n            if cnts[0] <= m and cnts[1] <= n:\n                d.append(cnts)\n        sorted_d3 = sorted(d, key=lambda x:(x[0]+x[1], x[0], x[1]))\n        m_left, n_left = m, n\n        ans3 = 0\n        while sorted_d3:\n            subset = sorted_d3.pop(0)\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\n                ans3 += 1\n                m_left = m_left-subset[0]\n                n_left = n_left-subset[1]\n        sorted_d4 = sorted(d, key=lambda x:(x[0]+x[1], x[1], x[0]))\n        m_left, n_left = m, n\n        ans4 = 0\n        while sorted_d4:\n            subset = sorted_d4.pop(0)\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\n                ans4 += 1\n                m_left = m_left-subset[0]\n                n_left = n_left-subset[1]\n        m_left, n_left = m, n\n        sorted_d1 = sorted(d, key=lambda x:(x[0], x[1]))\n        ans1 = 0\n        while sorted_d1:\n            subset = sorted_d1.pop(0)\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\n                ans1 += 1\n                m_left = m_left-subset[0]\n                n_left = n_left-subset[1]\n        m_left, n_left =  m, n\n        sorted_d2 = sorted(d, key=lambda x:(x[1], x[0]))\n        ans2 = 0\n        while sorted_d2:\n            subset = sorted_d2.pop(0)\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\n                ans2 += 1\n                m_left = m_left-subset[0]\n                n_left = n_left-subset[1]\n        return max(ans1, ans2, ans3, ans4)",
        "content": "# Overview\\nGreedily take strings based on some sorted order. 4 orders were examined: sorting by (# of 0\\'s, # of 1\\'s), sorting by (# of 1\\'s, # of 0\\'s), sorting (combined length, # of 0\\'s, # of 1\\'s), (combined length, # of 1\\'s, # of 0\\'s).\\n\\n# Code\\n```\\nclass Solution:\\n    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:\\n        d = []\\n        for s in strs:\\n            cnts = [0,0]\\n            for char in s:\\n                if char == \\'0\\': \\n                    cnts[0] +=1\\n                else:\\n                    cnts[1] += 1\\n            if cnts[0] <= m and cnts[1] <= n:\\n                d.append(cnts)\\n        sorted_d3 = sorted(d, key=lambda x:(x[0]+x[1], x[0], x[1]))\\n        m_left, n_left = m, n\\n        ans3 = 0\\n        while sorted_d3:\\n            subset = sorted_d3.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans3 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        sorted_d4 = sorted(d, key=lambda x:(x[0]+x[1], x[1], x[0]))\\n        m_left, n_left = m, n\\n        ans4 = 0\\n        while sorted_d4:\\n            subset = sorted_d4.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans4 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left = m, n\\n        sorted_d1 = sorted(d, key=lambda x:(x[0], x[1]))\\n        ans1 = 0\\n        while sorted_d1:\\n            subset = sorted_d1.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans1 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        m_left, n_left =  m, n\\n        sorted_d2 = sorted(d, key=lambda x:(x[1], x[0]))\\n        ans2 = 0\\n        while sorted_d2:\\n            subset = sorted_d2.pop(0)\\n            if m_left-subset[0] >= 0 and n_left-subset[1] >= 0:\\n                ans2 += 1\\n                m_left = m_left-subset[0]\\n                n_left = n_left-subset[1]\\n        return max(ans1, ans2, ans3, ans4)\\n```\\n\\nPasses all current test cases, but fails on this test:\\n[\"0000\", \"1110\", \"1100\", \"1100\"]\\nm = 4, n = 4"
    },
    {
        "slug": "minimum-space-wasted-from-packaging",
        "tags": "python3",
        "release_time": 1622952118,
        "code": "class Solution:\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\n        packages.sort()\n        prefix = [0]\n        for x in packages: prefix.append(prefix[-1] + x)\n        \n        ans = inf \n        for box in boxes: \n            box.sort()\n            if packages[-1] <= box[-1]: \n                kk = val = 0 \n                for x in box: \n                    k = bisect_right(packages, x)\n                    val += (k - kk) * x - (prefix[k] - prefix[kk])\n                    kk = k\n                ans = min(ans, val)\n        return ans % 1_000_000_007 if ans < inf else -1",
        "content": "\\n```\\nclass Solution:\\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n        packages.sort()\\n        prefix = [0]\\n        for x in packages: prefix.append(prefix[-1] + x)\\n        \\n        ans = inf \\n        for box in boxes: \\n            box.sort()\\n            if packages[-1] <= box[-1]: \\n                kk = val = 0 \\n                for x in box: \\n                    k = bisect_right(packages, x)\\n                    val += (k - kk) * x - (prefix[k] - prefix[kk])\\n                    kk = k\\n                ans = min(ans, val)\\n        return ans % 1_000_000_007 if ans < inf else -1 \\n```\\n\\nEdited on 6/6/2021\\nIt turns out that we don\\'t need prefix sum (per @lee215). \\n\\n```\\nclass Solution:\\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n        packages.sort()\\n        \\n        ans = inf \\n        for box in boxes: \\n            box.sort()\\n            if packages[-1] <= box[-1]: \\n                kk = val = 0 \\n                for x in box: \\n                    k = bisect_right(packages, x)\\n                    val += (k - kk) * x\\n                    kk = k\\n                ans = min(ans, val)\\n        return (ans - sum(packages)) % 1_000_000_007 if ans < inf else -1 \\n```"
    },
    {
        "slug": "check-if-matrix-is-x-matrix",
        "tags": "python3",
        "release_time": 1679733934,
        "code": "class Solution:\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\n        n=len(grid)\n        for i in range(n):\n            for j in range(n):\n                if((i!=j and i+j!=n-1) and grid[i][j]!=0):\n                    return 0\n                elif((i==j or i+j==n-1) and grid[i][j]==0):\n                    return 0\n        return 1",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\\n        n=len(grid)\\n        for i in range(n):\\n            for j in range(n):\\n                if((i!=j and i+j!=n-1) and grid[i][j]!=0):\\n                    return 0\\n                elif((i==j or i+j==n-1) and grid[i][j]==0):\\n                    return 0\\n        return 1\\n\\n\\n```\\nLike? hit that button"
    },
    {
        "slug": "bulb-switcher",
        "tags": "python3",
        "release_time": 1682558254,
        "code": "class Solution:     \n    def bulbSwitch(self, n: int) -> int:\n        \n        return isqrt(n)",
        "content": "Here\\'s the intuition:\\n\\n1. A light switch is a toggle with two states,`off`and`on`, and in this problem the initial state is`off`, so reason tells us that the bulbs that will be`on`at the end are those with an odd number of divisors.\\n2. Consider lightbulb`k`, where`0 <= k <= n-1`. For every divisor`d`of`k`, `k//d` is also a divisor, and reason also tells us that`d*(k//d) = k`. Also,`k`can have an odd number of distinct divisors if and only if`k = d*d`for exactly one divisor`d`, which is true if and only if `k`is a perfect square.\\n3. From 2) above, the answer to the problem is the integer part of the square root of`n`.\\n```\\nclass Solution:     \\n    def bulbSwitch(self, n: int) -> int:\\n        \\n        return isqrt(n) \\n```\\n[https://leetcode.com/submissions/detail/674479447/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(log*n*) and space complexity is *O*(1)."
    },
    {
        "slug": "rings-and-rods",
        "tags": "python3",
        "release_time": 1689053900,
        "code": "class Solution:\n    def countPoints(self, rings: str) -> int:\n        lst=[]\n        rgb=[]\n        count=0\n        for i in range(1,len(rings),2):\n            rgb=[]\n            if rings[i] not in lst:\n                lst.append(rings[i])\n                for j in range(1,len(rings),2):\n                    if rings[j]==rings[i]:\n                        if rings[j-1]=='R':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='G':\n                            rgb.append(rings[j-1])\n                        if rings[j-1]=='B':\n                            rgb.append(rings[j-1])\n                if len(set(rgb))==3:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countPoints(self, rings: str) -> int:\\n        lst=[]\\n        rgb=[]\\n        count=0\\n        for i in range(1,len(rings),2):\\n            rgb=[]\\n            if rings[i] not in lst:\\n                lst.append(rings[i])\\n                for j in range(1,len(rings),2):\\n                    if rings[j]==rings[i]:\\n                        if rings[j-1]==\\'R\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'G\\':\\n                            rgb.append(rings[j-1])\\n                        if rings[j-1]==\\'B\\':\\n                            rgb.append(rings[j-1])\\n                if len(set(rgb))==3:\\n                    count+=1\\n        return count\\n\\n```"
    },
    {
        "slug": "substrings-of-size-three-with-distinct-characters",
        "tags": "python3",
        "release_time": 1677600394,
        "code": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n        count=0\n        for i in range(len(s)-2):\n            x=s[i:i+3]\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```"
    },
    {
        "slug": "fizz-buzz",
        "tags": "python3",
        "release_time": 1691389137,
        "code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        arr=[]\n        for i in range(1,n+1):\n            if i % 3==0 and  i % 5==0 :\n                arr.append(\"FizzBuzz\")\n            elif i % 3==0:\n                arr.append(\"Fizz\")\n            elif i % 5==0 :\n                arr.append(\"Buzz\")\n  \n            else:\n                arr.append(str(i))\n        return(arr)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        arr=[]\\n        for i in range(1,n+1):\\n            if i % 3==0 and  i % 5==0 :\\n                arr.append(\"FizzBuzz\")\\n            elif i % 3==0:\\n                arr.append(\"Fizz\")\\n            elif i % 5==0 :\\n                arr.append(\"Buzz\")\\n  \\n            else:\\n                arr.append(str(i))\\n        return(arr)\\n```"
    },
    {
        "slug": "count-number-of-maximum-bitwise-or-subsets",
        "tags": "python3",
        "release_time": 1680970308,
        "code": "import functools\nclass Solution:\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\n        mapping = collections.defaultdict(int)\n        for count in range(1,len(nums)+1):\n            subsets = list(itertools.combinations(nums,count))\n            for ele in subsets:\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\n        return mapping[max(mapping.keys())]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport functools\\nclass Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        mapping = collections.defaultdict(int)\\n        for count in range(1,len(nums)+1):\\n            subsets = list(itertools.combinations(nums,count))\\n            for ele in subsets:\\n                mapping[functools.reduce(lambda a,b: a|b,list(ele))] += 1\\n        return mapping[max(mapping.keys())]\\n\\n```"
    },
    {
        "slug": "contains-duplicate",
        "tags": "python3",
        "release_time": 1692552469,
        "code": "class Solution:\n    def containsDuplicate(self, nums: List[int]) -> bool:\n        sets=set(nums)\n        if len(sets) != len(nums):\n            return True\n        else:\n            return False",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        sets=set(nums)\\n        if len(sets) != len(nums):\\n            return True\\n        else:\\n            return False\\n```"
    },
    {
        "slug": "k-similar-strings",
        "tags": "python3",
        "release_time": 1659752487,
        "code": "class Solution:\n    def kSimilarity(self, s1: str, s2: str) -> int:\n        #the deque keeps track of the set of strings that we want to perform swaps on\n        #at the start, the deque contains only s1\n        deque = collections.deque([s1])\n        \n        #this set wasn't mentioned in the \"intuition\" part. it helps us avoid doing repeated work by adding the same strings to our deque\n        seen = set() \n        \n        answ=0 #counter for the number of \"swaps\" done so far\n        \n        \n        while deque:\n            for _ in range(len(deque)): #loops through each string in the deque\n                \n                string = deque.popleft() #gets the first string in the deque\n                if string ==s2: return answ\n                \n                #finds the first non-matching letter in s1\n                #this satisfies condition 1 of a \"useful\" swap\n                #ex: this would be s1[3] in the above example\n                i=0\n                while string[i]==s2[i]:\n                    i+=1\n                \n                #checks all the other letters for potential swaps\n                for j in range(i+1, len(string)):\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\n                        \n                        #swaps the letters at positions i and j\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\n                        \n                        #adds the \"new string\" if it was not previously added\n                        if new not in seen:\n                            seen.add(new)\n                            deque.append(new)\n            \n            #record that one more swap was done for each string in the deque\n            answ+=1",
        "content": "# **Intuition**\\n\\nFirst, let\\'s understand how the BFS works with some examples.\\n\\n\\ts1: \"aaabcbea\"\\n\\ts2: \"aaaebcba\"\\n\\nA **swap** is when we switch two letters, s1[i] and s1[j]. Not all **swaps** are useful to us. In the above example, we don\\'t want to swap s1[0] with any s1[j].\\n\\n**Swaps** are only useful if they satisfy these conditions:\\n1. s1[i] != s2[i] *(the letter isn\\'t already in the correct position)*\\n2. s1[i] = s2[j]   *(we are moving s1[i] to a location where it matches)*\\n3. s1[j]! = s2[j]   *(the SECOND letter isn\\'t already in the correct position*)\\n\\n**Our approach is to find the first non-matching letter in s1. Then, we try all possible \"useful\" swaps.**\\n\\nSo, in the above example, the first non-matching letter is s1[3], or \"b\". Performing a **swap** with s1[4] and s1[6] are both \"useful\", because the \"b\" is moved to the right position.\\n\\nWe do both of these swaps. This gives us two strings:\\n\\n\\toriginal s1: \"aaabcbea\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew string 1: \"aaacbbea\"\\n\\tnew string 2: \"aaaecbba\"\\n\\t\\nWe keep track that we made **1** change so far. Then, we repeat the same process on BOTH \"new string 1\" and \"new string 2\".\\n\\nFor new string 1, there is only one possible swap.\\n\\n\\tnew string 1: \"aaacbbea\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew new string 1: \"aaaebbca\"\\n\\t\\nFor new string 2, there is also only one possible swap.\\n\\n\\tnew string 2: \"aaaecbba\"\\n\\ts2: \"aaaebcba\"\\n\\t\\n\\tnew new string 2: \"aaaebcba\"\\n\\t\\nAt this point, new new string 2 matches s2, so we are done. We return the number of swaps made so far, which is 2.\\n\\n\\n# **Code**\\n```\\nclass Solution:\\n    def kSimilarity(self, s1: str, s2: str) -> int:\\n        #the deque keeps track of the set of strings that we want to perform swaps on\\n        #at the start, the deque contains only s1\\n        deque = collections.deque([s1])\\n        \\n        #this set wasn\\'t mentioned in the \"intuition\" part. it helps us avoid doing repeated work by adding the same strings to our deque\\n        seen = set() \\n        \\n        answ=0 #counter for the number of \"swaps\" done so far\\n        \\n        \\n        while deque:\\n            for _ in range(len(deque)): #loops through each string in the deque\\n                \\n                string = deque.popleft() #gets the first string in the deque\\n                if string ==s2: return answ\\n                \\n                #finds the first non-matching letter in s1\\n                #this satisfies condition 1 of a \"useful\" swap\\n                #ex: this would be s1[3] in the above example\\n                i=0\\n                while string[i]==s2[i]:\\n                    i+=1\\n                \\n                #checks all the other letters for potential swaps\\n                for j in range(i+1, len(string)):\\n                    if string[i]==s2[j]!=s1[j]: #checks conditions 2 and 3 of a useful swap\\n                        \\n                        #swaps the letters at positions i and j\\n                        new = string[:i] + string[j] + string[i+1:j] + string[i] + string[j+1:]\\n                        \\n                        #adds the \"new string\" if it was not previously added\\n                        if new not in seen:\\n                            seen.add(new)\\n                            deque.append(new)\\n            \\n            #record that one more swap was done for each string in the deque\\n            answ+=1\\n\\n```\\n\\n**Still Confused?**\\nIf you thoroughly read through this explanation and don\\'t get it, I\\'d recommend checking out this explanation on 2x speed:\\nhttps://www.youtube.com/watch?v=GacKZ1-p3-0&t=1292s&ab_channel=HappyCoding"
    },
    {
        "slug": "minimum-cost-to-cut-a-stick",
        "tags": "python3",
        "release_time": 1685244609,
        "code": "class Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        \n        cuts = sorted(chain(cuts,[0,n]))\n        \n        @lru_cache(None)\n        def dfs(l, r):\n            length, M = cuts[r] - cuts[l], range(l+1, r)\n            return min((dfs(l,i) + dfs(i,r) for i in M),\n                       default = -length) + length\n        \n        return dfs(0, len(cuts)-1)",
        "content": "```\\nclass Solution:\\n    def minCost(self, n: int, cuts: List[int]) -> int:\\n        \\n        cuts = sorted(chain(cuts,[0,n]))\\n        \\n        @lru_cache(None)\\n        def dfs(l, r):\\n            length, M = cuts[r] - cuts[l], range(l+1, r)\\n            return min((dfs(l,i) + dfs(i,r) for i in M),\\n                       default = -length) + length\\n        \\n        return dfs(0, len(cuts)-1)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-cut-a-stick/submissions/958717387/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^3) and space complexity is *O*(*N*^2), in which *N* ~`n`."
    },
    {
        "slug": "determine-the-winner-of-a-bowling-game",
        "tags": "python3",
        "release_time": 1684312110,
        "code": "class Solution:\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\n        res1=0\n        res2=0\n        if 10 in nums1 and len(nums1)>1:\n            res1+=nums1[0]\n            for i in range(1,len(nums1)):\n                res1+=nums1[i]\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\n                        res1+=nums1[i]\n                else:\n                    pass\n        else:\n            res1=sum(nums1)\n        if 10 in nums2 and len(nums2)>1:\n            res2+=nums2[0]\n            for i in range(1,len(nums2)):\n                res2+=nums2[i]\n\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\n                        res2+=nums2[i]\n                else:\n                    pass\n        else:\n            res2=sum(nums2)\n\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\n        if res1>res2:\n            return(1)\n        elif res1<res2:\n            return(2)\n        else:\n            return(0)",
        "content": "# Intuition\\nusing for loop and few conditions\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def isWinner(self, nums1: List[int], nums2: List[int]) -> int:\\n        res1=0\\n        res2=0\\n        if 10 in nums1 and len(nums1)>1:\\n            res1+=nums1[0]\\n            for i in range(1,len(nums1)):\\n                res1+=nums1[i]\\n                if nums1[i-1]==10 or i>=2 and nums1[i-2]==10:\\n                        res1+=nums1[i]\\n                else:\\n                    pass\\n        else:\\n            res1=sum(nums1)\\n        if 10 in nums2 and len(nums2)>1:\\n            res2+=nums2[0]\\n            for i in range(1,len(nums2)):\\n                res2+=nums2[i]\\n\\n                if nums2[i-1]==10 or i>=2 and nums2[i-2]==10:\\n                        res2+=nums2[i]\\n                else:\\n                    pass\\n        else:\\n            res2=sum(nums2)\\n\\n        # print(1 if res1>res2 2: if res2>res1: 0 if res1==res2)\\n        if res1>res2:\\n            return(1)\\n        elif res1<res2:\\n            return(2)\\n        else:\\n            return(0)\\n```"
    },
    {
        "slug": "minimum-add-to-make-parentheses-valid",
        "tags": "python3",
        "release_time": 1680970052,
        "code": "class Solution:\n    def minAddToMakeValid(self, s: str) -> int:\n        stack = []\n        for ele in s:\n            if stack: \n                if stack[-1] == '(' and ele == ')':\n                    stack.pop()\n                else:\n                    stack.append(ele)\n            else:\n                stack.append(ele)\n        return len(stack)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minAddToMakeValid(self, s: str) -> int:\\n        stack = []\\n        for ele in s:\\n            if stack: \\n                if stack[-1] == \\'(\\' and ele == \\')\\':\\n                    stack.pop()\\n                else:\\n                    stack.append(ele)\\n            else:\\n                stack.append(ele)\\n        return len(stack)\\n\\n```"
    },
    {
        "slug": "height-checker",
        "tags": "python3",
        "release_time": 1689660695,
        "code": "class Solution:\n    def heightChecker(self, heights: List[int]) -> int:\n        expected=list(heights)\n        expected.sort()\n        cnt=0\n        for i in range(len(heights)):\n            if expected[i]!=heights[i]:\n                cnt+=1\n        return cnt",
        "content": "# Code\\n```\\nclass Solution:\\n    def heightChecker(self, heights: List[int]) -> int:\\n        expected=list(heights)\\n        expected.sort()\\n        cnt=0\\n        for i in range(len(heights)):\\n            if expected[i]!=heights[i]:\\n                cnt+=1\\n        return cnt\\n```"
    },
    {
        "slug": "maximum-count-of-positive-integer-and-negative-integer",
        "tags": "python3",
        "release_time": 1673160962,
        "code": "class Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        a = []\n        for i in nums:\n            if i < 0:\n                a.append(0)\n            elif i > 0:\n                a.append(1)\n        return max(a.count(0),a.count(1))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumCount(self, nums: List[int]) -> int:\\n        a = []\\n        for i in nums:\\n            if i < 0:\\n                a.append(0)\\n            elif i > 0:\\n                a.append(1)\\n        return max(a.count(0),a.count(1))\\n```"
    },
    {
        "slug": "find-players-with-zero-or-one-losses",
        "tags": "python3",
        "release_time": 1669639917,
        "code": "class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n\n        winners, losers = defaultdict(int), defaultdict(int)\n\n        for match in matches:\n\n            winners[match[0]] += 1\n            losers[match[1]] += 1\n\n        res_1, res_2 = [], []\n\n        for k, v in winners.items():\n            if k not in losers:\n                res_1.append(k)\n        \n        for k, v in losers.items():\n            if v == 1:\n                res_2.append(k)\n\n        res_1.sort()\n        res_2.sort()\n        \n        return [ res_1, res_2 ]",
        "content": "# Intuition\\nIf you need to aggregate and count some sequens you cen use either array or hasmap if it is a matter of a uniqueness.\\n\\n# Approach\\nIn our case we need to find unique teams that either not loose or loose not more than 1 match. So we need to distribute the information about all matches among two grous and\\n1. Check for intesection for winners\\n2. Check for 1 lost for loosers\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\\n\\n        winners, losers = defaultdict(int), defaultdict(int)\\n\\n        for match in matches:\\n\\n            winners[match[0]] += 1\\n            losers[match[1]] += 1\\n\\n        res_1, res_2 = [], []\\n\\n        for k, v in winners.items():\\n            if k not in losers:\\n                res_1.append(k)\\n        \\n        for k, v in losers.items():\\n            if v == 1:\\n                res_2.append(k)\\n\\n        res_1.sort()\\n        res_2.sort()\\n        \\n        return [ res_1, res_2 ]\\n```"
    },
    {
        "slug": "ransom-note",
        "tags": "python3",
        "release_time": 1688389692,
        "code": "class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        ransomNote = list(ransomNote)\n        magazine = list(magazine)\n        for char in ransomNote:\n            if char in magazine:\n                magazine.remove(char)\n            else:\n                return False\n        return True",
        "content": "# Intuition\\nThe intuition behind the given code is to check if we can construct the ransomNote string using the letters from the magazine string, while adhering to the constraint that each letter in magazine can only be used once.\\n\\nThe code accomplishes this by using two for loops to traverse the ransomNote and magazine strings.\\n\\n# Approach\\nIn the first loop, we iterate over each character in the ransomNote string. For each character, we check if it is present in the magazine string. If the character is found, it means we can use it to construct the ransomNote, so we remove that character from the magazine string by calling magazine.remove(char).\\n\\nIf a character in ransomNote is not found in magazine, it means we cannot construct the ransomNote using the available characters, so we immediately return False.\\n\\nAfter iterating over all characters in ransomNote, if we have successfully removed each character from the magazine string, it means we can construct the ransomNote using the letters from magazine, while satisfying the constraint that each letter in magazine can only be used once. In this case, we return True.\\n\\nThe approach of converting the strings to lists allows us to manipulate the magazine string by removing characters as they are used, effectively ensuring that each letter in magazine is used only once.\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n\\n- Space complexity: O(n+m)\\n\\n# Code\\n```\\nclass Solution:\\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\\n        ransomNote = list(ransomNote)\\n        magazine = list(magazine)\\n        for char in ransomNote:\\n            if char in magazine:\\n                magazine.remove(char)\\n            else:\\n                return False\\n        return True\\n```"
    },
    {
        "slug": "longest-repeating-character-replacement",
        "tags": "python3",
        "release_time": 1684077157,
        "code": "class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n\n        count = {}\n        l=0\n        maxf=0\n        res=0\n\n       #count.get(s[i], 0) gets the current count of the character s[i] from the count dictionary. If the character s[i] is not already a key in the dictionary, count.get(s[i], 0) returns the default value of 0. \n        for r in range(len(s)):\n            count[s[r]]=1+count.get(s[r],0)\n            maxf = max(maxf, count[s[r]])\n            \n\n            if (r-l+1) - maxf >k:\n                 \n                count[s[l]]-=1\n                l+=1\n            \n            res = max(res,r-l+1)\n        \n\n        return res",
        "content": "Intuition:\\n\\n- Initialize two pointers l and r to 0, and a dictionary count to keep track of the frequency of characters in the current window.\\n- Initialize maxf and res to 0. maxf stores the frequency of the most frequent character in the current window, and res stores the length of the longest substring containing only one character seen so far.\\n- Iterate over the string using the right end r of the window. For each character s[r], update its frequency in the count dictionary. Also, update maxf to be the maximum frequency of any character in the current window.\\n- If the length of the window r-l+1 minus the frequency of the most frequent character maxf is greater than k, shrink the window from the left end l. Decrement the frequency of the character at s[l] in the count dictionary and increment l.\\n- Continue updating res to be the maximum length of a substring containing only one character seen so far.\\n- Once the entire string has been iterated over, return res.\\n\\nApproach:\\n1. Initialize `count` to an empty dictionary, `l` to 0, `maxf` and `res` to 0.\\n2. Iterate over the string using the right end `r` of the window:\\n   a. Update the frequency of the character `s[r]` in the `count` dictionary.\\n   b. Update `maxf` to be the maximum frequency of any character in the current window.\\n   c. If the length of the window `r-l+1` minus the frequency of the most frequent character `maxf` is greater than `k`, we need to shrink the window from the left end `l`. Decrement the frequency of the character at `s[l]` in the `count` dictionary, and increment `l`.\\n   d. Update `res` to be the maximum length of a substring containing only one character seen so far.\\n3. Return `res`.\\n\\nComplexity:\\n\\nTime complexity: The time complexity of the algorithm is O(n), where n is the length of the string `s`. This is because we iterate over the string once using the right end `r` of the window, and each character is processed at most twice (once during expansion, and once during contraction).\\n\\nSpace complexity: The space complexity of the algorithm is O(1), since the size of the `count` dictionary is bounded by the number of distinct characters in the string.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def characterReplacement(self, s: str, k: int) -> int:\\n\\n        count = {}\\n        l=0\\n        maxf=0\\n        res=0\\n\\n       #count.get(s[i], 0) gets the current count of the character s[i] from the count dictionary. If the character s[i] is not already a key in the dictionary, count.get(s[i], 0) returns the default value of 0. \\n        for r in range(len(s)):\\n            count[s[r]]=1+count.get(s[r],0)\\n            maxf = max(maxf, count[s[r]])\\n            \\n\\n            if (r-l+1) - maxf >k:\\n                 \\n                count[s[l]]-=1\\n                l+=1\\n            \\n            res = max(res,r-l+1)\\n        \\n\\n        return res\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```"
    },
    {
        "slug": "knight-probability-in-chessboard",
        "tags": "python3",
        "release_time": 1690012168,
        "code": "class Solution:\n    def dp(self,x,y,n,visited,k):\n        if k<0:\n            return 1\n        if (x<0 or x>=n) or (y<0 or y>=n):\n            return 0\n        if (x,y,k) in visited:\n            return visited[(x,y,k)]\n        a=self.dp(x+2,y+1,n,visited,k-1)*1/8\n        b=self.dp(x+2,y-1,n,visited,k-1)*1/8\n        c=self.dp(x-2,y+1,n,visited,k-1)*1/8\n        d=self.dp(x-2,y-1,n,visited,k-1)*1/8\n        e=self.dp(x+1,y+2,n,visited,k-1)*1/8\n        f=self.dp(x+1,y-2,n,visited,k-1)*1/8\n        g=self.dp(x-1,y+2,n,visited,k-1)*1/8\n        h=self.dp(x-1,y-2,n,visited,k-1)*1/8\n        visited[(x,y,k)]=a+b+c+d+e+f+g+h\n        return a+b+c+d+e+f+g+h\n        \n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n        return self.dp(row,column,n,{},k)",
        "content": "# Code\\n```\\nclass Solution:\\n    def dp(self,x,y,n,visited,k):\\n        if k<0:\\n            return 1\\n        if (x<0 or x>=n) or (y<0 or y>=n):\\n            return 0\\n        if (x,y,k) in visited:\\n            return visited[(x,y,k)]\\n        a=self.dp(x+2,y+1,n,visited,k-1)*1/8\\n        b=self.dp(x+2,y-1,n,visited,k-1)*1/8\\n        c=self.dp(x-2,y+1,n,visited,k-1)*1/8\\n        d=self.dp(x-2,y-1,n,visited,k-1)*1/8\\n        e=self.dp(x+1,y+2,n,visited,k-1)*1/8\\n        f=self.dp(x+1,y-2,n,visited,k-1)*1/8\\n        g=self.dp(x-1,y+2,n,visited,k-1)*1/8\\n        h=self.dp(x-1,y-2,n,visited,k-1)*1/8\\n        visited[(x,y,k)]=a+b+c+d+e+f+g+h\\n        return a+b+c+d+e+f+g+h\\n        \\n    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\\n        return self.dp(row,column,n,{},k)\\n\\n```"
    },
    {
        "slug": "find-resultant-array-after-removing-anagrams",
        "tags": "python3",
        "release_time": 1673366943,
        "code": "class Solution:\n    def removeAnagrams(self, words: List[str]) -> List[str]:\n        return (next(val) for _, val in groupby(words, key=sorted))",
        "content": "Here\\'s a one-liner\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```"
    },
    {
        "slug": "html-entity-parser",
        "tags": "python3",
        "release_time": 1670671849,
        "code": "class Solution:\n    def entityParser(self, text: str) -> str:\n        return text.replace('&quot;', '\"').replace('&gt;', '>').replace('&lt;', '<').replace('&apos;', \"'\").replace('&amp;', '&').replace('&frasl;', '/')",
        "content": "# One liner Code. Python.\\n# Code\\n```\\nclass Solution:\\n    def entityParser(self, text: str) -> str:\\n        return text.replace(\\'&quot;\\', \\'\"\\').replace(\\'&gt;\\', \\'>\\').replace(\\'&lt;\\', \\'<\\').replace(\\'&apos;\\', \"\\'\").replace(\\'&amp;\\', \\'&\\').replace(\\'&frasl;\\', \\'/\\')\\n```"
    },
    {
        "slug": "reachable-nodes-with-restrictions",
        "tags": "python3",
        "release_time": 1682443628,
        "code": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        adj_list = defaultdict(list)\n        for x,y in edges:\n            adj_list[x].append(y)\n            adj_list[y].append(x)\n    \n        que = deque()\n        que.append(0)\n        result = 0\n        visited = set()\n        for node in restricted:\n            visited.add(node)\n\n        while que:\n            cur = que.popleft()\n            if cur in visited:\n                continue    \n            visited.add(cur)\n            result += 1\n            for node in adj_list[cur]:\n                que.append(node)\n        \n        return result",
        "content": "# Intuition\\nBFS\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        adj_list = defaultdict(list)\\n        for x,y in edges:\\n            adj_list[x].append(y)\\n            adj_list[y].append(x)\\n    \\n        que = deque()\\n        que.append(0)\\n        result = 0\\n        visited = set()\\n        for node in restricted:\\n            visited.add(node)\\n\\n        while que:\\n            cur = que.popleft()\\n            if cur in visited:\\n                continue    \\n            visited.add(cur)\\n            result += 1\\n            for node in adj_list[cur]:\\n                que.append(node)\\n        \\n        return result\\n\\n\\n\\n\\n```"
    },
    {
        "slug": "sort-integers-by-the-power-value",
        "tags": "python3",
        "release_time": 1671276439,
        "code": "class Solution:\n    def getKth(self, lo: int, hi: int, k: int) -> int:\n        def getPow(num, ans):\n            if num == 1:\n                return ans\n            if num % 2 == 0:\n                num = num // 2\n            else:\n                num = 3 * num + 1\n            ans += 1\n            return getPow(num, ans)\n        maps = {i:getPow(i, 0) for i in range(lo, hi+1)}\n        ans = [k for k, v in sorted(maps.items(), key=lambda a:a[1])]\n        return ans[k-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def getKth(self, lo: int, hi: int, k: int) -> int:\\n        def getPow(num, ans):\\n            if num == 1:\\n                return ans\\n            if num % 2 == 0:\\n                num = num // 2\\n            else:\\n                num = 3 * num + 1\\n            ans += 1\\n            return getPow(num, ans)\\n        maps = {i:getPow(i, 0) for i in range(lo, hi+1)}\\n        ans = [k for k, v in sorted(maps.items(), key=lambda a:a[1])]\\n        return ans[k-1]\\n\\n```"
    },
    {
        "slug": "count-subtrees-with-max-distance-between-cities",
        "tags": "python3",
        "release_time": 1687072167,
        "code": "class Solution:\n    # odd/even diameter couned individually\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        adj = [[] for i in range(n)]\n        for u,v in edges:\n            adj[u-1].append(v-1)\n            adj[v-1].append(u-1)\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\n            if len(q)<len(p): p,q = q,p\n            res = [0]*len(q)\n            res[0] = p[0]*q[0]\n            for i in range(1,len(p)): p[i] += p[i-1]\n            for i in range(1,len(q)): q[i] += q[i-1]\n            for i in range(1,len(p)):\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\n            for i in range(len(p),len(q)):\n                res[i] = (q[i]-q[i-1])*p[-1]\n            return res\n            \n        def dfs(r,p): # num of subtree rooted at r with given depth\n            d = [1]\n            for v in adj[r]:\n                if v==p: continue\n                t = [1]+dfs(v,r)\n                d = comb(t,d)\n            return d\n        #end dfs\n        ans = [0]*n\n        # odd diameter with (u,v) as center edge\n        for u,v in edges:\n            u -= 1; v-=1\n            p = dfs(u,v)\n            q = dfs(v,u)\n            for i in range(min(len(p),len(q))):\n                ans[i+i+1] += p[i]*q[i]\n        #even diamter with v as center vertex\n        for v in range(n): \n            if len(adj[v])==1: continue \n            tree = [1]+dfs(adj[v][0],v) #tree with depth\n            curr = [0]*n\n            for u in adj[v][1:]:\n                q = [1]+dfs(u,v)\n                # curr tree + new small\n                j = 1; t = q[1]+1 # prefix sum of q\n                for i in range(4,n,2):\n                    while j+1<min(i//2,len(q)):\n                        j += 1; t += q[j]\n                    curr[i] *= t\n                # curr tree + same height\n                for i in range(min(len(tree),len(q))):\n                    curr[i+i] += tree[i]*q[i]\n                tree = comb(tree,q)\n            for i in range(2,n,2):\n                ans[i] += curr[i]\n        #end\n        return ans[1:]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA (sub)tree may have many diameters, but there is exactly one or two centers. To simplfying the implementation, we divide into two cases: diameter is even or odd. For the case of even diameter, we  count the subtrees by enumerating each vertex as the center. For the case of odd diameter, we enumerate each edge as the center. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each node $v$ as the center, we root the tree at $v$ and do a DFS. When visiting a vertex $u$, we recursively compute the number of subtrees rooted at $u$ and with depth $i$, for each possible $i$.\\nWhen combining the results from the children of $u$, a naive implementation takes $O(deg(u)\\\\times n^2)$ time. By using prefix sum, it can be reduced to $O(deg(u)\\\\times n)$ time. Thus a DFS takes $O(n^2)$ since the total degree of a tree is $O(n)$.\\nAt root $v$, we combine the results from its children. Since we care about only even diameter and centered at $v$, two branches of same depth $i$ form a subtree of diamter $2i$. When combining the branches one by one, we need to count the way that a current subtree is merged with a small incoming subtree which does not change its diameter.\\nThe case of odd diameter is similar and simpler since there are only two branches for each center edge.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n^3)$ since each center vertex takes $O(n^2)$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nLinear.\\n\\n# Code\\n```\\nclass Solution:\\n    # odd/even diameter couned individually\\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\\n        adj = [[] for i in range(n)]\\n        for u,v in edges:\\n            adj[u-1].append(v-1)\\n            adj[v-1].append(u-1)\\n        def comb(p,q): # merge p and q, res[max(i,j)]+=p[i]*q[j]\\n            if len(q)<len(p): p,q = q,p\\n            res = [0]*len(q)\\n            res[0] = p[0]*q[0]\\n            for i in range(1,len(p)): p[i] += p[i-1]\\n            for i in range(1,len(q)): q[i] += q[i-1]\\n            for i in range(1,len(p)):\\n                res[i] = p[i]*q[i]-p[i-1]*q[i-1]\\n            for i in range(len(p),len(q)):\\n                res[i] = (q[i]-q[i-1])*p[-1]\\n            return res\\n            \\n        def dfs(r,p): # num of subtree rooted at r with given depth\\n            d = [1]\\n            for v in adj[r]:\\n                if v==p: continue\\n                t = [1]+dfs(v,r)\\n                d = comb(t,d)\\n            return d\\n        #end dfs\\n        ans = [0]*n\\n        # odd diameter with (u,v) as center edge\\n        for u,v in edges:\\n            u -= 1; v-=1\\n            p = dfs(u,v)\\n            q = dfs(v,u)\\n            for i in range(min(len(p),len(q))):\\n                ans[i+i+1] += p[i]*q[i]\\n        #even diamter with v as center vertex\\n        for v in range(n): \\n            if len(adj[v])==1: continue \\n            tree = [1]+dfs(adj[v][0],v) #tree with depth\\n            curr = [0]*n\\n            for u in adj[v][1:]:\\n                q = [1]+dfs(u,v)\\n                # curr tree + new small\\n                j = 1; t = q[1]+1 # prefix sum of q\\n                for i in range(4,n,2):\\n                    while j+1<min(i//2,len(q)):\\n                        j += 1; t += q[j]\\n                    curr[i] *= t\\n                # curr tree + same height\\n                for i in range(min(len(tree),len(q))):\\n                    curr[i+i] += tree[i]*q[i]\\n                tree = comb(tree,q)\\n            for i in range(2,n,2):\\n                ans[i] += curr[i]\\n        #end\\n        return ans[1:]\\n\\n\\n```\\n"
    },
    {
        "slug": "number-of-1-bits",
        "tags": "python3",
        "release_time": 1690482901,
        "code": "class Solution:\n    def hammingWeight(self, n: int) -> int:\n        c = Counter(str(bin(n)))\n        return c['1']",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWorking on Binary Digits\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Counter on the Binary Digits\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def hammingWeight(self, n: int) -> int:\\n        c = Counter(str(bin(n)))\\n        return c[\\'1\\']\\n\\n```"
    },
    {
        "slug": "soup-servings",
        "tags": "python3",
        "release_time": 1690615440,
        "code": "class Solution:\n    def soupServings(self, n: int) -> float:\n        if n > 4500:\n            return 1\n        SERVING_OPTIONS = [(100, 0), (75, 25), (50, 50), (25, 75)]\n        # (ml_soup_a, ml_soup_b) = [numerator, denominator]\n        quantities_chance = {(n, n): [1, 1]}\n        q = deque()\n        q.appendleft((n, n))\n        answer_numerator = 0\n        answer_denominator = 1\n        while q:\n            ml_soup_a, ml_soup_b = q.pop()\n            chance_numerator, chance_denominator = quantities_chance.pop((ml_soup_a, ml_soup_b))\n            if min(ml_soup_a, ml_soup_b) <= 0:\n                while answer_denominator < chance_denominator:\n                    answer_numerator <<= 2\n                    answer_denominator <<= 2\n                if ml_soup_a <= 0:\n                    answer_numerator += chance_numerator\n                if ml_soup_b > 0:\n                    answer_numerator += chance_numerator\n                continue\n            for serving_a, serving_b in SERVING_OPTIONS:\n                remaining_soups = (ml_soup_a - serving_a, ml_soup_b - serving_b)\n                if remaining_soups not in quantities_chance:\n                    q.appendleft(remaining_soups)\n                    quantities_chance[remaining_soups] = [0, chance_denominator << 2]\n                quantities_chance[remaining_soups][0] += chance_numerator\n        return answer_numerator / (answer_denominator << 1)",
        "content": "![2023-07-29 00_20_36-LeetCode - The World\\'s Leading Online Programming Learning Platform.png](https://assets.leetcode.com/users/images/ace05f84-6f19-4024-8b7f-8d10ecbe8694_1690615271.3925884.png)\\n\\n\\n# Intuition\\nMost of this follows similar concepts as the editorial, but instead of adding complexity with dividing by 25 and messing about with adding fractions of fractions, I chose to keep everything integer and keep track of the success count and total count as numerator and denominator. Because of the curveball of tie counting for half, the numerator is doubled in the loop, and at the very end I double the denominator to compensate. \\n\\nOnly integer subtraction is needed for soup quantities, the chance count is addition. \\nMultiplication of the denominator is required when forking to different possibilities, and when updating the answer to common denominator, but in those cases it\\'s both multiplying by 4. That is equivalent to bitshift by 2, which i\\'ve chosen to replace it with.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def soupServings(self, n: int) -> float:\\n        if n > 4500:\\n            return 1\\n        SERVING_OPTIONS = [(100, 0), (75, 25), (50, 50), (25, 75)]\\n        # (ml_soup_a, ml_soup_b) = [numerator, denominator]\\n        quantities_chance = {(n, n): [1, 1]}\\n        q = deque()\\n        q.appendleft((n, n))\\n        answer_numerator = 0\\n        answer_denominator = 1\\n        while q:\\n            ml_soup_a, ml_soup_b = q.pop()\\n            chance_numerator, chance_denominator = quantities_chance.pop((ml_soup_a, ml_soup_b))\\n            if min(ml_soup_a, ml_soup_b) <= 0:\\n                while answer_denominator < chance_denominator:\\n                    answer_numerator <<= 2\\n                    answer_denominator <<= 2\\n                if ml_soup_a <= 0:\\n                    answer_numerator += chance_numerator\\n                if ml_soup_b > 0:\\n                    answer_numerator += chance_numerator\\n                continue\\n            for serving_a, serving_b in SERVING_OPTIONS:\\n                remaining_soups = (ml_soup_a - serving_a, ml_soup_b - serving_b)\\n                if remaining_soups not in quantities_chance:\\n                    q.appendleft(remaining_soups)\\n                    quantities_chance[remaining_soups] = [0, chance_denominator << 2]\\n                quantities_chance[remaining_soups][0] += chance_numerator\\n        return answer_numerator / (answer_denominator << 1)\\n\\n\\n```"
    },
    {
        "slug": "longest-word-in-dictionary-through-deleting",
        "tags": "python3",
        "release_time": 1678402227,
        "code": "class Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        longest_word = ''\n        for word in d:\n            i , j =0 , 0\n            while i < len(word) and j < len(s):\n                if word[i] == s[j]:\n                    i+=1\n                    j+=1\n                else:\n                    j+=1\n            if i == len(word):\n                if len(longest_word) < len(word):\n                    longest_word = word\n                elif len(word) == len(longest_word):\n                    longest_word = min(longest_word , word)\n        return longest_word\n\nclass Solution:\n    def findLongestWord(self, s: str, d: List[str]) -> str:\n        res = ''\n        for cand in d:\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\n                res = cand\n        return res\n    \n\n    def find(self , s ,d):\n        i , j = 0 , 0\n        while i < len(s) and j < len(d):\n            if s[i] == d[j]:\n                i+=1\n                j+=1\n            else:\n                i+=1\n        return j == len(d)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        longest_word = \\'\\'\\n        for word in d:\\n            i , j =0 , 0\\n            while i < len(word) and j < len(s):\\n                if word[i] == s[j]:\\n                    i+=1\\n                    j+=1\\n                else:\\n                    j+=1\\n            if i == len(word):\\n                if len(longest_word) < len(word):\\n                    longest_word = word\\n                elif len(word) == len(longest_word):\\n                    longest_word = min(longest_word , word)\\n        return longest_word\\n\\nclass Solution:\\n    def findLongestWord(self, s: str, d: List[str]) -> str:\\n        res = \\'\\'\\n        for cand in d:\\n            if self.find(s, cand) and (len(cand) > len(res) or (len(cand) == len(res) and cand < res)):\\n                res = cand\\n        return res\\n    \\n\\n    def find(self , s ,d):\\n        i , j = 0 , 0\\n        while i < len(s) and j < len(d):\\n            if s[i] == d[j]:\\n                i+=1\\n                j+=1\\n            else:\\n                i+=1\\n        return j == len(d)\\n"
    },
    {
        "slug": "making-a-large-island",
        "tags": "python3",
        "release_time": 1676904433,
        "code": "from collections import deque\nclass Solution:\n    def largestIsland(self, grid: List[List[int]]) -> int:\n        i = 0 \n        j = 0\n        n = len(grid)\n        islands_sizes = []\n        \n\n        def vertex_neighb(coord_i, coord_j):\n            neighbours = []\n            if coord_j + 1 < n and grid[coord_i][coord_j + 1] == 1:\n                neighbours.append((coord_i, coord_j + 1))\n\n            if coord_j > 0 and grid[coord_i][coord_j - 1] == 1:\n                neighbours.append((coord_i, coord_j - 1))\n\n            if coord_i + 1 < n and grid[coord_i + 1][coord_j] == 1:\n                neighbours.append((coord_i + 1, coord_j))\n\n            if coord_i > 0 and grid[coord_i - 1][coord_j] == 1:\n                neighbours.append((coord_i - 1, coord_j))\n\n            return neighbours\n\n        for i in range(n):\n            for j in range(n):\n                que = deque([(i, j)])\n                \n                if grid[i][j] == 1:\n                    islands_sizes.append(1)\n                    while que:\n                        vertex = que.popleft()\n                        grid[vertex[0]][vertex[1]] = len(islands_sizes) + 1\n                        \n                        for neighb in vertex_neighb(vertex[0], vertex[1]):\n                            grid[neighb[0]][neighb[1]] = len(islands_sizes) + 1\n                            islands_sizes[-1] += 1\n                            que.append((neighb[0], neighb[1]))\n\n        if islands_sizes:    \n            ans = max(islands_sizes)\n        else:\n            ans = 0\n         \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    neighbours = set()\n                    if j + 1 < n and grid[i][j + 1] != 0:\n                        neighbours.add(grid[i][j + 1])\n\n                    if j > 0 and grid[i][j - 1] != 0:\n                        neighbours.add(grid[i][j - 1])\n\n                    if i + 1 < n and grid[i + 1][j] != 0:\n                        neighbours.add(grid[i + 1][j])\n\n                    if i > 0 and grid[i - 1][j] != 0:\n                        neighbours.add(grid[i - 1][j])\n                    curr_size = 1\n                    for neighb in neighbours:\n                        curr_size += islands_sizes[neighb - 2]\n                    \n                    ans = max(ans, curr_size)\n\n        return ans",
        "content": "# Intuition\\nBy replacing water cell to earth cell (0 -> 1) we can either increase area of nearby island by +1 or either connect nearby island by that cell. If there is no nearby island, we got island of size 1.\\nSo, at every water cell we calculate size of possible island `curr_size` and update max size `ans`. \\n\\n# Approach\\nFirstly, we apply Breadth-First Search to find all islands and save size of islands in array `islands_sizes`. Moreover, we mark every visited island as `number` 2, 3, 4.. and `islands_sizes[number - 2]` is a size of island `number`. \\n\\nNext, we iterate over water cells. At every `0` cell, initialy `curr_size = 1`, then we check its neighbours and if it is island `number`, we increase current cell size by size of this neighbour island `islands_sizes[number - 2]`. For this step `neighbours` of current water cell is `set()`, because we have to add size of every neighbour only once.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\nBFS and iterating over all water cells is N^2 + N^2.\\n\\n- Space complexity: O(N^2)\\n`islands_sizes` in the worst case has N*N / 2 elements. So memory is O(N^2).\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        i = 0 \\n        j = 0\\n        n = len(grid)\\n        islands_sizes = []\\n        \\n\\n        def vertex_neighb(coord_i, coord_j):\\n            neighbours = []\\n            if coord_j + 1 < n and grid[coord_i][coord_j + 1] == 1:\\n                neighbours.append((coord_i, coord_j + 1))\\n\\n            if coord_j > 0 and grid[coord_i][coord_j - 1] == 1:\\n                neighbours.append((coord_i, coord_j - 1))\\n\\n            if coord_i + 1 < n and grid[coord_i + 1][coord_j] == 1:\\n                neighbours.append((coord_i + 1, coord_j))\\n\\n            if coord_i > 0 and grid[coord_i - 1][coord_j] == 1:\\n                neighbours.append((coord_i - 1, coord_j))\\n\\n            return neighbours\\n\\n        for i in range(n):\\n            for j in range(n):\\n                que = deque([(i, j)])\\n                \\n                if grid[i][j] == 1:\\n                    islands_sizes.append(1)\\n                    while que:\\n                        vertex = que.popleft()\\n                        grid[vertex[0]][vertex[1]] = len(islands_sizes) + 1\\n                        \\n                        for neighb in vertex_neighb(vertex[0], vertex[1]):\\n                            grid[neighb[0]][neighb[1]] = len(islands_sizes) + 1\\n                            islands_sizes[-1] += 1\\n                            que.append((neighb[0], neighb[1]))\\n\\n        if islands_sizes:    \\n            ans = max(islands_sizes)\\n        else:\\n            ans = 0\\n         \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    neighbours = set()\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        neighbours.add(grid[i][j + 1])\\n\\n                    if j > 0 and grid[i][j - 1] != 0:\\n                        neighbours.add(grid[i][j - 1])\\n\\n                    if i + 1 < n and grid[i + 1][j] != 0:\\n                        neighbours.add(grid[i + 1][j])\\n\\n                    if i > 0 and grid[i - 1][j] != 0:\\n                        neighbours.add(grid[i - 1][j])\\n                    curr_size = 1\\n                    for neighb in neighbours:\\n                        curr_size += islands_sizes[neighb - 2]\\n                    \\n                    ans = max(ans, curr_size)\\n\\n        return ans\\n\\n```"
    },
    {
        "slug": "minimum-number-of-work-sessions-to-finish-the-tasks",
        "tags": "python3",
        "release_time": 1630248857,
        "code": "class Solution:\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\n        subsets = []\n        self.ans = len(tasks)\n        \n        def func(idx):\n            if len(subsets) >= self.ans:\n                return\n            \n            if idx == len(tasks):\n                self.ans = min(self.ans, len(subsets))\n                return\n            \n            for i in range(len(subsets)):\n                if subsets[i] + tasks[idx] <= sessionTime:\n                    subsets[i] += tasks[idx]\n                    func(idx + 1)\n                    subsets[i] -= tasks[idx]\n            \n            subsets.append(tasks[idx])\n            func(idx + 1)\n            subsets.pop()\n        \n        func(0)\n        return self.ans",
        "content": "* I think the test cases are little weak, because I just did backtracking and a little pruning and seems to be 4x faster than bitmask solutions.\\n* The question boils down to finding minimum number of subsets such that each subset sum <= sessionTime. I maintain a list called subsets, where I track each subset sum. For each tasks[i] try to fit it into one of the existing subsets or create a new subset with this tasks[i] and recurse further. Once I reach the end of the list, I compare the length of the subsets list with current best and record minimum.\\n* For pruning, I do the following - Once the length of subsets is larger than current best length, I backtrack. This doesn\\'t decrease complexity in mathematical terms but I think in implementation, it helps a lot.\\n\\n```\\nclass Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        subsets = []\\n        self.ans = len(tasks)\\n        \\n        def func(idx):\\n            if len(subsets) >= self.ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                self.ans = min(self.ans, len(subsets))\\n                return\\n            \\n            for i in range(len(subsets)):\\n                if subsets[i] + tasks[idx] <= sessionTime:\\n                    subsets[i] += tasks[idx]\\n                    func(idx + 1)\\n                    subsets[i] -= tasks[idx]\\n            \\n            subsets.append(tasks[idx])\\n            func(idx + 1)\\n            subsets.pop()\\n        \\n        func(0)\\n        return self.ans"
    },
    {
        "slug": "time-to-cross-a-bridge",
        "tags": "python3",
        "release_time": 1673150950,
        "code": "class Solution:\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\n        ans = 0\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\n        right = []\n        save = []\n        heapify(left)\n        cnt = note = tmstamp = 0\n        while cnt < n:\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\n                tmstamp = save[0][0]\n            while save and save[0][0] <= tmstamp:\n                t, eff, idx, direction = heappop(save)\n                if direction == 1:\n                    heappush(left, [eff, idx])\n                else:\n                    heappush(right, [eff, idx])\n            flag = True\n            if note == n:\n                while len(right) == 0:\n                    t, eff, idx, direction = heappop(save)\n                    tmstamp = t\n                    if direction == 0: heappush(right, [eff, idx])\n            elif len(right) == 0: flag = False\n            cnt += flag\n            if flag:\n                eff, idx = heappop(right)\n                tmstamp += time[-idx][2]\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\n            else:\n                eff, idx = heappop(left)\n                tmstamp += time[-idx][0]\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\n                note += 1\n        return tmstamp",
        "content": "Credit to @Yawn_Sean for this incredible solution (for self-learning purpose).\\n\\n# Code\\n```\\nclass Solution:\\n    def findCrossingTime(self, n: int, k: int, time: List[List[int]]) -> int:\\n        ans = 0\\n        left = [[-t[0]-t[2], -i] for i, t in enumerate(time)]\\n        right = []\\n        save = []\\n        heapify(left)\\n        cnt = note = tmstamp = 0\\n        while cnt < n:\\n            if len(left) == len(right) == 0 and save[0][0] > tmstamp:\\n                tmstamp = save[0][0]\\n            while save and save[0][0] <= tmstamp:\\n                t, eff, idx, direction = heappop(save)\\n                if direction == 1:\\n                    heappush(left, [eff, idx])\\n                else:\\n                    heappush(right, [eff, idx])\\n            flag = True\\n            if note == n:\\n                while len(right) == 0:\\n                    t, eff, idx, direction = heappop(save)\\n                    tmstamp = t\\n                    if direction == 0: heappush(right, [eff, idx])\\n            elif len(right) == 0: flag = False\\n            cnt += flag\\n            if flag:\\n                eff, idx = heappop(right)\\n                tmstamp += time[-idx][2]\\n                heappush(save, [tmstamp + time[-idx][3], eff, idx, 1])\\n            else:\\n                eff, idx = heappop(left)\\n                tmstamp += time[-idx][0]\\n                heappush(save, [tmstamp + time[-idx][1], eff, idx, 0])\\n                note += 1\\n        return tmstamp\\n```"
    },
    {
        "slug": "corporate-flight-bookings",
        "tags": "python3",
        "release_time": 1683138059,
        "code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        diff = [0] * (n + 1)\n        for f, l, s in bookings:\n            diff[f - 1] += s\n            diff[l] -= s\n        for i in range(1, n):\n            diff[i] += diff[i - 1]\n        return diff[:-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n        diff = [0] * (n + 1)\\n        for f, l, s in bookings:\\n            diff[f - 1] += s\\n            diff[l] -= s\\n        for i in range(1, n):\\n            diff[i] += diff[i - 1]\\n        return diff[:-1]\\n```"
    },
    {
        "slug": "create-components-with-same-value",
        "tags": "python3",
        "release_time": 1665861689,
        "code": "class Solution:\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\n        tree = [[] for _ in nums]\n        for u, v in edges: \n            tree[u].append(v)\n            tree[v].append(u)\n        \n        def fn(u, p):\n            \"\"\"Post-order dfs.\"\"\"\n            ans = nums[u]\n            for v in tree[u]: \n                if v != p: ans += fn(v, u)\n            return 0 if ans == cand else ans\n        \n        total = sum(nums)\n        for cand in range(1, total//2+1): \n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\n        return 0",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b09317beeb5fa2ae0b6d2537172ab52647a75cea) for solutions of biweekly 89. \\n\\n```\\nclass Solution:\\n    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:\\n        tree = [[] for _ in nums]\\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        \\n        def fn(u, p):\\n            \"\"\"Post-order dfs.\"\"\"\\n            ans = nums[u]\\n            for v in tree[u]: \\n                if v != p: ans += fn(v, u)\\n            return 0 if ans == cand else ans\\n        \\n        total = sum(nums)\\n        for cand in range(1, total//2+1): \\n            if total % cand == 0 and fn(0, -1) == 0: return total//cand-1\\n        return 0 \\n```"
    },
    {
        "slug": "two-furthest-houses-with-different-colors",
        "tags": "python3",
        "release_time": 1637467628,
        "code": "class Solution:\n    def maxDistance(self, colors: List[int]) -> int:\n        ans = 0 \n        for i, x in enumerate(colors): \n            if x != colors[0]: ans = max(ans, i)\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\n        return ans",
        "content": "Downvoters, lease a comment! \\n\\nIt is not difficult to find out that at least one of the end points will be used. \\n\\nPlease check out this [commit](https://github.com/gaosanyong/leetcode/commit/b5ca73e6f7d317e9f30f7e67a499b0bf489ec019) for the solutions of weekly 268. \\n```\\nclass Solution:\\n    def maxDistance(self, colors: List[int]) -> int:\\n        ans = 0 \\n        for i, x in enumerate(colors): \\n            if x != colors[0]: ans = max(ans, i)\\n            if x != colors[-1]: ans = max(ans, len(colors)-1-i)\\n        return ans \\n```"
    },
    {
        "slug": "remove-all-adjacent-duplicates-in-string-ii",
        "tags": "python3",
        "release_time": 1674847647,
        "code": "class Solution:\n    def removeDuplicates(self, s: str, k: int) -> str:\n\n        stack = [] #will contain lists with [letter, count] pairs\n\n        for letter in s: #loop through each letter in string s\n            if stack and letter == stack[-1][0]: #if stack is not empty and the current letter is the same as the previously appended letter\n                stack[-1][1] += 1 #increase the consecutive count by 1 \n                if stack[-1][1] == k: #if the count is == k: \n                    stack.pop() # then remove the last appended item\n            else: stack.append([letter, 1]) #else append the letter and a count of 1\n            \n        return \"\".join(letter * count for letter, count in stack) #concatenate remaining letter strings and join them together",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str, k: int) -> str:\\n\\n        stack = [] #will contain lists with [letter, count] pairs\\n\\n        for letter in s: #loop through each letter in string s\\n            if stack and letter == stack[-1][0]: #if stack is not empty and the current letter is the same as the previously appended letter\\n                stack[-1][1] += 1 #increase the consecutive count by 1 \\n                if stack[-1][1] == k: #if the count is == k: \\n                    stack.pop() # then remove the last appended item\\n            else: stack.append([letter, 1]) #else append the letter and a count of 1\\n            \\n        return \"\".join(letter * count for letter, count in stack) #concatenate remaining letter strings and join them together\\n```"
    },
    {
        "slug": "split-linked-list-in-parts",
        "tags": "python3",
        "release_time": 1680676083,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\n\n        # first calculate the length\n        # then find the arrangement of the number of elements and store it in list\n    \n        l = []\n        length = 0\n        ptr = head\n        while(ptr) :\n            length += 1\n            ptr = ptr.next\n\n        # possible length of the elements of an node to split\n        # first find how much it will be posiibe to split by length // k\n        # then calculate the remaining no of elements by length % k\n        arrange = []\n        maxi = length//k \n        remain = length%k\n\n        for i in range(k) :\n            if remain :\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\n                remain -= 1\n            else:\n                arrange.append(maxi)\n\n        # now traverse the linked list and split the node \n        j = 0\n        ptr = head \n        i = 0\n        while(ptr) :\n            q = ptr \n            i += 1\n            ptr = ptr.next \n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\n            if i == arrange[j] :\n                q.next = None\n                l.append(head)\n                head = ptr \n                i = 0\n                j += 1\n\n        # if the length is not satisfied then just add none\n        for i in range(j,k):\n            l.append(None)\n        return l",
        "content": "\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:\\n\\n        # first calculate the length\\n        # then find the arrangement of the number of elements and store it in list\\n    \\n        l = []\\n        length = 0\\n        ptr = head\\n        while(ptr) :\\n            length += 1\\n            ptr = ptr.next\\n\\n        # possible length of the elements of an node to split\\n        # first find how much it will be posiibe to split by length // k\\n        # then calculate the remaining no of elements by length % k\\n        arrange = []\\n        maxi = length//k \\n        remain = length%k\\n\\n        for i in range(k) :\\n            if remain :\\n                arrange.append(maxi + 1)  # add 1 till the reaminder become 0\\n                remain -= 1\\n            else:\\n                arrange.append(maxi)\\n\\n        # now traverse the linked list and split the node \\n        j = 0\\n        ptr = head \\n        i = 0\\n        while(ptr) :\\n            q = ptr \\n            i += 1\\n            ptr = ptr.next \\n            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None\\n            if i == arrange[j] :\\n                q.next = None\\n                l.append(head)\\n                head = ptr \\n                i = 0\\n                j += 1\\n\\n        # if the length is not satisfied then just add none\\n        for i in range(j,k):\\n            l.append(None)\\n        return l\\n```"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "tags": "python3",
        "release_time": 1679810937,
        "code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        n=len(edges)\n        bl=[0]*n\n        mp=defaultdict(int)\n        mx=-1\n        for i in range(n):\n            if(bl[i]==0):\n                x=i\n                l=0\n                st=set()\n                while x>-1 and bl[x]==0:\n                    bl[x]=1\n                    mp[x]=l\n                    l+=1\n                    st.add(x)\n                    x=edges[x]\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\n        return mx",
        "content": "![image.png](https://assets.leetcode.com/users/images/32aa55a9-332b-46f6-a6ba-0936acd42ead_1679810850.9233634.png)\\n# Please UPVOTE\\uD83D\\uDE0A\\n\\n## Python3\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        bl=[0]*n\\n        mp=defaultdict(int)\\n        mx=-1\\n        for i in range(n):\\n            if(bl[i]==0):\\n                x=i\\n                l=0\\n                st=set()\\n                while x>-1 and bl[x]==0:\\n                    bl[x]=1\\n                    mp[x]=l\\n                    l+=1\\n                    st.add(x)\\n                    x=edges[x]\\n                if(x!=-1 and x in st): mx=max(mx,l-mp[x])\\n        return mx\\n```"
    },
    {
        "slug": "simple-bank-system",
        "tags": "python3",
        "release_time": 1634443438,
        "code": "class Bank:\n\n    def __init__(self, balance: List[int]):\n        self.balance = balance\n\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\n        if self.withdraw(account1, money): \n            if self.deposit(account2, money): return True \n            self.deposit(account1, money)\n\n    def deposit(self, account: int, money: int) -> bool:\n        if 1 <= account <= len(self.balance): \n            self.balance[account-1] += money\n            return True \n        \n    def withdraw(self, account: int, money: int) -> bool:\n        if 1 <= account <= len(self.balance) and self.balance[account-1] >= money: \n            self.balance[account-1] -= money\n            return True",
        "content": "\\n```\\nclass Bank:\\n\\n    def __init__(self, balance: List[int]):\\n        self.balance = balance\\n\\n    def transfer(self, account1: int, account2: int, money: int) -> bool:\\n        if self.withdraw(account1, money): \\n            if self.deposit(account2, money): return True \\n            self.deposit(account1, money)\\n\\n    def deposit(self, account: int, money: int) -> bool:\\n        if 1 <= account <= len(self.balance): \\n            self.balance[account-1] += money\\n            return True \\n        \\n    def withdraw(self, account: int, money: int) -> bool:\\n        if 1 <= account <= len(self.balance) and self.balance[account-1] >= money: \\n            self.balance[account-1] -= money\\n            return True \\n```"
    },
    {
        "slug": "redundant-connection",
        "tags": "python3",
        "release_time": 1680183186,
        "code": "class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        parent = [i for i in range(len(edges)+1)]\n        rank = [1]* (len(edges)+1)\n\n        def find(n):\n            temp = parent[n]\n            while temp!=parent[temp]:\n                temp=parent[temp]\n            return temp\n        \n        def union(n1,n2):\n            p1 , p2 = find(n1),find(n2)\n\n            if p1 == p2:\n                return False\n            \n            if rank[p1] > rank[p2]:\n                parent[p2] = p1\n                rank[p1]+=rank[p2]\n            else: \n                parent[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n        \n        for i,j in edges:\n            if not union(i,j):\n                return [i,j]",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\\n        parent = [i for i in range(len(edges)+1)]\\n        rank = [1]* (len(edges)+1)\\n\\n        def find(n):\\n            temp = parent[n]\\n            while temp!=parent[temp]:\\n                temp=parent[temp]\\n            return temp\\n        \\n        def union(n1,n2):\\n            p1 , p2 = find(n1),find(n2)\\n\\n            if p1 == p2:\\n                return False\\n            \\n            if rank[p1] > rank[p2]:\\n                parent[p2] = p1\\n                rank[p1]+=rank[p2]\\n            else: \\n                parent[p1] = p2\\n                rank[p2] += rank[p1]\\n            return True\\n        \\n        for i,j in edges:\\n            if not union(i,j):\\n                return [i,j]\\n\\n\\n\\n        \\n```"
    },
    {
        "slug": "categorize-box-according-to-criteria",
        "tags": "python3",
        "release_time": 1673528770,
        "code": "class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        volume = length*width*height\n        if (volume >= 10**9 or height >= 10**4 or width >= 10**4 or length >= 10**4) and mass >=100:\n            return (\"Both\")\n        elif (volume < 10**9 or height < 10**4 or width < 10**4 or length < 10**4) and mass >=100:\n            return (\"Heavy\")\n        elif (volume >= 10**9 or height >= 10**4 or width >= 10**4 or length >= 10**4) and mass <100:\n            return (\"Bulky\")\n        else:\n            return (\"Neither\")",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\\n        volume = length*width*height\\n        if (volume >= 10**9 or height >= 10**4 or width >= 10**4 or length >= 10**4) and mass >=100:\\n            return (\"Both\")\\n        elif (volume < 10**9 or height < 10**4 or width < 10**4 or length < 10**4) and mass >=100:\\n            return (\"Heavy\")\\n        elif (volume >= 10**9 or height >= 10**4 or width >= 10**4 or length >= 10**4) and mass <100:\\n            return (\"Bulky\")\\n        else:\\n            return (\"Neither\")\\n\\n```"
    },
    {
        "slug": "can-convert-string-in-k-moves",
        "tags": "python3",
        "release_time": 1672245179,
        "code": "class Solution:\n    def canConvertString(self, s, t, k):\n        if len(s) != len(t): return False\n        dp = [-1] * 27\n        for a, b in zip(s, t):\n            n = ord(b) - ord(a)\n            dp[n if n >= 0 else 26 + n] += 1\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def canConvertString(self, s, t, k):\\n        if len(s) != len(t): return False\\n        dp = [-1] * 27\\n        for a, b in zip(s, t):\\n            n = ord(b) - ord(a)\\n            dp[n if n >= 0 else 26 + n] += 1\\n        return all([dp[i] <= (k - i) // 26 for i in range(1, 27)])\\n```"
    },
    {
        "slug": "day-of-the-year",
        "tags": "python3",
        "release_time": 1690719004,
        "code": "class Solution:\n    def dayOfYear(self, date: str) -> int:\n\n        return datetime.date.fromisoformat(date).timetuple().tm_yday",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def dayOfYear(self, date: str) -> int:\\n\\n        return datetime.date.fromisoformat(date).timetuple().tm_yday\\n```"
    },
    {
        "slug": "can-you-eat-your-favorite-candy-on-your-favorite-day",
        "tags": "python3",
        "release_time": 1612065726,
        "code": "class Solution:\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\n        prefix = [0]\n        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum \n        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]",
        "content": "**Algo**\\nCompute the prefix sum of `candiesCount`. For a given query (`t`, `day` and `cap`), the condition for `True` is \\n`prefix[t] < (day + 1) * cap and day < prefix[t+1]`\\nwhere the first half reflects the fact that if we eat maximum candies every day we can reach the preferred one and the second half means that if we eat minimum candies (i.e. one candy) every day we won\\'t pass the preferred one. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def canEat(self, candiesCount: List[int], queries: List[List[int]]) -> List[bool]:\\n        prefix = [0]\\n        for x in candiesCount: prefix.append(prefix[-1] + x) # prefix sum \\n        return [prefix[t] < (day+1)*cap and day < prefix[t+1] for t, day, cap in queries]\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`"
    },
    {
        "slug": "powerful-integers",
        "tags": "python3",
        "release_time": 1685619256,
        "code": "class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        if bound == 0:\n            return []\n        \n        def get(v):\n            yield 1\n            if v == 1:\n                return\n            vi = v\n            while vi <= bound:\n                yield vi\n                vi *= v\n        \n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\\n        if bound == 0:\\n            return []\\n        \\n        def get(v):\\n            yield 1\\n            if v == 1:\\n                return\\n            vi = v\\n            while vi <= bound:\\n                yield vi\\n                vi *= v\\n        \\n        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})\\n```"
    },
    {
        "slug": "remove-element",
        "tags": "python3",
        "release_time": 1687139346,
        "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n        i = 0\n        while i < len(nums):\n            if nums[i]==val:\n                nums.pop(i)\n                i-=1\n\n            i+=1\n        return len(nums)",
        "content": "# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n        i = 0\\n        while i < len(nums):\\n            if nums[i]==val:\\n                nums.pop(i)\\n                i-=1\\n\\n            i+=1\\n        return len(nums)\\n```"
    },
    {
        "slug": "roman-to-integer",
        "tags": "python3",
        "release_time": 1674513678,
        "code": "import functools as fn\nimport operator as op\n\nclass Solution:\n    lookup_table = {\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\": 1000,\n    }\n    ops = {\n        False: op.add,\n        True: op.sub\n    }\n    def romanToInt(self, s: str) -> int:\n        _, result = fn.reduce(\n            lambda state, c:  \n                (lambda num, prev_num, result:\n                    (num, self.ops[prev_num > num](result, num))\n                )(self.lookup_table[c], *state),\n            s[::-1],\n            (0, 0)  # prev_num, result\n        )\n        return result",
        "content": "# Intuition\\n\\nUsing `reduce` function from module `functools`\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n# Code\\n```\\nimport functools as fn\\nimport operator as op\\n\\nclass Solution:\\n    lookup_table = {\\n        \"I\": 1,\\n        \"V\": 5,\\n        \"X\": 10,\\n        \"L\": 50,\\n        \"C\": 100,\\n        \"D\": 500,\\n        \"M\": 1000,\\n    }\\n    ops = {\\n        False: op.add,\\n        True: op.sub\\n    }\\n    def romanToInt(self, s: str) -> int:\\n        _, result = fn.reduce(\\n            lambda state, c:  \\n                (lambda num, prev_num, result:\\n                    (num, self.ops[prev_num > num](result, num))\\n                )(self.lookup_table[c], *state),\\n            s[::-1],\\n            (0, 0)  # prev_num, result\\n        )\\n        return result\\n```"
    },
    {
        "slug": "binary-search",
        "tags": "python3",
        "release_time": 1680308257,
        "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        leng = len(nums)\n        hi = leng\n        lo = 0\n        mid = (lo+hi)//2\n        while lo < hi:\n            curr = nums[mid]\n            if curr == target:\n                return mid\n            elif curr < target:\n                lo = mid\n                mid = (lo+hi)//2\n                if lo == mid:\n                    lo+=1\n            else:\n                hi = mid\n                mid = (lo+hi)//2\n                if hi == mid:\n                    hi-=1\n        return -1",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        leng = len(nums)\\n        hi = leng\\n        lo = 0\\n        mid = (lo+hi)//2\\n        while lo < hi:\\n            curr = nums[mid]\\n            if curr == target:\\n                return mid\\n            elif curr < target:\\n                lo = mid\\n                mid = (lo+hi)//2\\n                if lo == mid:\\n                    lo+=1\\n            else:\\n                hi = mid\\n                mid = (lo+hi)//2\\n                if hi == mid:\\n                    hi-=1\\n        return -1\\n```"
    },
    {
        "slug": "check-if-two-string-arrays-are-equivalent",
        "tags": "python3",
        "release_time": 1691924075,
        "code": "class Solution:\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\n        word3=\"\".join(word1)\n        word4=\"\".join(word2)\n        if word3==word4:\n            return True\n        else:\n            return False",
        "content": "**1**.First we will join the contents or concatenate the Strings present in the list using join()\\n**2**.then compare 2 list.\\n**3** if true return true else return false\\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:\\n        word3=\"\".join(word1)\\n        word4=\"\".join(word2)\\n        if word3==word4:\\n            return True\\n        else:\\n            return False\\n```\\n**code**\\nOnline Solution :\\n    -Thank you for this solution @jeevabharathiS\\n        \\n```\\nclass Solution:\\n    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) \\n        return((\"\".join(word1))==(\"\".join(word2)))\\n```"
    },
    {
        "slug": "number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold",
        "tags": "python3",
        "release_time": 1672453951,
        "code": "class Solution:\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\n        minSum = threshold*k\n        firstSum = sum(arr[:k]) \n        count = 0\n        if firstSum >= minSum:\n            count+=1\n\n        for i in range(1,len(arr)-k+1):\n            firstSum -= arr[i-1]\n            firstSum += arr[i+k-1]\n            if firstSum >= minSum:\n                count+=1 \n\n        return count",
        "content": "# Code\\n```\\nclass Solution:\\n    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:\\n        minSum = threshold*k\\n        firstSum = sum(arr[:k]) \\n        count = 0\\n        if firstSum >= minSum:\\n            count+=1\\n\\n        for i in range(1,len(arr)-k+1):\\n            firstSum -= arr[i-1]\\n            firstSum += arr[i+k-1]\\n            if firstSum >= minSum:\\n                count+=1 \\n\\n        return count\\n\\n```"
    },
    {
        "slug": "design-memory-allocator",
        "tags": "python3",
        "release_time": 1670731951,
        "code": "class Allocator:\n\n    def __init__(self, n: int):\n        self.mem = [0]*n\n        \n    def allocate(self, size: int, mID: int) -> int:\n        def checksize(size):\n            flag = False \n            pos = -1\n            count = 0\n            for i in range(0, len(self.mem)):\n                if self.mem[i] == 0:\n                    flag = True\n                    count += 1\n                    if count == size:\n                        return pos + 1\n                else:\n                    if count >= size:\n                        return pos + 1\n                    pos = i\n                    count = 0\n            return -1\n                \n                \n        idx = checksize(size)\n        if idx == -1:\n            return -1\n        else:\n            for i in range(idx, idx+size):\n                self.mem[i] = mID\n            return idx\n        \n    def free(self, mID: int) -> int:\n        count = 0\n        for i in range(0, len(self.mem)):\n            if self.mem[i] == mID:\n                self.mem[i] = 0\n                count += 1\n        return count\n\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)",
        "content": "# Code\\n```\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.mem = [0]*n\\n        \\n    def allocate(self, size: int, mID: int) -> int:\\n        def checksize(size):\\n            flag = False \\n            pos = -1\\n            count = 0\\n            for i in range(0, len(self.mem)):\\n                if self.mem[i] == 0:\\n                    flag = True\\n                    count += 1\\n                    if count == size:\\n                        return pos + 1\\n                else:\\n                    if count >= size:\\n                        return pos + 1\\n                    pos = i\\n                    count = 0\\n            return -1\\n                \\n                \\n        idx = checksize(size)\\n        if idx == -1:\\n            return -1\\n        else:\\n            for i in range(idx, idx+size):\\n                self.mem[i] = mID\\n            return idx\\n        \\n    def free(self, mID: int) -> int:\\n        count = 0\\n        for i in range(0, len(self.mem)):\\n            if self.mem[i] == mID:\\n                self.mem[i] = 0\\n                count += 1\\n        return count\\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```"
    },
    {
        "slug": "redundant-connection",
        "tags": "python3",
        "release_time": 1672482190,
        "code": "class Disjoint:\n    def __init__(self,n):\n        self.rank=[0]*(n+1)\n        self.parent=[i for i in range(n+1)]\n    \n    def findUpar(self,node):\n        if node==self.parent[node]:\n            return node\n        self.parent[node]=self.findUpar(self.parent[node])\n        return self.parent[node]\n\n    def byRank(self,u,v):\n        ulp_u=self.findUpar(u)\n        ulp_v=self.findUpar(v)\n        if ulp_u==ulp_v:\n            return False\n        if self.rank[ulp_u]>self.rank[ulp_v]:\n            self.parent[ulp_v]=ulp_u\n        elif self.rank[ulp_v]<self.rank[ulp_u]:\n            self.parent[ulp_u]=ulp_v\n        else:\n            self.parent[ulp_v]=ulp_u\n            self.rank[ulp_u]+=1\n        return True\n\n\nclass Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        n=len(edges)\n        disjoint=Disjoint(n)\n        for x,y in edges:\n            if disjoint.byRank(x,y)==False:\n                lst=[x,y]\n        return lst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n$$ Disjoint Set $$\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Disjoint:\\n    def __init__(self,n):\\n        self.rank=[0]*(n+1)\\n        self.parent=[i for i in range(n+1)]\\n    \\n    def findUpar(self,node):\\n        if node==self.parent[node]:\\n            return node\\n        self.parent[node]=self.findUpar(self.parent[node])\\n        return self.parent[node]\\n\\n    def byRank(self,u,v):\\n        ulp_u=self.findUpar(u)\\n        ulp_v=self.findUpar(v)\\n        if ulp_u==ulp_v:\\n            return False\\n        if self.rank[ulp_u]>self.rank[ulp_v]:\\n            self.parent[ulp_v]=ulp_u\\n        elif self.rank[ulp_v]<self.rank[ulp_u]:\\n            self.parent[ulp_u]=ulp_v\\n        else:\\n            self.parent[ulp_v]=ulp_u\\n            self.rank[ulp_u]+=1\\n        return True\\n\\n\\nclass Solution:\\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\\n        n=len(edges)\\n        disjoint=Disjoint(n)\\n        for x,y in edges:\\n            if disjoint.byRank(x,y)==False:\\n                lst=[x,y]\\n        return lst\\n```"
    },
    {
        "slug": "design-a-text-editor",
        "tags": "python3",
        "release_time": 1671134501,
        "code": "class TextEditor:\n    def __init__(self):\n        self.stack = []\n        self.q = deque([])\n        \n    def addText(self, text: str) -> None:\n        for c in text:\n            self.stack.append(c)\n\n        #return \"\".join(self.stack)\n        \n    def deleteText(self, k: int) -> int:\n        i = 0\n        while self.stack and i < k:\n            self.stack.pop()\n            i += 1\n        return i\n        \n    def cursorLeft(self, k: int) -> str:\n        i = 0\n        while self.stack and i < k:\n            self.q.appendleft(self.stack.pop())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\n    def cursorRight(self, k: int) -> str:\n        i = 0\n        while self.q and i < k:\n            self.stack.append(self.q.popleft())\n            i += 1\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \n            \n\n\n\n       \n        \n\n\n# Your TextEditor object will be instantiated and called as such:\n# obj = TextEditor()\n# obj.addText(text)\n# param_2 = obj.deleteText(k)\n# param_3 = obj.cursorLeft(k)\n# param_4 = obj.cursorRight(k)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\naddText: O(n)\\ndeleteText: O(k)\\ncursorLeft: O(k)\\ncursorRight: O(k)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n\\nclass TextEditor:\\n    def __init__(self):\\n        self.stack = []\\n        self.q = deque([])\\n        \\n    def addText(self, text: str) -> None:\\n        for c in text:\\n            self.stack.append(c)\\n\\n        #return \"\".join(self.stack)\\n        \\n    def deleteText(self, k: int) -> int:\\n        i = 0\\n        while self.stack and i < k:\\n            self.stack.pop()\\n            i += 1\\n        return i\\n        \\n    def cursorLeft(self, k: int) -> str:\\n        i = 0\\n        while self.stack and i < k:\\n            self.q.appendleft(self.stack.pop())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack)\\n    def cursorRight(self, k: int) -> str:\\n        i = 0\\n        while self.q and i < k:\\n            self.stack.append(self.q.popleft())\\n            i += 1\\n        return \"\".join(self.stack[-10:]) if len(self.stack) >= 10 else \"\".join(self.stack) \\n            \\n\\n\\n\\n       \\n        \\n\\n\\n# Your TextEditor object will be instantiated and called as such:\\n# obj = TextEditor()\\n# obj.addText(text)\\n# param_2 = obj.deleteText(k)\\n# param_3 = obj.cursorLeft(k)\\n# param_4 = obj.cursorRight(k)\\n```"
    },
    {
        "slug": "minimum-suffix-flips",
        "tags": "python3",
        "release_time": 1595736156,
        "code": "class Solution:\n    def minFlips(self, target: str) -> int:\n        return len(list(groupby(\"0\" + target)))-1",
        "content": "Algo: \\n\\nTo abstract this problem in math terms, the purpose of it is to simply convert a string composed of `0`\\'s and `1`\\'s to all `0`\\'s using a predefined flip operation that flips everything from a given position to the end. As a result, at any step, one could focus on the left-most `1`. By fliping it, a desirable byproduct is that a continous chunk of `1`\\'s connecting to the left-most `1` is set to `0`. An undesirable side effect is that the next `0` will become the left-most `1`. In the next step, you would have to flip this `1`. \\n\\nIt is not difficult to realize that this problem is to count the number of changes in the string. One caveat is the first character, for which one flip needs to be counted if it is `1`. To unify the operation, we could add a dummy `0` in front so that the string always starts with `0`. \\n\\nUsing the example given by the problem, the above argument would suggest 3 as the answer as there are in total 3 changes while scanning `010111` (a dummy `0` is added in front) from left to right. \\n`10111`\\n`01000` after 1st flip\\n`00111` after 2nd flip\\n`00000` after 3rd flip \\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        return len(list(groupby(\"0\" + target)))-1\\n```\\n\\nHere, we leverage on `groupby` function of `itertools` module which groups the string for us though the only info we need is the number of groups minus one (`n` groups comes with `n-1` changes from group to group).\\n\\nFurthermore, the below elegant solution is due to @awice. \\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans = flip = 0\\n        for bulb in target: \\n            if flip ^ int(bulb): \\n                flip ^= 1\\n                ans += 1\\n        return ans\\n```\\n\\n```\\nclass Solution:\\n    def minFlips(self, target: str) -> int:\\n        ans, prev = 0,\"0\"\\n        for c in target: \\n            if prev != c: ans += 1\\n            prev = c\\n        return ans \\n```"
    },
    {
        "slug": "increasing-decreasing-string",
        "tags": "python3",
        "release_time": 1675543738,
        "code": "class Solution:\n    def sortString(self, s: str) -> str:\n        freq = {}\n        letters = sorted(set(s))\n        res = \"\"\n        for i in s:\n            if i in freq:\n                freq[i]+=1\n            else:\n                freq[i] = 1\n        while freq:\n            for i in letters:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n            for i in letters[::-1]:\n                if  i in freq:\n                    if freq[i]>0:\n                        res+=i\n                        freq[i]-=1\n                    else:\n                        del freq[i]\n\n\n        return res",
        "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a frequency map of s.\\n\\nIterate over all the letters of s in sorted manner and add that character to result .\\n\\nRepeat above step but for reversed string.\\n \\nIf the frequency becomes 0 then we delete the key from dict.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortString(self, s: str) -> str:\\n        freq = {}\\n        letters = sorted(set(s))\\n        res = \"\"\\n        for i in s:\\n            if i in freq:\\n                freq[i]+=1\\n            else:\\n                freq[i] = 1\\n        while freq:\\n            for i in letters:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n            for i in letters[::-1]:\\n                if  i in freq:\\n                    if freq[i]>0:\\n                        res+=i\\n                        freq[i]-=1\\n                    else:\\n                        del freq[i]\\n\\n\\n        return res\\n\\n```"
    },
    {
        "slug": "longest-subsequence-with-limited-sum",
        "tags": "python3",
        "release_time": 1671999947,
        "code": "class Solution:\n  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n    nums, sums, res, n = sorted(nums), [0], [], len(nums)+1\n    for num in nums:\n      sums.append(sums[-1] + num)\n    \n    def bSearch(q, l=0, mid=n>>1, r=n):\n      while l < mid < r:\n        if sums[mid] > q:\n          r = mid\n        elif sums[mid] < q:\n          l = mid\n        else: break\n        mid = (l+r)>>1\n      return mid\n\n    return [bSearch(q) for q in queries]",
        "content": "# Intuition\\n1. Create sums array of sorted\\n2. Search index\\n\\n# Approach\\nBinary search of each index with time complexity $$O(logN)$$\\n\\n# Complexity\\n- Time complexity:\\n  $$O(M*logN)$$\\n\\n- Space complexity:\\n  $$O(Nbi)$$\\n\\n# Code\\n```\\nclass Solution:\\n  def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\\n    nums, sums, res, n = sorted(nums), [0], [], len(nums)+1\\n    for num in nums:\\n      sums.append(sums[-1] + num)\\n    \\n    def bSearch(q, l=0, mid=n>>1, r=n):\\n      while l < mid < r:\\n        if sums[mid] > q:\\n          r = mid\\n        elif sums[mid] < q:\\n          l = mid\\n        else: break\\n        mid = (l+r)>>1\\n      return mid\\n\\n    return [bSearch(q) for q in queries]\\n```"
    },
    {
        "slug": "maximize-number-of-nice-divisors",
        "tags": "python3",
        "release_time": 1686713202,
        "code": "class Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n        else:\n            power = primeFactors // 3\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxNiceDivisors(self, primeFactors: int) -> int:\\n        if primeFactors <= 3:\\n            return primeFactors\\n        \\n        MOD = int(1e9 + 7)\\n        if primeFactors % 3 == 0:\\n            power = primeFactors // 3\\n            return self.calculateNiceDivisors(3, power, MOD)\\n        elif primeFactors % 3 == 1:\\n            power = (primeFactors // 3) - 1\\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\\n        else:\\n            power = primeFactors // 3\\n            return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\\n    \\n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\\n        if power == 0:\\n            return 1\\n\\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\\n        result = (result * result) % MOD\\n\\n        if power % 2 == 1:\\n            result = (result * base) % MOD\\n\\n        return result\\n\\n```"
    },
    {
        "slug": "plates-between-candles",
        "tags": "python3",
        "release_time": 1668663676,
        "code": "# Slightly modified Binary search\n# Say you have an array [3, 5, 7, 9, 15] and you have an element\n# 6 and you want to find closest elements on the left and right\n# of 6 in the array. You can run binary search and ultimately\n# r will point to 5 and l will point to 7, i.e r, l gives the boundary\n# However, if the query is 5, both r, l will point to 5 (note)\n# Also, if q is 16, r will point to 15 but l will point to an element\n# at index = len(array) + 1 ( which doesn't exist) -- so need to handle\n# these cases.\n\n# Using this logic in this problem we'll use Binary Search to find \n# the closest candle on the right of the first element in the \n# query and the closest candle on the left of the second element in the query.\n# The we'll use the prefix sum already computed to compute the \n# sum of the plates between these candles\n\nclass Solution:\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\n        look_up, pre_sum, res = [], [], []\n        for i, e in enumerate(s):\n            if s[i] == '|':\n                look_up.append(i)\n                pre_sum.append(pre_sum[-1] if pre_sum else 0)\n            else:\n                pre_sum.append(pre_sum[-1] + 1 if pre_sum else 1)\n        \n        for st, end in queries:\n            _, r = self.range_bs(look_up, st)\n            l, _ = self.range_bs(look_up, end)\n            if st < end and 0<= r < len(look_up) and 0 <= l < len(look_up):\n                res.append(\n                    max(pre_sum[look_up[l]] - pre_sum[look_up[r]], 0)\n                )\n            else:\n                res.append(0)\n         \n        return res\n                \n        \n    def range_bs(self, look_up, q):\n        l, r = 0, len(look_up) - 1\n        while l <= r:\n            mid = (l+r)//2\n            if look_up[mid] == q:\n                return mid, mid\n            elif look_up[mid] < q:\n                l = mid+1\n            else:\n                r = mid-1\n        return r, l",
        "content": "\\n# Code\\n```\\n# Slightly modified Binary search\\n# Say you have an array [3, 5, 7, 9, 15] and you have an element\\n# 6 and you want to find closest elements on the left and right\\n# of 6 in the array. You can run binary search and ultimately\\n# r will point to 5 and l will point to 7, i.e r, l gives the boundary\\n# However, if the query is 5, both r, l will point to 5 (note)\\n# Also, if q is 16, r will point to 15 but l will point to an element\\n# at index = len(array) + 1 ( which doesn\\'t exist) -- so need to handle\\n# these cases.\\n\\n# Using this logic in this problem we\\'ll use Binary Search to find \\n# the closest candle on the right of the first element in the \\n# query and the closest candle on the left of the second element in the query.\\n# The we\\'ll use the prefix sum already computed to compute the \\n# sum of the plates between these candles\\n\\nclass Solution:\\n    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:\\n        look_up, pre_sum, res = [], [], []\\n        for i, e in enumerate(s):\\n            if s[i] == \\'|\\':\\n                look_up.append(i)\\n                pre_sum.append(pre_sum[-1] if pre_sum else 0)\\n            else:\\n                pre_sum.append(pre_sum[-1] + 1 if pre_sum else 1)\\n        \\n        for st, end in queries:\\n            _, r = self.range_bs(look_up, st)\\n            l, _ = self.range_bs(look_up, end)\\n            if st < end and 0<= r < len(look_up) and 0 <= l < len(look_up):\\n                res.append(\\n                    max(pre_sum[look_up[l]] - pre_sum[look_up[r]], 0)\\n                )\\n            else:\\n                res.append(0)\\n         \\n        return res\\n                \\n        \\n    def range_bs(self, look_up, q):\\n        l, r = 0, len(look_up) - 1\\n        while l <= r:\\n            mid = (l+r)//2\\n            if look_up[mid] == q:\\n                return mid, mid\\n            elif look_up[mid] < q:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return r, l\\n```"
    },
    {
        "slug": "remove-digit-from-number-to-maximize-result",
        "tags": "python3",
        "release_time": 1679225330,
        "code": "class Solution:\n    def removeDigit(self, number: str, digit: str) -> str:\n        n = len(number)\n        for x in range(1, n):\n            prev, cur = number[x-1], number[x]\n            if prev == digit:\n                last_ind = x-1\n                if cur > prev:\n                    ind = x - 1\n                    return number[:ind] + number[ind+1:]\n        else:\n            if number[-1] == digit:\n                last_ind = n-1\n            if last_ind < n-1:\n                return number[:last_ind] + number[last_ind+1:]\n            return number[:last_ind]",
        "content": "# Code\\n```\\nclass Solution:\\n    def removeDigit(self, number: str, digit: str) -> str:\\n        n = len(number)\\n        for x in range(1, n):\\n            prev, cur = number[x-1], number[x]\\n            if prev == digit:\\n                last_ind = x-1\\n                if cur > prev:\\n                    ind = x - 1\\n                    return number[:ind] + number[ind+1:]\\n        else:\\n            if number[-1] == digit:\\n                last_ind = n-1\\n            if last_ind < n-1:\\n                return number[:last_ind] + number[last_ind+1:]\\n            return number[:last_ind]\\n\\n```"
    },
    {
        "slug": "minimum-common-value",
        "tags": "python3",
        "release_time": 1682849769,
        "code": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        p1=0\n        p2=0\n        while p1<len(nums1) and p2<len(nums2):\n            if nums1[p1]<nums2[p2]:\n                p1+=1\n            elif nums1[p1]>nums2[p2]:\n                p2+=1\n            else:\n                return nums1[p1]\n        return -1",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        p1=0\\n        p2=0\\n        while p1<len(nums1) and p2<len(nums2):\\n            if nums1[p1]<nums2[p2]:\\n                p1+=1\\n            elif nums1[p1]>nums2[p2]:\\n                p2+=1\\n            else:\\n                return nums1[p1]\\n        return -1\\n\\n\\n```"
    },
    {
        "slug": "smallest-range-i",
        "tags": "python3",
        "release_time": 1674662361,
        "code": "class Solution:\n    def smallestRangeI(self, A: List[int], K: int) -> int:\n        a=max((max(A) - min(A) - 2*K), 0)\n        return a",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestRangeI(self, A: List[int], K: int) -> int:\\n        a=max((max(A) - min(A) - 2*K), 0)\\n        return a\\n```"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "tags": "python3",
        "release_time": 1689914450,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        l=defaultdict(list)\n        def traversal(root,h):\n            if root is None:\n                return\n            l[h].append(root.val)\n            traversal(root.left,h+1)\n            traversal(root.right,h+1)\n        traversal(root,1)\n        res=[]\n        for i in l.values():\n            res.append(sum(i))\n        res.sort(reverse=True)\n        if k>len(res):\n            return -1\n        return res[k-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/22b9e4b8-e437-417a-877d-8b8fa7c8de68_1689914446.3691285.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,1)\\n        res=[]\\n        for i in l.values():\\n            res.append(sum(i))\\n        res.sort(reverse=True)\\n        if k>len(res):\\n            return -1\\n        return res[k-1]\\n\\n```"
    },
    {
        "slug": "construct-binary-tree-from-inorder-and-postorder-traversal",
        "tags": "python3",
        "release_time": 1692256962,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\n        postorder_idx=len(postorder)-1\n\n        def treeHelper(left, right):\n            nonlocal postorder_idx\n            if left>right:\n                return None\n\n            node_val = postorder[postorder_idx]\n            root=TreeNode(node_val)\n            postorder_idx-=1\n\n            inorder_index=inorder_map[node_val]\n\n            root.right = treeHelper(inorder_index+1, right)\n            root.left = treeHelper(left, inorder_index-1 )\n            \n\n            return root\n\n        return treeHelper(0, len(inorder)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\\n        inorder_map={val:idx for idx, val in enumerate(inorder)}\\n        postorder_idx=len(postorder)-1\\n\\n        def treeHelper(left, right):\\n            nonlocal postorder_idx\\n            if left>right:\\n                return None\\n\\n            node_val = postorder[postorder_idx]\\n            root=TreeNode(node_val)\\n            postorder_idx-=1\\n\\n            inorder_index=inorder_map[node_val]\\n\\n            root.right = treeHelper(inorder_index+1, right)\\n            root.left = treeHelper(left, inorder_index-1 )\\n            \\n\\n            return root\\n\\n        return treeHelper(0, len(inorder)-1)\\n```"
    },
    {
        "slug": "remove-duplicates-from-sorted-array",
        "tags": "python3",
        "release_time": 1679120737,
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        i,j=0,1\n        while i<=j and j<len(nums):\n            if nums[i]==nums[j]:\n                j+=1\n            else:\n                nums[i+1]=nums[j]\n                i+=1\n        return i+1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        i,j=0,1\\n        while i<=j and j<len(nums):\\n            if nums[i]==nums[j]:\\n                j+=1\\n            else:\\n                nums[i+1]=nums[j]\\n                i+=1\\n        return i+1\\n\\n\\n        \\n```\\n# Consider upvoting if found helpul\\n    \\n![57jfh9.jpg](https://assets.leetcode.com/users/images/42468411-f114-491a-8a3d-e8170fad5d00_1679120730.6341107.jpeg)\\n"
    },
    {
        "slug": "truncate-sentence",
        "tags": "python3",
        "release_time": 1691339606,
        "code": "class Solution:\n    def truncateSentence(self, s: str, k: int) -> str:\n        s = s.split()\n        return ' '.join(map(str,s[0:k]))",
        "content": "# Intuition\\nThe problem requires us to write a Python code to perform a specific operation on a given input array and display a subset of elements based on a user-defined value. We will implement a simple Python script that takes an integer input followed by a space-separated list of elements. The code will then extract the first \\'n\\' elements from the list, where \\'n\\' is the integer provided as input. Finally, it will display the selected subset of elements as output.\\n\\n\\n# Approach\\nTo solve this problem, we will follow these steps in our Python code:\\n\\nAccept an integer input using the input() function and store it in a variable, representing the number of elements to be selected from the list.\\nTake the next input, which is a space-separated list of elements, using the input().split() function and store it in a list.\\nExtract the first \\'n\\' elements from the list using array slicing (e.g., list[:n]).\\nConvert the selected subset of elements to a string using the join() function and print the result to the console.\\nWe will ensure the correctness of our code and test it with various input scenarios to verify its functionality.\\n\\nOnce we have written the code, we can share it on LeetCode or any other platform for others to review and provide feedback or use it for their own learning and understanding.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def truncateSentence(self, s: str, k: int) -> str:\\n        s = s.split()\\n        return \\' \\'.join(map(str,s[0:k]))\\n\\n```"
    },
    {
        "slug": "find-the-kth-largest-integer-in-the-array",
        "tags": "python3",
        "release_time": 1688963881,
        "code": "class Solution:\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\n        ls = []\n        for i in nums:\n            ls.append(int(i))\n        sorted_ = sorted(ls)\n        return str(sorted_[-1*k])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        ls = []\\n        for i in nums:\\n            ls.append(int(i))\\n        sorted_ = sorted(ls)\\n        return str(sorted_[-1*k])\\n```"
    },
    {
        "slug": "shortest-distance-to-target-string-in-a-circular-array",
        "tags": "python3",
        "release_time": 1681314529,
        "code": "class Solution:\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\n\n        n = len(words)\n\n        for i in range(n//2 + 1):\n            if target in (words[(startIndex+i) % n],\n                          words[(startIndex-i) % n]):\n                return i\n        \n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom the start index, we can fan out away from it and use the rotation function in case the end of the array is reached.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe increment starting from the starting point and fan out in both directions until they both go opposite directions around the array.  They should meet on the other side.  If the target is found, we immediately return the increment value since that is how far the starting point is from the position that matches the target.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the number of elements in the list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) for a variable to hold the count.\\n\\n# Code\\n```\\nclass Solution:\\n    def closetTarget(self, words: List[str], target: str, startIndex: int) -> int:\\n\\n        n = len(words)\\n\\n        for i in range(n//2 + 1):\\n            if target in (words[(startIndex+i) % n],\\n                          words[(startIndex-i) % n]):\\n                return i\\n        \\n        return -1\\n\\n```"
    },
    {
        "slug": "count-vowel-substrings-of-a-string",
        "tags": "python3",
        "release_time": 1675710573,
        "code": "class Solution:\n    def countVowelSubstrings(self, s: str) -> int:\n        count = 0\n        l = []\n        b = [\"a\",\"e\",\"i\",\"o\",\"u\"]\n        for i in range(len(s)+1):\n            for j in range(i):\n                a = s[j:i]\n                if \"a\" in a and \"e\" in a and \"i\" in a and \"o\" in a and \"u\" in a:\n                    l.append(a)\n        for i in l:\n            c1 = 0\n            for j in i:\n                if j not in b:\n                    c1+=1\n                    break\n            if c1==0:\n                count+=1\n                \n        return (count)",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str) -> int:\\n        count = 0\\n        l = []\\n        b = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                a = s[j:i]\\n                if \"a\" in a and \"e\" in a and \"i\" in a and \"o\" in a and \"u\" in a:\\n                    l.append(a)\\n        for i in l:\\n            c1 = 0\\n            for j in i:\\n                if j not in b:\\n                    c1+=1\\n                    break\\n            if c1==0:\\n                count+=1\\n                \\n        return (count)\\n                \\n```"
    },
    {
        "slug": "powx-n",
        "tags": "python3",
        "release_time": 1690205364,
        "code": "class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        # Base case: If the power is 0, return 1\n        if n == 0:\n            return 1\n\n        # Base case: If the power is 1, return x\n        if n == 1:\n            return x\n\n        # If n is negative, invert x and change n to positive\n        if n < 0:\n            x = 1 / x\n            n = -n\n\n        # Recursive case: Divide and conquer, reducing the power by half\n        half_pow = self.myPow(x, n // 2)\n\n        # If n is even, return half_pow squared\n        if n % 2 == 0:\n            return half_pow * half_pow\n        # If n is odd, return half_pow squared times x\n        else:\n            return half_pow * half_pow * x",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def myPow(self, x: float, n: int) -> float:\\n        # Base case: If the power is 0, return 1\\n        if n == 0:\\n            return 1\\n\\n        # Base case: If the power is 1, return x\\n        if n == 1:\\n            return x\\n\\n        # If n is negative, invert x and change n to positive\\n        if n < 0:\\n            x = 1 / x\\n            n = -n\\n\\n        # Recursive case: Divide and conquer, reducing the power by half\\n        half_pow = self.myPow(x, n // 2)\\n\\n        # If n is even, return half_pow squared\\n        if n % 2 == 0:\\n            return half_pow * half_pow\\n        # If n is odd, return half_pow squared times x\\n        else:\\n            return half_pow * half_pow * x\\n\\n```"
    },
    {
        "slug": "longest-cycle-in-a-graph",
        "tags": "python3",
        "release_time": 1679838535,
        "code": "class Solution:\n    def longestCycle(self, edges: List[int]) -> int:\n        v=[0]*len(edges)\n        ans=-1\n        for i in range(len(edges)):\n            t=1\n            c=i\n            while c>=0:\n                if v[c]!=0:\n                    if v[c][0]==i:\n                        ans=max(ans,t-v[c][1])\n                    break\n                else:\n                    v[c]=[i,t]\n                    t+=1\n                    c=edges[c]\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def longestCycle(self, edges: List[int]) -> int:\\n        v=[0]*len(edges)\\n        ans=-1\\n        for i in range(len(edges)):\\n            t=1\\n            c=i\\n            while c>=0:\\n                if v[c]!=0:\\n                    if v[c][0]==i:\\n                        ans=max(ans,t-v[c][1])\\n                    break\\n                else:\\n                    v[c]=[i,t]\\n                    t+=1\\n                    c=edges[c]\\n        return ans\\n\\n\\n```"
    },
    {
        "slug": "largest-number",
        "tags": "python3",
        "release_time": 1689351895,
        "code": "class Solution:\n    def largestNumber(self, nums: List[int]) -> str:\n        lst = []\n\n        for ele in nums:\n            lst += [str(ele)]\n        \n        n = len(lst)\n\n        for i in range(n):\n            for j in range(i+1 , n):\n                \n                if str(lst[i]) + str(lst[j]) > str(lst[j]) + str(lst[i]):\n                    # if current order is greatest value .. continue\n                    continue\n                else:\n                    # else swap the values ..!!!\n                    lst[i] , lst[j] = lst[j] , lst[i]\n        \n        \n        ans = ''.join(lst)\n\n        if int(ans) == 0:\n            return \"0\"\n        \n        return ans\n\n        \"\"\"\n        A = str(lst[i])\n        B = str(lst[j])\n\n        if AB > BA:\n            continue\n        else:\n            str(lst[i]) = B\n            str(lst[j]) = A\n            # to make the order as BA\n        \"\"\"",
        "content": "# Code\\n```\\nclass Solution:\\n    def largestNumber(self, nums: List[int]) -> str:\\n        lst = []\\n\\n        for ele in nums:\\n            lst += [str(ele)]\\n        \\n        n = len(lst)\\n\\n        for i in range(n):\\n            for j in range(i+1 , n):\\n                \\n                if str(lst[i]) + str(lst[j]) > str(lst[j]) + str(lst[i]):\\n                    # if current order is greatest value .. continue\\n                    continue\\n                else:\\n                    # else swap the values ..!!!\\n                    lst[i] , lst[j] = lst[j] , lst[i]\\n        \\n        \\n        ans = \\'\\'.join(lst)\\n\\n        if int(ans) == 0:\\n            return \"0\"\\n        \\n        return ans\\n\\n        \"\"\"\\n        A = str(lst[i])\\n        B = str(lst[j])\\n\\n        if AB > BA:\\n            continue\\n        else:\\n            str(lst[i]) = B\\n            str(lst[j]) = A\\n            # to make the order as BA\\n        \"\"\"\\n```"
    },
    {
        "slug": "minimum-changes-to-make-alternating-binary-string",
        "tags": "python3",
        "release_time": 1679330768,
        "code": "class Solution:\n    def minOperations(self, s: str) -> int:\n        return min(\n            sum(int(bit) == i & 1 for i, bit in enumerate(s)),\n            sum(int(bit) != i & 1 for i, bit in enumerate(s)),\n        )",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, s: str) -> int:\\n        return min(\\n            sum(int(bit) == i & 1 for i, bit in enumerate(s)),\\n            sum(int(bit) != i & 1 for i, bit in enumerate(s)),\\n        )\\n```\\n"
    },
    {
        "slug": "handling-sum-queries-after-update",
        "tags": "python3",
        "release_time": 1676818644,
        "code": "class Solution:\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        #root of the tree is at the index 0\n        tree = [0]*(4*n)\n        lazy = [0]*(4*n)\n\n        def update(v, lo, hi, i, j):\n            if lazy[v]:\n                tree[v] = (hi - lo + 1) - tree[v]\n                if lo < hi:\n                    lazy[2*v + 1] ^= lazy[v]\n                    lazy[2*v + 2] ^= lazy[v]\n                lazy[v] = 0\n            if lo > j or hi < i: \n                return \n            if i <= lo and hi <= j:\n                tree[v] = (hi - lo + 1) - tree[v]\n                if lo < hi:\n                    lazy[2*v + 1] ^= 1 \n                    lazy[2*v + 2] ^= 1\n                return\n            m = (lo + hi)//2\n            update(2*v + 1, lo, m, i, j) \n            update(2*v + 2, m+1, hi, i, j)\n            tree[v] = tree[2*v + 1] + tree[2*v + 2]\n\n        for i, b in enumerate(nums1):\n            if b: update(0,0,n-1,i,i)\n        sum2 = sum(nums2)\n        res = []\n        for t, l, r in queries:\n            if t == 1:\n                update(0, 0, n-1, l, r)\n            elif t == 2:\n                sum2 += l*tree[0]\n            else:\n                res.append(sum2)\n        return res",
        "content": "# Code\\n```\\n\\n\\nclass Solution:\\n    def handleQuery(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\\n        n = len(nums1)\\n        #root of the tree is at the index 0\\n        tree = [0]*(4*n)\\n        lazy = [0]*(4*n)\\n\\n        def update(v, lo, hi, i, j):\\n            if lazy[v]:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= lazy[v]\\n                    lazy[2*v + 2] ^= lazy[v]\\n                lazy[v] = 0\\n            if lo > j or hi < i: \\n                return \\n            if i <= lo and hi <= j:\\n                tree[v] = (hi - lo + 1) - tree[v]\\n                if lo < hi:\\n                    lazy[2*v + 1] ^= 1 \\n                    lazy[2*v + 2] ^= 1\\n                return\\n            m = (lo + hi)//2\\n            update(2*v + 1, lo, m, i, j) \\n            update(2*v + 2, m+1, hi, i, j)\\n            tree[v] = tree[2*v + 1] + tree[2*v + 2]\\n\\n        for i, b in enumerate(nums1):\\n            if b: update(0,0,n-1,i,i)\\n        sum2 = sum(nums2)\\n        res = []\\n        for t, l, r in queries:\\n            if t == 1:\\n                update(0, 0, n-1, l, r)\\n            elif t == 2:\\n                sum2 += l*tree[0]\\n            else:\\n                res.append(sum2)\\n        return res\\n\\n"
    },
    {
        "slug": "neither-minimum-nor-maximum",
        "tags": "python3",
        "release_time": 1686456982,
        "code": "class Solution:\n    def findNonMinOrMax(self, nums: List[int]) -> int:\n        if len(nums) <= 2:\n            return -1\n        else:\n            return sorted(nums)[-2]",
        "content": "# Intuition\\nThe problem asks us to find a number from the given array that is neither the minimum nor the maximum value. This means that we need to exclude the smallest and largest values from consideration and return any other number. To solve this, we can sort the array and select the second largest element, as it will not be the maximum value.\\n\\n\\n# Approach\\nThe provided solution suggests using the sorted() function to sort the given array in ascending order. Since the array contains distinct positive integers, sorting the array will arrange the numbers in increasing order. If the length of the array is less than or equal to 2, we return -1, as there would be no number that satisfies the given condition. Otherwise, we return the second largest element, which can be accessed using the [-2] index.\\n\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the solution depends on the sorting algorithm used. If we consider the default sorting algorithm used by Python\\'s sorted() function, the time complexity is O(n log n), where n is the length of the input array nums. Sorting the array is the most time-consuming step in this approach.\\n\\n\\n- Space complexity:\\nSpace complexity: The space complexity is O(1) since we are not using any additional data structures that grow with the size of the input. The sorting operation is performed in-place, so it does not require additional space proportional to the input size.\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findNonMinOrMax(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return -1\\n        else:\\n            return sorted(nums)[-2] \\n```"
    },
    {
        "slug": "check-whether-two-strings-are-almost-equivalent",
        "tags": "python3",
        "release_time": 1679828439,
        "code": "class Solution:\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n        A = [0] * 26\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\n        return not any ([(f < -3 or f > 3) for f in A])",
        "content": "# Code\\n```\\nclass Solution:\\n    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\\n        A = [0] * 26\\n        for char in word1: A[ord(char) - ord(\"a\")] += 1\\n        for char in word2: A[ord(char) - ord(\"a\")] -= 1\\n        return not any ([(f < -3 or f > 3) for f in A])        \\n\\n```"
    },
    {
        "slug": "maximum-number-of-balls-in-a-box",
        "tags": "python3",
        "release_time": 1683718941,
        "code": "class Solution:\n    def countBalls(self, lowLimit: int, highLimit: int) -> int:\n        d=dict()\n        for i in range(lowLimit,highLimit+1):\n            s=str(i)\n            c=0\n            for i in s:\n                c+=int(i)\n            if(c in d):\n                d[c]+=1\n            else:\n                d[c]=1\n        return max(d.values())",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countBalls(self, lowLimit: int, highLimit: int) -> int:\\n        d=dict()\\n        for i in range(lowLimit,highLimit+1):\\n            s=str(i)\\n            c=0\\n            for i in s:\\n                c+=int(i)\\n            if(c in d):\\n                d[c]+=1\\n            else:\\n                d[c]=1\\n        return max(d.values())\\n\\n\\n```"
    },
    {
        "slug": "basic-calculator",
        "tags": "python3",
        "release_time": 1687835341,
        "code": "class Solution:\n    def calculate(self, s: str) -> int:\n        res = 0\n        pre_op = \"+\"\n        s += \"+\"\n        num = 0\n        stack = []\n        for i in s:\n            #print(i)\n            #print(num,res,pre_op,stack)\n            if i.isdigit():\n                num = num*10 + int(i)\n            elif i == \" \":\n                continue\n            elif i in [\"+\",\"-\"]:\n                if pre_op == \"+\":\n                    res += num\n                else:\n                    res -= num\n                pre_op = i\n                num = 0\n            elif i == \"(\":\n                stack.append(res)\n                stack.append(pre_op)\n                res = 0\n                num = 0\n                pre_op = \"+\"\n            elif i == \")\":\n                if pre_op == \"+\":\n                    res += num\n                else:\n                    res -= num\n                if stack[-1] == \"+\":\n                    #res += num\n                    stack.pop()\n                    res += stack.pop()\n                elif stack[-1] == \"-\":\n                   # res -= num\n                    stack.pop()\n                    res = stack.pop() - res\n                num = 0\n                pre_op = \"+\"\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculate(self, s: str) -> int:\\n        res = 0\\n        pre_op = \"+\"\\n        s += \"+\"\\n        num = 0\\n        stack = []\\n        for i in s:\\n            #print(i)\\n            #print(num,res,pre_op,stack)\\n            if i.isdigit():\\n                num = num*10 + int(i)\\n            elif i == \" \":\\n                continue\\n            elif i in [\"+\",\"-\"]:\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                pre_op = i\\n                num = 0\\n            elif i == \"(\":\\n                stack.append(res)\\n                stack.append(pre_op)\\n                res = 0\\n                num = 0\\n                pre_op = \"+\"\\n            elif i == \")\":\\n                if pre_op == \"+\":\\n                    res += num\\n                else:\\n                    res -= num\\n                if stack[-1] == \"+\":\\n                    #res += num\\n                    stack.pop()\\n                    res += stack.pop()\\n                elif stack[-1] == \"-\":\\n                   # res -= num\\n                    stack.pop()\\n                    res = stack.pop() - res\\n                num = 0\\n                pre_op = \"+\"\\n        return res \\n\\n```"
    },
    {
        "slug": "longest-even-odd-subarray-with-threshold",
        "tags": "python3",
        "release_time": 1689778547,
        "code": "class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        longest = 0 \n        current = 0 \n        for i in range(len(nums)): \n            if nums[i] > threshold: \n                current = 0 \n            elif current == 0 and nums[i] % 2 == 0: \n                current = 1 \n            elif current > 0 and nums[i] % 2 != nums[i - 1] % 2: \n                current += 1 \n            else: \n                current = 1 if nums[i] % 2 == 0 else 0 \n            longest = max(longest, current) \n        return longest",
        "content": "# Intuition\\nOn first glance, this problem seems to be about managing multiple conditions to manipulate an array. My initial thoughts were to iterate through the array while checking each condition. We would likely keep track of the longest sequence that meets all conditions and update it when necessary.\\n\\nhttps://youtu.be/4wrs6d8fj-o\\n\\n# Approach\\nThe approach I took was to iterate through the array using a for loop. I created two variables, \\'longest\\' and \\'current\\', to keep track of the longest subarray meeting the criteria and the current length of such a subarray, respectively. \\n\\nIf a number is greater than the threshold, it can\\'t be included in a valid subarray, so the \\'current\\' counter is reset to zero. Then we check the parity (even or odd) of the number. If \\'current\\' is zero (indicating we\\'re not in a valid subarray) and the number is even, a new subarray can be started and \\'current\\' is set to 1. If we\\'re in a valid subarray and the current number has a different parity from the last one, we can extend our subarray, incrementing \\'current\\'. Otherwise, if the number is even, we start a new subarray, otherwise, \\'current\\' is set to zero. At each iteration, \\'longest\\' is updated if the current subarray is longer than the previously longest subarray.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$ where n is the length of the array. This is because we process each element in the array exactly once.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$ since we only use a fixed amount of space to store our variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\\n        longest = 0 \\n        current = 0 \\n        for i in range(len(nums)): \\n            if nums[i] > threshold: \\n                current = 0 \\n            elif current == 0 and nums[i] % 2 == 0: \\n                current = 1 \\n            elif current > 0 and nums[i] % 2 != nums[i - 1] % 2: \\n                current += 1 \\n            else: \\n                current = 1 if nums[i] % 2 == 0 else 0 \\n            longest = max(longest, current) \\n        return longest \\n```\\nThis Python solution illustrates the approach described above. It identifies the longest subarray that meets the provided conditions and returns its length."
    },
    {
        "slug": "binary-search",
        "tags": "python3",
        "release_time": 1680309400,
        "code": "class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        if target not in nums:\n            return -1\n        \n        left, right = 0, len(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid\n        \n        return left",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        if target not in nums:\\n            return -1\\n        \\n        left, right = 0, len(nums)\\n        \\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        \\n        return left\\n        \\n```\\nOne-liner in python:\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        return bisect_left(nums, target) if target in nums else -1\\n```"
    },
    {
        "slug": "count-the-repetitions",
        "tags": "python3",
        "release_time": 1671908671,
        "code": "class Solution:\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n\n        rec, track = [0], defaultdict(int) \n        ct = start = ptr1 = ptr2 = 0\n\n        if not set(s2).issubset(set(s1)): return 0\n\n        s1 = ''.join(char for char in s1 if char in set(s2))\n        \n        while True:\n            for char in s2:\n                ptr = s1.find(char, start)\n                if ptr == -1:\n                    ct += 1\n                    ptr = s1.find(char)\n                start = ptr+1\n            rec.append(ct + 1)\n\n            if rec[-1] > n1: return (len(rec)-2)//n2\n\n            if ptr not in track: track[ptr] = len(rec)-1\n            else: break\n        \n        cycleStart = rec[track[ptr]]\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\n        rest = n1 - cycleStart\n        \n        rem = cycleStart + rest%cycle1\n\n        while rec[ptr2] <= rem: ptr2+= 1\n\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2",
        "content": "```\\nclass Solution:\\n    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\\n\\n        rec, track = [0], defaultdict(int) \\n        ct = start = ptr1 = ptr2 = 0\\n\\n        if not set(s2).issubset(set(s1)): return 0\\n\\n        s1 = \\'\\'.join(char for char in s1 if char in set(s2))\\n        \\n        while True:\\n            for char in s2:\\n                ptr = s1.find(char, start)\\n                if ptr == -1:\\n                    ct += 1\\n                    ptr = s1.find(char)\\n                start = ptr+1\\n            rec.append(ct + 1)\\n\\n            if rec[-1] > n1: return (len(rec)-2)//n2\\n\\n            if ptr not in track: track[ptr] = len(rec)-1\\n            else: break\\n        \\n        cycleStart = rec[track[ptr]]\\n        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]\\n        rest = n1 - cycleStart\\n        \\n        rem = cycleStart + rest%cycle1\\n\\n        while rec[ptr2] <= rem: ptr2+= 1\\n\\n        return (cycle2 * (rest//cycle1) + ptr2-1)//n2\\n```\\n[https://leetcode.com/problems/count-the-repetitions/submissions/864907562/](http://)\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*)."
    },
    {
        "slug": "the-kth-factor-of-n",
        "tags": "python3",
        "release_time": 1692616031,
        "code": "class Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        j = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                num = i\n                j += 1\n            if j == k:\n                break\n        return num if j == k else -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this code is to iterate through all positive integers from 1 to `n` and check if they are factors of `n`. The code aims to find the `kth` factor of `n`, where `k` is a given positive integer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The code uses a simple iterative approach to find the `kth` factor of `n`. It initializes a variable `j` to keep track of the number of factors found. For each integer `i` from 1 to `n`, it checks if `i` is a factor of n by verifying if `n % i == 0`. If `i` is indeed a factor, it increments `j` and updates the variable `num` with the value of `i`.\\n\\n- The loop continues until `j` becomes equal to k or until all integers from 1 to n have been considered. If `j` becomes equal to `k`, it breaks out of the loop. At the end of the loop, if `j` is equal to `k`, it returns the value of `num`; otherwise, it returns `-1` to indicate that there is no `kth` factor.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kthFactor(self, n: int, k: int) -> int:\\n        j = 0\\n        for i in range(1, n + 1):\\n            if n % i == 0:\\n                num = i\\n                j += 1\\n            if j == k:\\n                break\\n        return num if j == k else -1\\n```"
    },
    {
        "slug": "longest-substring-with-at-least-k-repeating-characters",
        "tags": "python3",
        "release_time": 1689559880,
        "code": "from collections import defaultdict\nclass Solution:\n    def longestSubstring(self, s: str, k: int) -> int:\n        x=self.recursion(s,k)\n        if x>=k:\n            return x\n        else:\n            \n            return 0\n\n    def recursion(self,s,k):\n        if len(s)<=1 :\n            return len(s)\n        flag=True\n        for i in range(len(s)):\n            if s.count(s[i])<k:\n                flag=False\n                break\n            \n        if flag:\n            return len(s)\n        left=(self.recursion(s[:i],k))\n        right=(self.recursion(s[i+1:],k))\n        if left>right:\n            return (left)\n        return (right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolve this problem by dividing the list at the point that has frequency less thn \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def longestSubstring(self, s: str, k: int) -> int:\\n        x=self.recursion(s,k)\\n        if x>=k:\\n            return x\\n        else:\\n            \\n            return 0\\n\\n    def recursion(self,s,k):\\n        if len(s)<=1 :\\n            return len(s)\\n        flag=True\\n        for i in range(len(s)):\\n            if s.count(s[i])<k:\\n                flag=False\\n                break\\n            \\n        if flag:\\n            return len(s)\\n        left=(self.recursion(s[:i],k))\\n        right=(self.recursion(s[i+1:],k))\\n        if left>right:\\n            return (left)\\n        return (right)\\n\\n```"
    },
    {
        "slug": "maximum-consecutive-floors-without-special-floors",
        "tags": "python3",
        "release_time": 1690781638,
        "code": "class Solution:\n    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\n        mx= 0\n        l = bottom\n        special.sort()\n        for idx, value in enumerate(special):\n            if idx==0:\n                mx=max(mx, value-l)\n                l=value\n            else:\n                mx=max(mx, value-l-1)\n                l=value\n        mx=max(mx, top-value)\n        return mx",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxConsecutive(self, bottom: int, top: int, special: List[int]) -> int:\\n        mx= 0\\n        l = bottom\\n        special.sort()\\n        for idx, value in enumerate(special):\\n            if idx==0:\\n                mx=max(mx, value-l)\\n                l=value\\n            else:\\n                mx=max(mx, value-l-1)\\n                l=value\\n        mx=max(mx, top-value)\\n        return mx\\n```"
    },
    {
        "slug": "smallest-missing-non-negative-integer-after-operations",
        "tags": "python3",
        "release_time": 1679198902,
        "code": "class Solution:\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\n        counter = Counter([x % value for x in nums])\n        ans = 0\n        while counter[ans % value] > 0:\n            counter[ans % value] -= 1\n            ans += 1\n        return ans",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(value)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\\n        counter = Counter([x % value for x in nums])\\n        ans = 0\\n        while counter[ans % value] > 0:\\n            counter[ans % value] -= 1\\n            ans += 1\\n        return ans\\n```"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "tags": "python3",
        "release_time": 1691471559,
        "code": "class Solution:\n    def totalMoney(self, n: int) -> int:\n        income=1;a=[1];ans=0\n        for i in range(n):\n            if i%7==0 and i!=0:income=(a[len(a)-7])\n            ans+=income;income+=1;a.append(income)      \n        return ans",
        "content": "![image.png](https://assets.leetcode.com/users/images/2f3418d9-04d9-483c-a41f-87c71b45cc76_1691471550.6305616.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def totalMoney(self, n: int) -> int:\\n        income=1;a=[1];ans=0\\n        for i in range(n):\\n            if i%7==0 and i!=0:income=(a[len(a)-7])\\n            ans+=income;income+=1;a.append(income)      \\n        return ans\\n```"
    },
    {
        "slug": "check-distances-between-same-letters",
        "tags": "python3",
        "release_time": 1682189975,
        "code": "class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        d = s[::-1]\n        if len(s)%2!=0:\n            return False\n        else:\n            for i in s:\n                #print((len(s)-d.index(i))-s.index(i)-1)\n                if (len(s)-d.index(i)-1)-s.index(i)-1 != distance[ord(i)-ord('a')]:\n                    return False\n            return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\\n        d = s[::-1]\\n        if len(s)%2!=0:\\n            return False\\n        else:\\n            for i in s:\\n                #print((len(s)-d.index(i))-s.index(i)-1)\\n                if (len(s)-d.index(i)-1)-s.index(i)-1 != distance[ord(i)-ord(\\'a\\')]:\\n                    return False\\n            return True\\n\\n```"
    },
    {
        "slug": "number-of-pairs-of-interchangeable-rectangles",
        "tags": "python3",
        "release_time": 1688578222,
        "code": "class Solution:\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\n        c = collections.Counter()\n        for x, y in rectangles:\n            gcd = math.gcd(x, y)\n            c[(x // gcd, y // gcd)] += 1\n        \n        res = 0\n        for k, v in c.items():\n            res += v * (v - 1) // 2\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\\n        c = collections.Counter()\\n        for x, y in rectangles:\\n            gcd = math.gcd(x, y)\\n            c[(x // gcd, y // gcd)] += 1\\n        \\n        res = 0\\n        for k, v in c.items():\\n            res += v * (v - 1) // 2\\n        return res\\n```"
    },
    {
        "slug": "basic-calculator",
        "tags": "python3",
        "release_time": 1686964565,
        "code": "class Solution:\n    def evaluate_expression(self, expression: str) -> int:\n        expression = expression.replace(\"--\", \"+\")\n        operands = expression.split(\"+\")\n        operands = [operand for operand in operands if operand != '']\n        results = []\n\n        for operand in operands:\n            is_first_negative = False\n            if operand[0] == \"-\":\n                is_first_negative = True\n\n            sub_operands = operand.split('-')\n            sub_operands = [sub_operand for sub_operand in sub_operands if sub_operand != '']\n            subtotal = 0\n\n            if is_first_negative:\n                subtotal = -1 * int(sub_operands[0])\n            else:\n                subtotal = int(sub_operands[0])\n\n            sub_operands.pop(0)\n\n            for sub_operand in sub_operands:\n                subtotal -= int(sub_operand)\n\n            results.append(subtotal)\n\n        total = 0\n\n        for result in results:\n            total += result\n\n        return total\n\n    def calculate(self, expression: str) -> int:\n        expression = expression.replace(\" \", \"\")\n        open_parentheses = []\n        end = 0\n        i = 0\n\n        while i < len(expression):\n            if expression[i] == '(':\n                open_parentheses.append(i)\n            elif expression[i] == ')':\n                end = i\n                start = open_parentheses[-1]\n                sub_expression = expression[start + 1:end]\n                evaluated_value = self.evaluate_expression(sub_expression)\n                new_expression = expression[:start] + str(evaluated_value) + expression[end + 1:]\n                open_parentheses.pop()\n                expression = new_expression\n                i = start - 1\n\n            i += 1\n\n        return self.evaluate_expression(expression)",
        "content": "The solution implements a basic calculator to evaluate a given expression string without using built-in functions like eval().\\n\\nThe evaluate_expression method handles the addition and subtraction operations within a given expression. It splits the expression at \\'+\\' characters and then further splits the resulting substrings at \\'-\\' characters. It keeps track of whether the first character of each substring is a \\'-\\' sign to indicate subtraction. It iterates over the substrings, converting them to integers and performing the necessary addition or subtraction. The results are stored in a list and then summed up to obtain the final result.\\n\\nThe calculate method handles the parentheses within the expression. It finds the outermost pair of parentheses, evaluates the expression inside them using evaluate_expression, and replaces the evaluated result back into the original string. This process is repeated until there are no more parentheses. Finally, it calls evaluate_expression with the modified string to calculate the overall result of the expression.\\n\\nThe solution provides a valid and accurate evaluation of the expression, taking into account the order of operations dictated by parentheses and the addition/subtraction operations.\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate_expression(self, expression: str) -> int:\\n        expression = expression.replace(\"--\", \"+\")\\n        operands = expression.split(\"+\")\\n        operands = [operand for operand in operands if operand != \\'\\']\\n        results = []\\n\\n        for operand in operands:\\n            is_first_negative = False\\n            if operand[0] == \"-\":\\n                is_first_negative = True\\n\\n            sub_operands = operand.split(\\'-\\')\\n            sub_operands = [sub_operand for sub_operand in sub_operands if sub_operand != \\'\\']\\n            subtotal = 0\\n\\n            if is_first_negative:\\n                subtotal = -1 * int(sub_operands[0])\\n            else:\\n                subtotal = int(sub_operands[0])\\n\\n            sub_operands.pop(0)\\n\\n            for sub_operand in sub_operands:\\n                subtotal -= int(sub_operand)\\n\\n            results.append(subtotal)\\n\\n        total = 0\\n\\n        for result in results:\\n            total += result\\n\\n        return total\\n\\n    def calculate(self, expression: str) -> int:\\n        expression = expression.replace(\" \", \"\")\\n        open_parentheses = []\\n        end = 0\\n        i = 0\\n\\n        while i < len(expression):\\n            if expression[i] == \\'(\\':\\n                open_parentheses.append(i)\\n            elif expression[i] == \\')\\':\\n                end = i\\n                start = open_parentheses[-1]\\n                sub_expression = expression[start + 1:end]\\n                evaluated_value = self.evaluate_expression(sub_expression)\\n                new_expression = expression[:start] + str(evaluated_value) + expression[end + 1:]\\n                open_parentheses.pop()\\n                expression = new_expression\\n                i = start - 1\\n\\n            i += 1\\n\\n        return self.evaluate_expression(expression)\\n\\n```"
    },
    {
        "slug": "split-the-array-to-make-coprime-products",
        "tags": "python3",
        "release_time": 1677993261,
        "code": "class Solution:\n    def findValidSplit(self, nums: List[int]) -> int:\n        def prime(n):\n            divisor = 2\n            factors = []\n            while divisor * divisor <= n:\n                if n % divisor:\n                    divisor += 1\n                else:\n                    n //= divisor\n                    factors.append(divisor)\n            \n            if n > 1:\n                factors.append(n)\n            return factors\n        \n        total = Counter()\n        for n in nums:\n            for f in prime(n):\n                total[f] += 1\n            \n\n        prefix = Counter()\n        for i, n in enumerate(nums):\n            if i == len(nums) - 1: return -1\n            \n            for f in prime(n):\n                prefix[f] += 1\n                total[f] -= 1\n                if total[f] == 0:\n                    del prefix[f]\n            if len(prefix) == 0:\n                return i",
        "content": "## For example [4,7,8,15,3,5]\\nTotal Prime Count:\\n2: 5\\n3: 2\\n5: 2\\n7: 1\\n\\n### Spilt at index 1\\n[4, 7] [8, 15, 3, 5]\\nPrefix Prime Count:\\n2: 2\\n7: 1 (prepare to delet)\\n\\nSuffix (Total - Prefix) Prime Count:\\n2: 3\\n3: 2\\n5: 2\\n\\nthen we delet prefix[7] because suffix don\\'t any Prime 7 and perfix won\\'t add any Prime 7\\n\\n## Split at index 2\\n[4 7 8] [15, 3, 5]\\nPrefix Prime Count:\\n2: 5 (prepare to delet)\\n\\nSuffix (Total - Prefix) Prime Count:\\n3: 2\\n5: 2\\n\\nafter delet final key 2, len(prefix) == 0\\n we get the index to fit the gcd(prefix, suffix) == 1 \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findValidSplit(self, nums: List[int]) -> int:\\n        def prime(n):\\n            divisor = 2\\n            factors = []\\n            while divisor * divisor <= n:\\n                if n % divisor:\\n                    divisor += 1\\n                else:\\n                    n //= divisor\\n                    factors.append(divisor)\\n            \\n            if n > 1:\\n                factors.append(n)\\n            return factors\\n        \\n        total = Counter()\\n        for n in nums:\\n            for f in prime(n):\\n                total[f] += 1\\n            \\n\\n        prefix = Counter()\\n        for i, n in enumerate(nums):\\n            if i == len(nums) - 1: return -1\\n            \\n            for f in prime(n):\\n                prefix[f] += 1\\n                total[f] -= 1\\n                if total[f] == 0:\\n                    del prefix[f]\\n            if len(prefix) == 0:\\n                return i\\n\\n```"
    },
    {
        "slug": "reverse-string-ii",
        "tags": "python3",
        "release_time": 1686096780,
        "code": "class Solution:\n    def reverseStr(self, s: str, k: int) -> str:\n        tab=[]\n        for i in range(len(s)):\n            if (i//k)%2==0:\n               tab.insert(i-i%k,s[i])\n            else:\n                tab.append(s[i])\n        res=\"\"\n        for t in tab:\n            res+=t\n        return res",
        "content": "# Intuition\\nThe problem requires us to reverse the first k characters for every 2k characters in a given string. To solve this, we can iterate over the string and use a list to store the reversed segments. By considering the pattern of reversing every 2k characters, we can determine the positions where the reversal needs to occur.\\n\\n\\n# Approach\\n1.\\tInitialize an empty list, \"tab,\" to store the reversed segments of the string.\\n2.\\tIterate over the characters in the string using a for loop.\\n3.\\tFor each character at index i, check if (i//k)%2 is equal to 0. This condition ensures that we are within the first k characters of every 2k segment.\\n4.\\tIf the condition is true, insert the character at index i in the \"tab\" list, using the formula (i-i%k). This ensures that the first k characters are reversed and inserted at the correct position.\\n5.\\tIf the condition is false, append the character to the end of the \"tab\" list.\\n6.\\tOnce the loop is complete, initialize an empty string, \"res,\" to store the final result.\\n7.\\tIterate over the elements in the \"tab\" list and concatenate them to the \"res\" string.\\n8.\\tReturn the \"res\" string as the reversed string with the specified pattern.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe algorithm iterates over each character in the string once, resulting in a time complexity of O(n), where n is the length of the string.\\n\\n\\n- Space complexity:\\nWe use additional space to store the reversed segments in the \"tab\" list. The space complexity is O(n), where n is the length of the string, as the size of the list grows linearly with the input.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reverseStr(self, s: str, k: int) -> str:\\n        tab=[]\\n        for i in range(len(s)):\\n            if (i//k)%2==0:\\n               tab.insert(i-i%k,s[i])\\n            else:\\n                tab.append(s[i])\\n        res=\"\"\\n        for t in tab:\\n            res+=t\\n        return res\\n```"
    },
    {
        "slug": "count-nodes-equal-to-average-of-subtree",
        "tags": "python3",
        "release_time": 1678595113,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\n        self.res = []\n        def trav(root):\n            if not root:\n                return None\n            temp = dfs(root,[])\n            if root.val == sum(temp)//len(temp):\n                self.res.append(root.val)\n\n            if root.left:\n                trav(root.left)\n            \n            if root.right:\n                trav(root.right)\n\n\n        def dfs(root,final):\n            if not root:\n                return None\n            \n            final.append(root.val)\n\n            if root.left:\n                dfs(root.left,final)\n            \n            if root.right:\n                dfs(root.right,final)\n            \n            return final\n        \n        trav(root)\n        return len(self.res)",
        "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def averageOfSubtree(self, root: Optional[TreeNode]) -> int:\\n        self.res = []\\n        def trav(root):\\n            if not root:\\n                return None\\n            temp = dfs(root,[])\\n            if root.val == sum(temp)//len(temp):\\n                self.res.append(root.val)\\n\\n            if root.left:\\n                trav(root.left)\\n            \\n            if root.right:\\n                trav(root.right)\\n\\n\\n        def dfs(root,final):\\n            if not root:\\n                return None\\n            \\n            final.append(root.val)\\n\\n            if root.left:\\n                dfs(root.left,final)\\n            \\n            if root.right:\\n                dfs(root.right,final)\\n            \\n            return final\\n        \\n        trav(root)\\n        return len(self.res)\\n\\n        \\n\\n\\n```"
    },
    {
        "slug": "baseball-game",
        "tags": "python3",
        "release_time": 1681186635,
        "code": "class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        stack=[]\n        for i in operations:\n            if i =='D':\n                stack.append(2*stack[-1])\n            elif i=='C':\n                stack.pop()\n            elif i=='+':\n                stack.append(stack[-1]+stack[-2])\n            else:\n                stack.append(int(i))\n        return sum(stack)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, operations: List[str]) -> int:\\n        stack=[]\\n        for i in operations:\\n            if i ==\\'D\\':\\n                stack.append(2*stack[-1])\\n            elif i==\\'C\\':\\n                stack.pop()\\n            elif i==\\'+\\':\\n                stack.append(stack[-1]+stack[-2])\\n            else:\\n                stack.append(int(i))\\n        return sum(stack)\\n```"
    },
    {
        "slug": "find-bottom-left-tree-value",
        "tags": "python3",
        "release_time": 1680189729,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\n        depth = 0\n        stack = collections.deque([(root)])\n        d = {}\n        a = 0\n        while stack:\n            lvl = []\n            for i in range(len(stack)):\n                n = stack.popleft()\n                lvl.append(n.val)\n                if n.left: stack.append(n.left)\n                if n.right: stack.append(n.right)\n        return lvl[0]",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:\\n        depth = 0\\n        stack = collections.deque([(root)])\\n        d = {}\\n        a = 0\\n        while stack:\\n            lvl = []\\n            for i in range(len(stack)):\\n                n = stack.popleft()\\n                lvl.append(n.val)\\n                if n.left: stack.append(n.left)\\n                if n.right: stack.append(n.right)\\n        return lvl[0]\\n```"
    },
    {
        "slug": "remove-linked-list-elements",
        "tags": "python3",
        "release_time": 1691723920,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\n        result = ListNode(0)\n        result.next = head\n        cur = result\n        while cur.next:\n            if cur.next.val == val:\n                cur.next = cur.next.next\n            else:\n                cur = cur.next\n        return result.next",
        "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        result = ListNode(0)\\n        result.next = head\\n        cur = result\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return result.next\\n```"
    },
    {
        "slug": "substring-xor-queries",
        "tags": "python3",
        "release_time": 1676176197,
        "code": "class Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        finder = defaultdict(lambda: [-1, -1])\n        for l in range(33, 0, -1):\n            for i in range(len(s)-l, -1, -1):\n                finder[int(s[i:i+l], 2)] = [i, i+l-1]\n        ans = []\n        for a, b in queries:\n            ans.append(finder[a^b])\n        return ans",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution string length can\\'t be over 32($2^{32}$).\\nThe approach is simple. Just preprocess all the bit string under 32 length.\\n\\n## Why can we calculate the answer like `a^b` ?\\n$$ A \\\\oplus X = B $$ \\n$$ X = A \\\\oplus B $$ \\n\\n## Note that we must process reversely\\nAnd we must process reversely because of description `there are multiple answers, choose the one with the minimum left.`\\n# Complexity\\n- Time complexity: $O(N \\\\times 32) $\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N \\\\times 32) $\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\\n        finder = defaultdict(lambda: [-1, -1])\\n        for l in range(33, 0, -1):\\n            for i in range(len(s)-l, -1, -1):\\n                finder[int(s[i:i+l], 2)] = [i, i+l-1]\\n        ans = []\\n        for a, b in queries:\\n            ans.append(finder[a^b])\\n        return ans\\n    \\n```"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "tags": "python3",
        "release_time": 1669474457,
        "code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        def gen_next(p):\n            directions = [(0,-1,2), (0,1,1), (1,0,3), (-1,0,4)]\n            for x, y, d in directions:\n                yield x, y, (0 if d == p else 1)\n        visited = set()\n        q = [(0,0,0)]\n        while len(q) > 0:\n            cost, x, y = heapq.heappop(q)\n            if x == len(grid) - 1 and y == len(grid[0]) - 1:\n                return cost\n            if (x, y) not in visited:\n                visited.add((x,y))\n                for dx, dy, c in gen_next(grid[x][y]):\n                    new_x, new_y = x + dx, y + dy\n                    if 0 <= new_y < len(grid[0]) and 0 <= new_x < len(grid):\n                        heapq.heappush(q, (cost+c, new_x, new_y))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n        def gen_next(p):\\n            directions = [(0,-1,2), (0,1,1), (1,0,3), (-1,0,4)]\\n            for x, y, d in directions:\\n                yield x, y, (0 if d == p else 1)\\n        visited = set()\\n        q = [(0,0,0)]\\n        while len(q) > 0:\\n            cost, x, y = heapq.heappop(q)\\n            if x == len(grid) - 1 and y == len(grid[0]) - 1:\\n                return cost\\n            if (x, y) not in visited:\\n                visited.add((x,y))\\n                for dx, dy, c in gen_next(grid[x][y]):\\n                    new_x, new_y = x + dx, y + dy\\n                    if 0 <= new_y < len(grid[0]) and 0 <= new_x < len(grid):\\n                        heapq.heappush(q, (cost+c, new_x, new_y))\\n\\n\\n```"
    },
    {
        "slug": "row-with-maximum-ones",
        "tags": "python3",
        "release_time": 1692366523,
        "code": "class Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        maxValue = 0\n        index = 0\n        for m in range(len(mat)):\n            sumN = 0\n            sumN = sum(mat[m])\n            if sumN > maxValue:\n                index =  m\n            maxValue=max(maxValue,sumN)\n        return [index,maxValue]",
        "content": "![Screenshot_307.png](https://assets.leetcode.com/users/images/13fcd1a5-36fc-46f8-9070-42c6b3c3ae79_1692366483.620762.png)\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```"
    },
    {
        "slug": "candy",
        "tags": "python3",
        "release_time": 1681874816,
        "code": "class Solution:\n    def candy(self, ratings: List[int]) -> int:\n        n = len(ratings)\n        give = [1] * n\n\n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                give[i] = give[i-1] + 1\n\n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\n                give[i] = give[i+1] + 1\n\n        return sum(give)",
        "content": "# Intuition\\nSome other solutions are too much complicated, which shouldn\\'t be. Just play some cases to get this idea. Please up vote if you agree with this idea and let me see if you like it.\\n\\nOkay, just saw other friends already got this idea. I did work it out alone since it\\'s pretty straightforward. Anyways, I hope my comments here help understanding.\\n\\n# Approach\\nGoing foward to reward higher rating on the right. Going backward for higher rating on left. Generally, there is only one rule:\\n- If you see a higher rating on the next child, it deserves one more candies if it didn\\'t\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ since only two passes on the rating array.\\n\\n- Space complexity:\\n$$O(n)$$ due to the $$give$$ list.\\n\\n# Code\\n```\\nclass Solution:\\n    def candy(self, ratings: List[int]) -> int:\\n        n = len(ratings)\\n        give = [1] * n\\n\\n        for i in range(1, n):\\n            if ratings[i] > ratings[i-1]:\\n                give[i] = give[i-1] + 1\\n\\n        for i in range(n-2, -1, -1):\\n            if ratings[i] > ratings[i+1] and give[i] <= give[i+1]:\\n                give[i] = give[i+1] + 1\\n\\n        return sum(give)\\n```"
    },
    {
        "slug": "maximum-gap",
        "tags": "python3",
        "release_time": 1686286240,
        "code": "class Solution:\n    def maximumGap(self, nums: List[int]) -> int:\n        nums=sorted(nums)\n        min=float(\"-inf\")\n        if len(nums)<2:\n            return 0\n        for i in range(len(nums)-1):\n            x=abs(nums[i]-nums[i+1])\n            if min<x:\n                min=x\n        return min",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumGap(self, nums: List[int]) -> int:\\n        nums=sorted(nums)\\n        min=float(\"-inf\")\\n        if len(nums)<2:\\n            return 0\\n        for i in range(len(nums)-1):\\n            x=abs(nums[i]-nums[i+1])\\n            if min<x:\\n                min=x\\n        return min\\n```"
    },
    {
        "slug": "lexicographically-smallest-beautiful-string",
        "tags": "python3",
        "release_time": 1682827345,
        "code": "class Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        s = list(s)\n        i = len(s) - 1\n        s[i] = chr(ord(s[i]) + 1)\n        while 0 <= i < len(s):\n            if ord(s[i]) - ord('a') >= k:\n                s[i] = 'a'\n                i -= 1\n                s[i] = chr(ord(s[i]) + 1)\n            elif (i >= 1 and s[i] == s[i - 1]) or (i >= 2 and s[i] == s[i - 2]):\n                s[i] = chr(ord(s[i]) + 1)\n            else:\n                i += 1\n        return '' if i < 0 else ''.join(s)",
        "content": "# Approach\\nTo make lexicographically smallest greater string, we need to check from right to left (similar to next greater integer). While traversing from right to left, we update last letter from right. While incrementing the last letter each time, we make sure that the formed string contains first $$k$$ letters and does not contain any substring as a palindrome.\\n\\n# Key Observation\\nIt is important to note that $$s$$ itself is a beautiful string, such that each time we generate a new string `s_next`, to determine whether `s_next` is a beautiful string (i.e. whether it contains any length >= 2 palindrome substring), we only need to check it _locally_.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestBeautifulString(self, s: str, k: int) -> str:\\n        s = list(s)\\n        i = len(s) - 1\\n        s[i] = chr(ord(s[i]) + 1)\\n        while 0 <= i < len(s):\\n            if ord(s[i]) - ord(\\'a\\') >= k:\\n                s[i] = \\'a\\'\\n                i -= 1\\n                s[i] = chr(ord(s[i]) + 1)\\n            elif (i >= 1 and s[i] == s[i - 1]) or (i >= 2 and s[i] == s[i - 2]):\\n                s[i] = chr(ord(s[i]) + 1)\\n            else:\\n                i += 1\\n        return \\'\\' if i < 0 else \\'\\'.join(s)\\n```"
    },
    {
        "slug": "number-of-operations-to-make-network-connected",
        "tags": "python3",
        "release_time": 1679553906,
        "code": "class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        adj=defaultdict(list)\n        for ele1,ele2 in connections:\n            adj[ele1].append(ele2)\n            adj[ele2].append(ele1)\n        self.cables=0\n        def dfs(i,visited,adj,parent):\n            if(i in visited):\n                self.cables+=1\n                return\n            visited.add(i)\n            for child in adj[i]:\n                if child!=parent:\n                    dfs(child,visited,adj,i)\n        c=0\n        visited=set()\n        for i in range(n):\n            if i not in visited:\n                c+=1\n                dfs(i,visited,adj,-1)\n        if(self.cables//2>=c-1):\n            return c-1\n        return -1",
        "content": "# Complexity\\n- Time complexity:\\nO(E+V)\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        adj=defaultdict(list)\\n        for ele1,ele2 in connections:\\n            adj[ele1].append(ele2)\\n            adj[ele2].append(ele1)\\n        self.cables=0\\n        def dfs(i,visited,adj,parent):\\n            if(i in visited):\\n                self.cables+=1\\n                return\\n            visited.add(i)\\n            for child in adj[i]:\\n                if child!=parent:\\n                    dfs(child,visited,adj,i)\\n        c=0\\n        visited=set()\\n        for i in range(n):\\n            if i not in visited:\\n                c+=1\\n                dfs(i,visited,adj,-1)\\n        if(self.cables//2>=c-1):\\n            return c-1\\n        return -1\\n\\n```"
    },
    {
        "slug": "pascals-triangle",
        "tags": "python3",
        "release_time": 1689471598,
        "code": "class Solution:\n    def generate(self, numRows: int) -> List[List[int]]:\n        if numRows == 1:\n            return [[1]]\n        prev = self.generate(numRows - 1)\n        fin = prev[-1]\n        now = [1]\n        for i in range(len(fin)-1):\n            now.append(fin[i] + fin[i+1])\n        now.append(1)\n        prev.append(now)\n        return prev",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def generate(self, numRows: int) -> List[List[int]]:\\n        if numRows == 1:\\n            return [[1]]\\n        prev = self.generate(numRows - 1)\\n        fin = prev[-1]\\n        now = [1]\\n        for i in range(len(fin)-1):\\n            now.append(fin[i] + fin[i+1])\\n        now.append(1)\\n        prev.append(now)\\n        return prev\\n```"
    },
    {
        "slug": "maximum-ascending-subarray-sum",
        "tags": "python3",
        "release_time": 1673276022,
        "code": "class Solution:\n    def maxAscendingSum(self, nums: List[int]) -> int:\n        sumx = -1\n        for i in range(len(nums)):\n            subarr=[nums[i]]\n            for j in range(i+1, len(nums)):\n                if nums[j]>subarr[-1]:subarr.append(nums[j])\n                else:break\n            s=sum(subarr)\n            if s>sumx:sumx=s\n        return sumx",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAscendingSum(self, nums: List[int]) -> int:\\n        sumx = -1\\n        for i in range(len(nums)):\\n            subarr=[nums[i]]\\n            for j in range(i+1, len(nums)):\\n                if nums[j]>subarr[-1]:subarr.append(nums[j])\\n                else:break\\n            s=sum(subarr)\\n            if s>sumx:sumx=s\\n        return sumx\\n```"
    },
    {
        "slug": "minimum-cost-of-buying-candies-with-discount",
        "tags": "python3",
        "release_time": 1674971143,
        "code": "class Solution:\n    def minimumCost(self, cost: List[int]) -> int:\n        cost=sorted(cost,reverse=True)\n        mincost=0\n        lenn=len(cost)-1\n        for i in range(0,len(cost),3):\n            mincost+=cost[i]\n            if i != lenn:\n                mincost+=cost[i+1]\n        return mincost",
        "content": "# Code1\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        cost=sorted(cost,reverse=True)\\n        mincost=0\\n        lenn=len(cost)-1\\n        for i in range(0,len(cost),3):\\n            mincost+=cost[i]\\n            if i != lenn:\\n                mincost+=cost[i+1]\\n        return mincost\\n```\\n# Code 2\\n```\\nclass Solution:\\n    def minimumCost(self, cost: List[int]) -> int:\\n        return sum(cost)-sum(sorted(cost,reverse=True)[2::3])\\n```"
    },
    {
        "slug": "all-elements-in-two-binary-search-trees",
        "tags": "python3",
        "release_time": 1689964880,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\n        l=list()\n        def traversal(root):\n            if root is None :\n                return\n            l.append(root.val)\n            traversal(root.left)\n            traversal(root.right)\n        traversal(root1)\n        traversal(root2)\n        l.sort()\n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/be31fa66-f14d-4430-a166-5f23f990b4cf_1689964875.4489777.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def getAllElements(self, root1: TreeNode, root2: TreeNode) -> List[int]:\\n        l=list()\\n        def traversal(root):\\n            if root is None :\\n                return\\n            l.append(root.val)\\n            traversal(root.left)\\n            traversal(root.right)\\n        traversal(root1)\\n        traversal(root2)\\n        l.sort()\\n        return l\\n\\n```"
    },
    {
        "slug": "group-the-people-given-the-group-size-they-belong-to",
        "tags": "python3",
        "release_time": 1690050328,
        "code": "class Solution:\n    def groupThePeople(self, gs: List[int]) -> List[List[int]]:\n        d={}\n        for i,v in enumerate(gs):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        x=sorted(d.items(),key=lambda d:d[0])\n        ans=[]\n        for i in x:\n            for k in range(len(i[1])//i[0]):\n                b=i[1][k*i[0]:(k+1)*i[0]]\n                ans.append(b)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe make a dictionary ,then sort the dictionary,then according to length we split and attach to answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndictionary with key being group length of array element,then sorting dictionary by order of keys,using sorted function then to ans array we append by splitting parts of dictionary element by size of group then we return ans array\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def groupThePeople(self, gs: List[int]) -> List[List[int]]:\\n        d={}\\n        for i,v in enumerate(gs):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        x=sorted(d.items(),key=lambda d:d[0])\\n        ans=[]\\n        for i in x:\\n            for k in range(len(i[1])//i[0]):\\n                b=i[1][k*i[0]:(k+1)*i[0]]\\n                ans.append(b)\\n        return ans\\n```"
    },
    {
        "slug": "find-all-good-indices",
        "tags": "python3",
        "release_time": 1673651535,
        "code": "class Solution:\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        stack = []\n        decre = [False] * n\n        incre = [False] * n\n        ans = []\n        for i in range(n):\n            if len(stack) >= k:\n                decre[i] = True   \n\n            if not stack:\n                stack.append(nums[i])\n\n            else:\n                if nums[i] <= stack[-1]:\n                    stack.append(nums[i])\n                else:\n                    stack = [nums[i]]\n\n        stack = []\n        for i in range(n-1,-1,-1):\n            if len(stack) >= k and decre[i]:\n                ans.append(i)\n\n            if not stack:\n                stack.append(nums[i])\n\n            else:\n                if nums[i] <= stack[-1]:\n                    stack.append(nums[i])\n                else:\n                    stack = [nums[i]]\n        return ans[::-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def goodIndices(self, nums: List[int], k: int) -> List[int]:\\n        n = len(nums)\\n        stack = []\\n        decre = [False] * n\\n        incre = [False] * n\\n        ans = []\\n        for i in range(n):\\n            if len(stack) >= k:\\n                decre[i] = True   \\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n\\n        stack = []\\n        for i in range(n-1,-1,-1):\\n            if len(stack) >= k and decre[i]:\\n                ans.append(i)\\n\\n            if not stack:\\n                stack.append(nums[i])\\n\\n            else:\\n                if nums[i] <= stack[-1]:\\n                    stack.append(nums[i])\\n                else:\\n                    stack = [nums[i]]\\n        return ans[::-1]                        \\n\\n\\n```"
    },
    {
        "slug": "minimum-cost-to-split-an-array",
        "tags": "python3",
        "release_time": 1674441057,
        "code": "class Solution:\n    def minCost(self, A, K):\n        n = len(A)\n        dp = [0] + [float('inf')] * n\n        for i in range(n):\n            C = [0] * n\n            val = K\n            for j in range(i, -1, -1):\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\n                C[A[j]] += 1\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, A, K):\\n        n = len(A)\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in range(n):\\n            C = [0] * n\\n            val = K\\n            for j in range(i, -1, -1):\\n                val += (C[A[j]] >= 1) + (C[A[j]] == 1)\\n                C[A[j]] += 1\\n                dp[i + 1] = min(dp[i + 1], dp[j] + val)\\n        return dp[-1]\\n```"
    },
    {
        "slug": "frog-jump",
        "tags": "python3",
        "release_time": 1676230502,
        "code": "class Solution:\n    def canCross(self, stones: List[int]) -> bool:\n        #destination is a variable which stores the \n        #position of last stone where frog need to reach\n        destination=stones[len(stones)-1]\n        #it may happen that elements can be repeated so to avoid that\n        #associate a set for every stone in stones array\n        #make a hash map of stones along with set()\n        #for eg.1 : \n        #stones = [0,1,3,5,6,8,12,17]\n        #hash_map={0: set(), 1: set(), 3: set(), 5: set(), 6: set(), 8: set(), 12: set(), 17: set()}\n        hash_map=dict()\n        #in hash map , key will be stone and value will be set()\n        for stone in stones:\n            hash_map[stone]=set()\n        #it is given that the initial jump of frog is 1\n        hash_map[stones[0]].add(1)\n        #jumps is a set of particular position of stones \n        #for every position of stone in stones\n        #find out the new position while iterating over set of jumps\n        for position in stones:\n            jumps=hash_map[position]\n            for j in jumps:\n                #calculate newposition by adding position with j \n                new_pos=position+j\n                #check whether the new_pos is our target destination or not\n                if new_pos==destination:\n                    return True\n                #check whether the new position is available in  hash map\n                #if yes ,perform the below operation\n                if new_pos in hash_map:\n                    #if j-1 > 0 then add j-1 to the new position in hashmap\n                    if (j-1)>0:\n                        hash_map[new_pos].add(j-1)\n                    #add j to the new position in hashmap\n                    hash_map[new_pos].add(j)\n                    #add j+1 to the new position in hashmap\n                    hash_map[new_pos].add(j+1)\n        #else return false\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canCross(self, stones: List[int]) -> bool:\\n        #destination is a variable which stores the \\n        #position of last stone where frog need to reach\\n        destination=stones[len(stones)-1]\\n        #it may happen that elements can be repeated so to avoid that\\n        #associate a set for every stone in stones array\\n        #make a hash map of stones along with set()\\n        #for eg.1 : \\n        #stones = [0,1,3,5,6,8,12,17]\\n        #hash_map={0: set(), 1: set(), 3: set(), 5: set(), 6: set(), 8: set(), 12: set(), 17: set()}\\n        hash_map=dict()\\n        #in hash map , key will be stone and value will be set()\\n        for stone in stones:\\n            hash_map[stone]=set()\\n        #it is given that the initial jump of frog is 1\\n        hash_map[stones[0]].add(1)\\n        #jumps is a set of particular position of stones \\n        #for every position of stone in stones\\n        #find out the new position while iterating over set of jumps\\n        for position in stones:\\n            jumps=hash_map[position]\\n            for j in jumps:\\n                #calculate newposition by adding position with j \\n                new_pos=position+j\\n                #check whether the new_pos is our target destination or not\\n                if new_pos==destination:\\n                    return True\\n                #check whether the new position is available in  hash map\\n                #if yes ,perform the below operation\\n                if new_pos in hash_map:\\n                    #if j-1 > 0 then add j-1 to the new position in hashmap\\n                    if (j-1)>0:\\n                        hash_map[new_pos].add(j-1)\\n                    #add j to the new position in hashmap\\n                    hash_map[new_pos].add(j)\\n                    #add j+1 to the new position in hashmap\\n                    hash_map[new_pos].add(j+1)\\n        #else return false\\n        return False\\n\\n             \\n```"
    },
    {
        "slug": "excel-sheet-column-title",
        "tags": "python3",
        "release_time": 1692672791,
        "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        if n<27:\n            return chr(ord('A')+(n-1)%26)\n        ans=\"\"\n        while n>0:\n            if n%26==0:\n                ans+=chr(ord('A')+25)\n                n-=1\n            else:\n                ans+=chr(ord('A')+n%26-1)\n            n//=26\n        return ans[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        if n<27:\\n            return chr(ord(\\'A\\')+(n-1)%26)\\n        ans=\"\"\\n        while n>0:\\n            if n%26==0:\\n                ans+=chr(ord(\\'A\\')+25)\\n                n-=1\\n            else:\\n                ans+=chr(ord(\\'A\\')+n%26-1)\\n            n//=26\\n        return ans[::-1]\\n```"
    },
    {
        "slug": "subarray-sums-divisible-by-k",
        "tags": "python3",
        "release_time": 1674092277,
        "code": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        m, tot = [1] + [0 for i in range(k - 1)], 0\n        \n        for i in accumulate(nums):\n            tot += m[i%k]\n            m[i%k] += 1\n        \n        return tot",
        "content": "# Intuition\\nStore number of times accumulate was modulo k\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        m, tot = [1] + [0 for i in range(k - 1)], 0\\n        \\n        for i in accumulate(nums):\\n            tot += m[i%k]\\n            m[i%k] += 1\\n        \\n        return tot\\n\\n\\n```"
    },
    {
        "slug": "removing-minimum-and-maximum-from-array",
        "tags": "python3",
        "release_time": 1688723249,
        "code": "class Solution:\n    def minimumDeletions(self, nums: List[int]) -> int:\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDeletions(self, nums: List[int]) -> int:\\n        return min((min(nums.index(min(nums))+1,len(nums)-nums.index(min(nums)))+min(nums.index(max(nums))+1,len(nums)-nums.index(max(nums)))),max(nums.index(min(nums))+1,nums.index(max(nums))+1),max(len(nums)-nums.index(min(nums)),len(nums)-nums.index(max(nums))))\\n```"
    },
    {
        "slug": "percentage-of-letter-in-string",
        "tags": "python3",
        "release_time": 1676733065,
        "code": "class Solution:\n    def percentageLetter(self, s: str, letter: str) -> int:\n        l=len(s)\n        count=0\n        for i in s:\n            if i==letter:\n                count+=1\n            else:\n                pass\n        return int((count/l)*100)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def percentageLetter(self, s: str, letter: str) -> int:\\n        l=len(s)\\n        count=0\\n        for i in s:\\n            if i==letter:\\n                count+=1\\n            else:\\n                pass\\n        return int((count/l)*100)        \\n```"
    },
    {
        "slug": "design-memory-allocator",
        "tags": "python3",
        "release_time": 1670742814,
        "code": "import heapq\nclass Allocator:\n\n    def __init__(self, n: int):\n        self.ht={}\n        self.freeMemeory=[[0, n]]\n\n    def allocate(self, size: int, mID: int) -> int:\n        if self.freeMemeory:\n            self.refreshMemeory()\n        val = self.giveFreeMemeory(size)\n        if not val:\n            return -1\n        # one mID can have multiple occurrences, so need to keep track of all occurrences.\n        if mID in self.ht:\n            self.ht[mID].append(val)\n        else:\n            self.ht[mID]=[val]\n        return val[0]\n        \n\n    def free(self, mID: int) -> int:\n        if self.freeMemeory:\n            self.refreshMemeory()\n        if mID not in self.ht or not self.ht[mID]:\n            return 0\n        size=0\n        # suppose we have multiple occurrences of 1 then in that case we need to remove all the occurrences and return the total size.\n        for ids in self.ht[mID]:\n            size+=ids[1]-ids[0]\n            heapq.heappush(self.freeMemeory,ids)\n        # need to reset the HashTable, once every occurrences are removed\n        self.ht[mID]=[]\n        return size\n\n    # giveFreeMemeory is to return FIRST FREE MEMORY which comes in the range of size.\n    def giveFreeMemeory(self, size):\n        temp=[]\n        send=[]\n        while self.freeMemeory:\n            start, end = heapq.heappop(self.freeMemeory)\n            if (end-start)>=size:\n                if (end-start)>size:\n                    heapq.heappush(self.freeMemeory,[start+size, end])\n                send=[start, start+size]\n                break\n            else:\n                temp.append([start, end])\n        if temp:\n            for i in range(len(temp)):\n                heapq.heappush(self.freeMemeory,temp[i])\n        if not send:\n            return 0\n        return send\n\n    # refreshMemeory function helps us to refactor the memory, suppose we have [[40,50], [12,40]] so this is nothing but [[12,50]], our refreshMemory function will help us do the same.\n    def refreshMemeory(self):\n        start, end = heapq.heappop(self.freeMemeory)\n        temp=[[start, end]]\n        while self.freeMemeory:\n            newStart, newEnd = heapq.heappop(self.freeMemeory)\n            if end==newStart:\n                temp.pop()\n                end=newEnd\n            else:\n                start=newStart\n                end=newEnd\n            temp.append([start, end])\n        if temp:\n            for i in range(len(temp)):\n                heapq.heappush(self.freeMemeory,temp[i])\n        \n\n\n# Your Allocator object will be instantiated and called as such:\n# obj = Allocator(n)\n# param_1 = obj.allocate(size,mID)\n# param_2 = obj.free(mID)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nclass Allocator:\\n\\n    def __init__(self, n: int):\\n        self.ht={}\\n        self.freeMemeory=[[0, n]]\\n\\n    def allocate(self, size: int, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        val = self.giveFreeMemeory(size)\\n        if not val:\\n            return -1\\n        # one mID can have multiple occurrences, so need to keep track of all occurrences.\\n        if mID in self.ht:\\n            self.ht[mID].append(val)\\n        else:\\n            self.ht[mID]=[val]\\n        return val[0]\\n        \\n\\n    def free(self, mID: int) -> int:\\n        if self.freeMemeory:\\n            self.refreshMemeory()\\n        if mID not in self.ht or not self.ht[mID]:\\n            return 0\\n        size=0\\n        # suppose we have multiple occurrences of 1 then in that case we need to remove all the occurrences and return the total size.\\n        for ids in self.ht[mID]:\\n            size+=ids[1]-ids[0]\\n            heapq.heappush(self.freeMemeory,ids)\\n        # need to reset the HashTable, once every occurrences are removed\\n        self.ht[mID]=[]\\n        return size\\n\\n    # giveFreeMemeory is to return FIRST FREE MEMORY which comes in the range of size.\\n    def giveFreeMemeory(self, size):\\n        temp=[]\\n        send=[]\\n        while self.freeMemeory:\\n            start, end = heapq.heappop(self.freeMemeory)\\n            if (end-start)>=size:\\n                if (end-start)>size:\\n                    heapq.heappush(self.freeMemeory,[start+size, end])\\n                send=[start, start+size]\\n                break\\n            else:\\n                temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        if not send:\\n            return 0\\n        return send\\n\\n    # refreshMemeory function helps us to refactor the memory, suppose we have [[40,50], [12,40]] so this is nothing but [[12,50]], our refreshMemory function will help us do the same.\\n    def refreshMemeory(self):\\n        start, end = heapq.heappop(self.freeMemeory)\\n        temp=[[start, end]]\\n        while self.freeMemeory:\\n            newStart, newEnd = heapq.heappop(self.freeMemeory)\\n            if end==newStart:\\n                temp.pop()\\n                end=newEnd\\n            else:\\n                start=newStart\\n                end=newEnd\\n            temp.append([start, end])\\n        if temp:\\n            for i in range(len(temp)):\\n                heapq.heappush(self.freeMemeory,temp[i])\\n        \\n\\n\\n# Your Allocator object will be instantiated and called as such:\\n# obj = Allocator(n)\\n# param_1 = obj.allocate(size,mID)\\n# param_2 = obj.free(mID)\\n```"
    },
    {
        "slug": "palindrome-partitioning-iv",
        "tags": "python3",
        "release_time": 1674859562,
        "code": "class Solution:\n    def checkPartitioning(self, s: str) -> bool:\n        '''\n        div into 3 palindrome parts, meaning one starts at begining, one ends at the end, of s\n        1. get the beginning palindrome candidates s[:i+1], save i to indicate its end (i+1 is starting of middle palindrome)\n        2. get the ending palindrome candidates s[j:], save j, save j to indicate the its beginning (j-1 is ending of middle palindrome)\n        3. iretatively check each beginning candidate and ending candidate, if remaining middle is non empty and fits the criteria, return True \n        '''\n        firsts_end, thirds_start = [], []\n        \n        for i in range(len(s)):\n            if s[:i+1] == s[:i+1][::-1]:\n                firsts_end.append(i)\n        \n        for i in range(len(s)):\n            if s[i:] == s[i:][::-1]:\n                thirds_start.append(i)\n        \n        # check\n        for f in firsts_end:\n            for t in reversed(thirds_start):\n                second = s[f+1:t]\n                if second == '': break\n                if second == second[::-1]:\n                    return True\n\n        # return \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkPartitioning(self, s: str) -> bool:\\n        \\'\\'\\'\\n        div into 3 palindrome parts, meaning one starts at begining, one ends at the end, of s\\n        1. get the beginning palindrome candidates s[:i+1], save i to indicate its end (i+1 is starting of middle palindrome)\\n        2. get the ending palindrome candidates s[j:], save j, save j to indicate the its beginning (j-1 is ending of middle palindrome)\\n        3. iretatively check each beginning candidate and ending candidate, if remaining middle is non empty and fits the criteria, return True \\n        \\'\\'\\'\\n        firsts_end, thirds_start = [], []\\n        \\n        for i in range(len(s)):\\n            if s[:i+1] == s[:i+1][::-1]:\\n                firsts_end.append(i)\\n        \\n        for i in range(len(s)):\\n            if s[i:] == s[i:][::-1]:\\n                thirds_start.append(i)\\n        \\n        # check\\n        for f in firsts_end:\\n            for t in reversed(thirds_start):\\n                second = s[f+1:t]\\n                if second == \\'\\': break\\n                if second == second[::-1]:\\n                    return True\\n\\n        # return \\n        return False \\n```"
    },
    {
        "slug": "least-operators-to-express-number",
        "tags": "python3",
        "release_time": 1689265645,
        "code": "import heapq\n\nclass Solution:\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\n        bfs = [(0, target)]\n        visited = set()\n        def push(operations, remaining):\n            heapq.heappush(bfs, (operations, remaining))\n                \n        while bfs:\n            operations, remaining = heapq.heappop(bfs)\n            if remaining == 0:\n                return operations\n            if remaining in visited:\n                continue\n            visited.add(remaining)\n            if x > remaining:\n                push(operations + abs(min((x - remaining) * 2, remaining * 2 - 1)), 0)\n                continue\n            result, current, prev = 0, x, None\n            while current < remaining:\n                prev = current\n                current *= x\n                result += 1\n            \n            push(operations + result + (current != remaining), current - remaining)\n            if prev is not None:\n                push(operations + result, remaining - prev)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def leastOpsExpressTarget(self, x: int, target: int) -> int:\\n        bfs = [(0, target)]\\n        visited = set()\\n        def push(operations, remaining):\\n            heapq.heappush(bfs, (operations, remaining))\\n                \\n        while bfs:\\n            operations, remaining = heapq.heappop(bfs)\\n            if remaining == 0:\\n                return operations\\n            if remaining in visited:\\n                continue\\n            visited.add(remaining)\\n            if x > remaining:\\n                push(operations + abs(min((x - remaining) * 2, remaining * 2 - 1)), 0)\\n                continue\\n            result, current, prev = 0, x, None\\n            while current < remaining:\\n                prev = current\\n                current *= x\\n                result += 1\\n            \\n            push(operations + result + (current != remaining), current - remaining)\\n            if prev is not None:\\n                push(operations + result, remaining - prev)\\n\\n```"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "tags": "python3",
        "release_time": 1677668239,
        "code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        def dnc(l, r, lo, hi):\n            if l == r - 1:\n                return l if lo == hi else -1\n            \n            mid = (l + r) // 2\n            right = sum(nums[mid:r])\n            left = sum(nums[l:mid])\n\n            left_ind = dnc(l, mid, lo, hi + right)\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\n        return dnc(0, len(nums), 0, 0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo we notice that for index `i` and index `i + 1`, most of the sum on the left and right side are shared. In particular, the left side of index `i` is `sum(nums[0..i-1])` and the left side of `i + 1` is `sum(nums[0..i-1]) + nums[i]`, so they both share `sum(nums[0..i-1]`. This is similar for the right side.\\n\\nSo we can split the problem in half, calculate the sum of the left half and calculate the sum of the right half and keep that in a cumulative sum so we don\\'t have to repeat work.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the sum of the left and right half of some subsection of the array (originally the entire array). Then find the middle index of the left half of the array recursively, but make sure to add on the sum of the right half you have calculated so far. Similar for the left side.\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: $O(n)$ (proof as an exercise to the reader)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        def dnc(l, r, lo, hi):\\n            if l == r - 1:\\n                return l if lo == hi else -1\\n            \\n            mid = (l + r) // 2\\n            right = sum(nums[mid:r])\\n            left = sum(nums[l:mid])\\n\\n            left_ind = dnc(l, mid, lo, hi + right)\\n            return left_ind if left_ind != -1 else dnc(mid, r, lo + left, hi)\\n        return dnc(0, len(nums), 0, 0)\\n```"
    },
    {
        "slug": "probability-of-a-two-boxes-having-the-same-number-of-distinct-balls",
        "tags": "python3",
        "release_time": 1689148739,
        "code": "class Solution:\n    def getProbability(self, balls: List[int]) -> float:\n        def fact(n):\n            if n <= 0:return 1\n            return n*fact(n-1)\n        t = 2**len(balls)\n        tm = len(balls)\n        res = 0\n        ed = sum(balls)//2\n        gt = fact(ed)\n        def go(arr):\n            ans = gt*gt\n            for x in range(tm):\n                ans /= fact(arr[x])\n                ans /= fact(abs(balls[x]-arr[x]))\n            return ans\n        def solve(i,l,r,cntl,arr):\n            nonlocal res, gets\n            if cntl>ed:\n                return \n            if i == tm:\n                if cntl == ed:\n                    res+=go(arr)\n                return\n            if (1<<i)&l != 0 and (1<<i)&r != 0:\n                for j in range(1,balls[i]):\n                    arr[i] = j\n                    solve(i+1, l,r, cntl+j, arr)\n                    arr[i] = 0\n            elif (1<<i)&l != 0:\n                arr[i] = balls[i]\n                solve(i+1, l, r, cntl+balls[i], arr)\n                arr[i] = 0\n            else:\n                solve(i+1, l, r, cntl, arr)\n        cnt = 0            \n        temp = [0 for i in range(tm)]\n        for i in range(t):\n            for j in range(t):\n                if bin(i|j).count(\"1\") == tm and bin(i).count(\"1\") == bin(j).count(\"1\"):\n                    solve(0,i,j,0,temp)\n        gets = fact(ed*2)\n        for i in balls:\n            gets /= fact(i) \n        return res/gets",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def getProbability(self, balls: List[int]) -> float:\\n        def fact(n):\\n            if n <= 0:return 1\\n            return n*fact(n-1)\\n        t = 2**len(balls)\\n        tm = len(balls)\\n        res = 0\\n        ed = sum(balls)//2\\n        gt = fact(ed)\\n        def go(arr):\\n            ans = gt*gt\\n            for x in range(tm):\\n                ans /= fact(arr[x])\\n                ans /= fact(abs(balls[x]-arr[x]))\\n            return ans\\n        def solve(i,l,r,cntl,arr):\\n            nonlocal res, gets\\n            if cntl>ed:\\n                return \\n            if i == tm:\\n                if cntl == ed:\\n                    res+=go(arr)\\n                return\\n            if (1<<i)&l != 0 and (1<<i)&r != 0:\\n                for j in range(1,balls[i]):\\n                    arr[i] = j\\n                    solve(i+1, l,r, cntl+j, arr)\\n                    arr[i] = 0\\n            elif (1<<i)&l != 0:\\n                arr[i] = balls[i]\\n                solve(i+1, l, r, cntl+balls[i], arr)\\n                arr[i] = 0\\n            else:\\n                solve(i+1, l, r, cntl, arr)\\n        cnt = 0            \\n        temp = [0 for i in range(tm)]\\n        for i in range(t):\\n            for j in range(t):\\n                if bin(i|j).count(\"1\") == tm and bin(i).count(\"1\") == bin(j).count(\"1\"):\\n                    solve(0,i,j,0,temp)\\n        gets = fact(ed*2)\\n        for i in balls:\\n            gets /= fact(i) \\n        return res/gets\\n```"
    },
    {
        "slug": "k-th-smallest-in-lexicographical-order",
        "tags": "python3",
        "release_time": 1638474846,
        "code": "class Solution:\n    def findKthNumber(self, n: int, k: int) -> int:\n        \n        def fn(x): \n            \"\"\"Return node counts in denary trie.\"\"\"\n            ans, diff = 0, 1\n            while x <= n: \n                ans += min(n - x + 1, diff)\n                x *= 10 \n                diff *= 10 \n            return ans \n        \n        x = 1\n        while k > 1: \n            cnt = fn(x)\n            if k > cnt: k -= cnt; x += 1\n            else: k -= 1; x *= 10 \n        return x",
        "content": "\\n```\\nclass Solution:\\n    def findKthNumber(self, n: int, k: int) -> int:\\n        \\n        def fn(x): \\n            \"\"\"Return node counts in denary trie.\"\"\"\\n            ans, diff = 0, 1\\n            while x <= n: \\n                ans += min(n - x + 1, diff)\\n                x *= 10 \\n                diff *= 10 \\n            return ans \\n        \\n        x = 1\\n        while k > 1: \\n            cnt = fn(x)\\n            if k > cnt: k -= cnt; x += 1\\n            else: k -= 1; x *= 10 \\n        return x\\n```"
    },
    {
        "slug": "number-of-pairs-of-strings-with-concatenation-equal-to-target",
        "tags": "python3",
        "release_time": 1683526112,
        "code": "class Solution:\n    def numOfPairs(self, nums: List[str], target: str) -> int:\n        d = defaultdict(int)\n        for char in nums:\n            d[char] += 1\n            \n        arr = []\n        for char in target:\n            arr.append(char)\n        \n        pairs = 0\n        num = \"\"\n        while len(arr) > 1:\n            num += arr.pop()\n            findNum = \"\".join(arr)\n            if num[::-1] not in d or findNum not in d:\n                continue\n\n            c1 = d[num[::-1]]\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\n            \n            c2 = d[findNum]\n            d[num[::-1]] += 1 # make the count again same.\n\n            pairs += c1 * c2\n        return pairs",
        "content": "# Code\\n```\\nclass Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        d = defaultdict(int)\\n        for char in nums:\\n            d[char] += 1\\n            \\n        arr = []\\n        for char in target:\\n            arr.append(char)\\n        \\n        pairs = 0\\n        num = \"\"\\n        while len(arr) > 1:\\n            num += arr.pop()\\n            findNum = \"\".join(arr)\\n            if num[::-1] not in d or findNum not in d:\\n                continue\\n\\n            c1 = d[num[::-1]]\\n            d[num[::-1]] -= 1 #reduce the count as we dont want to count it again if the other part is also same.\\n            \\n            c2 = d[findNum]\\n            d[num[::-1]] += 1 # make the count again same.\\n\\n            pairs += c1 * c2\\n        return pairs\\n        \\n```"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "tags": "python3",
        "release_time": 1672905271,
        "code": "class Solution:\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        dct=defaultdict(lambda :[])\n        indegree={}\n        n=len(recepies)\n\n        for i in recepies:\n            indegree[i]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                indegree[j]=0\n\n        for i in range(n):\n            for j in ingredients[i]:\n                dct[j].append(recepies[i])\n                indegree[recepies[i]]+=1\n\n        st=[]\n        for i in indegree:\n            if indegree[i]==0:\n                st.append(i)\n        flst=[]\n        ans=defaultdict(lambda :[])\n        while st:\n            x=st.pop(0)\n            for i in dct[x]:\n                # if ans[x]!=[]:\n                for j in ans[x]:\n                    if j not in ans[i]:\n                        ans[i].append(j)\n                ans[i].append(x)\n                indegree[i]-=1\n                if indegree[i]==0:\n                    st.append(i)\n            if x in recepies:\n                for k in ans[x]:\n                    if k not in supplies:\n                        break\n                else:\n                    flst.append(x)\n                    supplies.append(x)\n\n        return flst",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```"
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "tags": "python3",
        "release_time": 1664874410,
        "code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        nums.sort()\n        res = 100000\n        \n        for i in range(len(nums) - k + 1):\n            arr = nums[i:i + k]\n            res = min(res, arr[-1] - arr[0])\n            \n        return res",
        "content": "**Solution 1:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = 100000\\n        \\n        for i in range(len(nums) - k + 1):\\n            arr = nums[i:i + k]\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        arr = nums[:k]\\n        res = arr[-1] - arr[0]\\n        \\n        for i in range(k, len(nums)):\\n            arr.pop(0)\\n            arr.append(nums[i])\\n            res = min(res, arr[-1] - arr[0])\\n            \\n        return res\\n```"
    },
    {
        "slug": "count-negative-numbers-in-a-sorted-matrix",
        "tags": "python3",
        "release_time": 1686193447,
        "code": "class Solution:\n    def countNegatives(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        negatives = 0\n        col = 0\n        for row in range(ROWS - 1, -1, -1):\n            while col < COLS and grid[row][col] >= 0:\n                col += 1\n            negatives += COLS - col\n        return negatives",
        "content": "# Intuition\\nThe key idea is to take advantage of the sorted nature of the matrix, where both the rows and columns are sorted in non-increasing order. This means that once we find a negative number in a row, all the following numbers in that row will also be negative. Similarly, if a cell at the top of a column is negative, all the cells below it in that column will also be negative.\\n\\n# Approach\\nNegative numbers will form a staircase. So we start from the bottom-left, and follow along the staircase. For each row, we find the edge of the staircase, add all the count of elements to the right to the answer, and then move up a row and repeat.\\n\\n# Complexity\\n- Time complexity: O(m + n) - We visit each row and column at most once.\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def countNegatives(self, grid: List[List[int]]) -> int:\\n        ROWS, COLS = len(grid), len(grid[0])\\n        negatives = 0\\n        col = 0\\n        for row in range(ROWS - 1, -1, -1):\\n            while col < COLS and grid[row][col] >= 0:\\n                col += 1\\n            negatives += COLS - col\\n        return negatives\\n\\n```\\n\\n# Get Faster Interview Prep Results with Top Algos\\nWe all know how time-consuming it is to prepare for interviews and how frustratingly difficult it is to improve. We made **Top Algos** - a tool recommends the perfect algorithm problem based on your current skill level to help you improve the fastest in the shortest amount of time. Top Algos is your personalized coach that learns your skill level and finds the best problem you need to solve to improve.\\n\\nThe beta version of the product is available for **free** right now! You can sign up at https://topalgos.xyz/."
    },
    {
        "slug": "minimum-difference-between-highest-and-lowest-of-k-scores",
        "tags": "python3",
        "release_time": 1690753327,
        "code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        #sliding window\n        nums.sort()\n        l, r = 0, k-1\n        res = float(\"inf\")\n        while r < len(nums):\n            res = min(res, nums[r] - nums[l])\n            r += 1\n            l += 1\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumDifference(self, nums: List[int], k: int) -> int:\\n        #sliding window\\n        nums.sort()\\n        l, r = 0, k-1\\n        res = float(\"inf\")\\n        while r < len(nums):\\n            res = min(res, nums[r] - nums[l])\\n            r += 1\\n            l += 1\\n        return res\\n\\n\\n\\n```"
    },
    {
        "slug": "minimum-time-to-type-word-using-special-typewriter",
        "tags": "python3",
        "release_time": 1629561712,
        "code": "class Solution:\n    def minTimeToType(self, word: str) -> int:\n        ans = len(word)\n        prev = \"a\"\n        for ch in word: \n            val = (ord(ch) - ord(prev)) % 26 \n            ans += min(val, 26 - val)\n            prev = ch\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def minTimeToType(self, word: str) -> int:\\n        ans = len(word)\\n        prev = \"a\"\\n        for ch in word: \\n            val = (ord(ch) - ord(prev)) % 26 \\n            ans += min(val, 26 - val)\\n            prev = ch\\n        return ans \\n```"
    },
    {
        "slug": "string-compression-ii",
        "tags": "python3",
        "release_time": 1684779092,
        "code": "class Solution:\n    def dp(self,i,s,prev,k,ct,n,dct):\n        if k<0:\n            return float(\"infinity\")\n        if i>=n:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            return x\n        if (i,prev,ct,k) in dct:\n            return dct[(i,prev,ct,k)]\n        if s[i]==prev:\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\n        else:\n            x=0\n            if ct>1:\n                x=len(str(ct))+1\n            elif ct==1:\n                x=1\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\n        dct[(i,prev,ct,k)]=min(inc,exc)\n        return min(inc,exc)\n\n\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n        n=len(s)\n        return self.dp(0,s,\"\",k,0,n,{})",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,s,prev,k,ct,n,dct):\\n        if k<0:\\n            return float(\"infinity\")\\n        if i>=n:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            return x\\n        if (i,prev,ct,k) in dct:\\n            return dct[(i,prev,ct,k)]\\n        if s[i]==prev:\\n            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)\\n        else:\\n            x=0\\n            if ct>1:\\n                x=len(str(ct))+1\\n            elif ct==1:\\n                x=1\\n            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)\\n        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)\\n        dct[(i,prev,ct,k)]=min(inc,exc)\\n        return min(inc,exc)\\n\\n\\n    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\\n        n=len(s)\\n        return self.dp(0,s,\"\",k,0,n,{})\\n\\n        \\n```"
    },
    {
        "slug": "convert-sorted-list-to-binary-search-tree",
        "tags": "python3",
        "release_time": 1678550489,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\n        nums=[]\n        curr=head\n        while curr:\n            nums.append(curr.val)\n            curr=curr.next\n        def helper(l,r):\n            if l>r:\n                return None\n            mid=(l+r)//2\n            root=TreeNode(nums[mid])\n            root.left=helper(l,mid-1)\n            root.right=helper(mid+1,r)\n            return root\n        return helper(0,len(nums)-1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def sortedListToBST(self, head: Optional[ListNode]) -> Optional[TreeNode]:\\n        nums=[]\\n        curr=head\\n        while curr:\\n            nums.append(curr.val)\\n            curr=curr.next\\n        def helper(l,r):\\n            if l>r:\\n                return None\\n            mid=(l+r)//2\\n            root=TreeNode(nums[mid])\\n            root.left=helper(l,mid-1)\\n            root.right=helper(mid+1,r)\\n            return root\\n        return helper(0,len(nums)-1)\\n\\n        \\n```"
    },
    {
        "slug": "third-maximum-number",
        "tags": "python3",
        "release_time": 1688789383,
        "code": "class Solution:\n    def thirdMax(self, nums: List[int]) -> int:\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def thirdMax(self, nums: List[int]) -> int:\\n        return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\\n```"
    },
    {
        "slug": "watering-plants-ii",
        "tags": "python3",
        "release_time": 1639281726,
        "code": "class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        ans = 0 \n        lo, hi = 0, len(plants)-1\n        canA, canB = capacityA, capacityB\n        while lo < hi: \n            if canA < plants[lo]: ans += 1; canA = capacityA\n            canA -= plants[lo]\n            if canB < plants[hi]: ans += 1; canB = capacityB\n            canB -= plants[hi]\n            lo, hi = lo+1, hi-1\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\n        return ans",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/f57038d6cca9ccb356a137b3af67fba615a067dd) for solutions of weekly 271. \\n\\n```\\nclass Solution:\\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\\n        ans = 0 \\n        lo, hi = 0, len(plants)-1\\n        canA, canB = capacityA, capacityB\\n        while lo < hi: \\n            if canA < plants[lo]: ans += 1; canA = capacityA\\n            canA -= plants[lo]\\n            if canB < plants[hi]: ans += 1; canB = capacityB\\n            canB -= plants[hi]\\n            lo, hi = lo+1, hi-1\\n        if lo == hi and max(canA, canB) < plants[lo]: ans += 1\\n        return ans \\n```"
    },
    {
        "slug": "find-target-indices-after-sorting-array",
        "tags": "python3",
        "release_time": 1690911655,
        "code": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        lessThanEqual = 0\n        onlyLess = 0\n        for i in nums:\n            if i <= target:\n                lessThanEqual += 1\n            if i < target:\n                onlyLess += 1\n        return list(range(onlyLess, lessThanEqual))",
        "content": "# Intuition\\nwe dont need actual indices, we dont care about sequence or order so we don\\'t need sort.\\nbinary search \\n# Approach\\nJust count number of elements which are less than or equal to given target. say lessThanOrEqualCount\\nThen count number of elements which are strictly less than given target onlyLessThanCount\\n\\nif lessThanOrEqualCount = onlyLessThanCount: return empty\\nor else all numbers between them\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity: O(1)\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```\\n\\nPlease upvote if you like the solution.\\n"
    },
    {
        "slug": "maximum-depth-of-n-ary-tree",
        "tags": "python3",
        "release_time": 1665143377,
        "code": "\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val=None, children=None):\n        self.val = val\n        self.children = children\n\"\"\"\n\nclass Solution:\n    def maxDepth(self, root: 'Node') -> int:\n        if root == None:\n            return 0\n        else:\n            depth = 0\n            nodes_queue = [root]\n            next_nodes_queue = []\n            while(nodes_queue):\n                node_out = nodes_queue.pop(0)\n                for child in node_out.children:\n                    next_nodes_queue.append(child)\n                if nodes_queue == []:\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\n                    depth += 1\n            return depth",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution:\\n    def maxDepth(self, root: \\'Node\\') -> int:\\n        if root == None:\\n            return 0\\n        else:\\n            depth = 0\\n            nodes_queue = [root]\\n            next_nodes_queue = []\\n            while(nodes_queue):\\n                node_out = nodes_queue.pop(0)\\n                for child in node_out.children:\\n                    next_nodes_queue.append(child)\\n                if nodes_queue == []:\\n                    nodes_queue, next_nodes_queue = next_nodes_queue, nodes_queue\\n                    depth += 1\\n            return depth\\n```"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-binary-string-alternating",
        "tags": "python3",
        "release_time": 1621137987,
        "code": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        ones = s.count(\"1\")\n        zeros = len(s) - ones \n        if abs(ones - zeros) > 1: return -1 # impossible\n        \n        def fn(x): \n            \"\"\"Return number of swaps if string starts with x.\"\"\"\n            ans = 0 \n            for c in s: \n                if c != x: ans += 1\n                x = \"1\" if x == \"0\" else \"0\"\n            return ans//2\n        \n        if ones > zeros: return fn(\"1\")\n        elif ones < zeros: return fn(\"0\")\n        else: return min(fn(\"0\"), fn(\"1\"))",
        "content": "\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        ones = s.count(\"1\")\\n        zeros = len(s) - ones \\n        if abs(ones - zeros) > 1: return -1 # impossible\\n        \\n        def fn(x): \\n            \"\"\"Return number of swaps if string starts with x.\"\"\"\\n            ans = 0 \\n            for c in s: \\n                if c != x: ans += 1\\n                x = \"1\" if x == \"0\" else \"0\"\\n            return ans//2\\n        \\n        if ones > zeros: return fn(\"1\")\\n        elif ones < zeros: return fn(\"0\")\\n        else: return min(fn(\"0\"), fn(\"1\")) \\n```"
    },
    {
        "slug": "top-k-frequent-elements",
        "tags": "python3",
        "release_time": 1689052844,
        "code": "class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        dic=dict()\n        res=[]\n        lis=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in dic.values():\n            lis.append(i)\n        lis.sort()\n        lis=lis[-k:]\n        for i in lis[:k]:\n            for j in dic:\n                if dic[j]==i and j not in res:\n                    res.append(j)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\\n        dic=dict()\\n        res=[]\\n        lis=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in dic.values():\\n            lis.append(i)\\n        lis.sort()\\n        lis=lis[-k:]\\n        for i in lis[:k]:\\n            for j in dic:\\n                if dic[j]==i and j not in res:\\n                    res.append(j)\\n        return res\\n        \\n\\n\\n        \\n```"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "tags": "python3",
        "release_time": 1692290595,
        "code": "from collections import Counter\n\nclass Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        counter = Counter(nums)\n        index = 0\n\n        for num, count in counter.items():\n            nums[index] = num\n            index += 1\n            if count > 1:\n                nums[index] = num\n                index += 1\n\n        return index",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        counter = Counter(nums)\\n        index = 0\\n\\n        for num, count in counter.items():\\n            nums[index] = num\\n            index += 1\\n            if count > 1:\\n                nums[index] = num\\n                index += 1\\n\\n        return index\\n```"
    },
    {
        "slug": "reformat-phone-number",
        "tags": "python3",
        "release_time": 1679337153,
        "code": "class Solution:\n    def reformatNumber(self, number: str) -> str:\n        number = number.strip()\n        no=''\n\n        for i in number:\n            if i>=chr(48) and i <=chr(57):\n                no=no+i\n    \n        number=no\n        l,i = len(number),0\n        no=''\n\n        while(i<len(number)): \n            if l>4:\n                no=no+number[i]+number[i+1]+number[i+2]\n                no=no+'-'\n                l-=3\n                i+=3\n\n            if l==3:\n                no=no+number[i]+number[i+1]+number[i+2]\n                l-=3\n                i+=3\n\n            if l==4 or l==2:\n                no=no+number[i]+number[i+1]\n                if l!=2:\n                    no=no+'-'\n                l-=2\n                i+=2\n        return no",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def reformatNumber(self, number: str) -> str:\\n        number = number.strip()\\n        no=\\'\\'\\n\\n        for i in number:\\n            if i>=chr(48) and i <=chr(57):\\n                no=no+i\\n    \\n        number=no\\n        l,i = len(number),0\\n        no=\\'\\'\\n\\n        while(i<len(number)): \\n            if l>4:\\n                no=no+number[i]+number[i+1]+number[i+2]\\n                no=no+\\'-\\'\\n                l-=3\\n                i+=3\\n\\n            if l==3:\\n                no=no+number[i]+number[i+1]+number[i+2]\\n                l-=3\\n                i+=3\\n\\n            if l==4 or l==2:\\n                no=no+number[i]+number[i+1]\\n                if l!=2:\\n                    no=no+\\'-\\'\\n                l-=2\\n                i+=2\\n        return no\\n```"
    },
    {
        "slug": "second-largest-digit-in-a-string",
        "tags": "python3",
        "release_time": 1670469752,
        "code": "class Solution:\n    def secondHighest(self, s: str) -> int:\n        nums = []\n        for char in s:\n            if char.isdigit():\n                nums.append(int(char))\n        nums = [num for num in nums if num != max(nums)]\n        if len(nums) >= 1: return max(nums)\n        else: return -1",
        "content": "# Code\\n```\\nclass Solution:\\n    def secondHighest(self, s: str) -> int:\\n        nums = []\\n        for char in s:\\n            if char.isdigit():\\n                nums.append(int(char))\\n        nums = [num for num in nums if num != max(nums)]\\n        if len(nums) >= 1: return max(nums)\\n        else: return -1\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/c4c71af3-f3b3-48a6-ab0d-a185d1e6bc34_1670469692.8230677.png)\\n![image.png](https://assets.leetcode.com/users/images/71093191-2e72-4fb2-836e-8e2154a50128_1670469734.680368.png)\\nAww, man\\u2934"
    },
    {
        "slug": "check-if-array-is-good",
        "tags": "python3",
        "release_time": 1690051210,
        "code": "class Solution:\n    def isGood(self, nums: List[int]) -> bool:\n        xor = 0\n        n = len(nums) - 1\n        numN = 0\n        \n        for i in range(1, n):\n            xor ^= i\n        \n        for i in range(len(nums)):\n            if nums[i] > n:\n                return False\n            if nums[i] == n:\n                numN += 1\n            else:\n                xor ^= nums[i]\n                                \n        return xor == 0 and numN == 2",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGood(self, nums: List[int]) -> bool:\\n        xor = 0\\n        n = len(nums) - 1\\n        numN = 0\\n        \\n        for i in range(1, n):\\n            xor ^= i\\n        \\n        for i in range(len(nums)):\\n            if nums[i] > n:\\n                return False\\n            if nums[i] == n:\\n                numN += 1\\n            else:\\n                xor ^= nums[i]\\n                                \\n        return xor == 0 and numN == 2\\n```\\n\\n# Edit\\n<!-- Describe your approach to solving the problem. -->\\nAlthough this passes, it fails when using the `[1, 2, 3, 2, 5, 6, 1, 8, 8]` as a custom test case. It would be great if someone figured out a way to fix this problem.\\n`\\n"
    },
    {
        "slug": "longest-nice-substring",
        "tags": "python3",
        "release_time": 1613836849,
        "code": "class Solution:\n    def longestNiceSubstring(self, s: str) -> str:\n        ans = \"\"\n        for i in range(len(s)):\n            for ii in range(i+1, len(s)+1):\n                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): \n                    ans = max(ans, s[i:ii], key=len)\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        ans = \"\"\\n        for i in range(len(s)):\\n            for ii in range(i+1, len(s)+1):\\n                if all(s[k].swapcase() in s[i:ii] for k in range(i, ii)): \\n                    ans = max(ans, s[i:ii], key=len)\\n        return ans \\n```\\n\\nEdited on 2/23/2021\\nApparently, the small size doesn\\'t give me enough motivation to seek more efficient algo. Below is the implementation of divide and conquer in Python3 of this [post](https://leetcode.com/problems/longest-nice-substring/discuss/1074589/JavaStraightforward-Divide-and-Conquer). This is indeed a lot faster than the naive solution above. Credit goes to original author. \\n```\\nclass Solution:\\n    def longestNiceSubstring(self, s: str) -> str:\\n        if not s: return \"\" # boundary condition \\n        ss = set(s)\\n        for i, c in enumerate(s):\\n            if c.swapcase() not in ss: \\n                s0 = self.longestNiceSubstring(s[:i])\\n                s1 = self.longestNiceSubstring(s[i+1:])\\n                return max(s0, s1, key=len)\\n        return s\\n```"
    },
    {
        "slug": "make-array-empty",
        "tags": "python3",
        "release_time": 1682784138,
        "code": "class Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\n        s = 0\n        curr = 0\n        curr_loop_subtract = 0\n        looped_subtract = 0\n        for ind in sorted_index:\n            if curr <= ind:\n                s += ind - curr + 1\n                curr = ind + 1\n                curr_loop_subtract += 1\n            else:#wrap around\n                s += ind + (len(nums) - curr) + 1\n                curr = ind + 1\n                s -= looped_subtract\n                looped_subtract += curr_loop_subtract \n                curr_loop_subtract = 1\n        s -= (curr - curr_loop_subtract) \n        return s",
        "content": "# Intuition\\nIntuition:\\nIf the problem is simplied such that the smallest number, instead of being removed, is only marked, then the solution is simply to do index sort and then suming up differences (index[i + 1] - index[i] + 1, when index[i + 1] > index[i]. or index[i + 1] + len(nums) - index[i] + 1 when index[i] > index[i + 1])\\n\\nThe additional condition that we remove the the smallest remaining number doesn\\'t change the process that much. The key difference being, when calculating index differences, we have to discount the removed indexes (index[i + 1] - index[i] + 1 - num_removed_indexes[index[i]:index[i + 1]], when index[i + 1] > index[i] )\\n\\nThe naive way of tracking all removed indexes in a boolean array would result in o(n) look up and times out as there are o(n) removes, totalling to o(n^2) complexity.\\n\\nThe key insight is that between each \\'wrapping around\\', if we calculate moves as if numbers are marked instead of removed, the overcount is always the number of indexs we removed already in previous loop. Therefore, we never have to actually deal with removed indexes until \\'wrapping around\\', during which we can easily track and query number of removed indexes in o(1). \\n\\n![IMG-0172.jpg](https://assets.leetcode.com/users/images/0ca944bf-ef4d-46e4-bf1b-4032e0253c2f_1682784289.5164747.jpeg)\\n\\nEdit: forgot about the sorting in complexity lol. o(nlgn)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        sorted_index = [i[0] for i in sorted(enumerate(nums), key=lambda x:x[1])]\\n        s = 0\\n        curr = 0\\n        curr_loop_subtract = 0\\n        looped_subtract = 0\\n        for ind in sorted_index:\\n            if curr <= ind:\\n                s += ind - curr + 1\\n                curr = ind + 1\\n                curr_loop_subtract += 1\\n            else:#wrap around\\n                s += ind + (len(nums) - curr) + 1\\n                curr = ind + 1\\n                s -= looped_subtract\\n                looped_subtract += curr_loop_subtract \\n                curr_loop_subtract = 1\\n        s -= (curr - curr_loop_subtract) \\n        return s\\n            \\n        \\n```"
    },
    {
        "slug": "check-if-all-as-appears-before-all-bs",
        "tags": "python3",
        "release_time": 1666263208,
        "code": "class Solution:\n    def checkString(self, s: str) -> bool:\n        c=s[0]\n        if s[0]=='b' and 'a'  in s:\n            return False\n        n=len(s)\n        for i in range(n):\n            if c==s[i]:\n                continue\n            elif c in s[i+1:]:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkString(self, s: str) -> bool:\\n        c=s[0]\\n        if s[0]==\\'b\\' and \\'a\\'  in s:\\n            return False\\n        n=len(s)\\n        for i in range(n):\\n            if c==s[i]:\\n                continue\\n            elif c in s[i+1:]:\\n                return False\\n        return True\\n```"
    },
    {
        "slug": "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
        "tags": "python3",
        "release_time": 1690124160,
        "code": "class Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n            for di, dj in dirs:\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n        \n        dfs(m - 1, n - 1)\n    \n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n1. DFS + BFS\\n```\\nclass Solution:\\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\\n        m, n = len(grid), len(grid[0])\\n        dirs = [(-1, 0), (0, -1)]\\n        def dfs(i: int, j: int) -> None:\\n            grid[i][j] = 2\\n            for di, dj in dirs:\\n                if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\\n        \\n        dfs(m - 1, n - 1)\\n    \\n        dq = collections.deque([(0, 0)])\\n        grid[0][0] = 0\\n        dirs = [(1, 0), (0, 1)]\\n        while dq:\\n            l = len(dq)\\n            for _ in range(l):\\n                i, j = dq.popleft()\\n                if i == m - 1 and j == n - 1: return False\\n                for di, dj in dirs:\\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \\n                        dq.append((i + di, j + dj))\\n                        grid[i + di][j + dj] = 0\\n\\n\\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\\n\\n        return True\\n```"
    },
    {
        "slug": "implement-magic-dictionary",
        "tags": "python3",
        "release_time": 1689870399,
        "code": "class TrieNode:\n\n    def __init__(self):\n        self.children = collections.defaultdict(TrieNode)\n        self.is_end = False\n\n\nclass MagicDictionary:\n\n    def __init__(self):\n        self.trie = TrieNode()\n        self.s = set()\n        \n\n    def buildDict(self, dictionary: List[str]) -> None:\n        for word in dictionary:\n            self.s.add(word)\n            cur = self.trie\n            for ch in word:\n                cur = cur.children[ch]\n            cur.is_end = True\n        \n\n    def search(self, searchWord: str) -> bool:\n        n = len(searchWord)\n        def dfs(root: TrieNode, cnt: int, i: int) -> bool:\n            if cnt > 1 or i == n: return cnt == 1 and root.is_end\n            return any([dfs(root.children[c], cnt + int(c != searchWord[i]), i + 1) for c in root.children])\n        \n        return dfs(self.trie, 0, 0)\n\n# Your MagicDictionary object will be instantiated and called as such:\n# obj = MagicDictionary()\n# obj.buildDict(dictionary)\n# param_2 = obj.search(searchWord)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*K)$$ with N is the number of word and K is length of each word\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TrieNode:\\n\\n    def __init__(self):\\n        self.children = collections.defaultdict(TrieNode)\\n        self.is_end = False\\n\\n\\nclass MagicDictionary:\\n\\n    def __init__(self):\\n        self.trie = TrieNode()\\n        self.s = set()\\n        \\n\\n    def buildDict(self, dictionary: List[str]) -> None:\\n        for word in dictionary:\\n            self.s.add(word)\\n            cur = self.trie\\n            for ch in word:\\n                cur = cur.children[ch]\\n            cur.is_end = True\\n        \\n\\n    def search(self, searchWord: str) -> bool:\\n        n = len(searchWord)\\n        def dfs(root: TrieNode, cnt: int, i: int) -> bool:\\n            if cnt > 1 or i == n: return cnt == 1 and root.is_end\\n            return any([dfs(root.children[c], cnt + int(c != searchWord[i]), i + 1) for c in root.children])\\n        \\n        return dfs(self.trie, 0, 0)\\n\\n# Your MagicDictionary object will be instantiated and called as such:\\n# obj = MagicDictionary()\\n# obj.buildDict(dictionary)\\n# param_2 = obj.search(searchWord)\\n```"
    },
    {
        "slug": "koko-eating-bananas",
        "tags": "python3",
        "release_time": 1686109303,
        "code": "class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        def check(x):\n            return sum(ceil(ele/x) for ele in piles) <= h\n\n        l = 1\n        r = max(piles)\n        while l < r:\n            mid = (l+r) >> 1\n            if not check(mid):\n                l=mid+1\n            else:\n                r=mid\n        return l",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\\n        def check(x):\\n            return sum(ceil(ele/x) for ele in piles) <= h\\n\\n        l = 1\\n        r = max(piles)\\n        while l < r:\\n            mid = (l+r) >> 1\\n            if not check(mid):\\n                l=mid+1\\n            else:\\n                r=mid\\n        return l\\n```"
    },
    {
        "slug": "reverse-subarray-to-maximize-array-value",
        "tags": "python3",
        "release_time": 1684976469,
        "code": "class Solution:\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\n        originalValue, sz = 0, len(nums)\n        for idx in range(sz - 1):\n            originalValue += abs(nums[idx] - nums[idx + 1])\n        finalValue = originalValue\n        for idx in range(1, sz - 1):\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\n        minimum, maximum = inf, -inf\n        for idx in range(sz - 1):\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\n            minimum = min(minimum, tempMax)\n            maximum = max(maximum, tempMin)\n        return finalValue",
        "content": "# Code\\n```\\nclass Solution:\\n    def maxValueAfterReverse(self, nums: List[int]) -> int:\\n        originalValue, sz = 0, len(nums)\\n        for idx in range(sz - 1):\\n            originalValue += abs(nums[idx] - nums[idx + 1])\\n        finalValue = originalValue\\n        for idx in range(1, sz - 1):\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx + 1]) + abs(nums[idx + 1] - nums[0]))\\n            finalValue = max(finalValue, originalValue - abs(nums[idx] - nums[idx - 1]) + abs(nums[idx - 1] - nums[sz - 1]))\\n        minimum, maximum = inf, -inf\\n        for idx in range(sz - 1):\\n            tempMin, tempMax = min(nums[idx], nums[idx + 1]), max(nums[idx], nums[idx + 1])\\n            if minimum < tempMin: finalValue = max(finalValue, originalValue + (tempMin - minimum) * 2)\\n            if tempMax < maximum: finalValue = max(finalValue, originalValue + (maximum - tempMax) * 2)\\n            minimum = min(minimum, tempMax)\\n            maximum = max(maximum, tempMin)\\n        return finalValue\\n```"
    },
    {
        "slug": "maximum-product-of-splitted-binary-tree",
        "tags": "python3",
        "release_time": 1670642810,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef tsum(root):\n    if(root==None):\n        return 0\n    x= root.val+tsum(root.left)+tsum(root.right)\n    return x\ndef fun(root,sm,mx):\n    if(root==None):\n        return 0\n    a=fun(root.left,sm,mx)\n    b=fun(root.right,sm,mx)\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\n    return a+b+root.val\n    \nclass Solution:\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\n        mx=[0]\n        sm=tsum(root)\n        memo={}\n        fun(root,sm,mx)\n        return mx[0]%(10**9+7)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef tsum(root):\\n    if(root==None):\\n        return 0\\n    x= root.val+tsum(root.left)+tsum(root.right)\\n    return x\\ndef fun(root,sm,mx):\\n    if(root==None):\\n        return 0\\n    a=fun(root.left,sm,mx)\\n    b=fun(root.right,sm,mx)\\n    mx[0]=max(mx[0],a*(sm-a),b*(sm-b))\\n    return a+b+root.val\\n    \\nclass Solution:\\n    def maxProduct(self, root: Optional[TreeNode]) -> int:\\n        mx=[0]\\n        sm=tsum(root)\\n        memo={}\\n        fun(root,sm,mx)\\n        return mx[0]%(10**9+7)\\n```"
    },
    {
        "slug": "minimum-reverse-operations",
        "tags": "python3",
        "release_time": 1680408853,
        "code": "class Solution:\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\n        out = [-1] * n\n        # To speed up iterations, mark banned positions differently; remember to\n        # convert them to -1 at the end.\n        for node in banned:\n            out[node] = -2\n        # Perform reversals in level-based breadth-first order.\n        nodes = [p]\n        depth = 0\n        out[p] = depth\n        step = k - 1\n        \n        # TLEs occur when n is large, k is large, and not to many are banned,\n        # so that very O(N) points have O(N) possible post-reverse positions.\n        # These O(N) post-reverse positions are 2 apart, but each only needs\n        # to be visited once. We will nextNode2s dynamically to save work.\n        nextNode2s = [i + 2 for i in range(n)]  # might be out of range\n\n        while nodes:\n            depth += 1\n            newNodes = []\n            for node1 in nodes:\n                # The post-reverse positions are every other node between\n                # loNode2 and hiNode2, inclusive.\n                loReverseStart = max(node1 - step, 0)\n                hiReverseStart = min(node1, n - k) # Inclusive\n                loNode2 = 2 * loReverseStart + k - 1 - node1\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1  # Inclusive\n                # We will exclude the entire range from future iterations\n                # by setting nextNode2s[node2] to hiNode2 + 2 for every\n                # visited node2.\n                postHiNode2 = hiNode2 + 2\n                node2 = loNode2\n                while node2 <= hiNode2:\n                    nextNode2 = nextNode2s[node2]\n                    nextNode2s[node2] = postHiNode2\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\n                        newNodes.append(node2)\n                        out[node2] = depth\n                    node2 = nextNode2\n            nodes = newNodes\n            \n        # Mark all banned positions as -1 (see above).\n        for i in range(n):\n            if out[i] == -2:\n                out[i] = -1\n        return out",
        "content": "# Intuition\\nThis problem was hard to understand, and it has an $$O(K * N)$$ issue that needs to be addressed.\\n\\n# Approach\\nThe basic algorithm is a breadth-first search of positions, where depth is a reversal operation.\\n*   Avoid set lookups by marking `banned` positions with a `-2` reduces the constant coefficient speed-up. This is not enough to avoid a TLE, however.\\n*   Every visited position has $$O(k)$$ potential target positions. On visiting a new position, the multiplicative cost can be avoided by updating `nextNode2s`, which originally points forward 2, to point beyond all target positions considered for that position.\\n\\n# Complexity\\n- Time complexity: $$O(n + k)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minReverseOperations(self, n: int, p: int, banned: List[int], k: int) -> List[int]:\\n        out = [-1] * n\\n        # To speed up iterations, mark banned positions differently; remember to\\n        # convert them to -1 at the end.\\n        for node in banned:\\n            out[node] = -2\\n        # Perform reversals in level-based breadth-first order.\\n        nodes = [p]\\n        depth = 0\\n        out[p] = depth\\n        step = k - 1\\n        \\n        # TLEs occur when n is large, k is large, and not to many are banned,\\n        # so that very O(N) points have O(N) possible post-reverse positions.\\n        # These O(N) post-reverse positions are 2 apart, but each only needs\\n        # to be visited once. We will nextNode2s dynamically to save work.\\n        nextNode2s = [i + 2 for i in range(n)]  # might be out of range\\n\\n        while nodes:\\n            depth += 1\\n            newNodes = []\\n            for node1 in nodes:\\n                # The post-reverse positions are every other node between\\n                # loNode2 and hiNode2, inclusive.\\n                loReverseStart = max(node1 - step, 0)\\n                hiReverseStart = min(node1, n - k) # Inclusive\\n                loNode2 = 2 * loReverseStart + k - 1 - node1\\n                hiNode2 = 2 * hiReverseStart + k - 1 - node1  # Inclusive\\n                # We will exclude the entire range from future iterations\\n                # by setting nextNode2s[node2] to hiNode2 + 2 for every\\n                # visited node2.\\n                postHiNode2 = hiNode2 + 2\\n                node2 = loNode2\\n                while node2 <= hiNode2:\\n                    nextNode2 = nextNode2s[node2]\\n                    nextNode2s[node2] = postHiNode2\\n                    if node2 >= 0 and node2 < n and out[node2] == -1:\\n                        newNodes.append(node2)\\n                        out[node2] = depth\\n                    node2 = nextNode2\\n            nodes = newNodes\\n            \\n        # Mark all banned positions as -1 (see above).\\n        for i in range(n):\\n            if out[i] == -2:\\n                out[i] = -1\\n        return out\\n        \\n```"
    },
    {
        "slug": "binary-tree-level-order-traversal-ii",
        "tags": "python3",
        "release_time": 1666016205,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n                r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n                if curr.left:\n                    q.append(curr.left)\n                if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)",
        "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\\n        def checkReverse(ans):\\n            l,r = 0,len(ans)-1\\n            while l<=r:\\n                ans[l],ans[r] = ans[r],ans[l]\\n                l+=1\\n                r-=1\\n            return ans\\n\\n        if not root: return None\\n        q,ans = [root],[]\\n        while q:\\n            n,l = len(q),[]\\n            for i in range(n):\\n                curr = q.pop(0)\\n                l.append(curr.val)\\n                if curr.left:\\n                    q.append(curr.left)\\n                if curr.right:\\n                    q.append(curr.right)\\n            ans.append(l)\\n        return checkReverse(ans)\\n```"
    },
    {
        "slug": "find-kth-largest-xor-coordinate-value",
        "tags": "python3",
        "release_time": 1611461626,
        "code": "class Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        m, n = len(matrix), len(matrix[0]) # dimensions \n        \n        ans = []\n        for i in range(m): \n            for j in range(n): \n                if i: matrix[i][j] ^= matrix[i-1][j]\n                if j: matrix[i][j] ^= matrix[i][j-1]\n                if i and j: matrix[i][j] ^= matrix[i-1][j-1]\n                ans.append(matrix[i][j])\n        return sorted(ans)[-k]",
        "content": "**Algo**\\nCompute `xor` of at `(i, j)` as `xor[i][j] = xor[i-1][j] ^ xor[i][j-1] ^ xor[i-1][j-1] ^ matrix[i][j]`. The return the `k`th largest among observed. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        ans = []\\n        for i in range(m): \\n            for j in range(n): \\n                if i: matrix[i][j] ^= matrix[i-1][j]\\n                if j: matrix[i][j] ^= matrix[i][j-1]\\n                if i and j: matrix[i][j] ^= matrix[i-1][j-1]\\n                ans.append(matrix[i][j])\\n        return sorted(ans)[-k] \\n```\\n\\n**Analysis**\\nTime complexity `O(MNlog(MN))` (`O(MN)` is possible via quick select)\\nSpace complexity `O(MN)`\\n\\nEdited on 1/24/2021\\nAdding two more implementation for improved time complexity \\n`O(MNlogK)` time & `logK` space \\n```\\nclass Solution:\\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        pq = []\\n        for i in range(m): \\n            for j in range(n): \\n                if i: matrix[i][j] ^= matrix[i-1][j]\\n                if j: matrix[i][j] ^= matrix[i][j-1]\\n                if i and j: matrix[i][j] ^= matrix[i-1][j-1]\\n                heappush(pq, matrix[i][j])\\n                if len(pq) > k: heappop(pq)\\n        return pq[0]\\n```\\n\\n\\n`O(MN)` time & `O(MN)` space \\n```\\nclass Solution:\\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\\n        m, n = len(matrix), len(matrix[0]) # dimensions \\n        \\n        vals = []\\n        for i in range(m): \\n            for j in range(n): \\n                if i: matrix[i][j] ^= matrix[i-1][j]\\n                if j: matrix[i][j] ^= matrix[i][j-1]\\n                if i and j: matrix[i][j] ^= matrix[i-1][j-1]\\n                vals.append(matrix[i][j])\\n        \\n        def part(lo, hi): \\n            \"\"\"Partition vals from lo (inclusive) to hi (exclusive).\"\"\"\\n            i, j = lo+1, hi-1\\n            while i <= j: \\n                if vals[i] < vals[lo]: i += 1\\n                elif vals[lo] < vals[j]: j -= 1\\n                else: \\n                    vals[i], vals[j] = vals[j], vals[i]\\n                    i += 1\\n                    j -= 1\\n            vals[lo], vals[j] = vals[j], vals[lo]\\n            return j \\n        \\n        lo, hi = 0, len(vals)\\n        while lo < hi: \\n            mid = part(lo, hi)\\n            if mid + k < len(vals): lo = mid + 1\\n            else: hi = mid\\n        return vals[lo]\\n```"
    },
    {
        "slug": "invalid-transactions",
        "tags": "python3",
        "release_time": 1662407821,
        "code": "class Solution:\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\n        cities = defaultdict(lambda: defaultdict(list))\n        output = []\n        \n\t\t#build city map. \n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            cities[city][name].append(time)\n\n\t\t#Check each transaction against all transactions in a given city name from a given person\n        for t in transactions:\n            name, time, amount, city = t.split(',')\n            \n\t\t\t#Case 1\n            if int(amount) > 1000:\n                output.append(t)\n                continue\n                \n\t\t\t#Case 2\n            for k,v in cities.items():\n                if k == city:\n                    continue\n                    \n                if any([abs(int(x) - int(time)) <= 60 for x in v[name]]):\n                    output.append(t)\n                    break;\n        \n        return output",
        "content": "```\\nclass Solution:\\n    def invalidTransactions(self, transactions: List[str]) -> List[str]:\\n        cities = defaultdict(lambda: defaultdict(list))\\n        output = []\\n        \\n\\t\\t#build city map. \\n        for t in transactions:\\n            name, time, amount, city = t.split(\\',\\')\\n            cities[city][name].append(time)\\n\\n\\t\\t#Check each transaction against all transactions in a given city name from a given person\\n        for t in transactions:\\n            name, time, amount, city = t.split(\\',\\')\\n            \\n\\t\\t\\t#Case 1\\n            if int(amount) > 1000:\\n                output.append(t)\\n                continue\\n                \\n\\t\\t\\t#Case 2\\n            for k,v in cities.items():\\n                if k == city:\\n                    continue\\n                    \\n                if any([abs(int(x) - int(time)) <= 60 for x in v[name]]):\\n                    output.append(t)\\n                    break;\\n        \\n        return output\\n```"
    },
    {
        "slug": "maximum-alternating-subsequence-sum",
        "tags": "python3",
        "release_time": 1681714211,
        "code": "class Solution:\n    def maxAlternatingSum(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(len(nums) - 1):\n            if nums[i] > nums[i + 1]:\n                ans += nums[i] - nums[i + 1]\n        ans += nums[-1]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn the problem statement it was clearly mentioned that we need to take maximum altering sum. so we have to take one max element and then a min element and that too in order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso iterate through the loop in list and take the two numbers if nums[i]>nums[i+1].\\nlast item we need to take everytime. if you think why the answer is it was a odd indices number any way so we need to add it to result to get maximum list. \\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n- we iterate through the list so it takes n time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n- we used a single variable ans so 1 space required.\\n- please upvote me if you like the answer,it will gives me motivation.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(len(nums) - 1):\\n            if nums[i] > nums[i + 1]:\\n                ans += nums[i] - nums[i + 1]\\n        ans += nums[-1]\\n        return ans\\n```"
    },
    {
        "slug": "merge-sorted-array",
        "tags": "python3",
        "release_time": 1679058826,
        "code": "class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        for i in range(m,m+n):\n            nums1[i]=nums2[i-m]\n        nums1.sort()\n    #please upvote me it would encourage me alot",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\\n        for i in range(m,m+n):\\n            nums1[i]=nums2[i-m]\\n        nums1.sort()\\n    #please upvote me it would encourage me alot\\n\\n\\n```"
    },
    {
        "slug": "longest-harmonious-subsequence",
        "tags": "python3",
        "release_time": 1690719700,
        "code": "class Solution:\n    def findLHS(self, nums: List[int]) -> int:\n        result = 0\n        count_map = {}\n        for num in nums:\n            if num not in count_map:\n                count_map[num] = 1\n            else:\n                count_map[num] += 1\n        for num, count in count_map.items():\n            if num + 1 in count_map:\n                result = max(count + count_map[num + 1], result)\n        return result",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a count map holding occurences on elements and loop on keys to check if next consecutive element is present in the map.\\nIf present, compare the result with the max variable\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def findLHS(self, nums: List[int]) -> int:\\n        result = 0\\n        count_map = {}\\n        for num in nums:\\n            if num not in count_map:\\n                count_map[num] = 1\\n            else:\\n                count_map[num] += 1\\n        for num, count in count_map.items():\\n            if num + 1 in count_map:\\n                result = max(count + count_map[num + 1], result)\\n        return result\\n\\n```"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "tags": "python3",
        "release_time": 1670614819,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n\n        ans = [float(\"-inf\")]\n        self.FindMax(root, ans, root.val, root.val)\n        return ans[0]\n\n    def FindMax(self, root, ans, maxVal, minVal):\n\n        if(root is None):\n            return \n        \n        maxVal = max(maxVal, root.val)\n        minVal = min(minVal, root.val)        \n        ans[0] = max(ans[0], abs(maxVal - minVal))\n\n        self.FindMax(root.left, ans, maxVal, minVal)\n        self.FindMax(root.right, ans, maxVal, minVal)\n        return",
        "content": "# Intuition and Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThis problem can be solved with 2 approaches and with different Time Complexity.\\n\\n**1st Approach (Naive Solution):-**\\nWe can iterate over every node one by one and we will create another function which will traverse its subtree (children nodes).\\n\\nUsing that, at every point, we can find the absolute value and store the maximum value at every node. \\nSimilarly, we can do this for each and every node.\\n\\nTime Complexity - O(N * N), where N is the no. of nodes in the tree\\nSpace Complexity - O(1)\\n\\n**2nd Approach (Optimal Solution):-**\\nWe can iterate over every node and simultaneously we can keep three variables:-\\n1. ans - maximum difference ie ans\\n2. maxVal - maximum value till now in the current tree wrt its children and ancestor\\n3. minVal - minimum value till now in the current tree wrt its children and ancestor\\n\\nThen we can traverse the tree, and for that, we can create a DFS helper function and in that, we can pass our root and 3 variables as parameters. \\n\\nIn the DFS function, we can always keep a check of max absolute difference achieved till now, max value in that subtree and min value in that subtree.\\n\\nThen we can keep on updating those values at every call and in the end just return.\\n\\nIn the main function, after the completion of the helper function we have got the maximum difference, just return it. \\n\\n\\n# Complexity\\n- Time complexity: O(N), where N is the no. of nodes in the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n\\n        ans = [float(\"-inf\")]\\n        self.FindMax(root, ans, root.val, root.val)\\n        return ans[0]\\n\\n    def FindMax(self, root, ans, maxVal, minVal):\\n\\n        if(root is None):\\n            return \\n        \\n        maxVal = max(maxVal, root.val)\\n        minVal = min(minVal, root.val)        \\n        ans[0] = max(ans[0], abs(maxVal - minVal))\\n\\n        self.FindMax(root.left, ans, maxVal, minVal)\\n        self.FindMax(root.right, ans, maxVal, minVal)\\n        return\\n```"
    },
    {
        "slug": "find-all-lonely-numbers-in-the-array",
        "tags": "python3",
        "release_time": 1689511881,
        "code": "class Solution:\n    def findLonely(self, nums: List[int]) -> List[int]:\n        dic={}\n        res=[]\n        for i in nums:\n            if i in dic:\n                dic[i]+=1\n            else:\n                dic[i]=1\n        for i in nums:\n            if dic[i]==1:\n                if (i-1 not in dic) and (i+1 not in dic):\n                    res.append(i)\n        return res",
        "content": "# Code\\n```\\nclass Solution:\\n    def findLonely(self, nums: List[int]) -> List[int]:\\n        dic={}\\n        res=[]\\n        for i in nums:\\n            if i in dic:\\n                dic[i]+=1\\n            else:\\n                dic[i]=1\\n        for i in nums:\\n            if dic[i]==1:\\n                if (i-1 not in dic) and (i+1 not in dic):\\n                    res.append(i)\\n        return res\\n```"
    },
    {
        "slug": "wildcard-matching",
        "tags": "python3",
        "release_time": 1691149590,
        "code": "class Solution:\n\n    def isMatch(self, s: str, p: str) -> bool:\n        memo = {}\n\n        def recur(i, j):\n            if (i, j) in memo:\n                return memo[(i, j)]\n\n            if i >= len(s) and j >= len(p):\n                memo[(i, j)] = True\n            elif j >= len(p):\n                memo[(i, j)] = False\n            elif i >= len(s):\n                if p[j] == '*':\n                    memo[(i, j)] = recur(i, j + 1)\n                else:\n                    memo[(i, j)] = False\n            elif p[j] == '*':\n                memo[(i, j)] = recur(i + 1, j + 1) or recur(i, j + 1) or recur(i + 1, j)\n            elif p[j] == '?' or p[j] == s[i]:\n                memo[(i, j)] = recur(i + 1, j + 1)\n            else:\n                memo[(i, j)] = False\n\n            return memo[(i, j)]\n\n        return recur(0, 0)",
        "content": "# Intuition\\n- The problem can be classified as Backtracking but to optimize it, we can add memoization to eliminate repeat recursions when computing \\'*\\'s.\\n\\n# Approach\\n    - Backtracking with Dynamic Programming (memoization)\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def isMatch(self, s: str, p: str) -> bool:\\n        memo = {}\\n\\n        def recur(i, j):\\n            if (i, j) in memo:\\n                return memo[(i, j)]\\n\\n            if i >= len(s) and j >= len(p):\\n                memo[(i, j)] = True\\n            elif j >= len(p):\\n                memo[(i, j)] = False\\n            elif i >= len(s):\\n                if p[j] == \\'*\\':\\n                    memo[(i, j)] = recur(i, j + 1)\\n                else:\\n                    memo[(i, j)] = False\\n            elif p[j] == \\'*\\':\\n                memo[(i, j)] = recur(i + 1, j + 1) or recur(i, j + 1) or recur(i + 1, j)\\n            elif p[j] == \\'?\\' or p[j] == s[i]:\\n                memo[(i, j)] = recur(i + 1, j + 1)\\n            else:\\n                memo[(i, j)] = False\\n\\n            return memo[(i, j)]\\n\\n        return recur(0, 0)\\n\\n\\n```"
    },
    {
        "slug": "count-good-numbers",
        "tags": "python3",
        "release_time": 1689780826,
        "code": "class Solution:\n    def countGoodNumbers(self, n: int) -> int:\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodNumbers(self, n: int) -> int:\\n        return (pow(5,(n + 1)//2,1000000007)*pow(4,n//2,1000000007))%1000000007\\n\\n```"
    },
    {
        "slug": "rearrange-words-in-a-sentence",
        "tags": "python3",
        "release_time": 1589688242,
        "code": "class Solution:\n    def arrangeWords(self, text: str) -> str:\n        return \" \".join(sorted(text.split(), key=len)).capitalize()",
        "content": "A few string operations chained together to get the job done. \\n\\n```\\nclass Solution:\\n    def arrangeWords(self, text: str) -> str:\\n        return \" \".join(sorted(text.split(), key=len)).capitalize()\\n```"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "tags": "python3",
        "release_time": 1673811505,
        "code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n        M, N = range(m), range(n)\n\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n        def dfs(x: int,y: int)->None:\n            while not seen(x,y):\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\n                queue.append((x,y))\n                x,y = x+dx, y+dy\n            return\n\n        dfs(0, 0)\n\n        while queue:\n            if (m-1, n-1) in queue: return cost\n            cost += 1\n            q = len(queue)\n\n            for _ in range(q):\n                x, y = queue.popleft()\n                for dx,dy in dir[1:]:\n                    dfs(x+dx, y+dy)",
        "content": "We re-use grid to keep track of `seen`.\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n\\n        m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\\n        M, N = range(m), range(n)\\n\\n        seen = lambda x,y : not x in M or y not in N or not grid[x][y]\\n        dir = ((),(0,1), (0,-1), (1,0), (-1,0))\\n\\n        def dfs(x: int,y: int)->None:\\n            while not seen(x,y):\\n                (dx,dy), grid[x][y] = dir[grid[x][y]], None\\n                queue.append((x,y))\\n                x,y = x+dx, y+dy\\n            return\\n\\n        dfs(0, 0)\\n\\n        while queue:\\n            if (m-1, n-1) in queue: return cost\\n            cost += 1\\n            q = len(queue)\\n\\n            for _ in range(q):\\n                x, y = queue.popleft()\\n                for dx,dy in dir[1:]:\\n                    dfs(x+dx, y+dy)\\n```\\n[https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/submissions/878791604/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*MN*) and space complexity is worstcase\\n *O*(*MN*)."
    },
    {
        "slug": "design-hashmap",
        "tags": "python3",
        "release_time": 1684521147,
        "code": "class MyHashMap:\n\n    def __init__(self):\n        self.h = {}\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.h:\n            self.h[key] = value\n        else:\n            self.h[key] = value\n\n    def get(self, key: int) -> int:\n        if key not in self.h:\n            return -1\n        else:\n            return self.h[key]\n\n    def remove(self, key: int) -> None:\n        if key in self.h:\n            del self.h[key]\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyHashMap:\\n\\n    def __init__(self):\\n        self.h = {}\\n\\n    def put(self, key: int, value: int) -> None:\\n        if key in self.h:\\n            self.h[key] = value\\n        else:\\n            self.h[key] = value\\n\\n    def get(self, key: int) -> int:\\n        if key not in self.h:\\n            return -1\\n        else:\\n            return self.h[key]\\n\\n    def remove(self, key: int) -> None:\\n        if key in self.h:\\n            del self.h[key]\\n\\n# Your MyHashMap object will be instantiated and called as such:\\n# obj = MyHashMap()\\n# obj.put(key,value)\\n# param_2 = obj.get(key)\\n# obj.remove(key)\\n```"
    },
    {
        "slug": "maximum-xor-with-an-element-from-array",
        "tags": "python3",
        "release_time": 1609048622,
        "code": "class Solution:\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\n        nums.sort()\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\n        ans = [-1]*len(queries)\n        \n        trie = {}\n        k = 0\n        for m, x, i in queries: \n            while k < len(nums) and nums[k] <= m: \n                node = trie\n                val = bin(nums[k])[2:].zfill(32)\n                for c in val: node = node.setdefault(int(c), {})\n                node[\"#\"] = nums[k]\n                k += 1\n            if trie: \n                node = trie\n                val = bin(x)[2:].zfill(32)\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\n                ans[i] = x ^ node[\"#\"]\n        return ans",
        "content": "**Algo**\\nThis problem is similar to [421. Maximum XOR of Two Numbers in an Array](https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/) which can be solved efficiently via a trie. \\n\\n**Implementation** (100%)\\n```\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        ans = [-1]*len(queries)\\n        \\n        trie = {}\\n        k = 0\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                node = trie\\n                val = bin(nums[k])[2:].zfill(32)\\n                for c in val: node = node.setdefault(int(c), {})\\n                node[\"#\"] = nums[k]\\n                k += 1\\n            if trie: \\n                node = trie\\n                val = bin(x)[2:].zfill(32)\\n                for c in val: node = node.get(1-int(c)) or node.get(int(c))\\n                ans[i] = x ^ node[\"#\"]\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\nEdited on 12/27/2020\\nAdding a refactored version below for clarity \\n```\\nclass Trie: \\n    def __init__(self):\\n        self.root = {}\\n        \\n    def __bool__(self):\\n        return bool(self.root)\\n    \\n    def insert(self, num):\\n        node = self.root \\n        for x in bin(num)[2:].zfill(32): \\n            node = node.setdefault(int(x), {})\\n        node[\"#\"] = num\\n    \\n    def query(self, num): \\n        node = self.root\\n        for x in bin(num)[2:].zfill(32):\\n            node = node.get(1 - int(x)) or node.get(int(x))\\n        return num ^ node[\"#\"]\\n\\n\\nclass Solution:\\n    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        nums.sort()\\n        queries = sorted((m, x, i) for i, (x, m) in enumerate(queries))\\n        \\n        ans = [-1]*len(queries)\\n        k = 0\\n        trie = Trie()\\n        for m, x, i in queries: \\n            while k < len(nums) and nums[k] <= m: \\n                trie.insert(nums[k])\\n                k += 1\\n            if trie: ans[i] = trie.query(x)\\n        return ans \\n```"
    },
    {
        "slug": "number-of-good-leaf-nodes-pairs",
        "tags": "python3",
        "release_time": 1595737230,
        "code": "class Solution:\n    def countPairs(self, root: TreeNode, distance: int) -> int:\n        graph = collections.defaultdict(list)\n        \n        def dfs(node, par = None):\n            if node:\n                graph[node].append(par)\n                graph[par].append(node)\n                dfs(node.left, node)\n                dfs(node.right, node)\n\n        dfs(root)\n        \n        leaves = []\n        for node in graph.keys():\n            if node and not node.left and not node.right:\n                leaves.append(node)\n        \n        count = 0\n        \n        for leaf in leaves:\n            queue = [(leaf,0)]\n            seen = set(queue)\n            while queue:\n                node,length = queue.pop(0)\n                if length>distance:\n                    break\n                if node:\n                    for nei in graph[node]:\n                        if nei not in seen:\n                            seen.add(nei)\n                            queue.append((nei,length+1))\n                    if node!=leaf and not node.left and not node.right and length<=distance:\n                        count+=1\n                    \n        return count//2",
        "content": "```\\nclass Solution:\\n    def countPairs(self, root: TreeNode, distance: int) -> int:\\n        graph = collections.defaultdict(list)\\n        \\n        def dfs(node, par = None):\\n            if node:\\n                graph[node].append(par)\\n                graph[par].append(node)\\n                dfs(node.left, node)\\n                dfs(node.right, node)\\n\\n        dfs(root)\\n        \\n        leaves = []\\n        for node in graph.keys():\\n            if node and not node.left and not node.right:\\n                leaves.append(node)\\n        \\n        count = 0\\n        \\n        for leaf in leaves:\\n            queue = [(leaf,0)]\\n            seen = set(queue)\\n            while queue:\\n                node,length = queue.pop(0)\\n                if length>distance:\\n                    break\\n                if node:\\n                    for nei in graph[node]:\\n                        if nei not in seen:\\n                            seen.add(nei)\\n                            queue.append((nei,length+1))\\n                    if node!=leaf and not node.left and not node.right and length<=distance:\\n                        count+=1\\n                    \\n        return count//2\\n"
    },
    {
        "slug": "special-array-with-x-elements-greater-than-or-equal-x",
        "tags": "python3",
        "release_time": 1673436871,
        "code": "class Solution:\n    def specialArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        l, r = 0, n\n        while(l<=r):\n            mid = (l+r)//2\n            count = 0 \n            for i in nums:\n                if(i>=mid):\n                    count +=1\n\n            if (count == mid): return mid\n            elif count > mid:\n                l = mid + 1\n            else : \n                r = mid - 1\n\n        return -1",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def specialArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        l, r = 0, n\\n        while(l<=r):\\n            mid = (l+r)//2\\n            count = 0 \\n            for i in nums:\\n                if(i>=mid):\\n                    count +=1\\n\\n            if (count == mid): return mid\\n            elif count > mid:\\n                l = mid + 1\\n            else : \\n                r = mid - 1\\n\\n        return -1            \\n\\n\\n\\n\\n```"
    },
    {
        "slug": "combination-sum-ii",
        "tags": "python3",
        "release_time": 1683093894,
        "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ret = []\n        Len = len(candidates)\n        C = sorted(candidates)\n        \n        def rec(List,ind):\n            s = sum(List)\n            if s == target and List not in ret: \n                ret.append(List)\n            elif s < target:\n                for i in range(ind,Len): \n                    if i > ind and C[i] == C[i-1]:  \n                        continue\n                    # if s + sum(C[i:]) < target:  \n                    #     break\n                    rec(List+[C[i]],i+1)\n        \n        rec([],0)\n        return ret",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        ret = []\\n        Len = len(candidates)\\n        C = sorted(candidates)\\n        \\n        def rec(List,ind):\\n            s = sum(List)\\n            if s == target and List not in ret: \\n                ret.append(List)\\n            elif s < target:\\n                for i in range(ind,Len): \\n                    if i > ind and C[i] == C[i-1]:  \\n                        continue\\n                    # if s + sum(C[i:]) < target:  \\n                    #     break\\n                    rec(List+[C[i]],i+1)\\n        \\n        rec([],0)\\n        return ret\\n                \\n\\n```"
    },
    {
        "slug": "count-words-obtained-after-adding-a-letter",
        "tags": "python3",
        "release_time": 1641700880,
        "code": "class Solution:\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\n        seen = set()\n        for word in startWords: \n            m = 0\n            for ch in word: m ^= 1 << ord(ch)-97\n            seen.add(m)\n            \n        ans = 0 \n        for word in targetWords: \n            m = 0 \n            for ch in word: m ^= 1 << ord(ch)-97\n            for ch in word: \n                if m ^ (1 << ord(ch)-97) in seen: \n                    ans += 1\n                    break \n        return ans",
        "content": "Please checkout this [commit](https://github.com/gaosanyong/leetcode/commit/36536bdcdd42d372f17893d27ffbe283d970e24f) for solutions of weekly 275. \\n\\n```\\nclass Solution:\\n    def wordCount(self, startWords: List[str], targetWords: List[str]) -> int:\\n        seen = set()\\n        for word in startWords: \\n            m = 0\\n            for ch in word: m ^= 1 << ord(ch)-97\\n            seen.add(m)\\n            \\n        ans = 0 \\n        for word in targetWords: \\n            m = 0 \\n            for ch in word: m ^= 1 << ord(ch)-97\\n            for ch in word: \\n                if m ^ (1 << ord(ch)-97) in seen: \\n                    ans += 1\\n                    break \\n        return ans \\n```"
    },
    {
        "slug": "delete-operation-for-two-strings",
        "tags": "python3",
        "release_time": 1667237998,
        "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m=len(word1)\n        n=len(word2)\n        dp=[]\n        for i in range (m+1):\n            dp.append([0]*(n+1))\n        for i in range (m+1):\n            dp[i][0]=i\n        for i in range (n+1):\n            dp[0][i]=i\n        for i in range (1,m+1):\n            for j in range (1,n+1):\n                if word1[i-1]==word2[j-1]:\n                    dp[i][j]=dp[i-1][j-1]\n                else:\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\n        return dp[-1][-1]",
        "content": "```\\nclass Solution:\\n    def minDistance(self, word1: str, word2: str) -> int:\\n        m=len(word1)\\n        n=len(word2)\\n        dp=[]\\n        for i in range (m+1):\\n            dp.append([0]*(n+1))\\n        for i in range (m+1):\\n            dp[i][0]=i\\n        for i in range (n+1):\\n            dp[0][i]=i\\n        for i in range (1,m+1):\\n            for j in range (1,n+1):\\n                if word1[i-1]==word2[j-1]:\\n                    dp[i][j]=dp[i-1][j-1]\\n                else:\\n                    dp[i][j]=min(dp[i][j-1],dp[i-1][j])+1\\n        return dp[-1][-1]\\n        \\n```"
    },
    {
        "slug": "find-the-string-with-lcp",
        "tags": "python3",
        "release_time": 1676779600,
        "code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        ans = []\n        for i in range(n): \n            tabu = set()\n            for j in range(i): \n                if lcp[i][j]: \n                    ans.append(ans[j])\n                    break\n                else: tabu.add(ans[j])\n            else: \n                for ch in ascii_lowercase: \n                    if ch not in tabu: \n                        ans.append(ch)\n                        break\n                else: return \"\"\n        dp = [[0]*n for _ in range(n)]\n        for i in range(n-1, -1, -1): \n            for j in range(n-1, -1, -1): \n                if ans[i] == ans[j]: \n                    if i == n-1 or j == n-1: dp[i][j] = 1\n                    else: dp[i][j] = 1 + dp[i+1][j+1]\n                if dp[i][j] != lcp[i][j]: return \"\"\n        return \"\".join(ans)",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/485c537c6fa9056ce656959ea352d2a68cef473f) for solutions of weekly 333. \\n\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        n = len(lcp)\\n        ans = []\\n        for i in range(n): \\n            tabu = set()\\n            for j in range(i): \\n                if lcp[i][j]: \\n                    ans.append(ans[j])\\n                    break\\n                else: tabu.add(ans[j])\\n            else: \\n                for ch in ascii_lowercase: \\n                    if ch not in tabu: \\n                        ans.append(ch)\\n                        break\\n                else: return \"\"\\n        dp = [[0]*n for _ in range(n)]\\n        for i in range(n-1, -1, -1): \\n            for j in range(n-1, -1, -1): \\n                if ans[i] == ans[j]: \\n                    if i == n-1 or j == n-1: dp[i][j] = 1\\n                    else: dp[i][j] = 1 + dp[i+1][j+1]\\n                if dp[i][j] != lcp[i][j]: return \"\"\\n        return \"\".join(ans)\\n```"
    },
    {
        "slug": "climbing-stairs",
        "tags": "python3",
        "release_time": 1687792877,
        "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        l = [1] * n\n        ret = 0\n\n        def f(n):\n            if n == 0:\n                return 1\n            r = 1\n            for i in range(1, 1+n):\n                r*= i\n            return r\n\n        def peerms(l):\n            one = l.count(1)\n            two = l.count(2)\n            return f(one+two)/(f(one)*f(two))\n\n        while l.count(1) > 1:\n            ret += peerms(l)\n            l.pop()\n            l.pop()\n            l.insert(0, 2)\n\n        ret += 1\n        if l.count(1) == 1:\n            ret += l.count(2)\n        \n        return int(ret)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach valid way of climbing n stairs can  be thought of as solution to\\nx1 +  x2 + ... xr = n \\nwhere xr = 1 or 2 only\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe represent the values of x1 x2 ... xr in a list \\nSince order of single or double step dosent matter, for a particular solution we consider all permutations of varaables\\n eg: 2 + 1 + 1  = 4\\nwe consider all 3 possible ways for 2,1,1 set.\\nthe formula to calculate permutation of p alike and q alike objects is (p+q)!/p!q!\\n\\nfirst we consider all xr = 1\\nthen we subsequently remove two 1s and add one 2.\\nloop this until number of 1s in list become either 0 or 1 \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def climbStairs(self, n: int) -> int:\\n        l = [1] * n\\n        ret = 0\\n\\n        def f(n):\\n            if n == 0:\\n                return 1\\n            r = 1\\n            for i in range(1, 1+n):\\n                r*= i\\n            return r\\n\\n        def peerms(l):\\n            one = l.count(1)\\n            two = l.count(2)\\n            return f(one+two)/(f(one)*f(two))\\n\\n        while l.count(1) > 1:\\n            ret += peerms(l)\\n            l.pop()\\n            l.pop()\\n            l.insert(0, 2)\\n\\n        ret += 1\\n        if l.count(1) == 1:\\n            ret += l.count(2)\\n        \\n        return int(ret)\\n    \\n\\n\\n```"
    },
    {
        "slug": "maximum-strength-of-a-group",
        "tags": "python3",
        "release_time": 1685204639,
        "code": "class Solution:\n    def maxStrength(self, nums: List[int]) -> int:\n        max_memo, min_memo = nums[0], nums[0]\n        for num in nums[1:]:\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\n        return max_memo",
        "content": "# Approach\\nKeep track of minimum and maximum combinations.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStrength(self, nums: List[int]) -> int:\\n        max_memo, min_memo = nums[0], nums[0]\\n        for num in nums[1:]:\\n            max_memo, min_memo = max(max_memo, num, num*max_memo, num*min_memo), min(min_memo, num, num*min_memo, num*max_memo)\\n        return max_memo\\n```"
    },
    {
        "slug": "count-anagrams",
        "tags": "python3",
        "release_time": 1675229602,
        "code": "mod = 10**9+7\n\nclass Solution:\n    def countAnagrams(self, s: str) -> int:\n\n        l = s.split()\n        ans = 1\n\n        for i in l:\n            d = {}\n        # counting frequencies of word i in dictionary d\n            for j in i:\n                if(d.get(j)):\n                    d[j] += 1\n                else:\n                    d[j] = 1  \n            \n            duplicates = 1\n            for j in d.values():\n                duplicates *= math.factorial(j)\n            curr = math.factorial(len(i))//duplicates\n\n            ans *= curr\n            ans = ans%mod\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is very simple. Total count of anagrams for each word is\\n(factorial of length of word) divided by factorial of duplicates.\\n\\nEg : aabbc -  5!/(2! * 2!)\\n\\n# Code\\n```\\nmod = 10**9+7\\n\\nclass Solution:\\n    def countAnagrams(self, s: str) -> int:\\n\\n        l = s.split()\\n        ans = 1\\n\\n        for i in l:\\n            d = {}\\n        # counting frequencies of word i in dictionary d\\n            for j in i:\\n                if(d.get(j)):\\n                    d[j] += 1\\n                else:\\n                    d[j] = 1  \\n            \\n            duplicates = 1\\n            for j in d.values():\\n                duplicates *= math.factorial(j)\\n            curr = math.factorial(len(i))//duplicates\\n\\n            ans *= curr\\n            ans = ans%mod\\n\\n        return ans        \\n        \\n        \\n```"
    },
    {
        "slug": "intersection-of-two-arrays",
        "tags": "python3",
        "release_time": 1678963417,
        "code": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        return set(nums1).intersection(nums2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        return set(nums1).intersection(nums2)\\n```"
    },
    {
        "slug": "neighboring-bitwise-xor",
        "tags": "python3",
        "release_time": 1684130489,
        "code": "class Solution:\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\n        b = True\n        for n in derived:\n            b = not b if n else b\n        return b",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start with an arbitary original[0] and iteratively calculate original[n - 1] from the formula derived[i] = original[i] \\u2295 original[i + 1].\\nThe only thing we need to check is if derived[n - 1] = original[n - 1] \\u2295 original[0]. Since we\\'ve fixed original[0] = 1, we can write derived[n - 1] = original[n - 1] \\u2295 1. The function is true when derived[n - 1] is NOT original[n - 1], or we can say the array is valid if derived[n - 1] \\u2295 original[n - 1] is true. \\n\\n### Example 1:\\n**Input:** derived = [1,1,0]\\n**Output:** true\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nderived[1] = 1 &rarr; original[2] is NOT original[1] &rarr; original[2] = 1\\nFinally we need to check if derived[2] \\u2295 original[2] is true &rarr; 0 \\u2295 1, which is true!\\n\\n### Example 3:\\n**Input:** derived = [1,0]\\n**Output:** false\\n**Explanation:**\\nLet original[0] = 1\\nderived[0] = 1 &rarr; original[1] is NOT original[0] &rarr; original[1] = 0\\nFinally we need to check if derived[1] \\u2295 original[1] is true &rarr; 0 \\u2295 0, which is false!\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def doesValidArrayExist(self, derived: List[int]) -> bool:\\n        b = True\\n        for n in derived:\\n            b = not b if n else b\\n        return b\\n```"
    },
    {
        "slug": "palindrome-pairs",
        "tags": "python3",
        "release_time": 1663377683,
        "code": "class Solution:\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\n        backward, res = {}, []\n        for i, word in enumerate(words):\n            backward[word[::-1]] = i\n\n        for i, word in enumerate(words):\n            \n            if word in backward and backward[word] != i:\n                res.append([i, backward[word]])\n                \n            if word != \"\" and \"\" in backward and word == word[::-1]:\n                res.append([i, backward[\"\"]])\n                res.append([backward[\"\"], i])\n                \n            for j in range(len(word)):\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\n                    res.append([backward[word[j:]], i])\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\n                    res.append([i, backward[word[:j]]])\n                    \n        return res",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def palindromePairs(self, words: List[str]) -> List[List[int]]:\\n        backward, res = {}, []\\n        for i, word in enumerate(words):\\n            backward[word[::-1]] = i\\n\\n        for i, word in enumerate(words):\\n            \\n            if word in backward and backward[word] != i:\\n                res.append([i, backward[word]])\\n                \\n            if word != \"\" and \"\" in backward and word == word[::-1]:\\n                res.append([i, backward[\"\"]])\\n                res.append([backward[\"\"], i])\\n                \\n            for j in range(len(word)):\\n                if word[j:] in backward and word[:j] == word[j-1::-1]:\\n                    res.append([backward[word[j:]], i])\\n                if word[:j] in backward and word[j:] == word[:j-1:-1]:\\n                    res.append([i, backward[word[:j]]])\\n                    \\n        return res"
    },
    {
        "slug": "ugly-number-iii",
        "tags": "python3",
        "release_time": 1594093779,
        "code": "class Solution:\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n        # inclusion-exclusion principle\n        ab = a*b//gcd(a, b)\n        bc = b*c//gcd(b, c)\n        ca = c*a//gcd(c, a)\n        abc = ab*c//gcd(ab, c)\n        \n        lo, hi = 1, n*min(a, b, c)\n        while lo < hi: \n            mid = lo + hi >> 1\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\n            else: hi = mid \n        return lo",
        "content": "The term \"ugly number\" seems to reflect a poorly-defined concept. Upon Googling it, I can only find it in a few places such as LC, GFG, etc. Even in the few posts on LC, the concept varies. For example, in [263. Ugly Number](https://leetcode.com/problems/ugly-number/), an ugly number is a positive integer whose only factors are 2, 3 and 5, but 1 is treated as an ugly number. This definition is consistent with that of [264. Ugly Number II](https://leetcode.com/problems/ugly-number-ii/). But in [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/), ugly number becomes positive integers divisible by given factors (let\\'s still use 2, 3, 5 unless stated otherwise), and 1 is not considered ugly any more. \\n\\nLet\\'s refer to the definition in 263 and 264 \"Def 1\" and the definition in 1201 \"Def 2\". Under Def 1, the first few ugly numbers are 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, ... while under Def 2 the first few ugly numbers are 2, 3, 4, 5, 6, 8, 9, 10, 12, 14, 15, ... . The similarity is obvious at first glance. But if you look deeper, a fundamental difference can be revealed. Namely, under Def 1, ugly number is self-generated, i.e. large ugly numbers are generated by multiplying factors with small ugly numbers. Because of this, ugly numbers become rarer as number becomes larger. However, under Def 2, ugly numbers are periodic. The pattern repeats when least common multiple is reached. \\n\\nTo reflect the \"self-generating\" property of ugly number under Def 1, 263 and 264 can be solved using dynamic programming. For example, this [post](https://leetcode.com/problems/ugly-number/discuss/719320/Python3-4-line-concise) and this [post](https://leetcode.com/problems/ugly-number-ii/discuss/720034/Python3-7-line-dp) implement the solution using top-down approach. But 1201 needs to be solved in a completely different way. In the spirit of this difference, I think it is more confusing than helpful to put 1201 in the ugly number series. It is probably clearer if this is treated as a completely independent problem. \\n\\n```\\nclass Solution:\\n    def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\\n        # inclusion-exclusion principle\\n        ab = a*b//gcd(a, b)\\n        bc = b*c//gcd(b, c)\\n        ca = c*a//gcd(c, a)\\n        abc = ab*c//gcd(ab, c)\\n        \\n        lo, hi = 1, n*min(a, b, c)\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if mid//a + mid//b + mid//c - mid//ab - mid//bc - mid//ca + mid//abc < n: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```"
    },
    {
        "slug": "decode-the-slanted-ciphertext",
        "tags": "python3",
        "release_time": 1681219442,
        "code": "class Solution:\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\n        if rows == 1:\n            return encoded_text\n\n        N = len(encoded_text)\n        cols = N // rows\n        i, j, k = 0, 0, 0\n        original_text = []\n\n        while k < N:\n            original_text.append(encoded_text[k])\n            i += 1\n            if i == rows:\n                i = 0\n                j += 1\n            k = i*(cols + 1) + j\n\n        return ''.join(original_text).rstrip()",
        "content": "![Capture d\\u2019\\xE9cran (96).png](https://assets.leetcode.com/users/images/3e9f8a31-b0d3-4995-ae49-64d20c8c39d1_1681219407.2042663.png)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decodeCiphertext(self, encoded_text: str, rows: int) -> str:\\n        if rows == 1:\\n            return encoded_text\\n\\n        N = len(encoded_text)\\n        cols = N // rows\\n        i, j, k = 0, 0, 0\\n        original_text = []\\n\\n        while k < N:\\n            original_text.append(encoded_text[k])\\n            i += 1\\n            if i == rows:\\n                i = 0\\n                j += 1\\n            k = i*(cols + 1) + j\\n\\n        return \\'\\'.join(original_text).rstrip()\\n```"
    },
    {
        "slug": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
        "tags": "python3",
        "release_time": 1674972392,
        "code": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        cnt1=Counter(s)\n        cnt2=Counter(t)\n        sm=0\n        cnt=cnt1-cnt2+(cnt2-cnt1)\n        for i in cnt.values():\n            sm+=i\n        return sm",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```"
    },
    {
        "slug": "partition-string-into-substrings-with-values-at-most-k",
        "tags": "python3",
        "release_time": 1672545654,
        "code": "class Solution:\n    def minimumPartition(self, s: str, k: int) -> int:\n        curr, ans = 0, 1\n        for d in s:\n            if int(d) > k:\n                return -1\n            curr = 10 * curr + int(d)\n            if curr > k:\n                ans += 1\n                curr = int(d)\n        return ans",
        "content": "# Approach\\nWe scan all digits in `s` from left to right, and add 1 to `ans` whenever the current value of the segment exceeds `k`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumPartition(self, s: str, k: int) -> int:\\n        curr, ans = 0, 1\\n        for d in s:\\n            if int(d) > k:\\n                return -1\\n            curr = 10 * curr + int(d)\\n            if curr > k:\\n                ans += 1\\n                curr = int(d)\\n        return ans\\n```"
    },
    {
        "slug": "magic-squares-in-grid",
        "tags": "python3",
        "release_time": 1690032442,
        "code": "class Solution:\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\n        M, N = len(grid), len(grid[0])\n        res = 0\n\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\n\n\n        for i in range(M):\n            for j in range(N):\n                arr = []\n\n                for k in range(3):\n                    if k + i >= M:\n                        break\n                    arr.append(tuple(grid[i + k][j:j + 3]))\n                \n                arr.sort(key=lambda x: x[0])\n\n                if tuple(arr) in solution:\n                    res += 1\n                else:\n                    for row in arr:\n                        row = row[::-1]\n\n                    if tuple(arr) in solution:\n                        res += 1\n\n        \n        return res\n\n\n\n        '''\n        logic: find answer for 3 by 3 grid\n\n        4 3 8 \n        9 5 1\n        2 7 6\n\n\n        8 3 4\n        1 5 9 \n        2 7 6\n\n\n        have a solution key with all possible answers\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\n\n\n        '''",
        "content": "```\\nclass Solution:\\n    def numMagicSquaresInside(self, grid: List[List[int]]) -> int:\\n        M, N = len(grid), len(grid[0])\\n        res = 0\\n\\n        solution = [((2, 7, 6), (4, 3, 8), (9, 5, 1)), ((3, 5, 7), (4, 9, 2), (8, 1, 6)), ((1, 5, 9), (6, 7, 2), (8, 3, 4)), ((1, 8, 6), (5, 3, 7), (9, 4, 2)), ((2, 9, 4), (6, 1, 8), (7, 5, 3))]\\n\\n\\n        for i in range(M):\\n            for j in range(N):\\n                arr = []\\n\\n                for k in range(3):\\n                    if k + i >= M:\\n                        break\\n                    arr.append(tuple(grid[i + k][j:j + 3]))\\n                \\n                arr.sort(key=lambda x: x[0])\\n\\n                if tuple(arr) in solution:\\n                    res += 1\\n                else:\\n                    for row in arr:\\n                        row = row[::-1]\\n\\n                    if tuple(arr) in solution:\\n                        res += 1\\n\\n        \\n        return res\\n\\n\\n\\n        \\'\\'\\'\\n        logic: find answer for 3 by 3 grid\\n\\n        4 3 8 \\n        9 5 1\\n        2 7 6\\n\\n\\n        8 3 4\\n        1 5 9 \\n        2 7 6\\n\\n\\n        have a solution key with all possible answers\\n        iterate through matrix if from top left can build 3 x 3 chekc if in solution set if it is add one ot res\\n\\n\\n        \\'\\'\\'\\n```"
    },
    {
        "slug": "minesweeper",
        "tags": "python3",
        "release_time": 1670538654,
        "code": "class Solution:\n    def updateBoard(self, board, click):\n\n        if board[click[0]][click[1]] == 'M':                # <-- handle case that\n            board[click[0]][click[1]] = 'X' ; return board  #     click is mined\n\n        adjacent = lambda x,y : [(x+dx,y+dy) for dx in range(-1,2) for dy in range(-1,2) \n                if (dx or dy) and 0 <= x+dx < len(board) and 0 <= y+dy < len(board[0])]\n        \n        def dfs(x: int,y: int)-> None:                      # \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013start function\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\n            adj = adjacent(x,y)\n                                                            \n            mines = sum(board[X][Y] == 'M' for X,Y in adj)  # <-- count up adjacent mines \n                                                            #     to board[x][y]\n            if  mines:\n                board[x][y] = str(mines)                    # <-- If mines, write count...\n\n            else:    \n                board[x][y] = 'B'                           # <-- ... if not, mark it \"revealed\" \n\n                for X,Y in adj:\n                    if board[X][Y] == 'E':                  # <-- explore each adjacent cell\n                        dfs(X,Y)                            #     if unexplored\n            return                                          #\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013end function\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\n                                                            \n        dfs(*click)                                         # <-- start at click\n\n        return board                                        # <-- return updated board",
        "content": "```\\nclass Solution:\\n    def updateBoard(self, board, click):\\n\\n        if board[click[0]][click[1]] == \\'M\\':                # <-- handle case that\\n            board[click[0]][click[1]] = \\'X\\' ; return board  #     click is mined\\n\\n        adjacent = lambda x,y : [(x+dx,y+dy) for dx in range(-1,2) for dy in range(-1,2) \\n                if (dx or dy) and 0 <= x+dx < len(board) and 0 <= y+dy < len(board[0])]\\n        \\n        def dfs(x: int,y: int)-> None:                      # \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013start function\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            adj = adjacent(x,y)\\n                                                            \\n            mines = sum(board[X][Y] == \\'M\\' for X,Y in adj)  # <-- count up adjacent mines \\n                                                            #     to board[x][y]\\n            if  mines:\\n                board[x][y] = str(mines)                    # <-- If mines, write count...\\n\\n            else:    \\n                board[x][y] = \\'B\\'                           # <-- ... if not, mark it \"revealed\" \\n\\n                for X,Y in adj:\\n                    if board[X][Y] == \\'E\\':                  # <-- explore each adjacent cell\\n                        dfs(X,Y)                            #     if unexplored\\n            return                                          #\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013end function\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n                                                            \\n        dfs(*click)                                         # <-- start at click\\n\\n        return board                                        # <-- return updated board\\n```\\n[https://leetcode.com/problems/minesweeper/submissions/856849255/](http://)\\n\\n\\n\\nI\\'m not sure time and space on this one. Thoughts?"
    },
    {
        "slug": "fizz-buzz",
        "tags": "python3",
        "release_time": 1673526978,
        "code": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        l = []\n        for i in range(1,n+1):\n            if i%3==0 and i%5==0:\n                l.append(\"FizzBuzz\")\n\n            elif i%3!=0 and i%5!=0:\n                l.append(str(i))\n            elif i%3==0:\n                l.append(\"Fizz\")\n            elif i%5==0:\n                l.append(\"Buzz\")\n            \n        return l",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def fizzBuzz(self, n: int) -> List[str]:\\n        l = []\\n        for i in range(1,n+1):\\n            if i%3==0 and i%5==0:\\n                l.append(\"FizzBuzz\")\\n\\n            elif i%3!=0 and i%5!=0:\\n                l.append(str(i))\\n            elif i%3==0:\\n                l.append(\"Fizz\")\\n            elif i%5==0:\\n                l.append(\"Buzz\")\\n            \\n        return l\\n\\n```"
    },
    {
        "slug": "minimum-time-to-collect-all-apples-in-a-tree",
        "tags": "python3",
        "release_time": 1673404337,
        "code": "class Solution:\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\n                          \n        seen, g = set(), defaultdict(list)\n\n        for a,b in edges: \n            g[a].append((b))  ;  g[b].append((a))\n           \n        def dfs(node: int)->int:\n            seen.add(node)    \n  \n            ans = sum(dfs(n) for n in g[node] if n not in seen) \n \n            if not ans and not hasApple[node]: return 0\n\n            return ans+2           \n\n        return max (0,dfs(0)-2)",
        "content": "Here\\'s the plan:\\n- We build the graph`g`and initialize the set`seen`to track which nodes have been visited.\\n- We start at`node = 0`, as directed, and traverse the graph recursively. We return when we hit a dead-end node, that is, a node`n`for which all nodes in g[n] already have been visited.\\n- It\\'s recursion; you get the idea. \\n```\\nclass Solution:\\n    def minTime(self, n: int, edges: list[list[int]], hasApple: list[bool]) -> int:\\n                          \\n        seen, g = set(), defaultdict(list)\\n\\n        for a,b in edges: \\n            g[a].append((b))  ;  g[b].append((a))\\n           \\n        def dfs(node: int)->int:\\n            seen.add(node)    \\n  \\n            ans = sum(dfs(n) for n in g[node] if n not in seen) \\n \\n            if not ans and not hasApple[node]: return 0\\n\\n            return ans+2           \\n\\n        return max (0,dfs(0)-2)\\n```\\n[https://leetcode.com/problems/minimum-time-to-collect-all-apples-in-a-tree/submissions/875780976/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*)."
    },
    {
        "slug": "online-election",
        "tags": "python3",
        "release_time": 1683431208,
        "code": "class TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n        self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]",
        "content": "# Code\\n```\\nclass TopVotedCandidate:\\n\\n    def __init__(self, persons: List[int], times: List[int]):\\n        self.persons = []\\n        self.times = []\\n        self.dic = collections.defaultdict(int)\\n        self.m = 0\\n        self.idx = -1\\n\\n        for i in range(len(times)):\\n            self.times.append(times[i])\\n            self.dic[persons[i]] += 1\\n            if self.dic[persons[i]] >= self.m:\\n                self.persons.append(persons[i])\\n                self.m = self.dic[persons[i]]\\n            else:\\n                self.persons.append(self.persons[-1])\\n\\n    def q(self, t: int) -> int:\\n        idx = bisect.bisect_right(self.times,t)\\n        return self.persons[idx-1]\\n\\n```"
    },
    {
        "slug": "smallest-string-starting-from-leaf",
        "tags": "python3",
        "release_time": 1672085022,
        "code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n\n        #to check if a node is leaf node, return true if it is\n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        # recursive function to traverse\n        def traversar(path,node):\n            if (not node): return\n            \n            #convert value to char and append to current path\n            path+=chr(ord('a')+node.val)\n\n            #if it's lexicographically smaller than current path,   \n            # then replace result with current path.reverse\n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n                return\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
        "content": "\\n# Approach\\n- We traverse the the tree and pass path to the node till now as parameter of recursive function\\n- When we encounter a leaf node - compare it with lowestPath\\n- if we encounter null we end recursive branch\\n- for normal node we add value to path and pass on/ call recursive function for it\\'s left and right child\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - time to traverse each node\\n(assuming path to compare paths in negligible othervise)\\n\\n- Space complexity:\\n$$O(1)$$  - not saving anything other one string\\n\\n# Code\\n```\\n\\nclass Solution:\\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\\n\\n        #to check if a node is leaf node, return true if it is\\n        def isLeaf(node):\\n            if(node):\\n                return ((not node.left) and (not node.right))\\n            return False\\n        \\n        # recursive function to traverse\\n        def traversar(path,node):\\n            if (not node): return\\n            \\n            #convert value to char and append to current path\\n            path+=chr(ord(\\'a\\')+node.val)\\n\\n            #if it\\'s lexicographically smaller than current path,   \\n            # then replace result with current path.reverse\\n            if(isLeaf(node) and path[::-1]<self.result):\\n                self.result=path[::-1]\\n                return\\n            \\n            traversar(path,node.left)\\n            traversar(path,node.right)\\n\\n        traversar(\"\",root)\\n\\n        return self.result\\n            \\n\\n\\n\\n```"
    },
    {
        "slug": "scramble-string",
        "tags": "python3",
        "release_time": 1680718887,
        "code": "class Solution:\n    @cache\n    def isScramble(self, s1: str, s2: str) -> bool:\n        if Counter(s1) != Counter(s2):\n            return False\n        if s1 == s2:\n            return True\n        for k in range(1, len(s1)):\n            if (\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\n            ) or (\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\n            ): return True\n        return False",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def isScramble(self, s1: str, s2: str) -> bool:\\n        if Counter(s1) != Counter(s2):\\n            return False\\n        if s1 == s2:\\n            return True\\n        for k in range(1, len(s1)):\\n            if (\\n                self.isScramble(s1[k:], s2[k:]) and self.isScramble(s1[:k], s2[:k])\\n            ) or (\\n                self.isScramble(s1[k:], s2[:-k]) and self.isScramble(s1[:k], s2[-k:])\\n            ): return True\\n        return False\\n        \\n```"
    },
    {
        "slug": "find-the-array-concatenation-value",
        "tags": "python3",
        "release_time": 1678875810,
        "code": "class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i=0\n        c=0\n        j=len(nums)-1\n        while(i<=j):\n            if(i==j):\n                c=c+nums[i]\n                break\n            s=str(nums[i])+str(nums[j])\n            c=c+int(s)\n            i=i+1\n            j=j-1\n        return c",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\\n        i=0\\n        c=0\\n        j=len(nums)-1\\n        while(i<=j):\\n            if(i==j):\\n                c=c+nums[i]\\n                break\\n            s=str(nums[i])+str(nums[j])\\n            c=c+int(s)\\n            i=i+1\\n            j=j-1\\n        return c\\n                \\n```"
    },
    {
        "slug": "design-front-middle-back-queue",
        "tags": "python3",
        "release_time": 1687808758,
        "code": "class FrontMiddleBackQueue:\n\n    def __init__(self):\n        self.queue=[]\n        \n\n    def pushFront(self, val: int) -> None:\n        self.queue.insert(0,val)\n        \n\n    def pushMiddle(self, val: int) -> None:\n        n=len(self.queue)\n        self.queue.insert(n//2,val)\n    def pushBack(self, val: int) -> None:\n        self.queue.append(val)\n\n    def popFront(self) -> int:\n        if len(self.queue)==0:\n            return -1    \n        return self.queue.pop(0)\n        \n\n    def popMiddle(self) -> int:\n        if len(self.queue)==0:\n            return -1\n        n=len(self.queue)\n        if n%2==0:\n            n=(n//2)-1\n        else:\n            n=int(n//2)\n        return self.queue.pop(n)\n        \n\n    def popBack(self) -> int:\n        if len(self.queue)==0:\n            return -1 \n        return self.queue.pop()\n        \n\n\n# Your FrontMiddleBackQueue object will be instantiated and called as such:\n# obj = FrontMiddleBackQueue()\n# obj.pushFront(val)\n# obj.pushMiddle(val)\n# obj.pushBack(val)\n# param_4 = obj.popFront()\n# param_5 = obj.popMiddle()\n# param_6 = obj.popBack()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/cec6492f-2ebe-45ff-9614-85e1aefa95af_1687808754.8704185.png)\\n\\n# Code\\n```\\nclass FrontMiddleBackQueue:\\n\\n    def __init__(self):\\n        self.queue=[]\\n        \\n\\n    def pushFront(self, val: int) -> None:\\n        self.queue.insert(0,val)\\n        \\n\\n    def pushMiddle(self, val: int) -> None:\\n        n=len(self.queue)\\n        self.queue.insert(n//2,val)\\n    def pushBack(self, val: int) -> None:\\n        self.queue.append(val)\\n\\n    def popFront(self) -> int:\\n        if len(self.queue)==0:\\n            return -1    \\n        return self.queue.pop(0)\\n        \\n\\n    def popMiddle(self) -> int:\\n        if len(self.queue)==0:\\n            return -1\\n        n=len(self.queue)\\n        if n%2==0:\\n            n=(n//2)-1\\n        else:\\n            n=int(n//2)\\n        return self.queue.pop(n)\\n        \\n\\n    def popBack(self) -> int:\\n        if len(self.queue)==0:\\n            return -1 \\n        return self.queue.pop()\\n        \\n\\n\\n# Your FrontMiddleBackQueue object will be instantiated and called as such:\\n# obj = FrontMiddleBackQueue()\\n# obj.pushFront(val)\\n# obj.pushMiddle(val)\\n# obj.pushBack(val)\\n# param_4 = obj.popFront()\\n# param_5 = obj.popMiddle()\\n# param_6 = obj.popBack()\\n```"
    },
    {
        "slug": "kth-largest-sum-in-a-binary-tree",
        "tags": "python3",
        "release_time": 1680295273,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        dq = collections.deque([root])\n        a = []\n        lvl = 1\n        while dq:\n            lvlsum = 0\n            for i in range(len(dq)):\n               n = dq.popleft()\n               lvlsum += n.val\n               if n.left: dq.append(n.left)\n               if n.right: dq.append(n.right)\n            a.append(lvlsum)\n            lvl += 1\n        a.sort(reverse=True)\n        return a[k-1] if len(a) >= k else -1",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\\n        dq = collections.deque([root])\\n        a = []\\n        lvl = 1\\n        while dq:\\n            lvlsum = 0\\n            for i in range(len(dq)):\\n               n = dq.popleft()\\n               lvlsum += n.val\\n               if n.left: dq.append(n.left)\\n               if n.right: dq.append(n.right)\\n            a.append(lvlsum)\\n            lvl += 1\\n        a.sort(reverse=True)\\n        return a[k-1] if len(a) >= k else -1\\n```"
    },
    {
        "slug": "minimum-obstacle-removal-to-reach-corner",
        "tags": "python3",
        "release_time": 1688233113,
        "code": "class Solution:\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[float('inf') for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            d, i, j = q.popleft()\n            if i == m - 1 and j == n - 1: return d\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if d + grid[ci][cj] < distance[ci][cj]:\n                        distance[ci][cj] = d + grid[ci][cj]\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\n                        else: q.appendleft((distance[ci][cj], ci, cj))\n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\nFind the shortest path with the weight is only 0 or 1 => 0-1 BFS\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\ncan refer 0-1 BFS [here](https://cp-algorithms.com/graph/01_bfs.html#algorithm)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumObstacles(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[float(\\'inf\\') for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            d, i, j = q.popleft()\\n            if i == m - 1 and j == n - 1: return d\\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if d + grid[ci][cj] < distance[ci][cj]:\\n                        distance[ci][cj] = d + grid[ci][cj]\\n                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))\\n                        else: q.appendleft((distance[ci][cj], ci, cj))\\n        return distance[m - 1][n - 1]\\n```"
    },
    {
        "slug": "number-complement",
        "tags": "python3",
        "release_time": 1682091742,
        "code": "class Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n                com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findComplement(self, num: int) -> int:\\n        com = \\'\\'\\n        while num > 0 :\\n            \\n            if num % 2 == 1:\\n                com += \\'0\\'\\n            else:\\n                com += \\'1\\'\\n            num = num // 2\\n        return int(com[::-1],2)\\n        \\n\\n```"
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "tags": "python3",
        "release_time": 1675402966,
        "code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        c=0\n        i=0\n        nums.sort()\n        while i<len(nums) and nums[i]==0:\n            i+=1\n        #iterate over the entire array till the last element equals to zero....\n        while nums[-1]!=0:\n            value=nums[i]\n            for x in range(i,len(nums)):\n                nums[x]=nums[x]-value\n                if(nums[x]==0):\n                    i+=1\n            #i+=1\n            print(nums)\n            c+=1\n        return c",
        "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is just a greedy approach as they said to pick an element which should be minimum ...\\nSort the input array and then decrement the corresponding value everytime in the array and then continue the process till it gets zero..\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        c=0\\n        i=0\\n        nums.sort()\\n        while i<len(nums) and nums[i]==0:\\n            i+=1\\n        #iterate over the entire array till the last element equals to zero....\\n        while nums[-1]!=0:\\n            value=nums[i]\\n            for x in range(i,len(nums)):\\n                nums[x]=nums[x]-value\\n                if(nums[x]==0):\\n                    i+=1\\n            #i+=1\\n            print(nums)\\n            c+=1\\n        return c\\n```"
    },
    {
        "slug": "linked-list-random-node",
        "tags": "python3",
        "release_time": 1678456111,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n\n    def __init__(self, head: Optional[ListNode]):\n        self.head=head\n\n    def getRandom(self) -> int:\n        count,output=0,0\n        current=self.head\n        while current:\n            count+=1\n            if random.randint(1,count)==1:  \n                output=current.val\n            current=current.next\n        return output\n#please upvote me it would encourage me alot",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n\\n    def __init__(self, head: Optional[ListNode]):\\n        self.head=head\\n\\n    def getRandom(self) -> int:\\n        count,output=0,0\\n        current=self.head\\n        while current:\\n            count+=1\\n            if random.randint(1,count)==1:  \\n                output=current.val\\n            current=current.next\\n        return output\\n#please upvote me it would encourage me alot\\n\\n```"
    },
    {
        "slug": "smallest-index-with-equal-value",
        "tags": "python3",
        "release_time": 1677840508,
        "code": "class Solution:\n    def smallestEqual(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if i%10 == nums[i]:\n                return i\n                break\n        return -1",
        "content": "![image.png](https://assets.leetcode.com/users/images/e2f89b95-ef02-4717-8c6f-8b4a6e2b1d2c_1677840452.4258904.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def smallestEqual(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if i%10 == nums[i]:\\n                return i\\n                break\\n        return -1\\n```\\n![image.png](https://assets.leetcode.com/users/images/d7d77fea-776f-40a6-8c7c-0cfd2a24c6ae_1677840466.5254948.png)\\n"
    },
    {
        "slug": "kth-distinct-string-in-an-array",
        "tags": "python3",
        "release_time": 1635609753,
        "code": "class Solution:\n    def kthDistinct(self, arr: List[str], k: int) -> str:\n        freq = Counter(arr)\n        for x in arr: \n            if freq[x] == 1: k -= 1\n            if k == 0: return x\n        return \"\"",
        "content": "\\n```\\nclass Solution:\\n    def kthDistinct(self, arr: List[str], k: int) -> str:\\n        freq = Counter(arr)\\n        for x in arr: \\n            if freq[x] == 1: k -= 1\\n            if k == 0: return x\\n        return \"\"\\n```"
    },
    {
        "slug": "construct-the-lexicographically-largest-valid-sequence",
        "tags": "python3",
        "release_time": 1682108757,
        "code": "class Solution:\n    def constructDistancedSequence(self, n: int) -> List[int]:\n\n        def backtrack(idx1 = 0): \n\n            if not unseen: return True\n\n            if ans[idx1]: return backtrack(idx1+1)\n\n            for num in reversed(range(1,n+1)):\n\n                idx2 = idx1 + num if num != 1 else idx1\n\n                if num in unseen and idx2 < n+n-1 and not ans[idx2]:\n                    ans[idx1] = ans[idx2] = num\n                    unseen.remove(num)\n\n                    if backtrack(idx1+1): return True\n                    ans[idx1] = ans[idx2] = 0\n                    unseen.add(num)\n\n            return False\n\n        ans, unseen = [0]*(n+n-1), set(range(1,n+1))\n\n        backtrack()\n\n        return ans",
        "content": "```\\nclass Solution:\\n    def constructDistancedSequence(self, n: int) -> List[int]:\\n\\n        def backtrack(idx1 = 0): \\n\\n            if not unseen: return True\\n\\n            if ans[idx1]: return backtrack(idx1+1)\\n\\n            for num in reversed(range(1,n+1)):\\n\\n                idx2 = idx1 + num if num != 1 else idx1\\n\\n                if num in unseen and idx2 < n+n-1 and not ans[idx2]:\\n                    ans[idx1] = ans[idx2] = num\\n                    unseen.remove(num)\\n\\n                    if backtrack(idx1+1): return True\\n                    ans[idx1] = ans[idx2] = 0\\n                    unseen.add(num)\\n\\n            return False\\n\\n        ans, unseen = [0]*(n+n-1), set(range(1,n+1))\\n\\n        backtrack()\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/construct-the-lexicographically-largest-valid-sequence/submissions/937592483/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N!*) (worst-case) and space complexity is *O*(*N*)."
    },
    {
        "slug": "minimum-sum-of-four-digit-number-after-splitting-digits",
        "tags": "python3",
        "release_time": 1691467333,
        "code": "class Solution:\n    def minimumSum(self, num: int) -> int:\n        arr = list(str(num))\n        arr.sort()\n        a = int(arr[0]+arr[2])+int(arr[1]+arr[3])\n        return a",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumSum(self, num: int) -> int:\\n        arr = list(str(num))\\n        arr.sort()\\n        a = int(arr[0]+arr[2])+int(arr[1]+arr[3])\\n        return a\\n```"
    },
    {
        "slug": "pascals-triangle-ii",
        "tags": "python3",
        "release_time": 1676870255,
        "code": "class Solution:\n    def getRow(self, rowIndex: int) -> List[int]:\n        new_list=[1,1]\n        old_list=[1]\n        if rowIndex==0:\n            return old_list\n        if rowIndex==1:\n            return new_list\n        for i in range(2,rowIndex+1):\n            old_list = new_list\n            new_list=[1]\n            for j in range(1,i):\n                new_list.append(old_list[j-1]+old_list[j])\n            new_list.append(1)\n        return new_list",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getRow(self, rowIndex: int) -> List[int]:\\n        new_list=[1,1]\\n        old_list=[1]\\n        if rowIndex==0:\\n            return old_list\\n        if rowIndex==1:\\n            return new_list\\n        for i in range(2,rowIndex+1):\\n            old_list = new_list\\n            new_list=[1]\\n            for j in range(1,i):\\n                new_list.append(old_list[j-1]+old_list[j])\\n            new_list.append(1)\\n        return new_list\\n```"
    },
    {
        "slug": "maximum-value-of-k-coins-from-piles",
        "tags": "python3",
        "release_time": 1681587445,
        "code": "class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        n = len(piles)\n\n        # Turn each pile to cummulative sum trimmed to k elements\n        for pi in range(n):\n            piles[pi] = list(accumulate(piles[pi][:k]))\n        \n        @cache\n        def helper(start_pile: int, hk: int):\n            if start_pile >= n or hk == 0:\n                return 0\n            # Consider we don't take anything from start_pile\n            ans = helper(start_pile + 1, hk)\n            for i, v in enumerate(piles[start_pile], start=1):\n                # Consider we take first i coins from start_pile\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\n                if i == hk:\n                    break\n            return ans\n        \n        return helper(0, k)",
        "content": "# Intuition\\nUse DP and prefix sum\\n\\n# Approach\\nFirst for each pile, build a prefix sum (aka cummulative sum) up to k elements (we can just trim/ignore if there is more).\\n\\nThen focus on the first pile.\\nWe can take first coin, or two, or ... k and then deal with smaller problem (one less pile and same or less coins to consider).\\n\\nSo the base cases are:\\n- we have considered all piles\\n- we have no more coins to take\\n\\nIn the meoized helper DP function, we take two parameters:\\n`start_pile` - index of the pile we focus on (and later deal only with piles with bigger index)\\n`hp` - the helper version of k, that is remaining coins we need to consider\\n\\nOn the helper function we looking for the maximum,\\nconsidering taking from the start_pile 0 up to hk coins and remaining coins from the next piles recursively.\\n\\nHaving such helper function, the answer will be found by `helper(start_pile=0, hk=k)`\\n\\nIf you find it helpful please up-vote. Thank you!\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n\\\\times k)$$ I think...\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        n = len(piles)\\n\\n        # Turn each pile to cummulative sum trimmed to k elements\\n        for pi in range(n):\\n            piles[pi] = list(accumulate(piles[pi][:k]))\\n        \\n        @cache\\n        def helper(start_pile: int, hk: int):\\n            if start_pile >= n or hk == 0:\\n                return 0\\n            # Consider we don\\'t take anything from start_pile\\n            ans = helper(start_pile + 1, hk)\\n            for i, v in enumerate(piles[start_pile], start=1):\\n                # Consider we take first i coins from start_pile\\n                ans = max(ans, v + helper(start_pile + 1, hk - i))\\n                if i == hk:\\n                    break\\n            return ans\\n        \\n        return helper(0, k)```"
    },
    {
        "slug": "jump-game-ii",
        "tags": "python3",
        "release_time": 1679374027,
        "code": "class Solution:\n    def jump(self, nums: List[int]) -> int:\n        #print(nums)\n        L=len(nums)\n        if L==1:\n            return 0\n        steps=[0]\n        for i in range(nums[0]):\n            steps.append(1)\n        for index in range(1,L):\n            len_steps=len(steps)\n            if len_steps >= nums[index]+index+1:\n                index += 1\n            elif len_steps < nums[index]+index+1:\n                for j in range(nums[index]+index-len_steps+1):\n                    #print(index-1,steps[index-1])\n                    steps.append(steps[index]+1)\n            #print(steps)\n        return steps[L-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def jump(self, nums: List[int]) -> int:\\n        #print(nums)\\n        L=len(nums)\\n        if L==1:\\n            return 0\\n        steps=[0]\\n        for i in range(nums[0]):\\n            steps.append(1)\\n        for index in range(1,L):\\n            len_steps=len(steps)\\n            if len_steps >= nums[index]+index+1:\\n                index += 1\\n            elif len_steps < nums[index]+index+1:\\n                for j in range(nums[index]+index-len_steps+1):\\n                    #print(index-1,steps[index-1])\\n                    steps.append(steps[index]+1)\\n            #print(steps)\\n        return steps[L-1]\\n\\n```"
    },
    {
        "slug": "all-possible-full-binary-trees",
        "tags": "python3",
        "release_time": 1690078946,
        "code": "from copy import deepcopy\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\n        ans = []\n        if not n % 2: # impossible to produce even num full tree\n            return ans\n        # combinatorial search with backtracking, at each step either set two children or set 0 children\n        def generate_trees(n, node, unprocessed):\n            if n == 0:\n                ans.append(deepcopy(head))\n                return\n            node.left = TreeNode()\n            node.right = TreeNode()\n            unprocessed.append(node.left)\n            unprocessed.append(node.right)\n            # go over every combination of dfs expansion based on unprocessed candidates\n            for ind, next_node in enumerate(unprocessed):\n                generate_trees(n - 2, next_node, unprocessed[ind+1:])\n                next_node.left = next_node.right = None # backtrack\n                if n - 2 == 0: return # don't double count dups\n        head = TreeNode()\n        unprocessed = []\n        generate_trees(n-1, head, unprocessed)\n        return ans",
        "content": "# Intuition\\n\\nDP solutions are much faster, but the first solution that came to my head is a recursive combinatorial search + backtracking, similar to combinations problem.\\n\\nJust wanted to include this post as an alternate method of solving the problem albeit with much slower time since it doesn\\'t leverage memoization or symmetry.\\n\\nNote: this solution is only 5% faster speed and memory  XD.\\n\\n# Approach\\n\\nTry to generate combinations of possible trees starting from the root node using combinatorial search recursively and backtracking. \\n\\nAt each step, we can choose a candidate from the unprocessed nodes (aka nodes we haven\\'t recursed on) to expand. Either choose to include it (add 2 children) or disclude it (no children). Expand upon the unprocessed linearly such that duplicate combinations aren\\'t included (similar to combinations problems).\\n\\n# Complexity\\n\\n- Time complexity:\\n$$O(2^n)$$, based on combinations of largest possible unprocssed array, number of unprocessed each step increases by 1 per level, highest possible number of levels in full binary tree is n + 1 / 2.\\n\\n- Space complexity:\\n$$O(n^2)$$, highest levels is factor of n, number of unprocessed is limited by n also.\\n\\nNote: Please correct me if I\\'m wrong about the complexity, thanks!\\n\\n# Code\\n```\\nfrom copy import deepcopy\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\\n        ans = []\\n        if not n % 2: # impossible to produce even num full tree\\n            return ans\\n        # combinatorial search with backtracking, at each step either set two children or set 0 children\\n        def generate_trees(n, node, unprocessed):\\n            if n == 0:\\n                ans.append(deepcopy(head))\\n                return\\n            node.left = TreeNode()\\n            node.right = TreeNode()\\n            unprocessed.append(node.left)\\n            unprocessed.append(node.right)\\n            # go over every combination of dfs expansion based on unprocessed candidates\\n            for ind, next_node in enumerate(unprocessed):\\n                generate_trees(n - 2, next_node, unprocessed[ind+1:])\\n                next_node.left = next_node.right = None # backtrack\\n                if n - 2 == 0: return # don\\'t double count dups\\n        head = TreeNode()\\n        unprocessed = []\\n        generate_trees(n-1, head, unprocessed)\\n        return ans \\n```"
    },
    {
        "slug": "make-k-subarray-sums-equal",
        "tags": "python3",
        "release_time": 1680500634,
        "code": "class Solution:\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\n        gcd = math.gcd(len(arr), k)\n        \n        ans = 0\n        for i in range(gcd):\n            seq = arr[i::gcd]\n            m = int(statistics.median(seq))\n            for n in seq:\n                ans += abs(n-m)\n        return ans",
        "content": "1. Consider the example:\\n![image](https://assets.leetcode.com/users/images/26344d41-8ebe-4aa1-91cf-f15912b80fd1_1680499535.2074687.png)\\n`arr[0] + arr[1] + arr[2] + arr[3] = arr[1] + arr[2] + arr[3] + arr[4]`, so `arr[0] = arr[4]`. \\nBy similar calculation we have `arr[0] = arr[4] = arr[2]`, `arr[1] = arr[5] = arr[3]`.\\n2. As above, `arr` can be divided into subarrays of equal length, and the length would be `g := gcd(len(arr), k)`.\\n3. All subarrays would look the same after we finish operations, i.e. `arr[i] = arr[i+g] = arr[i+2*g] = ... for all i`.\\n4. Now the problem becomes: given some integers `i_0, i_1, i_2, ..., i_n`, what `x` would make the sum `abs(i_0 - x) + abs(i_1 - x) + abs(i_2 - x) + ... + abs(i_n - x)` smallest?\\n`x = median(i_0, i_1, i_2, ..., i_n)` would do.\\n```\\nclass Solution:\\n    def makeSubKSumEqual(self, arr: List[int], k: int) -> int:\\n        gcd = math.gcd(len(arr), k)\\n        \\n        ans = 0\\n        for i in range(gcd):\\n            seq = arr[i::gcd]\\n            m = int(statistics.median(seq))\\n            for n in seq:\\n                ans += abs(n-m)\\n        return ans"
    },
    {
        "slug": "n-th-tribonacci-number",
        "tags": "python3",
        "release_time": 1691827777,
        "code": "class Solution:\n    def tribonacci(self, n: int) -> int:\n        if n==0:return 0\n        d=[0]*(3)\n        d[0]=0\n        d[1]=d[2]=1\n        for i in range(3,n+1):\n            d.append(sum(d))\n            d.pop(0)\n        return d[2]",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\na array of size 3 is there it has values of `fib(0),fib(1),fib(2)`\\nfurthur usig thier sum we append it to end of list and pop the first element\\nat end answer will be stored in last `a[2]` returning it does the job\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**______O(N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**______O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def tribonacci(self, n: int) -> int:\\n        if n==0:return 0\\n        d=[0]*(3)\\n        d[0]=0\\n        d[1]=d[2]=1\\n        for i in range(3,n+1):\\n            d.append(sum(d))\\n            d.pop(0)\\n        return d[2]\\n```"
    },
    {
        "slug": "valid-parenthesis-string",
        "tags": "python3",
        "release_time": 1674151600,
        "code": "class Solution:\n    def checkValidString(self, s):\n        st=[]\n        sr=[]\n        for i in range(len(s)):\n            if s[i]=='(':\n                st.append(i)\n            elif s[i]== '*':\n                sr.append(i)\n            else:\n                if st:\n                    st.pop()\n                elif sr:\n                    sr.pop()\n                else:\n                    return False\n        while st:\n            if len(sr)==0:\n                return False\n            elif st[-1]< sr[-1]:\n                st.pop()\n                sr.pop()\n            else:\n                return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing two stack approch\\nfirst stack store only opening bracket\\nsecond stack store only star\\n\\nwhen closing bracket comes that time \\n1} check opening bracket exits or not if exist then pop out one opening bracket because it will valid parenthesis\\n2} if opening bracket not exit check star if exist then it is also valid parenthesis string ex ---> *) < -- this is valid\\n3} else it will False because there is only closing bracket ex--> ) (  )  <-- invalid\\n\\ncheck againg any  opening bracket presint or not \\nif  opening bracket remaning and stars are not exits then it will false\\n\\nif stars are present and indexing is greater than opening bracket then it will valid otherwise false ex --> *( <-- not valid if it is valid when * comes after bracket --> ( *      \\n\\nThanks\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def checkValidString(self, s):\\n        st=[]\\n        sr=[]\\n        for i in range(len(s)):\\n            if s[i]==\\'(\\':\\n                st.append(i)\\n            elif s[i]== \\'*\\':\\n                sr.append(i)\\n            else:\\n                if st:\\n                    st.pop()\\n                elif sr:\\n                    sr.pop()\\n                else:\\n                    return False\\n        while st:\\n            if len(sr)==0:\\n                return False\\n            elif st[-1]< sr[-1]:\\n                st.pop()\\n                sr.pop()\\n            else:\\n                return False\\n        return True\\n\\n\\n\\n\\n                \\n\\n            \\n\\n```"
    },
    {
        "slug": "lemonade-change",
        "tags": "python3",
        "release_time": 1679208308,
        "code": "class Solution:\n    def lemonadeChange(self, bills: List[int]) -> bool:\n        ind , n = 0, len(bills)\n        change = {5:0, 10:0}\n        while ind < n:\n            cur = bills[ind]\n            if cur == 5: change[5] += 1\n            elif cur == 10:\n                if change[5]:\n                    change[5] -= 1\n                    change[10] += 1\n                else: return False\n            else:\n                if change[10]  and change[5]:\n                    change[10] -= 1\n                    change[5]-=1\n                elif change[5]>=3: change[5] -= 3\n                else: return False\n            ind += 1\n        return True",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def lemonadeChange(self, bills: List[int]) -> bool:\\n        ind , n = 0, len(bills)\\n        change = {5:0, 10:0}\\n        while ind < n:\\n            cur = bills[ind]\\n            if cur == 5: change[5] += 1\\n            elif cur == 10:\\n                if change[5]:\\n                    change[5] -= 1\\n                    change[10] += 1\\n                else: return False\\n            else:\\n                if change[10]  and change[5]:\\n                    change[10] -= 1\\n                    change[5]-=1\\n                elif change[5]>=3: change[5] -= 3\\n                else: return False\\n            ind += 1\\n        return True\\n```"
    },
    {
        "slug": "binary-search-tree-to-greater-sum-tree",
        "tags": "python3",
        "release_time": 1680283990,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def bstToGst(self, root: TreeNode) -> TreeNode:\n        if not root: return None\n        stack, val, curr = [], 0, root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.right\n            curr = stack.pop()\n            val += curr.val \n            curr.val = val\n            curr = curr.left\n        return root",
        "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n                                -    DFS    -                      \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def bstToGst(self, root: TreeNode) -> TreeNode:\\n        if not root: return None\\n        stack, val, curr = [], 0, root\\n        while curr or stack:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.right\\n            curr = stack.pop()\\n            val += curr.val \\n            curr.val = val\\n            curr = curr.left\\n        return root \\n```\\n                            -   Recursive DFS   -\\n```                                                                \\n        def dfs(node, val):\\n            if node.right:\\n                val = dfs(node.right, val)\\n            val += node.val\\n            node.val = val\\n            if node.left:\\n                val = dfs(node.left, val)\\n            return val\\n        dfs(root, 0)\\n        return root\\n```"
    },
    {
        "slug": "ways-to-split-array-into-good-subarrays",
        "tags": "python3",
        "release_time": 1690779579,
        "code": "class Solution:\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\n        try:\n            firstOne = nums.index(1)\n        except Exception:\n            return 0\n\n        ans = 1\n        subArrayCount = 1\n        for i in range(firstOne, len(nums)):\n            if nums[i] == 0:\n                subArrayCount += 1\n            else:\n                ans *= subArrayCount\n                ans %= (10 ** 9 + 7)\n                subArrayCount = 1\n\n        return ans",
        "content": "\\n\\n# Approach\\n![Screenshot 2023-07-30 225845.png](https://assets.leetcode.com/users/images/18a2381c-f8db-44c1-8fd5-9f61311ab45c_1690779539.2431946.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/575b7808-eafc-4a77-b2c3-659a473032cf_1690779557.2961736.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/016aad6c-a04f-4ff5-a6f8-eeaf7637367d_1690779566.9093945.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfGoodSubarraySplits(self, nums: List[int]) -> int:\\n        try:\\n            firstOne = nums.index(1)\\n        except Exception:\\n            return 0\\n\\n        ans = 1\\n        subArrayCount = 1\\n        for i in range(firstOne, len(nums)):\\n            if nums[i] == 0:\\n                subArrayCount += 1\\n            else:\\n                ans *= subArrayCount\\n                ans %= (10 ** 9 + 7)\\n                subArrayCount = 1\\n\\n        return ans\\n```"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "tags": "python3",
        "release_time": 1686875139,
        "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n        def test():\n            for key, val in track.items():\n                if val !=occ[key]:\n                    return False\n            return True\n        res=[]\n        #first look\n\n        for k in range(wlen):\n            for i in words:\n                track.update({i : 0})\n            for i in range(k,slen+k,wlen):\n                w=s[i:i+wlen]\n                if w in words:\n                    track.update({w: track[w]+1})\n            if test():\n                res.append(k)\n            #complete\n            for i in range(wlen+k, len(s)-slen+1,wlen):\n                \n                nw=s[i+slen-wlen:i+slen]\n                pw=s[i-wlen:i]\n                if nw in words:\n                    track.update({nw: track[nw]+1})\n                if pw in words:\n                    track.update({pw: track[pw]-1})\n                if test():\n                    res.append(i)\n        return res",
        "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```"
    },
    {
        "slug": "longest-substring-without-repeating-characters",
        "tags": "python3",
        "release_time": 1692548699,
        "code": "class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n\n        l = 0\n        hash_set = {}\n        max_len = 0\n        for r in range(len(s)):\n            \n            if s[r] in hash_set:\n\n                # changes l only if its greater than current l\n                # for test case such as abba\n                if hash_set[s[r]]+1>l: \n                    l = hash_set[s[r]]+1\n            \n            hash_set[s[r]] = r \n            max_len = max(max_len, r-l+1)\n\n        return max_len",
        "content": "# Intuition\\nKeep moving r, calculate max_length of window, update left to repeated elments previous index+1 if repeated element is found (update only if left is greater than current left)   \\n\\n# Approach\\nSliding window\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def lengthOfLongestSubstring(self, s: str) -> int:\\n\\n        l = 0\\n        hash_set = {}\\n        max_len = 0\\n        for r in range(len(s)):\\n            \\n            if s[r] in hash_set:\\n\\n                # changes l only if its greater than current l\\n                # for test case such as abba\\n                if hash_set[s[r]]+1>l: \\n                    l = hash_set[s[r]]+1\\n            \\n            hash_set[s[r]] = r \\n            max_len = max(max_len, r-l+1)\\n\\n        return max_len\\n```"
    },
    {
        "slug": "distinct-subsequences",
        "tags": "python3",
        "release_time": 1673543636,
        "code": "class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        n=len(s)\n        m=len(t)\n        if n<m:\n            return 0\n        # dp=[[0]*(m+1) for i in range(n+1)]\n        prev=[0]*(m+1)\n        # for i in range(n+1):\n        #     dp[i][0]=1\n        prev[0]=1\n        for i in range(1,n+1):\n            curr=[0]*(m+1)\n            curr[0]=1\n            for j in range(1,m+1):\n                x=0\n                if s[i-1]==t[j-1]:\n                    x=prev[j-1]\n                y=prev[j]\n                curr[j]=x+y\n                #     x=dp[i-1][j-1]\n                # y=dp[i-1][j]\n                # dp[i][j]=x+y\n            prev=curr\n        return prev[m]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N*M)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*M)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numDistinct(self, s: str, t: str) -> int:\\n        n=len(s)\\n        m=len(t)\\n        if n<m:\\n            return 0\\n        # dp=[[0]*(m+1) for i in range(n+1)]\\n        prev=[0]*(m+1)\\n        # for i in range(n+1):\\n        #     dp[i][0]=1\\n        prev[0]=1\\n        for i in range(1,n+1):\\n            curr=[0]*(m+1)\\n            curr[0]=1\\n            for j in range(1,m+1):\\n                x=0\\n                if s[i-1]==t[j-1]:\\n                    x=prev[j-1]\\n                y=prev[j]\\n                curr[j]=x+y\\n                #     x=dp[i-1][j-1]\\n                # y=dp[i-1][j]\\n                # dp[i][j]=x+y\\n            prev=curr\\n        return prev[m]\\n        \\n```"
    },
    {
        "slug": "maximum-non-negative-product-in-a-matrix",
        "tags": "python3",
        "release_time": 1600574927,
        "code": "class Solution:\n    def maxProductPath(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        \n        @lru_cache(None)\n        def fn(i, j): \n            \"\"\"Return maximum & minimum products ending at (i, j).\"\"\"\n            if i == 0 and j == 0: return grid[0][0], grid[0][0]\n            if i < 0 or j < 0: return -inf, inf\n            if grid[i][j] == 0: return 0, 0\n            mx1, mn1 = fn(i-1, j) # from top\n            mx2, mn2 = fn(i, j-1) # from left \n            mx, mn = max(mx1, mx2)*grid[i][j], min(mn1, mn2)*grid[i][j]\n            return (mx, mn) if grid[i][j] > 0 else (mn, mx)\n        \n        mx, _ = fn(m-1, n-1)\n        return -1 if mx < 0 else mx % 1_000_000_007",
        "content": "\\n```\\nclass Solution:\\n    def maxProductPath(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        \\n        @lru_cache(None)\\n        def fn(i, j): \\n            \"\"\"Return maximum & minimum products ending at (i, j).\"\"\"\\n            if i == 0 and j == 0: return grid[0][0], grid[0][0]\\n            if i < 0 or j < 0: return -inf, inf\\n            if grid[i][j] == 0: return 0, 0\\n            mx1, mn1 = fn(i-1, j) # from top\\n            mx2, mn2 = fn(i, j-1) # from left \\n            mx, mn = max(mx1, mx2)*grid[i][j], min(mn1, mn2)*grid[i][j]\\n            return (mx, mn) if grid[i][j] > 0 else (mn, mx)\\n        \\n        mx, _ = fn(m-1, n-1)\\n        return -1 if mx < 0 else mx % 1_000_000_007\\n```"
    },
    {
        "slug": "largest-element-in-an-array-after-merge-operations",
        "tags": "python3",
        "release_time": 1690100326,
        "code": "def solve(nums, x):\n    ans = nums[x]\n    for i in range(x, len(nums)-1):\n        if nums[i]<=nums[i+1]:\n            ans += nums[i+1]\n        else:\n            right = solve(nums, i+1)\n            if right >= nums[i]:\n                ans += right\n            break\n    return ans\n\nclass Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        return solve(nums, 0)",
        "content": "# Intuition\\nFor every element, we can add the numbers in it\\'s right only if the sum of all the numbers in the right is bigger than the element.\\nIn other words, when we traverse the array from left to right, for each element `i`, we will only consider elements on the right of `i` if sum of `nums[i+1]` to `nums[-1]` is bigger than `nums[i]`.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf `nums[i+1]` > `nums[i]` we add move forward. Otherwise, we do a recursive call with the right subarray that starts from index `i+1`.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef solve(nums, x):\\n    ans = nums[x]\\n    for i in range(x, len(nums)-1):\\n        if nums[i]<=nums[i+1]:\\n            ans += nums[i+1]\\n        else:\\n            right = solve(nums, i+1)\\n            if right >= nums[i]:\\n                ans += right\\n            break\\n    return ans\\n\\nclass Solution:\\n    def maxArrayValue(self, nums: List[int]) -> int:\\n        return solve(nums, 0)\\n```"
    },
    {
        "slug": "number-of-adjacent-elements-with-the-same-color",
        "tags": "python3",
        "release_time": 1683443656,
        "code": "class Solution:\n    def colorTheArray(self, n, queries):\n        ans, nums, count = [], [0]*n, 0\n\n        for i in range(len(queries)):\n            index, color = queries[i][0], queries[i][1]\n\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\n                count -= 1\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\n                count -= 1\n\n            nums[index] = color\n\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\n                count += 1\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\n                count += 1\n\n            ans.append(count)\n\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def colorTheArray(self, n, queries):\\n        ans, nums, count = [], [0]*n, 0\\n\\n        for i in range(len(queries)):\\n            index, color = queries[i][0], queries[i][1]\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count -= 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count -= 1\\n\\n            nums[index] = color\\n\\n            if index-1 >= 0 and nums[index] != 0 and nums[index-1] == nums[index]:\\n                count += 1\\n            if index+1 < n and nums[index] != 0 and nums[index+1] == nums[index]:\\n                count += 1\\n\\n            ans.append(count)\\n\\n        return ans\\n\\n            \\n\\n\\n\\n\\n\\n```"
    },
    {
        "slug": "rank-transform-of-an-array",
        "tags": "python3",
        "release_time": 1679115737,
        "code": "class Solution:\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\n        list1=[]\n        x=sorted(set(arr))\n        dict1={}\n        for i in range(len(x)):\n            dict1[x[i]]=i+1\n        for j in arr:\n            y=dict1[j]\n            list1.append(y)\n        return list1\n    #please do upvote it will help alot to gain my love in coding",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayRankTransform(self, arr: List[int]) -> List[int]:\\n        list1=[]\\n        x=sorted(set(arr))\\n        dict1={}\\n        for i in range(len(x)):\\n            dict1[x[i]]=i+1\\n        for j in arr:\\n            y=dict1[j]\\n            list1.append(y)\\n        return list1\\n    #please do upvote it will help alot to gain my love in coding\\n\\n```\\n# consider upvoting if found helpful![57jfh9.jpg](https://assets.leetcode.com/users/images/18e346ce-ffbb-46f1-995f-cfc301972ca0_1679115728.6807754.jpeg)\\n"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "tags": "python3",
        "release_time": 1690819672,
        "code": "class Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        # make a mapping of deque lists called indexes \n        indexes = collections.defaultdict(collections.deque)\n        # enumerate s \n        for index, character in enumerate(s) :\n            # indexes at the int cast of character has this index added to it  \n            indexes[int(character)].append(index)\n\n        # get unique values in t \n        unique_t_values = set([int(t_i) for t_i in t])\n        # for t_v in unique t values \n        for t_v in unique_t_values : \n            # if not in indexes \n            if t_v not in indexes :\n                # return False as we are missing pieces  \n                return False \n        \n        # loop over t in order given  \n        for character in t : \n            # get the characters integer designation \n            character_designation = int(character)\n            # update may cause new misses which may prevent future searches \n            if character_designation not in indexes : \n                return False \n            # for index in range up to character designation \n            for lesser_character in range(character_designation) : \n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    # our lists are not transformable, False \n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \n                    # this is detailed in the problem statement where they note that values must be in ascending order \n                    return False \n            # after consideration using this most recent index, remove it \n            indexes[character_designation].popleft()\n            # if length is now zero, remove it \n            if len(indexes[character_designation]) == 0 : \n                indexes.pop(character_designation)\n        \n        # if all characters able to sort, return it \n        return True",
        "content": "# Intuition\\nFaced with any substring sorting problems, I\\'m drawn to maps and graphs for ease of search space. As such, we can consider this one with not too much of a stretch of the mind. \\n\\nEach integer value in our selected string has a list of indices at which it appears. IF we make a mapping of these list of indices for each value in order of appearance in s, we can use that against the ordering of appearance of list of values in t (we do not necessarily need to make said list of t, but could if we so chose) \\n\\nOnce we have this map, our first bet is to actually get the set of unique items in t, which can be done rather nicely with generators that will do the autoskip inclusions as needed. \\n\\nUsing unique t, our first check is that all of the unique t values are present. If not, then we can skip to returning False. \\n\\nOtherwise, we need to loop over t, and for each character check if it is in our map. If not, also False. \\n\\nIf we then loop over values up to this point (such that if we drew say 5 we\\'d go from 0 to 4 inclusive) we need to find that the value is in indexes and that the indexes at that point has a starting value at least as advanced or more so than the indexes for the drawn values first appearance. If this does not occur, then they are not in ascending order and may also return False. \\n\\nIf all of that passes, we need to discard the current item at the front of indexes at the drawn character. If in doing so we now eliminate that list, we need to eliminate the character drawn from indices entirely (this is why we have that second check for inclusion near the top). \\n\\nIf we manage all of that, there\\'s nothing to stop the transformation and can return True. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse collections default dict with collections deque for each character valuation in s \\n\\nMake a map of the character values -> list of indices of occurrence in order from first to last \\n\\nMake a set of unique t values \\n\\n- For each unique t value in unique t values \\n    - if that value is not in our mapping \\n        - return False \\n\\nLoop over t (effectively getting the unique indices for each value of t) \\n- as you do, convert your character into its designated key (This is here for other mapping versions of the problem) \\n- if we do not have that designated ky in our map \\n    - return false \\n- otherwise, loop over lesser character designations in range to character designation \\n    - if we have the map at lesser character designation and the map at lesser character designation points to a list whose first index of occurrence is less than the first index of occurrence of our current character designation, it must be that they are not in order, and can return False \\n- after completing lesser character loop, remove the most recent occurrence of indexes at character designation by popping left from the map at the character designation \\n- if the map now points to an empty list for character designation, remove character designation from the map entirely.    \\n\\n# Complexity\\n- Time complexity : O(S + T)\\n    - O(S) to build s mapping \\n    - O(T) to build t unique characters \\n    - O(T) to loop over characters in T \\n        - within which we do at most O(5) work to loop in range of lesser characters on average \\n    - Total then is O(S + T + ~5T) -> O(S + C * T) -> O(S + T)  \\n\\n\\n- Space complexity : O(S + t) \\n    - Store O(s) lists of size to account for S, so O(S) \\n    - Store O(t) \\n    - Remove storage for potentially all of O(S) \\n    - Averages out to O(S + t) at worst  \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def isTransformable(self, s: str, t: str) -> bool :\\n        # make a mapping of deque lists called indexes \\n        indexes = collections.defaultdict(collections.deque)\\n        # enumerate s \\n        for index, character in enumerate(s) :\\n            # indexes at the int cast of character has this index added to it  \\n            indexes[int(character)].append(index)\\n\\n        # get unique values in t \\n        unique_t_values = set([int(t_i) for t_i in t])\\n        # for t_v in unique t values \\n        for t_v in unique_t_values : \\n            # if not in indexes \\n            if t_v not in indexes :\\n                # return False as we are missing pieces  \\n                return False \\n        \\n        # loop over t in order given  \\n        for character in t : \\n            # get the characters integer designation \\n            character_designation = int(character)\\n            # update may cause new misses which may prevent future searches \\n            if character_designation not in indexes : \\n                return False \\n            # for index in range up to character designation \\n            for lesser_character in range(character_designation) : \\n                # if indexes at lesser character and indexes at lesser character lists 0th item is before indexes at character designations lists 0th item \\n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \\n                    # our lists are not transformable, False \\n                    # this is because for any select string mapping of character designations that are greater than their sub indexes \\n                    # it must be such that the index priors sub mapping does not interfere with the index current mapping. \\n                    # this is detailed in the problem statement where they note that values must be in ascending order \\n                    return False \\n            # after consideration using this most recent index, remove it \\n            indexes[character_designation].popleft()\\n            # if length is now zero, remove it \\n            if len(indexes[character_designation]) == 0 : \\n                indexes.pop(character_designation)\\n        \\n        # if all characters able to sort, return it \\n        return True \\n```"
    },
    {
        "slug": "linked-list-in-binary-tree",
        "tags": "python3",
        "release_time": 1689594574,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\n\n        if head is None:\n            return True\n\n        if root is None:\n            return False\n\n        if head.val == root.val:\n            if self.isSame(head, root):\n                return True\n            \n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\n\n    \n    def isSame(self, head, root):\n\n        if head is None:\n            return True\n        \n        if root is None:\n            return False\n\n        if head.val == root.val:\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\n        \n        return False",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:\\n\\n        if head is None:\\n            return True\\n\\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            if self.isSame(head, root):\\n                return True\\n            \\n        return self.isSubPath(head, root.left) or self.isSubPath(head, root.right)\\n\\n    \\n    def isSame(self, head, root):\\n\\n        if head is None:\\n            return True\\n        \\n        if root is None:\\n            return False\\n\\n        if head.val == root.val:\\n            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)\\n        \\n        return False\\n        \\n\\n```"
    },
    {
        "slug": "max-points-on-a-line",
        "tags": "python3",
        "release_time": 1673194328,
        "code": "from collections import defaultdict\nclass Solution:\n    def maxPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        D = defaultdict(set)\n        if N <= 2:\n            return N \n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i+1, N):\n                x2, y2 = points[j]\n                if y1 == y2:\n                    k1, k2 = 'inf', y1\n                elif x1 == x2:\n                    k1, k2 = x1, 'inf'\n                else:\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\n                D[(k1,k2)].add(tuple(points[i]))\n                D[(k1,k2)].add(tuple(points[j]))\n        return max([len(i) for i in D.values()])",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        N = len(points)\\n        D = defaultdict(set)\\n        if N <= 2:\\n            return N \\n        for i in range(N):\\n            x1, y1 = points[i]\\n            for j in range(i+1, N):\\n                x2, y2 = points[j]\\n                if y1 == y2:\\n                    k1, k2 = \\'inf\\', y1\\n                elif x1 == x2:\\n                    k1, k2 = x1, \\'inf\\'\\n                else:\\n                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)\\n                D[(k1,k2)].add(tuple(points[i]))\\n                D[(k1,k2)].add(tuple(points[j]))\\n        return max([len(i) for i in D.values()])\\n        \\n\\n```"
    },
    {
        "slug": "alternating-digit-sum",
        "tags": "python3",
        "release_time": 1677611169,
        "code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        count=0\n        n=str(n)\n        for i in range(len(n)):\n            if i%2==0:\n                count+=int(n[i])\n            else:\n                count-=int(n[i])\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        count=0\\n        n=str(n)\\n        for i in range(len(n)):\\n            if i%2==0:\\n                count+=int(n[i])\\n            else:\\n                count-=int(n[i])\\n        return count\\n```"
    },
    {
        "slug": "final-prices-with-a-special-discount-in-a-shop",
        "tags": "python3",
        "release_time": 1676047572,
        "code": "class Solution:\n    def finalPrices(self, prices: List[int]) -> List[int]:\n        ans=[]\n        for i in range(len(prices)):\n            for j in range(1,len(prices)):\n                if j>i and prices[j]<=prices[i]:\n                    ans.append(prices[i]-prices[j])\n                    break\n            else:\n                ans.append(prices[i])\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def finalPrices(self, prices: List[int]) -> List[int]:\\n        ans=[]\\n        for i in range(len(prices)):\\n            for j in range(1,len(prices)):\\n                if j>i and prices[j]<=prices[i]:\\n                    ans.append(prices[i]-prices[j])\\n                    break\\n            else:\\n                ans.append(prices[i])\\n        return ans\\n```"
    },
    {
        "slug": "maximum-depth-of-binary-tree",
        "tags": "python3",
        "release_time": 1686009664,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        stack = [[root, 1]]\n        res = 0\n\n        while stack:\n            node, depth = stack.pop()\n\n            if node:\n                res = max(res, depth)\n                stack.append([node.left, depth + 1])\n                stack.append([node.right, depth + 1])\n            \n        return res",
        "content": "We should dive into our tree as far as possible until we come the bottom in the branch, and after we backtrack.\\n\\n# Complexity\\n- Time complexity: O(n) for traversing the tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) in the worst case where our stack is filled by every element in the single existing branch.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\\n        stack = [[root, 1]]\\n        res = 0\\n\\n        while stack:\\n            node, depth = stack.pop()\\n\\n            if node:\\n                res = max(res, depth)\\n                stack.append([node.left, depth + 1])\\n                stack.append([node.right, depth + 1])\\n            \\n        return res\\n\\n\\n```"
    },
    {
        "slug": "count-equal-and-divisible-pairs-in-an-array",
        "tags": "python3",
        "release_time": 1691512838,
        "code": "class Solution:\n    def countPairs(self, nums: List[int], k: int) -> int:\n        d={}\n        for i,v in enumerate(nums):\n            if v in d:\n                d[v].append(i)\n            else:\n                d|={v:[i]}\n        s=0\n        def make(a,n):\n            c=0\n            for i in range(n-1):\n                for j in range(i+1,n):\n                    if a[i]*a[j]%k==0:\n                        c+=1\n            return c\n        for i in d:\n            if len(d[i])==1:\n                continue\n            s+=make(d[i],len(d[i]))\n        return s",
        "content": "# stats\\n![Screenshot 2023-08-08 at 10.04.55 PM.png](https://assets.leetcode.com/users/images/50204932-e423-445f-a363-604c06a10146_1691512534.2270777.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe have a dictionary to store the indices in a array by looping through the array   \\n    We have function make which tries all combinations in the indices and checks if their product id dicvisible by k returning c\\nif length of indices is 1 we can skip the iteration\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*N) due to make function\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) due to dictionary\\n\\n# Code\\n```\\nclass Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        d={}\\n        for i,v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d|={v:[i]}\\n        s=0\\n        def make(a,n):\\n            c=0\\n            for i in range(n-1):\\n                for j in range(i+1,n):\\n                    if a[i]*a[j]%k==0:\\n                        c+=1\\n            return c\\n        for i in d:\\n            if len(d[i])==1:\\n                continue\\n            s+=make(d[i],len(d[i]))\\n        return s\\n```"
    },
    {
        "slug": "perfect-squares",
        "tags": "python3",
        "release_time": 1681361643,
        "code": "class Solution:\n    def numSquares(self, n: int) -> int:\n        dp = [20000 for _ in range(n + 1)]\n        dp[0] = 0\n        ps = []\n\n        for i in range(1,n + 1):\n            if pow(i, 2) > n:\n                break\n            ps.append(i ** 2)\n\n        for i in range(n + 1):\n            for j in ps:\n                if i + j <= n:\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\n                else:\n                    break\n\n        return dp[n]",
        "content": "# Code\\n```\\nclass Solution:\\n    def numSquares(self, n: int) -> int:\\n        dp = [20000 for _ in range(n + 1)]\\n        dp[0] = 0\\n        ps = []\\n\\n        for i in range(1,n + 1):\\n            if pow(i, 2) > n:\\n                break\\n            ps.append(i ** 2)\\n\\n        for i in range(n + 1):\\n            for j in ps:\\n                if i + j <= n:\\n                    dp[i + j] = min(dp[i] + 1, dp[i + j])\\n                else:\\n                    break\\n\\n        return dp[n]\\n```\\n# How it works\\nSo in the DP Array (Dynamic Programming Array) the rest except for the first one will be every big, why?, well because, you need to find the smallest value right? but if it samll like 0 and there is something bigger like x, it will need to be like this min(0,x) well 0 would be smaller and the answer will be 0. the for loop is basically finding all the perfect square what PS stands for, so I did it to make it faster, not anything else, and also the second for loop is calcualting, so we will find lots of possible results using Dynamic Programming and then, compare them. well thats it, you final answer will be at the end."
    },
    {
        "slug": "sum-of-absolute-differences-in-a-sorted-array",
        "tags": "python3",
        "release_time": 1680986222,
        "code": "class Solution:\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\n\n        n=len(nums)\n        total=sum(nums)\n        s1=0\n        s2=total\n        arr=[]\n        for i in range(n):\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\n            s1=s1+nums[i]\n            s2=total-s1\n\n        return arr",
        "content": "# Intuition\\nPlease Upvote if this Find HelpFull\\uD83D\\uDC4D\\uD83D\\uDC4D\\n\\n# Code\\n```\\nclass Solution:\\n    def getSumAbsoluteDifferences(self, nums: List[int]) -> List[int]:\\n\\n        n=len(nums)\\n        total=sum(nums)\\n        s1=0\\n        s2=total\\n        arr=[]\\n        for i in range(n):\\n            arr.append(abs(s1-(nums[i]*i))+abs((s2-(nums[i])*(n-i))) )\\n            s1=s1+nums[i]\\n            s2=total-s1\\n\\n        return arr\\n```"
    },
    {
        "slug": "n-queens-ii",
        "tags": "python3",
        "release_time": 1689338187,
        "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        def addans(board,ans):\n            temp=[]\n            for row in board:\n                for j in range(len(row)):\n                    if row[j]==\"Q\":\n                        temp.append(j+1)\n            ans.append(temp)\n        def solve(col,board,low,upper,lower,ans,n):\n            if col==n:\n                addans(board,ans)\n                return \n            for row in range(n):\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\n                    board[row][col]=\"Q\"\n                    low[row]=1\n                    upper[n-1+col-row]=1\n                    lower[row+col]=1\n                    solve(col+1,board,low,upper,lower,ans,n)\n                    low[row]=0\n                    upper[n-1+col-row]=0\n                    lower[row+col]=0\n        ans=[]        \n        board=[[0]*n for i in range(n)]\n        low=[0]*n\n        upper=[0]*(2*n-1)\n        lower=[0]*(2*n-1)\n        solve(0,board,low,upper,lower,ans,n)\n        return len(ans)",
        "content": "\\n\\n# 1. BackTracking Logic Solution\\n```\\nclass Solution:\\n    def totalNQueens(self, n: int) -> int:\\n        def addans(board,ans):\\n            temp=[]\\n            for row in board:\\n                for j in range(len(row)):\\n                    if row[j]==\"Q\":\\n                        temp.append(j+1)\\n            ans.append(temp)\\n        def solve(col,board,low,upper,lower,ans,n):\\n            if col==n:\\n                addans(board,ans)\\n                return \\n            for row in range(n):\\n                if low[row]==0 and upper[n-1+col-row]==0 and lower[row+col]==0:\\n                    board[row][col]=\"Q\"\\n                    low[row]=1\\n                    upper[n-1+col-row]=1\\n                    lower[row+col]=1\\n                    solve(col+1,board,low,upper,lower,ans,n)\\n                    low[row]=0\\n                    upper[n-1+col-row]=0\\n                    lower[row+col]=0\\n        ans=[]        \\n        board=[[0]*n for i in range(n)]\\n        low=[0]*n\\n        upper=[0]*(2*n-1)\\n        lower=[0]*(2*n-1)\\n        solve(0,board,low,upper,lower,ans,n)\\n        return len(ans)\\n```\\n   # please upvote me it would encourage me alot\\n\\n\\n\\n"
    },
    {
        "slug": "string-without-aaa-or-bbb",
        "tags": "python3",
        "release_time": 1672279272,
        "code": "class Solution:\n    def strWithout3a3b(self, a: int, b: int) -> str:\n        res = []\n        while a + b > 0:\n            if len(res) >= 2 and res[-2:] == ['a', 'a']:\n                res.append('b')\n                b-=1\n            elif len(res) >= 2 and res[-2:] == ['b', 'b']:\n                res.append('a')\n                a-=1\n            elif a > b:\n                res.append('a')\n                a-=1\n            else:\n                res.append('b')\n                b-=1\n            \n        return ''.join(res)",
        "content": "# Code\\n```\\nclass Solution:\\n    def strWithout3a3b(self, a: int, b: int) -> str:\\n        res = []\\n        while a + b > 0:\\n            if len(res) >= 2 and res[-2:] == [\\'a\\', \\'a\\']:\\n                res.append(\\'b\\')\\n                b-=1\\n            elif len(res) >= 2 and res[-2:] == [\\'b\\', \\'b\\']:\\n                res.append(\\'a\\')\\n                a-=1\\n            elif a > b:\\n                res.append(\\'a\\')\\n                a-=1\\n            else:\\n                res.append(\\'b\\')\\n                b-=1\\n            \\n        return \\'\\'.join(res)\\n```"
    },
    {
        "slug": "find-the-string-with-lcp",
        "tags": "python3",
        "release_time": 1690968356,
        "code": "class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n            if pattern[i] is not None:\n                continue\n            pattern[i] = next_el_ind\n            next_el_ind += 1\n            for j in range(i+1, n):\n                if lcp[i][j] > 0:\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\n                        return ''\n                    pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)",
        "content": "# Complexity\\n- Time complexity: $O(N^2)$\\n\\n- Space complexity: $O(N^2)$ (can be reduced to $O(N)$ if build and check new lcp at the same time)\\n\\n# Code\\n```\\nclass Solution:\\n    def findTheString(self, lcp: List[List[int]]) -> str:\\n        # simple validation\\n        n = len(lcp)\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if lcp[i][j] != lcp[j][i]:\\n                    return \\'\\'\\n                if lcp[i][j] > n - j:\\n                    return \\'\\'\\n        for i in range(n):\\n            if lcp[i][i] != n - i:\\n                return \\'\\'\\n        \\n        # build pattern \\u2014 the only possible candidate for answer\\n        pattern = [None for _ in range(n)]\\n        next_el_ind = 0\\n        for i in range(n):\\n            if pattern[i] is not None:\\n                continue\\n            pattern[i] = next_el_ind\\n            next_el_ind += 1\\n            for j in range(i+1, n):\\n                if lcp[i][j] > 0:\\n                    if pattern[j] is not None and pattern[j] != pattern[i]:\\n                        return \\'\\'\\n                    pattern[j] = pattern[i]\\n    \\n        # check if lcp is valid - check that pattern\\'s lcp == original lcp\\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\\n        for i in range(n-1, -1, -1):\\n            for j in range(n-1, -1, -1):\\n                if pattern[i] == pattern[j]:\\n                    if max(i, j) + 1 < n:\\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\\n                    else:\\n                        pattern_lcp[i][j] = 1\\n        for i in range(n):\\n            for j in range(n):\\n                if lcp[i][j] != pattern_lcp[i][j]:\\n                    return \\'\\'\\n    \\n        # check that answer has no more than 26 distinct elements\\n        if max(pattern) > ord(\\'z\\') - ord(\\'a\\'):\\n            return \\'\\'\\n\\n        return  \\'\\'.join(chr(ord(\\'a\\') + ind) for ind in pattern)\\n```"
    },
    {
        "slug": "find-positive-integer-solution-for-a-given-equation",
        "tags": "python3",
        "release_time": 1665119482,
        "code": "\"\"\"\n   This is the custom function interface.\n   You should not implement it, or speculate about its implementation\n   class CustomFunction:\n       # Returns f(x, y) for any given positive integers x and y.\n       # Note that f(x, y) is increasing with respect to both x and y.\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n       def f(self, x, y):\n  \n\"\"\"\n\nclass Solution:\n    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n        ans=[]\n        y=1000\n        for x in range(1,1001):\n            while y>1 and customfunction.f(x,y)>z:\n                y-=1\n            if customfunction.f(x,y)==z:\n                ans.append([x,y])\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(X+Y)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(X)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n   This is the custom function interface.\\n   You should not implement it, or speculate about its implementation\\n   class CustomFunction:\\n       # Returns f(x, y) for any given positive integers x and y.\\n       # Note that f(x, y) is increasing with respect to both x and y.\\n       # i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\\n       def f(self, x, y):\\n  \\n\"\"\"\\n\\nclass Solution:\\n    def findSolution(self, customfunction: \\'CustomFunction\\', z: int) -> List[List[int]]:\\n        ans=[]\\n        y=1000\\n        for x in range(1,1001):\\n            while y>1 and customfunction.f(x,y)>z:\\n                y-=1\\n            if customfunction.f(x,y)==z:\\n                ans.append([x,y])\\n        return ans\\n        \\n        \\n```"
    },
    {
        "slug": "minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
        "tags": "python3",
        "release_time": 1619928673,
        "code": "class Solution:\n    def getMinSwaps(self, num: str, k: int) -> int:\n        num = list(num)\n        orig = num.copy()\n        \n        for _ in range(k): \n            for i in reversed(range(len(num)-1)): \n                if num[i] < num[i+1]: \n                    ii = i+1 \n                    while ii < len(num) and num[i] < num[ii]: ii += 1\n                    num[i], num[ii-1] = num[ii-1], num[i]\n                    lo, hi = i+1, len(num)-1\n                    while lo < hi: \n                        num[lo], num[hi] = num[hi], num[lo]\n                        lo += 1\n                        hi -= 1\n                    break \n        \n        ans = 0\n        for i in range(len(num)): \n            ii = i\n            while orig[i] != num[i]: \n                ans += 1\n                ii += 1\n                num[i], num[ii] = num[ii], num[i]\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        orig = num.copy()\\n        \\n        for _ in range(k): \\n            for i in reversed(range(len(num)-1)): \\n                if num[i] < num[i+1]: \\n                    ii = i+1 \\n                    while ii < len(num) and num[i] < num[ii]: ii += 1\\n                    num[i], num[ii-1] = num[ii-1], num[i]\\n                    lo, hi = i+1, len(num)-1\\n                    while lo < hi: \\n                        num[lo], num[hi] = num[hi], num[lo]\\n                        lo += 1\\n                        hi -= 1\\n                    break \\n        \\n        ans = 0\\n        for i in range(len(num)): \\n            ii = i\\n            while orig[i] != num[i]: \\n                ans += 1\\n                ii += 1\\n                num[i], num[ii] = num[ii], num[i]\\n        return ans \\n```"
    },
    {
        "slug": "substring-with-concatenation-of-all-words",
        "tags": "python3",
        "release_time": 1689678056,
        "code": "class Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        n, num, size = len(s), len(words), len(words[0])\n        words = Counter(words)\n        res = []\n        for i in range(size):\n            l = i\n            unwanted = 0\n            seen = defaultdict(int)\n            for r in range(i, n, size):\n                word = s[r: r + size]\n                if word in words:\n                    seen[word] += 1\n                    if seen[word] > words[word]:\n                        unwanted += 1\n                else:\n                    l = r + size\n                    unwanted = 0\n                    seen = defaultdict(int)\n                if r - l == (num - 1) * size:\n                    if unwanted == 0:\n                        res.append(l)\n                    word = s[l: l + size]\n                    if seen[word] > words[word]:\n                        unwanted -= 1\n                    seen[word] -= 1\n                    l += size\n        return res",
        "content": "# Complexity\\n- Time complexity: $$O(s.length * words[i].length)$$\\n- Space complexity: $$O(s.length)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n, num, size = len(s), len(words), len(words[0])\\n        words = Counter(words)\\n        res = []\\n        for i in range(size):\\n            l = i\\n            unwanted = 0\\n            seen = defaultdict(int)\\n            for r in range(i, n, size):\\n                word = s[r: r + size]\\n                if word in words:\\n                    seen[word] += 1\\n                    if seen[word] > words[word]:\\n                        unwanted += 1\\n                else:\\n                    l = r + size\\n                    unwanted = 0\\n                    seen = defaultdict(int)\\n                if r - l == (num - 1) * size:\\n                    if unwanted == 0:\\n                        res.append(l)\\n                    word = s[l: l + size]\\n                    if seen[word] > words[word]:\\n                        unwanted -= 1\\n                    seen[word] -= 1\\n                    l += size\\n        return res\\n```"
    },
    {
        "slug": "dungeon-game",
        "tags": "python3",
        "release_time": 1678999117,
        "code": "class Solution:\n    def calculateMinimumHP(self, dungeon):\n        m, n = len(dungeon), len(dungeon[0])\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\n        dp[m-1][n], dp[m][n-1] = 1, 1\n            \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\n        \n        return dp[0][0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def calculateMinimumHP(self, dungeon):\\n        m, n = len(dungeon), len(dungeon[0])\\n        dp = [[float(\"inf\")]*(n+1) for _ in range(m+1)]\\n        dp[m-1][n], dp[m][n-1] = 1, 1\\n            \\n        for i in range(m-1,-1,-1):\\n            for j in range(n-1,-1,-1):\\n                dp[i][j] = max(min(dp[i+1][j],dp[i][j+1])-dungeon[i][j],1)\\n        \\n        return dp[0][0]\\n```"
    },
    {
        "slug": "sort-an-array",
        "tags": "python3",
        "release_time": 1677700522,
        "code": "class Solution:                                 \n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\n\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\n\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]",
        "content": "I think the time% and space% on this problem are extremely skewed because of the scofflaws who used`sort()`,`sorted`or`heapq`, not heeding the admonition on using \"built-in functions.\".\\n\\nUsing `Counter`,`chain`,`max`,or,`mn` techically makes me a scofflaw too, so I included a non-scofflaw version below as well.\\n\\nMy scofflaw version:\\n```\\nclass Solution:                                 \\n    def sortArray(self,nums:list[int]) -> list[int]:    #   Example: [3,3,1,8,6,5,5,5,5]\\n\\n        ctr  = Counter(nums)                            #   ctr = {5:4, 3:2, 1:1, 8:1, 6:1}\\n\\n        return list(chain(*([i]*ctr[i]                  #   return    list(chain( *([1]*1, [3]*2, [5]*4, [6]*1, [8]*1) ))   \\n                    for i in range(min(ctr),            #           = list(chain([1], [3,3,3], [5,5,5,5], [6], [8] ))\\n                    max(ctr)+1) if i in ctr)))          #           = [1, 3,3, 5,5,5,5, 6, 8]   \\n                    \\n\\n```\\n\\nNon-scofflaw:\\n```\\nclass Solution:\\n    def sortArray(self, nums: list[int]) -> list[int]: \\n\\n        ans, nSet, mx, mn = [],set(nums),nums[0],nums[0]\\n        d = {n:0 for n in nSet}\\n\\n        for n in nums: d[n]+= 1\\n\\n        for n in d:\\n            if n > mx: mx = n\\n            if n < mn: mn = n\\n\\n        for i in range(mn, mx+1):\\n            if i not in d: continue\\n            ans+= [i]*d[i]\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/sort-an-array/submissions/1007234945/](http://)\\n\\n\\nI could be wrong, but I think for each that time complexity is *O*(*NlogN*) and space complexity is *O*(*N*)."
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "tags": "python3",
        "release_time": 1670557881,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\ndef fun(root,mx,mn,ans):\n    if(root==None):\n        return\n    d1=abs(root.val-mx)\n    d2=abs(root.val-mn)\n    ans[0]=max(d1,d2,ans[0])\n    mx=max(mx,root.val)\n    mn=min(mn,root.val)\n    fun(root.left,mx,mn,ans)\n    fun(root.right,mx,mn,ans)\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans=[0]\n        if(root==None):\n            return 0\n        fun(root,root.val,root.val,ans)\n        return ans[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\ndef fun(root,mx,mn,ans):\\n    if(root==None):\\n        return\\n    d1=abs(root.val-mx)\\n    d2=abs(root.val-mn)\\n    ans[0]=max(d1,d2,ans[0])\\n    mx=max(mx,root.val)\\n    mn=min(mn,root.val)\\n    fun(root.left,mx,mn,ans)\\n    fun(root.right,mx,mn,ans)\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        ans=[0]\\n        if(root==None):\\n            return 0\\n        fun(root,root.val,root.val,ans)\\n        return ans[0]\\n```"
    },
    {
        "slug": "partition-labels",
        "tags": "python3",
        "release_time": 1647825179,
        "code": "class Solution:\n    def partitionLabels(self, s: str) -> List[int]:\n        L = len(s)\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\n        i, ans = 0, []\n        while i < L:\n            end, j = last[s[i]], i + 1\n            while j < end: # validation of the part [i, end]\n                if last[s[j]] > end:\n                    end = last[s[j]] # extend the part\n                j += 1\n           \n            ans.append(end - i + 1)\n            i = end + 1\n            \n        return ans",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nSince each letter can appear only in one part, we cannot form a part shorter than the index of the last appearance of a letter subtracted by an index of the first appearance. For example here (**a**bsf**a**b) the lengths of the first part are limited by the positions of the letter `a`. So it\\'s important to know at what index each letter appears in the string last time. We can create a hash map and fill it with the last indexes for letters.\\n\\nAlso, we have to validate a candidate part. For the same example (**a***b*sfa**b**) we see that letter `a` cannot form a border for the first part because of a nasty letter `b` inside. So we need to expand the range of the initial part.\\n\\nTime: **O(n)** - 2 sweeps\\nSpace: **O(1)** - hashmap consist of max 26 keys\\n\\nRuntime: 36 ms, faster than **96.88%** of Python3 online submissions for Partition Labels.\\nMemory Usage: 13.8 MB, less than **98.78%** of Python3 online submissions for Partition Labels.\\n\\n```\\nclass Solution:\\n    def partitionLabels(self, s: str) -> List[int]:\\n        L = len(s)\\n        last = {s[i]: i for i in range(L)} # last appearance of the letter\\n        i, ans = 0, []\\n        while i < L:\\n            end, j = last[s[i]], i + 1\\n            while j < end: # validation of the part [i, end]\\n                if last[s[j]] > end:\\n                    end = last[s[j]] # extend the part\\n                j += 1\\n           \\n            ans.append(end - i + 1)\\n            i = end + 1\\n            \\n        return ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**"
    },
    {
        "slug": "find-all-possible-recipes-from-given-supplies",
        "tags": "python3",
        "release_time": 1681536413,
        "code": "class Solution:\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n        menu = list(zip(recipes, ingredients))\n        graph = defaultdict(list)\n        indegrees = {r: 0 for r in recipes}\n        for r, ing in menu:\n            for i in ing:\n                graph[i].append(r) # parent is ing required to make child recipe \n                if i not in supplies:\n                    indegrees[r] += 1 #if not present the child is dependent\n        \n        q = deque()\n        possibleRecipe = []\n        for r, v in indegrees.items():\n            if v == 0:\n                q.append(r)\n                possibleRecipe.append(r)\n        \n        while q:\n            currRecipe = q.popleft()\n            for neiRecipe in graph[currRecipe]:\n                indegrees[neiRecipe] -= 1\n                if indegrees[neiRecipe] == 0:\n                    possibleRecipe.append(neiRecipe) # the parent was possible to made so now the child can be made too\n                    q.append(neiRecipe)\n        return(possibleRecipe)",
        "content": "# Intuition\\ntreat this problem as one of the standard topological problem finding ancestors.\\nWhere if you can create the parent then u can create the child recipe too.\\nNow the trick of the problem is to curate the graph.\\n`1. Think of it as what can be the parents? The ingredients required to make a recipe.`\\n`2. And how to get indegrees? If a ingredient required to make a recipe isnt available in supplies then its dependent on the parent i.e if u cannot make parent the child cant be prepared.`\\n\\nNow solve it as topological\\nif indegrees[recipe] == 0 #it can be made as all the items required are available/ created before\\neg -> \\n1. bread -> yeast (already available)\\n2. sandwich -> (bread, meat) (meat -> already available, bread -> created before)\\n\\nand those whose indegrees become 0 are created thus add it to ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        menu = list(zip(recipes, ingredients))\\n        graph = defaultdict(list)\\n        indegrees = {r: 0 for r in recipes}\\n        for r, ing in menu:\\n            for i in ing:\\n                graph[i].append(r) # parent is ing required to make child recipe \\n                if i not in supplies:\\n                    indegrees[r] += 1 #if not present the child is dependent\\n        \\n        q = deque()\\n        possibleRecipe = []\\n        for r, v in indegrees.items():\\n            if v == 0:\\n                q.append(r)\\n                possibleRecipe.append(r)\\n        \\n        while q:\\n            currRecipe = q.popleft()\\n            for neiRecipe in graph[currRecipe]:\\n                indegrees[neiRecipe] -= 1\\n                if indegrees[neiRecipe] == 0:\\n                    possibleRecipe.append(neiRecipe) # the parent was possible to made so now the child can be made too\\n                    q.append(neiRecipe)\\n        return(possibleRecipe)\\n```"
    },
    {
        "slug": "find-missing-observations",
        "tags": "python3",
        "release_time": 1688529919,
        "code": "class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        m = len(rolls)\n        sums = mean * (m+n) - sum(rolls)\n\n        if sums < n or not ( 1 <= sums / n <= 6):\n            return list()\n        if sums % n == 0:\n            return [sums // n] * n\n        else:\n            k = sums % n\n            res = [sums//n] * n\n            for i in range(k):\n                res[i] += 1\n            return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sums = mean * (m+n) - sum(rolls)\\n\\n        if sums < n or not ( 1 <= sums / n <= 6):\\n            return list()\\n        if sums % n == 0:\\n            return [sums // n] * n\\n        else:\\n            k = sums % n\\n            res = [sums//n] * n\\n            for i in range(k):\\n                res[i] += 1\\n            return res\\n        \\n```"
    },
    {
        "slug": "most-profit-assigning-work",
        "tags": "python3",
        "release_time": 1683110615,
        "code": "class Solution:\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\n        task = list(zip(d, p))\n        t = sorted(task, key=lambda x:-x[1])\n        w.sort(reverse=True)\n        profit = 0\n        i = 0\n        j = 0\n        while i < len(w) and j < len(t):\n            if w[i] < t[j][0]:\n                j += 1\n            else:\n                profit += t[j][1]\n                i += 1 \n        return profit",
        "content": "Sort the array on the basis of profit (desc order) instead of difficulty after zipping them togther\\nAlso sort the worker array in descending order\\nNow if a task difficulty > worker[i] -> this task cant be done by any other worker too so j + 1\\nif difficulty < worker[i] => this task can be done i + 1.\\n`why not j + 1 here?` Because one task can be done by multiple workers\\n# Code\\n```\\nclass Solution:\\n    def maxProfitAssignment(self, d: List[int], p: List[int], w: List[int]) -> int:\\n        task = list(zip(d, p))\\n        t = sorted(task, key=lambda x:-x[1])\\n        w.sort(reverse=True)\\n        profit = 0\\n        i = 0\\n        j = 0\\n        while i < len(w) and j < len(t):\\n            if w[i] < t[j][0]:\\n                j += 1\\n            else:\\n                profit += t[j][1]\\n                i += 1 \\n        return profit\\n\\n```"
    },
    {
        "slug": "sum-of-squares-of-special-elements",
        "tags": "python3",
        "release_time": 1689483746,
        "code": "class Solution:\n    def sumOfSquares(self, nums: List[int]) -> int:\n        n=len(nums)\n        tot=0\n        for i in range(1,n+1):\n            if n%i==0:\n                tot+=nums[i-1]**2\n        return tot",
        "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfSquares(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        tot=0\\n        for i in range(1,n+1):\\n            if n%i==0:\\n                tot+=nums[i-1]**2\\n        return tot\\n```"
    },
    {
        "slug": "distribute-candies",
        "tags": "python3",
        "release_time": 1671696051,
        "code": "class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(candyType)//2, len(set(candyType)))",
        "content": "# Code\\n```\\nclass Solution:\\n    def distributeCandies(self, candyType: List[int]) -> int:\\n        return min(len(candyType)//2, len(set(candyType)))\\n```"
    },
    {
        "slug": "minimize-the-total-price-of-the-trips",
        "tags": "python3",
        "release_time": 1681617659,
        "code": "class Solution:\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n        g = [[] for _ in range(n)]\n        for i, j in edges:\n            g[i].append(j)\n            g[j].append(i)\n            \n        freq = [0] * n\n        level = [0] * n\n        parent = [0] * n\n        \n        def dfs(i, l, p):\n            level[i] = l\n            parent[i] = p\n            for j in g[i]:\n                if j != p:\n                    dfs(j, l + 1, i)\n        \n        def LCA(a, b):\n            if level[a] > level[b]:\n                a, b = b, a\n            d = level[b] - level[a]\n            while d:\n                b = parent[b]\n                d -= 1\n            if a == b:\n                return a\n            while a != b:\n                a = parent[a]\n                b = parent[b]\n            return a\n        \n        dfs(0, 0, -1)\n        for i, j in trips:\n            lca = LCA(i, j)\n            path = []\n            while i != lca:\n                freq[i] += 1\n                i = parent[i]\n            freq[i] += 1\n            while j != lca:\n                freq[j] += 1\n                j = parent[j]\n        \n        def dp(i, p):\n            res0 = 0\n            res1 = price[i] // 2 * freq[i]\n            for j in g[i]:\n                if j != p:\n                    curr = dp(j, i)\n                    res0 += max(curr)\n                    res1 += curr[0]\n            return [res0, res1]\n        ans = 0\n        for i in range(n):\n            ans += freq[i] * price[i]\n        return ans - max(dp(0, -1))",
        "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```"
    },
    {
        "slug": "check-if-binary-string-has-at-most-one-segment-of-ones",
        "tags": "python3",
        "release_time": 1679905665,
        "code": "class Solution:\n    def checkOnesSegment(self, s: str) -> bool:\n        return not \"01\" in s",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe string is not leading by \\'0\\', it means it starts by \\'1\\'. Thus the satisfy string has the form \\'1111...0\\' or \\'1111...111\\'. Thus there must not exist \\'01\\' form in correct string, otherwise it is false\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkOnesSegment(self, s: str) -> bool:\\n        return not \"01\" in s\\n```"
    },
    {
        "slug": "how-many-numbers-are-smaller-than-the-current-number",
        "tags": "python3",
        "release_time": 1691334542,
        "code": "class Solution:\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\n        count=[0]*101\n        res=[]\n        for num in nums:\n            count[num]+=1 \n        for num in nums:\n            res.append(sum(count[:num]))\n        return res",
        "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```"
    },
    {
        "slug": "preimage-size-of-factorial-zeroes-function",
        "tags": "python3",
        "release_time": 1690001121,
        "code": "class Solution:\n    def factorialSize(self, n: int) -> int:\n        power = 1\n        res = 0\n        while n//(5**power) > 0:\n            res += (n//(5**power))\n            power +=1\n        return res\n    def preimageSizeFZF(self, k: int) -> int:\n        #note either 0 or 5 -> just check if possible to make or not\n        #k = floor(n/5) + floor(n/25) + floor(n/125) + ... < n/4 \n        #n > 4k, n < 5k + 6\n        lo, hi = 4*k, 5*k + 6\n        #binary search\n        while lo < hi:\n            med = (lo + hi)//2\n            #print(lo, med, hi)\n            num = self.factorialSize(med)\n            if num < k: lo = med+1\n            elif num == k: return 5\n            else: hi = med\n        return 0\n        #O(logn^2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe key here is simply knowing a mathematical formula for the numer of trailing zeroes of a factorial. It\\'s well known from math contests that this is just k = floor(n/5) + floor(n/25) + floor(n/125) + ....\\n\\nImportantly, this is monotonically increasing in n, so binary search is pretty intuitive. What\\'s next is to come up with some upper and lower bounds.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nClearly, k < n/5 + n/25 + n/125 + ... < n/4 by infinite geometric series. Similarly, k > n/5 - 1 (very crude upper bound.) This gives 4k < n < 5k + 6. Now, just binary search LOLZ.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nTo compute the number of zeroes using the formula is log n. You have to do it log n times. So, our time complexity is O(log^2 n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1). didn\\'t take up any space\\n# Code\\n```\\nclass Solution:\\n    def factorialSize(self, n: int) -> int:\\n        power = 1\\n        res = 0\\n        while n//(5**power) > 0:\\n            res += (n//(5**power))\\n            power +=1\\n        return res\\n    def preimageSizeFZF(self, k: int) -> int:\\n        #note either 0 or 5 -> just check if possible to make or not\\n        #k = floor(n/5) + floor(n/25) + floor(n/125) + ... < n/4 \\n        #n > 4k, n < 5k + 6\\n        lo, hi = 4*k, 5*k + 6\\n        #binary search\\n        while lo < hi:\\n            med = (lo + hi)//2\\n            #print(lo, med, hi)\\n            num = self.factorialSize(med)\\n            if num < k: lo = med+1\\n            elif num == k: return 5\\n            else: hi = med\\n        return 0\\n        #O(logn^2)\\n\\n         \\n```"
    },
    {
        "slug": "maximum-and-sum-of-array",
        "tags": "python3",
        "release_time": 1685807690,
        "code": "class Solution:\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\n        memo = {}\n        def dfs(i, slots):\n            if i == len(nums):\n                return 0\n            key = (i, ''.join(map(str, slots)))\n            if key in memo:\n                return memo[key]\n            ans = 0\n            for j in range(len(slots)):\n                if slots[j] > 0:\n                    slots[j] -= 1\n                    ans = max(ans, dfs(i+1, slots) + (nums[i] & (j+1)))\n                    slots[j] += 1\n            memo[key] = ans\n            return ans\n        slots = [2 for _ in range(numSlots)]\n        return dfs(0, slots)",
        "content": "I think bitmask is unintuitive while the slots selection state can be stored as a string instead. Although the performance will be less than using bitmask but time complexity will be the same.\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        memo = {}\\n        def dfs(i, slots):\\n            if i == len(nums):\\n                return 0\\n            key = (i, \\'\\'.join(map(str, slots)))\\n            if key in memo:\\n                return memo[key]\\n            ans = 0\\n            for j in range(len(slots)):\\n                if slots[j] > 0:\\n                    slots[j] -= 1\\n                    ans = max(ans, dfs(i+1, slots) + (nums[i] & (j+1)))\\n                    slots[j] += 1\\n            memo[key] = ans\\n            return ans\\n        slots = [2 for _ in range(numSlots)]\\n        return dfs(0, slots)\\n```"
    },
    {
        "slug": "count-largest-group",
        "tags": "python3",
        "release_time": 1672349394,
        "code": "class Solution:\n    def countLargestGroup(self, n: int) -> int:\n\n        # This method provides the sum of the digits of a number\n        def sumDigits(number: int) -> int:\n\n            return sum([int(d) for d in str(number)])\n        \n        # We initializate a dictionary to group the number by sumDigits\n        freq = {}\n\n        for j in range(1, n+1):\n\n            sumD = sumDigits(j)\n\n            if sumD in freq:\n                freq[sumD] += [sumD]\n            else: \n                freq[sumD] = [sumD]\n        \n        # We look at the number of elements with a given digitSum\n        groupLenght = [len(val) for val in freq.values()]\n\n        # We return the number of the largest groups\n        return groupLenght.count(max(groupLenght))",
        "content": "```\\nclass Solution:\\n    def countLargestGroup(self, n: int) -> int:\\n\\n        # This method provides the sum of the digits of a number\\n        def sumDigits(number: int) -> int:\\n\\n            return sum([int(d) for d in str(number)])\\n        \\n        # We initializate a dictionary to group the number by sumDigits\\n        freq = {}\\n\\n        for j in range(1, n+1):\\n\\n            sumD = sumDigits(j)\\n\\n            if sumD in freq:\\n                freq[sumD] += [sumD]\\n            else: \\n                freq[sumD] = [sumD]\\n        \\n        # We look at the number of elements with a given digitSum\\n        groupLenght = [len(val) for val in freq.values()]\\n\\n        # We return the number of the largest groups\\n        return groupLenght.count(max(groupLenght))\\n```"
    },
    {
        "slug": "remove-element",
        "tags": "python3",
        "release_time": 1691358211,
        "code": "class Solution:\n    def removeElement(self, nums: List[int], val: int) -> int:\n\n        nums[:] = [num for num in nums if num != val]\n        \n        return len(nums)",
        "content": "# Intuition\\nSeems like any other pythonic list comprehension problem. Only hurdle is that it has to be in place\\n# Approach\\nBy using nums[:] you can make it in place\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def removeElement(self, nums: List[int], val: int) -> int:\\n\\n        nums[:] = [num for num in nums if num != val]\\n        \\n        return len(nums)\\n```"
    },
    {
        "slug": "longest-consecutive-sequence",
        "tags": "python3",
        "release_time": 1692597955,
        "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        i = 0\n        max_len, cur_max_len = 1, 1\n        nums = list(set(nums))\n        nums.sort()\n        while i < len(nums) - 1:\n            if nums[i + 1] - nums[i] == 1:\n                cur_max_len += 1\n            else:\n                cur_max_len = 1\n            i += 1\n            if cur_max_len > max_len:\n                max_len = cur_max_len\n        return max_len if nums != [] else 0",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        i = 0\\n        max_len, cur_max_len = 1, 1\\n        nums = list(set(nums))\\n        nums.sort()\\n        while i < len(nums) - 1:\\n            if nums[i + 1] - nums[i] == 1:\\n                cur_max_len += 1\\n            else:\\n                cur_max_len = 1\\n            i += 1\\n            if cur_max_len > max_len:\\n                max_len = cur_max_len\\n        return max_len if nums != [] else 0\\n```"
    },
    {
        "slug": "intersection-of-two-arrays",
        "tags": "python3",
        "release_time": 1674679197,
        "code": "class Solution:\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        ans=[]\n        dc=defaultdict(lambda:0)\n        for a in nums1:\n            dc[a]=1\n        nums2=set(nums2)\n        for a in nums2:\n            if(dc[a]==1):\n                ans.append(a)\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def intersection(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        ans=[]\\n        dc=defaultdict(lambda:0)\\n        for a in nums1:\\n            dc[a]=1\\n        nums2=set(nums2)\\n        for a in nums2:\\n            if(dc[a]==1):\\n                ans.append(a)\\n        return ans\\n```"
    },
    {
        "slug": "restore-the-array-from-adjacent-pairs",
        "tags": "python3",
        "release_time": 1612065696,
        "code": "class Solution:\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\n        graph = {}\n        for u, v in adjacentPairs: \n            graph.setdefault(u, []).append(v)\n            graph.setdefault(v, []).append(u)\n        \n        ans = []\n        seen = set()\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\n        while stack: \n            n = stack.pop()\n            ans.append(n)\n            seen.add(n)\n            for nn in graph[n]: \n                if nn not in seen: stack.append(nn)\n        return ans",
        "content": "**Algo**\\nThe structure here is a doubly-linked list. But we can treat it as a graph. Create an adjacency list representation from `adjacentPairs`. Starting from a edge node (with 1 neighbor), traverse the graph to collect values in an array. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:\\n        graph = {}\\n        for u, v in adjacentPairs: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        ans = []\\n        seen = set()\\n        stack = [next(x for x in graph if len(graph[x]) == 1)]\\n        while stack: \\n            n = stack.pop()\\n            ans.append(n)\\n            seen.add(n)\\n            for nn in graph[n]: \\n                if nn not in seen: stack.append(nn)\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`"
    },
    {
        "slug": "root-equals-sum-of-children",
        "tags": "python3",
        "release_time": 1675319094,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\n        return root.val==root.left.val + root.right.val",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```"
    },
    {
        "slug": "valid-palindrome-ii",
        "tags": "python3",
        "release_time": 1692166184,
        "code": "class Solution:\n    def validPalindrome(self, s: str) -> bool:\n        if s == s[::-1]: return True\n        low,high = 0,len(s) - 1\n        c = 0\n        while low < high:\n            t1,t2 = s[low],s[high]\n            if t1 == t2:\n                low += 1\n                high -= 1\n            else:\n                temp1 = s[0:low] + s[low+1:]\n                temp2 = s[0:high] + s[high+1:]\n                if temp1 == temp1[::-1]: return True\n                elif temp2 == temp2[::-1]: return True\n                else:\n                    return False\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def validPalindrome(self, s: str) -> bool:\\n        if s == s[::-1]: return True\\n        low,high = 0,len(s) - 1\\n        c = 0\\n        while low < high:\\n            t1,t2 = s[low],s[high]\\n            if t1 == t2:\\n                low += 1\\n                high -= 1\\n            else:\\n                temp1 = s[0:low] + s[low+1:]\\n                temp2 = s[0:high] + s[high+1:]\\n                if temp1 == temp1[::-1]: return True\\n                elif temp2 == temp2[::-1]: return True\\n                else:\\n                    return False\\n        return True\\n\\n```"
    },
    {
        "slug": "range-sum-query-immutable",
        "tags": "python3",
        "release_time": 1674748439,
        "code": "class NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.nums=[0]+list(accumulate(nums))\n        print(self.nums)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.nums[right+1]-self.nums[left]\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```"
    },
    {
        "slug": "sort-an-array",
        "tags": "python3",
        "release_time": 1677688962,
        "code": "from random import randint as ri\nclass Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing inbuilt function, heap/priorityqueue sort and merger sort we can solve this.\\n\\n# Approach 1: Inbuilt function\\n- used python\\'s inbuilt fastest sorting function **TimeSort**\\n![Capture.PNG](https://assets.leetcode.com/users/images/06aa2b51-7890-4821-b880-e8c7421ad855_1677688428.8423078.png)\\n\\n```\\nfrom random import randint as ri\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n---\\n# Approach 2: PriorityQueue\\n- python\\'s priority queue uses heap structure\\n- so we know popping from heap always gives sorted array.\\n![Capture.PNG](https://assets.leetcode.com/users/images/449a84a5-cea1-43fb-adb1-b516b800b31b_1677688874.0392013.png)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity: O(2N)\\n# Code\\n```\\nfrom queue import PriorityQueue as pq\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        q = pq()\\n        for i in nums: q.put(i)\\n        for i in range(len(nums)): nums[i] = q.get()\\n        return nums\\n```\\n---\\n# Approach 3: MergeSort\\n- using mergesort we can solve this\\n- mergesort will take same time no matter what input is so this makes it easy when we have sorted array as input.\\n- and stack load is also fixed.\\n![Capture.PNG](https://assets.leetcode.com/users/images/e388ad68-4e20-4e34-a455-c66b2fd6b3b3_1677688912.2943568.png)\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity: O(N)\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        def mergesort(arr = nums):\\n            if len(arr) - 1:\\n                mid = len(arr) // 2\\n                left = arr[:mid]\\n                right = arr[mid:]\\n                mergesort(left)\\n                mergesort(right)\\n\\n                i = j = k = 0\\n\\n                while i < len(left) and j < len(right):\\n                    if left[i] <= right[j]:\\n                        arr[k] = left[i]\\n                        i += 1\\n                    else:\\n                        arr[k] = right[j]\\n                        j += 1\\n                    k += 1\\n                \\n                while i < len(left):\\n                    arr[k] = left[i]\\n                    i += 1\\n                    k += 1\\n                \\n                while j < len(right):\\n                    arr[k] = right[j]\\n                    j += 1\\n                    k += 1\\n        mergesort()\\n        return nums\\n```\\n# please like and comment :-)"
    },
    {
        "slug": "sliding-puzzle",
        "tags": "python3",
        "release_time": 1673813066,
        "code": "class Solution:\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\n        def get_neighbors(board):\n            neighbors = []\n            r, c = 0, 0\n            for i in range(2):\n                for j in range(3):\n                    if board[i][j] == 0:\n                        r, c = i, j\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_r, new_c = r + i, c + j\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\n                    new_board = [row[:] for row in board]\n                    new_board[r][c] = new_board[new_r][new_c]\n                    new_board[new_r][new_c] = 0\n                    neighbors.append(new_board)\n            return neighbors\n\n        queue = deque()\n        queue.append((board, 0))\n        seen = set()\n        seen.add(tuple(tuple(row) for row in board))\n\n        while queue:\n            board, moves = queue.popleft()\n            if board == [[1, 2, 3], [4, 5, 0]]:\n                return moves\n            for neighbor in get_neighbors(board):\n                if tuple(tuple(row) for row in neighbor) not in seen:\n                    queue.append((neighbor, moves + 1))\n                    seen.add(tuple(tuple(row) for row in neighbor))\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is that this problem can be solved using a breadth-first search (BFS) algorithm, where we start with the initial board state and explore all possible moves (by swapping the empty space with its neighboring tiles) until we reach the desired board state.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a BFS algorithm to explore all possible moves from the initial board state. The function starts by initializing a queue and adding the initial board state and the number of moves (0) to the queue. It also initializes a set to keep track of the board states that have already been seen. The function then enters a while loop that continues until the queue is empty. In each iteration, the function takes the first board state and move count from the queue, and checks if the board state is the desired state. If it is, the function returns the number of moves. If not, the function uses a helper function get_neighbors to find all possible moves (by swapping the empty space with its neighboring tiles) and adds them to the queue. The function also adds the new board states to the set of seen states. If the queue becomes empty, the function returns -1 indicating that the desired board state was not reached.\\n\\n\\n# Complexity\\n- Time complexity: $$O(mn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def slidingPuzzle(self, board: List[List[int]]) -> int:\\n        def get_neighbors(board):\\n            neighbors = []\\n            r, c = 0, 0\\n            for i in range(2):\\n                for j in range(3):\\n                    if board[i][j] == 0:\\n                        r, c = i, j\\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                new_r, new_c = r + i, c + j\\n                if 0 <= new_r < 2 and 0 <= new_c < 3:\\n                    new_board = [row[:] for row in board]\\n                    new_board[r][c] = new_board[new_r][new_c]\\n                    new_board[new_r][new_c] = 0\\n                    neighbors.append(new_board)\\n            return neighbors\\n\\n        queue = deque()\\n        queue.append((board, 0))\\n        seen = set()\\n        seen.add(tuple(tuple(row) for row in board))\\n\\n        while queue:\\n            board, moves = queue.popleft()\\n            if board == [[1, 2, 3], [4, 5, 0]]:\\n                return moves\\n            for neighbor in get_neighbors(board):\\n                if tuple(tuple(row) for row in neighbor) not in seen:\\n                    queue.append((neighbor, moves + 1))\\n                    seen.add(tuple(tuple(row) for row in neighbor))\\n        return -1\\n```"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
        "tags": "python3",
        "release_time": 1673716882,
        "code": "class Solution:\n    # def dp(self,i,buy,prices,n,dct):\n    #     if i>=n:\n    #         return 0\n    #     if (i,buy) in dct:\n    #         return dct[(i,buy)]\n    #     if buy:\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+1,0,prices,n,dct)-prices[i])\n    #     else:\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+2,1,prices,n,dct)+prices[i])\n    #     dct[(i,buy)]=x\n    #     return x\n\n    def maxProfit(self, prices: List[int]) -> int:\n        n=len(prices)\n        # dp=[[0]*2 for i in range(n+2)]\n        ahd=[0]*2\n        ahd2=[0]*2\n        for i in range(n-1,-1,-1):\n            curr=[0]*2\n            for buy in range(2):\n                if buy:\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\n                else:\n                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])\n            ahd2=ahd[:]\n            ahd=curr[:]\n        return ahd[1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O((N+2)*2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O((N+2)*2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    # def dp(self,i,buy,prices,n,dct):\\n    #     if i>=n:\\n    #         return 0\\n    #     if (i,buy) in dct:\\n    #         return dct[(i,buy)]\\n    #     if buy:\\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+1,0,prices,n,dct)-prices[i])\\n    #     else:\\n    #         x=max(self.dp(i+1,buy,prices,n,dct),self.dp(i+2,1,prices,n,dct)+prices[i])\\n    #     dct[(i,buy)]=x\\n    #     return x\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        # dp=[[0]*2 for i in range(n+2)]\\n        ahd=[0]*2\\n        ahd2=[0]*2\\n        for i in range(n-1,-1,-1):\\n            curr=[0]*2\\n            for buy in range(2):\\n                if buy:\\n                    curr[buy]=max(ahd[buy],ahd[0]-prices[i])\\n                else:\\n                    curr[buy]=max(ahd[buy],ahd2[1]+prices[i])\\n            ahd2=ahd[:]\\n            ahd=curr[:]\\n        return ahd[1]\\n\\n```"
    },
    {
        "slug": "number-of-times-binary-string-is-prefix-aligned",
        "tags": "python3",
        "release_time": 1673915257,
        "code": "# Keep track of the largest bit that is on\n\nclass Solution:\n    def numTimesAllBlue(self, flips: List[int]) -> int:\n        largest_bit = 0\n        count = 0\n        for i, bit in enumerate(flips, 1):\n            largest_bit = max(largest_bit, bit)\n            if largest_bit == i:\n                count += 1\n        return count",
        "content": "# Intuition\\nTo solve this problem we need to note one intricacy that will always hold true\\n* Each bit only appears in `flips` once. \\n* Therefore, if bit x is on (one based), then it is only possible to be \"Prefix-Aligned\" if we are on flip x (also one based). \\n\\nWe can now keep track of the largest bit, and the number of flips. After each flip we can check if it is possible to be \"Prefix-Aligned\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* To keep the book keeping simple, we will count the number of flips starting at 1\\n* `largest_bit` will keep track of the largest bit\\n* `count` will keep track of the number of times we have been \"Prefix-Aligned\"\\n\\n# Complexity\\n- Time complexity `O(|flips|)`:\\nSingle pass through all the flips\\n\\n- Space complexity `O(1)`:\\nA few constant variables\\n\\n# Code\\n```\\n# Keep track of the largest bit that is on\\n\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        largest_bit = 0\\n        count = 0\\n        for i, bit in enumerate(flips, 1):\\n            largest_bit = max(largest_bit, bit)\\n            if largest_bit == i:\\n                count += 1\\n        return count\\n```"
    },
    {
        "slug": "complement-of-base-10-integer",
        "tags": "python3",
        "release_time": 1679441842,
        "code": "class Solution:\n    def bitwiseComplement(self, n: int) -> int:\n        return (int((bin(n)[2:]).replace('1', '2').replace('0','1').replace('2','0'),2))\n\n        return (int((bin(n)[2:]).translate(str.maketrans(\"01\", \"10\")),2))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def bitwiseComplement(self, n: int) -> int:\\n        return (int((bin(n)[2:]).replace(\\'1\\', \\'2\\').replace(\\'0\\',\\'1\\').replace(\\'2\\',\\'0\\'),2))\\n\\n        return (int((bin(n)[2:]).translate(str.maketrans(\"01\", \"10\")),2))\\n```"
    },
    {
        "slug": "grid-game",
        "tags": "python3",
        "release_time": 1687022285,
        "code": "class Solution:\n    def gridGame(self, grid: List[List[int]]) -> int: \n        result = float(\"inf\")\n        left,right = 0,sum(grid[0])\n\n        for a,b in zip(grid[0],grid[1]):\n            right-=a\n\n            result = min(result,max(left,right))\n            left+=b\n        \n        return result\n\n# time & space - O(n),O(1)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def gridGame(self, grid: List[List[int]]) -> int: \\n        result = float(\"inf\")\\n        left,right = 0,sum(grid[0])\\n\\n        for a,b in zip(grid[0],grid[1]):\\n            right-=a\\n\\n            result = min(result,max(left,right))\\n            left+=b\\n        \\n        return result\\n\\n# time & space - O(n),O(1)\\n\\n\\n```"
    },
    {
        "slug": "minimum-interval-to-include-each-query",
        "tags": "python3",
        "release_time": 1664733995,
        "code": "class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n\t\n        queries_asc = sorted((q, i) for i, q in enumerate(queries))\n        intervals.sort()\n        \n        i, num_intervals = 0, len(intervals)\n        size_heap = [] # (size, left)\n        \n        for pos, qnum in queries_asc:\n            \n            while i < num_intervals:\n                left, right = intervals[i]\n                if left > pos:\n                    break\n                heapq.heappush(size_heap, (right - left + 1, left))\n                i += 1\n            \n            while size_heap:\n                size, left = size_heap[0]\n                right = left + size - 1\n                if right >= pos:\n                    break\n                heapq.heappop(size_heap)\n                   \n            queries[qnum] = size_heap[0][0] if size_heap else -1\n        \n        return queries",
        "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\n        queries_asc = sorted((q, i) for i, q in enumerate(queries))\\n        intervals.sort()\\n        \\n        i, num_intervals = 0, len(intervals)\\n        size_heap = [] # (size, left)\\n        \\n        for pos, qnum in queries_asc:\\n            \\n            while i < num_intervals:\\n                left, right = intervals[i]\\n                if left > pos:\\n                    break\\n                heapq.heappush(size_heap, (right - left + 1, left))\\n                i += 1\\n            \\n            while size_heap:\\n                size, left = size_heap[0]\\n                right = left + size - 1\\n                if right >= pos:\\n                    break\\n                heapq.heappop(size_heap)\\n                   \\n            queries[qnum] = size_heap[0][0] if size_heap else -1\\n        \\n        return queries"
    },
    {
        "slug": "sort-an-array",
        "tags": "python3",
        "release_time": 1677727583,
        "code": "class Solution:\n    def sortArray(self, nums: List[int]) -> List[int]:\n        nums.sort()\n        return nums",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPython has a built in sort() function that can sort the list for you if you don\\'t want to learn sorting algorithms.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust run list.sort() on its own line and return the list. It\\'s that simple.\\n\\n# Code\\n```\\nclass Solution:\\n    def sortArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        return nums\\n```"
    },
    {
        "slug": "largest-number-after-digit-swaps-by-parity",
        "tags": "python3",
        "release_time": 1672166650,
        "code": "class Solution:\n    def largestInteger(self, num: int) -> int:\n        evenlist=[]\n        oddlist=[]\n        nums= [int(x) for x in str(num)]\n        for i in nums:\n            if i%2==0:\n                evenlist.append(i)\n            else:\n                oddlist.append(i)\n        even= [-x for x in evenlist]\n        odd = [-x for x in oddlist]\n        heapq.heapify(even)\n        heapq.heapify(odd)\n        result=[]\n        for ele in nums:\n            if ele in evenlist:\n                result+=[-heapq.heappop(even)]\n            if ele in oddlist:\n                result+=[-heapq.heappop(odd)]\n        result =[str(x) for x in result]                \n        return int(''.join(result))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def largestInteger(self, num: int) -> int:\\n        evenlist=[]\\n        oddlist=[]\\n        nums= [int(x) for x in str(num)]\\n        for i in nums:\\n            if i%2==0:\\n                evenlist.append(i)\\n            else:\\n                oddlist.append(i)\\n        even= [-x for x in evenlist]\\n        odd = [-x for x in oddlist]\\n        heapq.heapify(even)\\n        heapq.heapify(odd)\\n        result=[]\\n        for ele in nums:\\n            if ele in evenlist:\\n                result+=[-heapq.heappop(even)]\\n            if ele in oddlist:\\n                result+=[-heapq.heappop(odd)]\\n        result =[str(x) for x in result]                \\n        return int(\\'\\'.join(result))\\n\\n\\n                    \\n\\n\\n        \\n\\n\\n```"
    },
    {
        "slug": "count-the-number-of-square-free-subsets",
        "tags": "python3",
        "release_time": 1676780340,
        "code": "class Solution:\n    def squareFreeSubsets(self, nums: List[int]) -> int:\n        sq = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\n        \n        def gcd(a, b):\n            while b != 0:\n                a, b = b, a % b\n            return a\n        \n        dic = {}\n        for i in nums:\n            if i in sq:\n                continue\n            tmp_dic = dict(dic)\n            for k in dic.keys():\n                if gcd(k, i) == 1:\n                    cur = k * i\n                    if cur in tmp_dic:\n                        tmp_dic[cur] += dic[k]\n                    else:\n                        tmp_dic[cur] = dic[k]\n            if i in tmp_dic:\n                tmp_dic[i] += 1\n            else:\n                tmp_dic[i] = 1\n            dic = tmp_dic\n        # print(dic)\n        return sum([dic[k] for k in dic.keys()]) % (10**9 + 7)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def squareFreeSubsets(self, nums: List[int]) -> int:\\n        sq = {4, 8, 9, 12, 16, 18, 20, 24, 25, 27, 28}\\n        \\n        def gcd(a, b):\\n            while b != 0:\\n                a, b = b, a % b\\n            return a\\n        \\n        dic = {}\\n        for i in nums:\\n            if i in sq:\\n                continue\\n            tmp_dic = dict(dic)\\n            for k in dic.keys():\\n                if gcd(k, i) == 1:\\n                    cur = k * i\\n                    if cur in tmp_dic:\\n                        tmp_dic[cur] += dic[k]\\n                    else:\\n                        tmp_dic[cur] = dic[k]\\n            if i in tmp_dic:\\n                tmp_dic[i] += 1\\n            else:\\n                tmp_dic[i] = 1\\n            dic = tmp_dic\\n        # print(dic)\\n        return sum([dic[k] for k in dic.keys()]) % (10**9 + 7)\\n\\n```"
    },
    {
        "slug": "average-value-of-even-numbers-that-are-divisible-by-three",
        "tags": "python3",
        "release_time": 1676326760,
        "code": "class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0",
        "content": "# Intuition\\nI wanted to solve this problem in **one line** using python, I figured this was the perfect use for the **Walrus Operator!**\\n\\n# Approach\\nI didn\\'t want any extra iterations, so we perform a list comprehention with only the values divisible by 6 (2 and 3) and use the walrus operator to store the comprehention in *lst*. Then, we can take the average as you would expect, accounting for dividing by zero using an in-line if statement.  \\n\\nIf you\\'ve never used the walrus operator before: https://realpython.com/python-walrus-operator/ \\n\\n# Complexity\\n- Time complexity:\\nO(n), we iterate over each item in the input list once. \\n\\n- Space complexity:\\nO(n), we store all elements divisible by both 2 and 3.\\n\\n# Code\\n\\n```\\nclass Solution:\\n    def averageValue(self, nums: List[int]) -> int:\\n        return int(sum(lst) / len(lst)) if len(lst := [num for num in nums if num % 6 == 0]) > 0 else 0 \\n```"
    },
    {
        "slug": "reachable-nodes-with-restrictions",
        "tags": "python3",
        "release_time": 1672637118,
        "code": "class Solution:\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\n        st=[0]\n        adj=[[] for _ in range(n)]\n        for i,j in edges:\n            adj[i].append(j)\n            adj[j].append(i)\n        visited=[0]*n\n        visited[0]=1\n        for i in restricted:\n            visited[i]=-1\n        ct=0\n        while st:\n            x=st.pop(0)\n            ct+=1\n            for i in adj[x]:\n                if visited[i]==0:\n                    st.append(i)\n                    visited[i]=1\n        return ct",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N+2E)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def reachableNodes(self, n: int, edges: List[List[int]], restricted: List[int]) -> int:\\n        st=[0]\\n        adj=[[] for _ in range(n)]\\n        for i,j in edges:\\n            adj[i].append(j)\\n            adj[j].append(i)\\n        visited=[0]*n\\n        visited[0]=1\\n        for i in restricted:\\n            visited[i]=-1\\n        ct=0\\n        while st:\\n            x=st.pop(0)\\n            ct+=1\\n            for i in adj[x]:\\n                if visited[i]==0:\\n                    st.append(i)\\n                    visited[i]=1\\n        return ct\\n\\n```"
    },
    {
        "slug": "chalkboard-xor-game",
        "tags": "python3",
        "release_time": 1684977873,
        "code": "class Solution:\n    def xorGame(self, nums: List[int]) -> bool:\n        xor=0\n        for item in nums:xor^=item\n        d={}\n        for item in nums:\n            if(item in d):\n                d[item]+=1\n            else:\n                d[item]=1\n        count=0\n        for item in d:\n            if(d[item]%2==0):\n                count+=2\n            else:\n                count+=1\n        return count%2==0 or xor==0",
        "content": "# Code\\n```\\nclass Solution:\\n    def xorGame(self, nums: List[int]) -> bool:\\n        xor=0\\n        for item in nums:xor^=item\\n        d={}\\n        for item in nums:\\n            if(item in d):\\n                d[item]+=1\\n            else:\\n                d[item]=1\\n        count=0\\n        for item in d:\\n            if(d[item]%2==0):\\n                count+=2\\n            else:\\n                count+=1\\n        return count%2==0 or xor==0\\n```"
    },
    {
        "slug": "subarray-sum-equals-k",
        "tags": "python3",
        "release_time": 1683181908,
        "code": "class Solution:\n\tdef subarraySum(self, nums: List[int], k: int) -> int:\n\n\t\tres=0\n\t\tpresum=0\n\t\tdict1={0:1}\n\n\t\tfor i in  nums:\n\t\t\tpresum = presum + i\n\n\t\t\tif (presum-k) in dict1:\n\t\t\t\tres = res + dict1[presum-k]\n\n\t\t\tif presum not in dict1:\n\t\t\t\tdict1[presum] = 1\n\t\t\telse:\n\t\t\t\tdict1[presum] = dict1[presum]+1\n\n\t\treturn res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing prefix sum and dictionary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef subarraySum(self, nums: List[int], k: int) -> int:\\n\\n\\t\\tres=0\\n\\t\\tpresum=0\\n\\t\\tdict1={0:1}\\n\\n\\t\\tfor i in  nums:\\n\\t\\t\\tpresum = presum + i\\n\\n\\t\\t\\tif (presum-k) in dict1:\\n\\t\\t\\t\\tres = res + dict1[presum-k]\\n\\n\\t\\t\\tif presum not in dict1:\\n\\t\\t\\t\\tdict1[presum] = 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdict1[presum] = dict1[presum]+1\\n\\n\\t\\treturn res\\n```"
    },
    {
        "slug": "longest-consecutive-sequence",
        "tags": "python3",
        "release_time": 1692597903,
        "code": "class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        if not nums:\n            return 0\n        nums_set = set(nums)\n        longest_streak = 0\n        for num in nums_set:\n            if num - 1 not in nums_set:  \n                current_num = num\n                current_streak = 1\n                while current_num + 1 in nums_set: \n                    current_num += 1\n                    current_streak += 1\n                longest_streak = max(longest_streak, current_streak)  \n        return longest_streak",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestConsecutive(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        nums_set = set(nums)\\n        longest_streak = 0\\n        for num in nums_set:\\n            if num - 1 not in nums_set:  \\n                current_num = num\\n                current_streak = 1\\n                while current_num + 1 in nums_set: \\n                    current_num += 1\\n                    current_streak += 1\\n                longest_streak = max(longest_streak, current_streak)  \\n        return longest_streak\\n\\n```"
    },
    {
        "slug": "available-captures-for-rook",
        "tags": "python3",
        "release_time": 1673542427,
        "code": "class Solution:\n    def numRookCaptures(self, board: List[List[str]]) -> int:\n        idx = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'R':\n                    idx = [i, j]\n                    break\n        x, y = idx[0], idx[1]\n        count = 0\n        for i in range(x-1, -1, -1):\n            if board[i][y] == 'p':\n                count+=1\n                break\n            elif board[i][y] == 'B':\n                break\n        \n        for i in range(x+1, 8):\n            if board[i][y] == 'p':\n                count+=1\n                break\n            elif board[i][y] == 'B':\n                break\n\n        for i in range(y-1, -1, -1):\n            if board[x][i] == 'p':\n                count+=1\n                break\n            elif board[x][i] == 'B':\n                break\n        \n        for i in range(y+1, 8):\n            if board[x][i] == 'p':\n                count+=1\n                break\n            elif board[x][i] == 'B':\n                break\n        return count",
        "content": "# Explanation:\\nFirst we try to find the position of Rook.\\nOnce we get that we already know that Rook always attacks in straight line i.e. Rows or Columns (not diagonals). So rather than traversing through the whole list we will only traverse through the rows and columns where Rook can attack. So we right 4 different for loops to traverse through rows and columns.\\n\\n# Complexity\\n- **Time complexity**: O(n^2) : As in worst case scenario the ROOK might be at position (7, 7)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numRookCaptures(self, board: List[List[str]]) -> int:\\n        idx = []\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'R\\':\\n                    idx = [i, j]\\n                    break\\n        x, y = idx[0], idx[1]\\n        count = 0\\n        for i in range(x-1, -1, -1):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n        \\n        for i in range(x+1, 8):\\n            if board[i][y] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[i][y] == \\'B\\':\\n                break\\n\\n        for i in range(y-1, -1, -1):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        \\n        for i in range(y+1, 8):\\n            if board[x][i] == \\'p\\':\\n                count+=1\\n                break\\n            elif board[x][i] == \\'B\\':\\n                break\\n        return count\\n\\n```\\n\\n# Learning\\nTo understand problems in simpler ways, need help with projects, want to learn coding from scratch, work on resume level projects, learn data science ...................\\n\\nSubscribe to Bolt Coding Channel - https://www.youtube.com/@boltcoding"
    },
    {
        "slug": "alternating-digit-sum",
        "tags": "python3",
        "release_time": 1691755636,
        "code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result=str(n)\n        sum=0\n        for i in range(len(result)):\n            if i%2 ==0:\n                sum=sum+int(result[i])\n            else:  \n                sum=sum-int(result[i])  \n        return sum",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def alternateDigitSum(self, n: int) -> int:\\n        result=str(n)\\n        sum=0\\n        for i in range(len(result)):\\n            if i%2 ==0:\\n                sum=sum+int(result[i])\\n            else:  \\n                sum=sum-int(result[i])  \\n        return sum        \\n```"
    },
    {
        "slug": "total-distance-traveled",
        "tags": "python3",
        "release_time": 1687890469,
        "code": "class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        d=0\n        while mainTank>0:\n            if mainTank>=5:\n                mainTank-=5\n                d+=5\n                if additionalTank>=1:\n                    additionalTank-=1\n                    mainTank+=1\n            if mainTank<5:\n                d+=mainTank\n                mainTank=0\n        return d*10",
        "content": "# Code\\n```\\nclass Solution:\\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\\n        d=0\\n        while mainTank>0:\\n            if mainTank>=5:\\n                mainTank-=5\\n                d+=5\\n                if additionalTank>=1:\\n                    additionalTank-=1\\n                    mainTank+=1\\n            if mainTank<5:\\n                d+=mainTank\\n                mainTank=0\\n        return d*10\\n```"
    },
    {
        "slug": "minimum-deletions-to-make-array-divisible",
        "tags": "python3",
        "release_time": 1672922632,
        "code": "class Solution:\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\n        gc=0\n        for i in numsDivide:\n            gc=int(math.gcd(gc,i))\n        nums.sort()\n        for i in range(len(nums)):\n            if gc%nums[i]==0:\n                return i\n        return -1",
        "content": "# Please upvote if it is helpful ^_^\\n*6Companies30days #ReviseWithArsh Challenge 2023\\nDay3\\nQ14. Deletions to make an array divisible.*\\n\\n**Intuition: *gcd***\\n![14.minimum-deletions-to-make-array-divisible.jpg](https://assets.leetcode.com/users/images/86f0dbdf-dfe7-41fb-b0a5-b6529a7477c6_1672922423.6993096.jpeg)\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def minOperations(self, nums: List[int], numsDivide: List[int]) -> int:\\n        gc=0\\n        for i in numsDivide:\\n            gc=int(math.gcd(gc,i))\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if gc%nums[i]==0:\\n                return i\\n        return -1\\n\\n```"
    },
    {
        "slug": "minimum-cost-to-make-all-characters-equal",
        "tags": "python3",
        "release_time": 1685247337,
        "code": "class Solution:\n    def minimumCost(self, s: str) -> int:\n        return sum(\n            min(i, len(s) - i)\n            for i, (a, b) in enumerate(pairwise(s), 1)\n            if a != b\n        )",
        "content": "# Intuition\\n\\nThe minimum cost can be found using a greedy approach based on each two-character substring.\\n\\n# Approach\\n\\nFocus on one two-character substring at a time. Assume the preceding characters match the first character and the following characters match the second.\\n\\nCase 1: ...000 **00** 000...\\n\\nSince all characters are equal, no operations are required.\\n\\nCase 2: ...000 **01** 111...\\n\\nSince the characters are not equal, an operation must be performed.\\n\\nSuppose the second character, **1**, has index `i`. \\n* The cost to inverse all the 0 bits would be `i - 1 + 1` where `i - 1` gives us the index of the first character, **0**, and the `+ 1` is the cost addend from the problem description.\\n* The cost to inverse all the 1 bits is simply `i`: the cost of inverting `i` to `n - i` as described in the description.\\n\\nThe remaining cases are `\"11\"` which follows the logic of Case 1 and `\"10\"` which follows the logic of Case 2.\\n\\n# Example\\n\\nUsing `\"0011\"` as an example.\\n\\nThe total minimum cost is built independently from the two-character cases described in the **Approach** section.\\n\\nSubstring 1: **00**11\\n\\n* The cost to make the strings equal is 0 as they are already equal.\\n* There are no preceding characters and thus there is no cost to make it equal to the first character, **0**.\\n* The succeeding characters, **11**, will have their cost to make equal to the second character, **0**, computed in the following iterations.\\n\\nSubstring 2: 0**01**1\\n\\n* The cost to make the strings equal is `min(i, len(s) - i) = min(2, 2) = 2`.\\n* The preceding characters, **0** has already had its cost to make equal to the first character, **0**, computed.\\n* As before, the cost to make the succeeding characters, **1**, equal to the second character, **1** will be computed in the following iterations.\\n\\nSubstring 3: 00**11**\\n\\n* Again, the cost to make the strings equal is 0 as they are already equal.\\n* As before the preceding characters, **00**, have had their minmum cost to make equal to the first character, **1**, computed.\\n* There are no following characters and thus have no cost to make equal to the second character, **1**.\\n\\n# Complexity\\n\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n\\nThe minimum cost of each operation on a pair is considered.\\n* Case 1: The pairs that are equal are filtered out.\\n* Case 2: The minimum operation cost to make all characters equal is calculated.\\n  * The first operation type is simplified from `i - 1 + 1` to `i`.\\n\\n```\\nclass Solution:\\n    def minimumCost(self, s: str) -> int:\\n        return sum(\\n            min(i, len(s) - i)\\n            for i, (a, b) in enumerate(pairwise(s), 1)\\n            if a != b\\n        )\\n```"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "tags": "python3",
        "release_time": 1670607233,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        self.ans = 0\n\n        def dfs(node, mn, mx):\n            mx = max(mx, node.val)\n            mn = min(mn, node.val)\n            self.ans = max( self.ans , abs( mx - mn ) )\n            if node.left:\n                dfs(node.left, mn, mx)\n            if node.right:\n                dfs(node.right, mn, mx)\n        \n        dfs(root, root.val, root.val)\n\n        return self.ans",
        "content": "# Intuition\\nUsing DFS, we find the min and max values and their absolute difference in all the paths from root to leaf nodes.\\n\\n# Approach\\nSolved using DFS Traversal of the Binary Tree.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        self.ans = 0\\n\\n        def dfs(node, mn, mx):\\n            mx = max(mx, node.val)\\n            mn = min(mn, node.val)\\n            self.ans = max( self.ans , abs( mx - mn ) )\\n            if node.left:\\n                dfs(node.left, mn, mx)\\n            if node.right:\\n                dfs(node.right, mn, mx)\\n        \\n        dfs(root, root.val, root.val)\\n\\n        return self.ans\\n```"
    },
    {
        "slug": "sum-of-subarray-minimums",
        "tags": "python3",
        "release_time": 1669346822,
        "code": "class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n=len(arr)\n        left=[1]*n\n        dec_q=[(arr[0],1)]\n        for i in range(1,n):\n            while dec_q and arr[i]<=dec_q[-1][0]:\n                left[i]+=dec_q.pop()[1]\n                \n            dec_q.append((arr[i],left[i]))\n        right=[1]*n\n        dec_q=[(arr[-1],1)]\n        for i in range(n-2,-1,-1):\n            while dec_q and arr[i]<dec_q[-1][0]:\n                right[i]+=dec_q.pop()[1]\n                \n            dec_q.append((arr[i], right[i]))\n            \n        ans=0\n        for i in range(n):\n            ans+=arr[i]*left[i]*right[i]\n            \n        mod=10**9+7\n        return ans%mod",
        "content": "\\n```\\nclass Solution:\\n    def sumSubarrayMins(self, arr: List[int]) -> int:\\n        n=len(arr)\\n        left=[1]*n\\n        dec_q=[(arr[0],1)]\\n        for i in range(1,n):\\n            while dec_q and arr[i]<=dec_q[-1][0]:\\n                left[i]+=dec_q.pop()[1]\\n                \\n            dec_q.append((arr[i],left[i]))\\n        right=[1]*n\\n        dec_q=[(arr[-1],1)]\\n        for i in range(n-2,-1,-1):\\n            while dec_q and arr[i]<dec_q[-1][0]:\\n                right[i]+=dec_q.pop()[1]\\n                \\n            dec_q.append((arr[i], right[i]))\\n            \\n        ans=0\\n        for i in range(n):\\n            ans+=arr[i]*left[i]*right[i]\\n            \\n        mod=10**9+7\\n        return ans%mod\\n```"
    },
    {
        "slug": "closest-dessert-cost",
        "tags": "python3",
        "release_time": 1614485176,
        "code": "class Solution:\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\n        toppingCosts *= 2\n        \n        @cache\n        def fn(i, x):\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\n            if x < 0 or i == len(toppingCosts): return 0\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\n        \n        ans = inf\n        for bc in baseCosts: \n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        toppingCosts *= 2\\n        \\n        @cache\\n        def fn(i, x):\\n            \"\"\"Return sum of subsequence of toppingCosts[i:] closest to x.\"\"\"\\n            if x < 0 or i == len(toppingCosts): return 0\\n            return min(fn(i+1, x), toppingCosts[i] + fn(i+1, x-toppingCosts[i]), key=lambda y: (abs(y-x), y))\\n        \\n        ans = inf\\n        for bc in baseCosts: \\n            ans = min(ans, bc + fn(0, target - bc), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(MNV)`\\n\\nEdited on 2/28/2021\\n\\nAdding the version by @lenchen1112\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        \\n        @cache\\n        def fn(i, cost):\\n            \"\"\"Return sum of subsequence closest to target.\"\"\"\\n            if cost >= target or i == len(toppingCosts): return cost\\n            return min(fn(i+1, cost), fn(i+1, cost+toppingCosts[i]), key=lambda x: (abs(x-target), x))\\n        \\n        ans = inf\\n        toppingCosts *= 2\\n        for cost in baseCosts: \\n            ans = min(ans, fn(0, cost), key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\n\\nAdding binary search implementation\\n```\\nclass Solution:\\n    def closestCost(self, baseCosts: List[int], toppingCosts: List[int], target: int) -> int:\\n        top = {0}\\n        for x in toppingCosts*2: \\n            top |= {x + xx for xx in top}\\n        top = sorted(top)\\n        \\n        ans = inf \\n        for bc in baseCosts: \\n            k = bisect_left(top, target - bc)\\n            if k < len(top): ans = min(ans, bc + top[k], key=lambda x: (abs(x-target), x))\\n            if k: ans = min(ans, bc + top[k-1], key=lambda x: (abs(x-target), x))\\n        return ans \\n```\\nTime complexity `O(N*2^(2N) + MN)`"
    },
    {
        "slug": "find-target-indices-after-sorting-array",
        "tags": "python3",
        "release_time": 1690911718,
        "code": "class Solution:\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\n        lessThanEqual = 0\n        onlyLess = 0\n        for i in nums:\n            if i <= target:\n                lessThanEqual += 1\n            if i < target:\n                onlyLess += 1\n        return list(range(onlyLess, lessThanEqual))",
        "content": "# Intuition\\nwe dont need actual indices, we dont care about sequence or order so we don\\'t need sort.\\nbinary search \\n# Approach\\nJust count number of elements which are less than or equal to given target. say lessThanOrEqualCount\\nThen count number of elements which are strictly less than given target onlyLessThanCount\\n\\nif lessThanOrEqualCount = onlyLessThanCount: return empty\\nor else all numbers between them\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity: O(1)\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def targetIndices(self, nums: List[int], target: int) -> List[int]:\\n        lessThanEqual = 0\\n        onlyLess = 0\\n        for i in nums:\\n            if i <= target:\\n                lessThanEqual += 1\\n            if i < target:\\n                onlyLess += 1\\n        return list(range(onlyLess, lessThanEqual))\\n```\\n\\nPlease upvote if you like the solution.\\n"
    },
    {
        "slug": "relative-sort-array",
        "tags": "python3",
        "release_time": 1675360896,
        "code": "class Solution:\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        ans = []\n        for i in arr2:\n            while i in arr1:\n                arr1.remove(i)\n                ans.append(i)\n\n        ans+=sorted(arr1)\n        return ans",
        "content": "\\n\\n# Approach\\n    For every element in arr2, we remove all the occurences of  element from the arr1 . Add the remaining elements of arr1 to result in sorted manner\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def relativeSortArray(self, arr1: List[int], arr2: List[int]) -> List[int]:\\n        ans = []\\n        for i in arr2:\\n            while i in arr1:\\n                arr1.remove(i)\\n                ans.append(i)\\n\\n        ans+=sorted(arr1)\\n        return ans\\n```"
    },
    {
        "slug": "partition-equal-subset-sum",
        "tags": "python3",
        "release_time": 1680164155,
        "code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        def rec(i,rsum ):\n            if(rsum==0): return True\n            if(i==len(nums) or rsum < 0): return False \n            elif(self.dp[i][rsum] != -1 ):\n                return self.dp[i][rsum]\n            self.dp[i][rsum]= rec(i+1,rsum-nums[i]) or rec(i+1,rsum)\n            return self.dp[i][rsum]\n        \n        \n        totalsum = sum(nums)\n        if(totalsum%2): return False \n        else: \n            self.dp = [ [-1]*((totalsum//2)+1) for _ in range(len(nums))]\n            return rec(0,totalsum//2)",
        "content": "```\\nclass Solution:\\n    def canPartition(self, nums: List[int]) -> bool:\\n        def rec(i,rsum ):\\n            if(rsum==0): return True\\n            if(i==len(nums) or rsum < 0): return False \\n            elif(self.dp[i][rsum] != -1 ):\\n                return self.dp[i][rsum]\\n            self.dp[i][rsum]= rec(i+1,rsum-nums[i]) or rec(i+1,rsum)\\n            return self.dp[i][rsum]\\n        \\n        \\n        totalsum = sum(nums)\\n        if(totalsum%2): return False \\n        else: \\n            self.dp = [ [-1]*((totalsum//2)+1) for _ in range(len(nums))]\\n            return rec(0,totalsum//2)\\n```"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "tags": "python3",
        "release_time": 1669544244,
        "code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        n = len(nums);ans = 0\n        dp = defaultdict(Counter)\n        for i in range(1,n):\n            for j in range(i):\n                d = nums[i] - nums[j]\n                dp[i][d] += dp[j][d] + 1\n            ans += sum(dp[i].values()) - i\n        return ans",
        "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n**2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n**2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        n = len(nums);ans = 0\\n        dp = defaultdict(Counter)\\n        for i in range(1,n):\\n            for j in range(i):\\n                d = nums[i] - nums[j]\\n                dp[i][d] += dp[j][d] + 1\\n            ans += sum(dp[i].values()) - i\\n        return ans\\n```"
    },
    {
        "slug": "string-matching-in-an-array",
        "tags": "python3",
        "release_time": 1586666769,
        "code": "class Solution:\n    def stringMatching(self, words: List[str]) -> List[str]:\n        def add(word: str):\n            node = trie\n            for c in word:\n                node = node.setdefault(c, {})\n\n        def get(word: str) -> bool:\n            node = trie\n            for c in word:\n                if (node := node.get(c)) is None: return False\n            return True\n\n        words.sort(key=len, reverse=True)\n        trie, result = {}, []\n        for word in words:\n            if get(word): result.append(word)\n            for i in range(len(word)):\n                add(word[i:])\n        return result",
        "content": "Sort `words` with length first.\\nThen add all suffix for each word to the trie after checking its existence in it.\\n\\nTime: `O(NlogN + N * S^2)`, where `S` is the max length of all words.\\nNlogN for sorting and N * S^2 for build suffix trie.\\n\\nSpace: `O(N * S^2)` for suffix trie\\n```\\nclass Solution:\\n    def stringMatching(self, words: List[str]) -> List[str]:\\n        def add(word: str):\\n            node = trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n\\n        def get(word: str) -> bool:\\n            node = trie\\n            for c in word:\\n                if (node := node.get(c)) is None: return False\\n            return True\\n\\n        words.sort(key=len, reverse=True)\\n        trie, result = {}, []\\n        for word in words:\\n            if get(word): result.append(word)\\n            for i in range(len(word)):\\n                add(word[i:])\\n        return result\\n```\\n\\n--\\nUpdate:\\nThere is [another `O(N * S^2)` approach](https://leetcode.com/problems/string-matching-in-an-array/discuss/575916/Python-3-Crazy-Trie-Implementation-O(N*S2)) proposed by [`@serdes`](https://leetcode.com/serdes/).\\nIt utilizes counting on trie nodes in suffix trie and can prevent to perform sorting at first.\\nMy implementation by referring to this idea:\\n```\\nclass Solution:\\n    def stringMatching(self, words: List[str]) -> List[str]:\\n        def add(word: str):\\n            node = trie\\n            for c in word:\\n                node = node.setdefault(c, {})\\n                node[\\'#\\'] = node.get(\\'#\\', 0) + 1\\n\\n        def get(word: str) -> bool:\\n            node = trie\\n            for c in word:\\n                if (node := node.get(c)) is None: return False\\n            return node[\\'#\\'] > 1\\n\\n        trie = {}\\n        for word in words:\\n            for i in range(len(word)):\\n                add(word[i:])\\n        return [word for word in words if get(word)]\\n```"
    },
    {
        "slug": "merge-in-between-linked-lists",
        "tags": "python3",
        "release_time": 1677385209,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\n        lst1,lst2= [],[]\n        while list1:\n            lst1.append(list1.val)\n            list1 = list1.next\n        while list2:\n            lst2.append(list2.val)\n            list2 = list2.next\n        lst1[a:b+1]=lst2[:]\n        a = ListNode(0)\n        temp = a\n        for i in lst1:\n            temp.next = ListNode(i)\n            temp = temp.next\n        return a.next",
        "content": "# It would be really great if you guys upvote, if found the solution helpful.\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\\n        lst1,lst2= [],[]\\n        while list1:\\n            lst1.append(list1.val)\\n            list1 = list1.next\\n        while list2:\\n            lst2.append(list2.val)\\n            list2 = list2.next\\n        lst1[a:b+1]=lst2[:]\\n        a = ListNode(0)\\n        temp = a\\n        for i in lst1:\\n            temp.next = ListNode(i)\\n            temp = temp.next\\n        return a.next\\n```"
    },
    {
        "slug": "best-time-to-buy-and-sell-stock-ii",
        "tags": "python3",
        "release_time": 1688875218,
        "code": "class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if len(prices) < 2:\n            return 0\n        if len(prices) == 2:\n            output = prices[1] - prices[0]\n            return output if output > 0 else 0\n        i = 0\n        j = 1\n        stockBuy = prices[i]\n        stockSell = prices[j]\n        counter = 0\n        profit = 0\n        while counter < len(prices)-2:\n            if stockSell - stockBuy < 0:\n                i = counter + 1\n                j = i + 1\n            else:\n                if prices[j+1] > prices[j]:\n                    j += 1\n                else:\n                    profit = profit + (stockSell - stockBuy)\n                    i = counter + 1\n                    j = i + 1\n\n            stockSell = prices[j]\n            stockBuy = prices[i]\n            counter += 1\n        if (stockSell - stockBuy) > 0:\n            profit = profit + (stockSell - stockBuy)\n        return profit",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices) < 2:\\n            return 0\\n        if len(prices) == 2:\\n            output = prices[1] - prices[0]\\n            return output if output > 0 else 0\\n        i = 0\\n        j = 1\\n        stockBuy = prices[i]\\n        stockSell = prices[j]\\n        counter = 0\\n        profit = 0\\n        while counter < len(prices)-2:\\n            if stockSell - stockBuy < 0:\\n                i = counter + 1\\n                j = i + 1\\n            else:\\n                if prices[j+1] > prices[j]:\\n                    j += 1\\n                else:\\n                    profit = profit + (stockSell - stockBuy)\\n                    i = counter + 1\\n                    j = i + 1\\n\\n            stockSell = prices[j]\\n            stockBuy = prices[i]\\n            counter += 1\\n        if (stockSell - stockBuy) > 0:\\n            profit = profit + (stockSell - stockBuy)\\n        return profit \\n```"
    },
    {
        "slug": "minimum-common-value",
        "tags": "python3",
        "release_time": 1688551451,
        "code": "class Solution:\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\n        i,j = 0,0\n        n,m = len(nums1), len(nums2)\n        while i<n and j<m:\n            if nums1[i]<nums2[j]:\n                i+=1\n            elif nums1[i]>nums2[j]:\n                j+=1\n            else:\n                return nums1[i]\n        return -1",
        "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n\\n\\n# Intuition\\nThe problem asks us to find the minimum integer common to two sorted arrays. We can use a two-pointer technique to compare the elements of the two arrays and find the first common integer.\\n\\n# Approach\\n1. Initialize two pointers `i` and `j` to 0, representing the current indices in `nums1` and `nums2`, respectively.\\n2. Initialize variables `n` and `m` to the lengths of `nums1` and `nums2`, respectively.\\n3. Use a while loop to iterate until either pointer reaches the end of its respective array.\\n4. If `nums1[i]` is less than `nums2[j]`, increment `i`.\\n5. If `nums1[i]` is greater than `nums2[j]`, increment `j`.\\n6. Otherwise, return `nums1[i]`.\\n7. If the loop terminates without finding a common integer, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(n + m)$$, where $$n$$ and $$m$$ are the lengths of the two arrays.\\n- Space complexity: $$O(1)$$, as we only need constant extra space for the pointers and variables.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def getCommon(self, nums1: List[int], nums2: List[int]) -> int:\\n        i,j = 0,0\\n        n,m = len(nums1), len(nums2)\\n        while i<n and j<m:\\n            if nums1[i]<nums2[j]:\\n                i+=1\\n            elif nums1[i]>nums2[j]:\\n                j+=1\\n            else:\\n                return nums1[i]\\n        return -1\\n```"
    },
    {
        "slug": "minimum-index-sum-of-two-lists",
        "tags": "python3",
        "release_time": 1671462500,
        "code": "class Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n        for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1",
        "content": "# Intuition\\nbeats 99.9%\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      n(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\\n        d2={}\\n        l=[]\\n        for i in range(len(list2)):\\n            d2[list2[i]]=i\\n        for i in range(len(list1)):\\n            if list1[i] in d2:\\n                l.append([i+d2[list1[i]],list1[i]])\\n        l1=[]\\n        l.sort()\\n        l1.append(l[0][1])\\n        for i in range(1,len(l)):\\n            if l[i][0]==l[i-1][0]:\\n                l1.append(l[i][1])\\n            else:\\n                break\\n        return l1\\n        \\n```"
    },
    {
        "slug": "palindrome-partitioning-iii",
        "tags": "python3",
        "release_time": 1663513046,
        "code": "class Solution:\n    def palindromePartition(self, s: str, k: int) -> int:\n        \n        \n\t\t#This is the cost function \n        \n        def Cost(s):\n            i,j,c=0,len(s)-1,0\n            \n            while i<j:\n                if s[i]!=s[j]:c+=1\n                j-=1\n                i+=1\n            return c\n        \n        dp={}\n        \n\t\t# Recursion\n\t\t\n        def A(s,k):\n\t\t\t# Memoization\n            if (s,k) in dp:\n                return dp[(s,k)]\n\t\t\t# if k==1 then we want the whole string there is no other way \n            if k==1:\n                return Cost(s)\n            \n\t\t\t#intial value to max\n            f=float('inf')\n            \n            #start checking whole string \n            for x in range(1,len(s)+1):\n                #check wheather if both the strings exist.\n                if len(s[:x]) and len(s[x:]):\n\t\t\t\t\n                    #if exist we find the cost recursively assign min value \n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\n             #store the min value       \n            dp[(s,k)]=f\n\t\t\t\n            return dp[(s,k)]\n        return A(s,k)",
        "content": "```\\nclass Solution:\\n    def palindromePartition(self, s: str, k: int) -> int:\\n        \\n        \\n\\t\\t#This is the cost function \\n        \\n        def Cost(s):\\n            i,j,c=0,len(s)-1,0\\n            \\n            while i<j:\\n                if s[i]!=s[j]:c+=1\\n                j-=1\\n                i+=1\\n            return c\\n        \\n        dp={}\\n        \\n\\t\\t# Recursion\\n\\t\\t\\n        def A(s,k):\\n\\t\\t\\t# Memoization\\n            if (s,k) in dp:\\n                return dp[(s,k)]\\n\\t\\t\\t# if k==1 then we want the whole string there is no other way \\n            if k==1:\\n                return Cost(s)\\n            \\n\\t\\t\\t#intial value to max\\n            f=float(\\'inf\\')\\n            \\n            #start checking whole string \\n            for x in range(1,len(s)+1):\\n                #check wheather if both the strings exist.\\n                if len(s[:x]) and len(s[x:]):\\n\\t\\t\\t\\t\\n                    #if exist we find the cost recursively assign min value \\n                    f=min(f,Cost(s[:x])+A(s[x:],k-1))\\n             #store the min value       \\n            dp[(s,k)]=f\\n\\t\\t\\t\\n            return dp[(s,k)]\\n        return A(s,k)\\n                \\n                    \\n            \\n            ```"
    },
    {
        "slug": "duplicate-zeros",
        "tags": "python3",
        "release_time": 1674730208,
        "code": "class Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify arr in-place instead.\n        \"\"\"\n        l = len(arr)\n        i = 0\n        while i < l:\n            if arr[i] == 0:\n                arr.insert(i+1, 0)\n                arr.pop()\n                i += 1\n            i += 1",
        "content": "# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        i = 0\\n        while i < l:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 1\\n            i += 1               \\n```\\nDo upvote if you like the solution :)"
    },
    {
        "slug": "maximum-number-of-darts-inside-of-a-circular-dartboard",
        "tags": "python3",
        "release_time": 1589688784,
        "code": "class Solution:\n    def numPoints(self, points: List[List[int]], r: int) -> int:\n        ans = 1\n        for x, y in points: \n            angles = []\n            for x1, y1 in points: \n                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \n                    angle = atan2(y1-y, x1-x)\n                    delta = acos(d/(2*r))\n                    angles.append((angle-delta, +1)) #entry\n                    angles.append((angle+delta, -1)) #exit\n            angles.sort(key=lambda x: (x[0], -x[1]))\n            val = 1\n            for _, entry in angles: \n                ans = max(ans, val := val+entry)\n        return ans",
        "content": "Algo\\nPick a point, say P, from the set, and rotate a circle with fixed-radius `r`. During the rotation P lies on the circumference of the circle (note P is not the center) and maintain a count of the number of points in the circle at an angle \\u0398 (between PC and x-axis, where C is the center of the circle). \\n\\nFor every other point Q within `2*r` distance to P, compute the angle \\u0398 when Q enters the circle and the angle \\u0398 when Q exits the circle with math. Sort the angles and scan through it to check the maximum points in the circle. \\n\\nPerform the above operation for all points to find the maximum. \\n\\nImplementation (time complexity `O(N^2 logN)` | space complexity `O(N)`) \\n```\\nclass Solution:\\n    def numPoints(self, points: List[List[int]], r: int) -> int:\\n        ans = 1\\n        for x, y in points: \\n            angles = []\\n            for x1, y1 in points: \\n                if (x1 != x or y1 != y) and (d:=sqrt((x1-x)**2 + (y1-y)**2)) <= 2*r: \\n                    angle = atan2(y1-y, x1-x)\\n                    delta = acos(d/(2*r))\\n                    angles.append((angle-delta, +1)) #entry\\n                    angles.append((angle+delta, -1)) #exit\\n            angles.sort(key=lambda x: (x[0], -x[1]))\\n            val = 1\\n            for _, entry in angles: \\n                ans = max(ans, val := val+entry)\\n        return ans \\n```"
    },
    {
        "slug": "longest-happy-prefix",
        "tags": "python3",
        "release_time": 1672917990,
        "code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n=len(s)\n        lps=[0]*n\n        j=0\n        for i in range(1,n):\n            while s[i]!=s[j] and j>0:\n                j=lps[j-1]\n\n            if s[i]==s[j]:\n                lps[i]=j+1\n                j+=1\n\n        return s[:lps[-1]]",
        "content": "# Please upvote if it is helpful ^_^\\n***6Companies30days #ReviseWithArsh Challenge 2023\\nDay2\\nQ12. Longest Happy Prefix***\\n\\n**Approach:** *KMP Approach, DP*\\n\\n![12.longest-happy-prefix.jpg](https://assets.leetcode.com/users/images/368329ab-8eb6-4ddb-8c57-fc07336b759d_1672917737.342274.jpeg)\\n\\n**Complexity:** *O(M+N)*\\n\\n# Code\\n**Python3:**\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n=len(s)\\n        lps=[0]*n\\n        j=0\\n        for i in range(1,n):\\n            while s[i]!=s[j] and j>0:\\n                j=lps[j-1]\\n\\n            if s[i]==s[j]:\\n                lps[i]=j+1\\n                j+=1\\n\\n        return s[:lps[-1]]\\n```"
    },
    {
        "slug": "minimum-distance-to-the-target-element",
        "tags": "python3",
        "release_time": 1685865735,
        "code": "class Solution:\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\n        curVal=len(nums)\n        for i in range(start,len(nums)):\n            if nums[i]==target:\n                curVal=min(curVal,abs(i-start))\n                break\n        j=start\n        while(j>=0):\n            if nums[j]==target:\n                curVal=min(curVal,abs(j-start))\n                break\n            j-=1\n        return curVal",
        "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```"
    },
    {
        "slug": "max-sum-of-a-pair-with-equal-sum-of-digits",
        "tags": "python3",
        "release_time": 1686305725,
        "code": "class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        a = [[sum([int(x) for x in str(nums[i])]), nums[i]] for i in range(len(nums))]\n        mx = 0\n        b = [a[i][0] for i in range(len(a))]\n        if len(b) == len(set(b)): return -1\n\n        d = defaultdict(list)\n        for i in range(len(a)):\n            d[a[i][0]].append(a[i][1])\n\n        c = list(d.values())\n        for ar in c:\n            if len(ar) >= 2:\n                mx = max(sorted(ar)[-1]+sorted(ar)[-2], mx)\n        return mx",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        a = [[sum([int(x) for x in str(nums[i])]), nums[i]] for i in range(len(nums))]\\n        mx = 0\\n        b = [a[i][0] for i in range(len(a))]\\n        if len(b) == len(set(b)): return -1\\n\\n        d = defaultdict(list)\\n        for i in range(len(a)):\\n            d[a[i][0]].append(a[i][1])\\n\\n        c = list(d.values())\\n        for ar in c:\\n            if len(ar) >= 2:\\n                mx = max(sorted(ar)[-1]+sorted(ar)[-2], mx)\\n        return mx\\n        \\n\\n```"
    },
    {
        "slug": "di-string-match",
        "tags": "python3",
        "release_time": 1673472218,
        "code": "class Solution:\n    def diStringMatch(self, s: str) -> List[int]:\n        L,ic,dc=[],0,len(s)\n        for i in s:\n            if i=='I':\n                L.append(ic)\n                ic+=1\n            else:\n                L.append(dc)\n                dc-=1\n        if s[-1]=='I':L.append(ic)\n        else:L.append(dc)\n        return L",
        "content": "# Code\\n```\\nclass Solution:\\n    def diStringMatch(self, s: str) -> List[int]:\\n        L,ic,dc=[],0,len(s)\\n        for i in s:\\n            if i==\\'I\\':\\n                L.append(ic)\\n                ic+=1\\n            else:\\n                L.append(dc)\\n                dc-=1\\n        if s[-1]==\\'I\\':L.append(ic)\\n        else:L.append(dc)\\n        return L\\n```"
    },
    {
        "slug": "implement-stack-using-queues",
        "tags": "python3",
        "release_time": 1688825006,
        "code": "class MyStack:\n\n    def __init__(self):\n        self.queue = []\n\n    def push(self, x: int) -> None:\n        self.queue.append(x)\n\n    def pop(self) -> int:\n        return self.queue.pop()\n\n    def top(self) -> int:\n        return self.queue[-1]\n\n    def empty(self) -> bool:\n        return not self.queue\n\n\n# Your MyStack object will be instantiated and called as such:\n# obj = MyStack()\n# obj.push(x)\n# param_2 = obj.pop()\n# param_3 = obj.top()\n# param_4 = obj.empty()",
        "content": "\\n\\n# Complexity\\n- Time complexity:\\n91.54%\\n- Space complexity:\\n97.2%\\n# Code\\n```\\nclass MyStack:\\n\\n    def __init__(self):\\n        self.queue = []\\n\\n    def push(self, x: int) -> None:\\n        self.queue.append(x)\\n\\n    def pop(self) -> int:\\n        return self.queue.pop()\\n\\n    def top(self) -> int:\\n        return self.queue[-1]\\n\\n    def empty(self) -> bool:\\n        return not self.queue\\n\\n\\n# Your MyStack object will be instantiated and called as such:\\n# obj = MyStack()\\n# obj.push(x)\\n# param_2 = obj.pop()\\n# param_3 = obj.top()\\n# param_4 = obj.empty()\\n```"
    },
    {
        "slug": "palindromic-substrings",
        "tags": "python3",
        "release_time": 1679565915,
        "code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        sub = []\n        for indi, i in enumerate(s):\n            for indj, j in enumerate(s[indi:], start=indi):\n                if i == j and s[indi:indj+1] == s[indi:indj+1][::-1]:\n                    sub.append(s[indi:indj+1])\n        return len(sub)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubstrings(self, s: str) -> int:\\n        sub = []\\n        for indi, i in enumerate(s):\\n            for indj, j in enumerate(s[indi:], start=indi):\\n                if i == j and s[indi:indj+1] == s[indi:indj+1][::-1]:\\n                    sub.append(s[indi:indj+1])\\n        return len(sub)\\n```"
    },
    {
        "slug": "median-of-two-sorted-arrays",
        "tags": "python3",
        "release_time": 1691292624,
        "code": "class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        p1 = 0\n        p2 = 0\n        new = []\n        while p1 < len(nums1) and p2 < len(nums2):\n            if nums1[p1] < nums2[p2]:\n                new.append(nums1[p1])\n                p1 += 1\n            else:\n                new.append(nums2[p2])\n                p2 += 1\n        while p1 < len(nums1):\n            new.append(nums1[p1])\n            p1 += 1\n        while p2 < len(nums2):\n            new.append(nums2[p2])\n            p2+= 1\n        if len(new) % 2 == 0:\n            index = len(new) // 2\n            median = (new[index] + new[index-1]) / 2\n        else:\n            median = float(new[len(new)//2])\n        return median",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to merge the two sorted arrays while maintaining the order, and then finding the median based on the length of the merged array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two pointers, p1 and p2, for the two input arrays nums1 and nums2, respectively, both starting at index 0.\\n2. Create an empty list new to store the merged array.\\n3. Iterate through both arrays using the pointers. Compare the elements pointed to by p1 and p2. Append the smaller element to the new array and increment the corresponding pointer.\\n4. After the iteration, there might be remaining elements in one of the arrays. Iterate through the remaining elements and append them to the new array.\\n5. Calculate the median based on the length of the new array. If the length is even, take the average of the middle two elements. If the length is odd, take the middle element.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m + n), where m and n are the lengths of the two input arrays.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m + n), as the merged array new can contain all the elements from the two input arrays.\\n\\n# Code\\n```\\nclass Solution:\\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\\n        p1 = 0\\n        p2 = 0\\n        new = []\\n        while p1 < len(nums1) and p2 < len(nums2):\\n            if nums1[p1] < nums2[p2]:\\n                new.append(nums1[p1])\\n                p1 += 1\\n            else:\\n                new.append(nums2[p2])\\n                p2 += 1\\n        while p1 < len(nums1):\\n            new.append(nums1[p1])\\n            p1 += 1\\n        while p2 < len(nums2):\\n            new.append(nums2[p2])\\n            p2+= 1\\n        if len(new) % 2 == 0:\\n            index = len(new) // 2\\n            median = (new[index] + new[index-1]) / 2\\n        else:\\n            median = float(new[len(new)//2])\\n        return median\\n```"
    },
    {
        "slug": "sum-of-distances-in-tree",
        "tags": "python3",
        "release_time": 1671727286,
        "code": "class Solution:\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        ans=[0]*n\n        g=[[] for _ in range(n)]\n        for e in edges:\n            g[e[0]].append(e[1])\n            g[e[1]].append(e[0])\n        q=[(0, 0)]\n        parent=[None]*n\n        s=0\n        for v2 in g[0]:\n            q.append((v2, 1))\n            parent[v2]=0\n        for curs in range(1, n):\n            v, lev=q[curs]\n            s+=lev\n            lev+=1\n            g[v].remove(parent[v])\n            for v2 in g[v]:\n                q.append((v2, lev))\n                parent[v2]=v\n        lst=[it[0] for it in q]\n        chil_ct=[-2]*n\n        for v in lst[n-1:0:-1]:\n            chil_ct[parent[v]]+=chil_ct[v]\n        ans[0]=s\n        for v in lst:\n            tmp=ans[v]+n\n            par=parent[v]\n            for v2 in g[v]:\n                ans[v2]=tmp+chil_ct[v2]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy initial approach was based on recursion. It was wrong, since it exceeded the time limit (it took $O(n^2)$ time).\\nIt turns out that the problem can be solved in linear time, traversing the tree exactly 3 times.\\n\\nEdit: After optimizing the solution, now it is faster and takes less memory than 100%. The optimization consists in using neighbor lists instead of sets. Clearly, lists are faster.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDuring the depth-first traversal of the graph, for each vertex we compute its distance to the starting vertex (its level), then we sum these distances. This gives the answer for the starting vertex.\\nOne could do the same for each vertex, but it would take too long ($O(n^2)$). However, it turns out that we only need to do this computation exactly once.\\nSuppose we know the total distance (the answer) for a parent vertex. For each child, the total distance changes as follows: for all its descendants including itself, the distance decreases by 1, while for all other vertices in the graph the distance increases by 1. Hence the total distance changes, between parent to child, by\\n$$\\n-desc+(n-desc)=n-2desc,\\n$$\\nwhere desc is the child\\'s number of descendants.\\nWe then compute the total distance for each parent before each child, then add $n-2desc$ each time when going from parent to child. Since we already traversed the graph, this computation can be done in one pass, in the same order.\\nFinally, the number of descendants of each vertex $desc$ can also be computed in one pass, recursively going from bottom to top. We can traverse the graph using the reverse of the previous order.\\nThus, we only need 3 passes to get the answer.\\n\\n\\n# Complexity\\n- Time complexity: $O(n)$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\\n        ans=[0]*n\\n        g=[[] for _ in range(n)]\\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n        q=[(0, 0)]\\n        parent=[None]*n\\n        s=0\\n        for v2 in g[0]:\\n            q.append((v2, 1))\\n            parent[v2]=0\\n        for curs in range(1, n):\\n            v, lev=q[curs]\\n            s+=lev\\n            lev+=1\\n            g[v].remove(parent[v])\\n            for v2 in g[v]:\\n                q.append((v2, lev))\\n                parent[v2]=v\\n        lst=[it[0] for it in q]\\n        chil_ct=[-2]*n\\n        for v in lst[n-1:0:-1]:\\n            chil_ct[parent[v]]+=chil_ct[v]\\n        ans[0]=s\\n        for v in lst:\\n            tmp=ans[v]+n\\n            par=parent[v]\\n            for v2 in g[v]:\\n                ans[v2]=tmp+chil_ct[v2]\\n        return ans\\n```"
    },
    {
        "slug": "merge-k-sorted-lists",
        "tags": "python3",
        "release_time": 1678579423,
        "code": "class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n        head = temp = ListNode()\n        arr = []\n\n        for ls in lists:\n            while ls:\n                arr.append(ls.val)\n                ls = ls.next\n\n        for val in sorted(arr):\n            temp.next = ListNode()\n            temp = temp.next\n            temp.val = val\n\n        return head.next",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\n        head = temp = ListNode()\\n        arr = []\\n\\n        for ls in lists:\\n            while ls:\\n                arr.append(ls.val)\\n                ls = ls.next\\n\\n        for val in sorted(arr):\\n            temp.next = ListNode()\\n            temp = temp.next\\n            temp.val = val\\n\\n        return head.next\\n```"
    },
    {
        "slug": "teemo-attacking",
        "tags": "python3",
        "release_time": 1681305665,
        "code": "class Solution:\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\n        total = 0\n        l = len(timeSeries)\n        for i in range(l):\n        \n            if i < l - 1:\n\n                if timeSeries[i] + duration - 1 < timeSeries[i+1]:\n                    total += duration\n                \n                else:\n                    total += timeSeries[i+1] - timeSeries[i]\n        \n            else:\n                total += duration\n        \n        return total",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:\\n        total = 0\\n        l = len(timeSeries)\\n        for i in range(l):\\n        \\n            if i < l - 1:\\n\\n                if timeSeries[i] + duration - 1 < timeSeries[i+1]:\\n                    total += duration\\n                \\n                else:\\n                    total += timeSeries[i+1] - timeSeries[i]\\n        \\n            else:\\n                total += duration\\n        \\n        return total\\n```"
    },
    {
        "slug": "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
        "tags": "python3",
        "release_time": 1688294967,
        "code": "class Solution:\n    def minCost(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]\n        distance[0][0] = 0\n        q = collections.deque([(0, 0, 0)])\n        while q:\n            c, i, j = q.popleft()\n            if c > distance[i][j]: continue\n            if i == m - 1 and j == n - 1: return c\n            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:\n                ci, cj = i + di, j + dj\n                if 0 <= ci < m and 0 <= cj < n:\n                    if c + int(d != grid[i][j]) < distance[ci][cj]:\n                        distance[ci][cj] = c + int(d != grid[i][j])\n                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))\n                        else: q.append((distance[ci][cj], ci, cj))\n        \n        return distance[m - 1][n - 1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(M * N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minCost(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        distance = [[m * n + 1 for _ in range(n)] for _ in range(m)]\\n        distance[0][0] = 0\\n        q = collections.deque([(0, 0, 0)])\\n        while q:\\n            c, i, j = q.popleft()\\n            if c > distance[i][j]: continue\\n            if i == m - 1 and j == n - 1: return c\\n            for di, dj, d in [(0, 1, 1), (0, -1, 2), (1, 0, 3), (-1, 0, 4)]:\\n                ci, cj = i + di, j + dj\\n                if 0 <= ci < m and 0 <= cj < n:\\n                    if c + int(d != grid[i][j]) < distance[ci][cj]:\\n                        distance[ci][cj] = c + int(d != grid[i][j])\\n                        if d == grid[i][j]: q.appendleft((distance[ci][cj], ci, cj))\\n                        else: q.append((distance[ci][cj], ci, cj))\\n        \\n        return distance[m - 1][n - 1]\\n```"
    },
    {
        "slug": "find-largest-value-in-each-tree-row",
        "tags": "python3",
        "release_time": 1689914910,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\n        l=defaultdict(list)\n        def traversal(root,h):\n            if root is None:\n                return\n            l[h].append(root.val)\n            traversal(root.left,h+1)\n            traversal(root.right,h+1)\n        traversal(root,0)\n        res=[]\n        for i in l.values():\n            res.append(max(i))\n        return res",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/f42b11e8-669a-43b0-b033-b32969815b9c_1689914892.6863434.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def largestValues(self, root: Optional[TreeNode]) -> List[int]:\\n        l=defaultdict(list)\\n        def traversal(root,h):\\n            if root is None:\\n                return\\n            l[h].append(root.val)\\n            traversal(root.left,h+1)\\n            traversal(root.right,h+1)\\n        traversal(root,0)\\n        res=[]\\n        for i in l.values():\\n            res.append(max(i))\\n        return res\\n```"
    },
    {
        "slug": "compare-strings-by-frequency-of-the-smallest-character",
        "tags": "python3",
        "release_time": 1662825726,
        "code": "class Solution:\n    #Let n = len(queries) and m = len(words)\n    #Time-Complexity: O(m + mlog(m) + n*log(m)) -> O(mlog(m) + nlog(m))\n    #Space-Complexity: O(10*m + n*10 + m) -> O(n + m)\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n        \n        #Approach: Traverse linearly through each and every word in words array\n        #and get its function value and append it to seperate array!\n        #Then, sort the separate array in increasing order.\n        #Then, for each ith query, get the function value from applying\n        #function on ith query string -> look for leftmost index in\n        #new array s.t. from that particular index onwards, all values\n        #will be larger than the ith query function value!\n        \n        #This will help us get number of words in words input array that\n        #have higher function value than current query!\n        \n        #We need to also define helper function that computes\n        #function value for any non-empty string!\n        def helper(s):\n            hashmap = {}\n            for c in s:\n                if c not in hashmap:\n                    hashmap[c] = 1\n                    continue\n                else:\n                    hashmap[c] += 1\n            #iterate through each key value and put it in array of tuples,\n            #where first element is letter and second element is its frequency!\n            \n            array = []\n            for k,v in hashmap.items():\n                array.append((k, v))\n            #then sort the array by lexicographical order: first element of tuple!\n            array.sort(key = lambda x: x[0])\n            #return the first element of array: lexicographically smallest\n            #char frequency!\n            return array[0][1]\n        ans = []\n        arr = []\n        for word in words:\n            arr.append(helper(word))\n        #sort the new array arr!\n        arr.sort()\n        \n        #iterate through each and every query!\n        for query in queries:\n            requirement = helper(query)\n            #initiate binary search to find leftmost index pos in arr!\n            l, r = 0, (len(arr) - 1)\n            leftmost_index = None\n            while l <= r:\n                mid = (l + r) // 2\n                middle = arr[mid]\n                if(middle > requirement):\n                    leftmost_index = mid\n                    r = mid - 1\n                    continue\n                else:\n                    l = mid + 1 \n                    continue\n            #once binary search is over, we should have leftmost index!\n            #Append the difference val since it tells number of words\n            #with function value greater than requirement!\n            \n            #we have to check whether leftmost_index still equals None ->\n            #if none of words in words array have function val greater than\n            #the requirement!\n            if(leftmost_index == None):\n                ans.append(0)\n                continue\n            ans.append(len(arr) - leftmost_index)\n        return ans",
        "content": "```\\nclass Solution:\\n    #Let n = len(queries) and m = len(words)\\n    #Time-Complexity: O(m + mlog(m) + n*log(m)) -> O(mlog(m) + nlog(m))\\n    #Space-Complexity: O(10*m + n*10 + m) -> O(n + m)\\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\\n        \\n        #Approach: Traverse linearly through each and every word in words array\\n        #and get its function value and append it to seperate array!\\n        #Then, sort the separate array in increasing order.\\n        #Then, for each ith query, get the function value from applying\\n        #function on ith query string -> look for leftmost index in\\n        #new array s.t. from that particular index onwards, all values\\n        #will be larger than the ith query function value!\\n        \\n        #This will help us get number of words in words input array that\\n        #have higher function value than current query!\\n        \\n        #We need to also define helper function that computes\\n        #function value for any non-empty string!\\n        def helper(s):\\n            hashmap = {}\\n            for c in s:\\n                if c not in hashmap:\\n                    hashmap[c] = 1\\n                    continue\\n                else:\\n                    hashmap[c] += 1\\n            #iterate through each key value and put it in array of tuples,\\n            #where first element is letter and second element is its frequency!\\n            \\n            array = []\\n            for k,v in hashmap.items():\\n                array.append((k, v))\\n            #then sort the array by lexicographical order: first element of tuple!\\n            array.sort(key = lambda x: x[0])\\n            #return the first element of array: lexicographically smallest\\n            #char frequency!\\n            return array[0][1]\\n        ans = []\\n        arr = []\\n        for word in words:\\n            arr.append(helper(word))\\n        #sort the new array arr!\\n        arr.sort()\\n        \\n        #iterate through each and every query!\\n        for query in queries:\\n            requirement = helper(query)\\n            #initiate binary search to find leftmost index pos in arr!\\n            l, r = 0, (len(arr) - 1)\\n            leftmost_index = None\\n            while l <= r:\\n                mid = (l + r) // 2\\n                middle = arr[mid]\\n                if(middle > requirement):\\n                    leftmost_index = mid\\n                    r = mid - 1\\n                    continue\\n                else:\\n                    l = mid + 1 \\n                    continue\\n            #once binary search is over, we should have leftmost index!\\n            #Append the difference val since it tells number of words\\n            #with function value greater than requirement!\\n            \\n            #we have to check whether leftmost_index still equals None ->\\n            #if none of words in words array have function val greater than\\n            #the requirement!\\n            if(leftmost_index == None):\\n                ans.append(0)\\n                continue\\n            ans.append(len(arr) - leftmost_index)\\n        return ans"
    },
    {
        "slug": "counting-bits",
        "tags": "python3",
        "release_time": 1679052546,
        "code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        list2=[0]*(n+1)\n        for i in range(n+1):\n            x=list(bin(i)[2:])\n            z=x.count('1')\n            list2.append(z)\n        return list2[n+1:]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countBits(self, n: int) -> List[int]:\\n        list2=[0]*(n+1)\\n        for i in range(n+1):\\n            x=list(bin(i)[2:])\\n            z=x.count(\\'1\\')\\n            list2.append(z)\\n        return list2[n+1:]\\n\\n```"
    },
    {
        "slug": "find-all-good-strings",
        "tags": "python3",
        "release_time": 1668991487,
        "code": "class Solution:\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n        p=10**9+7\n        ord_a=ord('a')\n        l=len(evil)\n        dup=[]\n        for i in range(1, l):\n            if evil[i:]==evil[:l-i]:\n                dup.append(i)\n        lend=len(dup)\n        def count(s):\n            tmp_ct=0\n            bd=1\n            ind=n\n            without_s=[]\n            for i in range(n):\n                tmp_ct*=26\n                if bd:\n                    tmp_ct+=ord(s[i])-ord_a\n                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:\n                    tmp_ct-=1\n                if i>=l:\n                    tmp_ct-=without_s[i-l]\n                if i>=l-1:\n                    if s[i-l+1:i+1]==evil:\n                        bd=0\n                        ind=i\n                tmp_ct%=p\n                tmp_with_s=0\n                for j in range(lend):\n                    d=dup[j]\n                    if i>=d:\n                        tmp_with_s+=without_s[i-d]\n                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:\n                        tmp_with_s+=1\n                without_s.append(tmp_ct-tmp_with_s)\n            return tmp_ct, bd\n        str_ct1, bd1=count(s1)\n        str_ct2, bd2=count(s2)\n        return (str_ct2-str_ct1+bd2)%p",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires very, very careful counting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem can be decomposed into two: counting all valid strings less than s1, then all valid strings less than s2 (and then considering s2 itself separately).\\n\\nCounting all valid strings less than some string s is straightforward, by recursion on n, if there is no excluded string. It is still easy when the excluded \"evil\" string has no overlapping prefixes and suffixes.\\n\\nWhen there is overlap, one also has to keep track of the number of valid strings that end in certain suffixes of the excluded string.\\n\\nFor example: if the excluded string is \"bbb\", one has to keep track of valid strings ending in \"b\" and \"bb\". If the excluded string is \"zaaz\", one has to keep track of valid strings ending in \"zaa\".\\n\\n# Complexity\\n- Time complexity: The solution takes at most $O(nl^2)$ time, where $l$ is the length of the excluded \"evil\" string.\\n\\n- Space complexity: The solution uses no more than $O(n)$ memory.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\\n        p=10**9+7\\n        ord_a=ord(\\'a\\')\\n        l=len(evil)\\n        dup=[]\\n        for i in range(1, l):\\n            if evil[i:]==evil[:l-i]:\\n                dup.append(i)\\n        lend=len(dup)\\n        def count(s):\\n            tmp_ct=0\\n            bd=1\\n            ind=n\\n            without_s=[]\\n            for i in range(n):\\n                tmp_ct*=26\\n                if bd:\\n                    tmp_ct+=ord(s[i])-ord_a\\n                if i>=l-1 and ind>i-l and evil<s[i-l+1:i+1]:\\n                    tmp_ct-=1\\n                if i>=l:\\n                    tmp_ct-=without_s[i-l]\\n                if i>=l-1:\\n                    if s[i-l+1:i+1]==evil:\\n                        bd=0\\n                        ind=i\\n                tmp_ct%=p\\n                tmp_with_s=0\\n                for j in range(lend):\\n                    d=dup[j]\\n                    if i>=d:\\n                        tmp_with_s+=without_s[i-d]\\n                    if i>=d-1 and ind>i-d and evil[:d]<s[i-d+1:i+1]:\\n                        tmp_with_s+=1\\n                without_s.append(tmp_ct-tmp_with_s)\\n            return tmp_ct, bd\\n        str_ct1, bd1=count(s1)\\n        str_ct2, bd2=count(s2)\\n        return (str_ct2-str_ct1+bd2)%p\\n        \\n```"
    },
    {
        "slug": "corporate-flight-bookings",
        "tags": "python3",
        "release_time": 1673235303,
        "code": "class Solution:\n    def increment(self, arr, start, end, val):\n        arr[start] += val\n        if end + 1 < len(arr):\n            arr[end+1] -= val\n        \n\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n        arr = [0 for _ in range(n)]\n        for book in bookings:\n            start, end ,seat = book\n            self.increment(arr, start-1, end-1, seat)\n            # print(arr)\n        res = [0 for _ in range(n)]\n        res[0] = arr[0]\n        for i in range(1, n):\n            res[i] = res[i-1] + arr[i]\n        # print(res)\n        return res",
        "content": "# Intuition\\nThis is the same problem as range addition. For any booking, we essentially add a number of seats to the specified range. \\n\\n# Approach\\nThere are `n` days in total. So we can create an array with length `n`, representing the difference array (ith entry represents the difference of ith and the (i-1)th entry of the original array). Then, for each booking, we add the `seat` to `arr[start]` and minus `seat` to `arr[end+1]`, so we are adding the number of seat to the days from `start` to `end`. \\n\\n# Complexity\\n- Time complexity:\\nFor each entry, we modify the array two times. So it\\'s $$O(N)$$.\\n\\n- Space complexity:\\nThe `arr` takes $$O(N)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def increment(self, arr, start, end, val):\\n        arr[start] += val\\n        if end + 1 < len(arr):\\n            arr[end+1] -= val\\n        \\n\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n        arr = [0 for _ in range(n)]\\n        for book in bookings:\\n            start, end ,seat = book\\n            self.increment(arr, start-1, end-1, seat)\\n            # print(arr)\\n        res = [0 for _ in range(n)]\\n        res[0] = arr[0]\\n        for i in range(1, n):\\n            res[i] = res[i-1] + arr[i]\\n        # print(res)\\n        return res\\n\\n\\n```"
    },
    {
        "slug": "remove-duplicates-from-sorted-array-ii",
        "tags": "python3",
        "release_time": 1691087840,
        "code": "class Solution:\n    def removeDuplicates(self, nums: List[int]) -> int:\n        if len(nums) < 3:\n            return len(nums)\n\n        p1, p2 = 1, 2\n\n        while p2 < len(nums):\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\n                    p2 += 1\n                if p2 == len(nums):\n                    break\n            p1 += 1\n            nums[p1] = nums[p2]\n            p2 += 1\n\n        return p1 + 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(0)\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, nums: List[int]) -> int:\\n        if len(nums) < 3:\\n            return len(nums)\\n\\n        p1, p2 = 1, 2\\n\\n        while p2 < len(nums):\\n            if nums[p1] == nums[p1-1] and nums[p2] == nums[p2-1] == nums[p2-2]:\\n                while p2 < len(nums) and nums[p2] == nums[p2-1]:\\n                    p2 += 1\\n                if p2 == len(nums):\\n                    break\\n            p1 += 1\\n            nums[p1] = nums[p2]\\n            p2 += 1\\n\\n        return p1 + 1\\n\\n```"
    },
    {
        "slug": "find-the-distance-value-between-two-arrays",
        "tags": "python3",
        "release_time": 1673204347,
        "code": "class Solution:\n    def is_left(self, n: int, arr: list[int], d: int):\n        l, r = 0, len(arr)-1\n        while l <= r:\n            m = (l + r) // 2\n            if abs(arr[m] - n) <= d:\n                return True\n            elif arr[m] > n:\n                r = m - 1\n            else:\n                l = m + 1\n        return False\n\n    def is_right(self, n: int, arr: list[int], d: int):\n        l, r = 0, len(arr)-1\n        while l <= r:\n            m = (l + r) // 2\n            if abs(arr[m] - n) <= d:\n                return True\n            elif arr[m] < n:\n                r = m - 1\n            else:\n                l = m + 1\n        return False\n\n    def findTheDistanceValue(self, arr1: list[int], arr2: list[int], d: int) -> int:\n        arr2.sort()\n        c = 0\n        for i in arr1:\n            if not self.is_left(i, arr2, d):\n                if not self.is_right(i, arr2, d):\n                    print(i)\n                    c += 1\n        return c",
        "content": "\\n# Complexity\\n- Time comple: 94.12 %\\n- Space complexity: 80 %\\n# Understanding\\n- First I have sort arr2.\\n- Then iterate arr1.\\n- Search element that you need (BSA)\\n- If there is no such value, increase the value of c by 1.\\n- Loop until the element arr1 is finished.\\n\\n<h1><a href=\"https://leetcode.com/MAMuhammad571/\">My account<a></h1>\\n\\n# Code\\n```\\nclass Solution:\\n    def is_left(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] > n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def is_right(self, n: int, arr: list[int], d: int):\\n        l, r = 0, len(arr)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if abs(arr[m] - n) <= d:\\n                return True\\n            elif arr[m] < n:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return False\\n\\n    def findTheDistanceValue(self, arr1: list[int], arr2: list[int], d: int) -> int:\\n        arr2.sort()\\n        c = 0\\n        for i in arr1:\\n            if not self.is_left(i, arr2, d):\\n                if not self.is_right(i, arr2, d):\\n                    print(i)\\n                    c += 1\\n        return c\\n```"
    },
    {
        "slug": "generate-random-point-in-a-circle",
        "tags": "python3",
        "release_time": 1673625736,
        "code": "class Solution:\n\n    def __init__(self, radius: float, x_center: float, y_center: float):\n        self.radius = radius\n        self.x_center = x_center\n        self.y_center = y_center\n        self.x = x_center\n        self.y = y_center\n        self.r = radius\n\n    def randPoint(self) -> List[float]:\n        while True:\n            x = random.uniform(self.x - self.r, self.x + self.r)\n            y = random.uniform(self.y - self.r, self.y + self.r)\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\n                return [x, y]\n# Your Solution object will be instantiated and called as such:\n# obj = Solution(radius, x_center, y_center)\n# param_1 = obj.randPoint()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to randomly generate points within a circle of radius radius and center point (x_center, y_center).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to use the built-in random.uniform(a, b) function which generates a random float number between a and b. We use this function to generate x and y coordinates for the point. We then check if the point is within the circle by checking if the point\\'s distance from the center of the circle is less than or equal to the radius. If it is, we return the point. If not, we continue generating new points until we find one that is within the circle.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, radius: float, x_center: float, y_center: float):\\n        self.radius = radius\\n        self.x_center = x_center\\n        self.y_center = y_center\\n        self.x = x_center\\n        self.y = y_center\\n        self.r = radius\\n\\n    def randPoint(self) -> List[float]:\\n        while True:\\n            x = random.uniform(self.x - self.r, self.x + self.r)\\n            y = random.uniform(self.y - self.r, self.y + self.r)\\n            if (x - self.x) ** 2 + (y - self.y) ** 2 <= self.r ** 2:\\n                return [x, y]\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(radius, x_center, y_center)\\n# param_1 = obj.randPoint()\\n```"
    },
    {
        "slug": "airplane-seat-assignment-probability",
        "tags": "python3",
        "release_time": 1676383918,
        "code": "class Solution:\n    def nthPersonGetsNthSeat(self, n: int) -> float:\n        if n==1:\n            return 1/n\n        else:\n            return 1/2",
        "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![airplane.PNG](https://assets.leetcode.com/users/images/61f239f0-2c8b-4d5d-a297-1c6256df7f1d_1676383885.0941582.png)\\n# Code\\n```\\nclass Solution:\\n    def nthPersonGetsNthSeat(self, n: int) -> float:\\n        if n==1:\\n            return 1/n\\n        else:\\n            return 1/2\\n```"
    },
    {
        "slug": "arithmetic-slices-ii-subsequence",
        "tags": "python3",
        "release_time": 1669526242,
        "code": "class Solution:\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\n        total, n = 0, len(nums)\n        dp = [defaultdict(int) for _ in nums]\n        for i in range(1, n):\n            for j in range(i):\n                diff = nums[j] - nums[i]\n                dp[i][diff] += dp[j][diff] + 1\n                total += dp[j][diff]\n        return total",
        "content": "**Python**\\n```\\nclass Solution:\\n    def numberOfArithmeticSlices(self, nums: List[int]) -> int:\\n        total, n = 0, len(nums)\\n        dp = [defaultdict(int) for _ in nums]\\n        for i in range(1, n):\\n            for j in range(i):\\n                diff = nums[j] - nums[i]\\n                dp[i][diff] += dp[j][diff] + 1\\n                total += dp[j][diff]\\n        return total\\n```\\n\\n**Swift**\\n```\\nclass Solution {\\n    func numberOfArithmeticSlices(_ nums: [Int]) -> Int {\\n        var total = 0\\n        let n = nums.count\\n        var dp = Array(repeating: [Int: Int](), count: n)\\n        for i in 1..<n {\\n            for j in 0..<i {\\n                let diff = nums[j] - nums[i]\\n                dp[i][diff, default: 0] += dp[j][diff, default: 0] + 1\\n                total += dp[j][diff, default: 0]\\n            }\\n        }\\n        return total\\n    }\\n}\\n```"
    },
    {
        "slug": "calculate-money-in-leetcode-bank",
        "tags": "python3",
        "release_time": 1678613177,
        "code": "class Solution:\n    N = 7\n\n    def totalMoney(self, n: int) -> int:\n        weeks, days = divmod(n, self.N)\n        return weeks * self.N * (self.N + weeks) // 2 + weeks * days + days * (days + 1) // 2",
        "content": "```\\nclass Solution:\\n    N = 7\\n\\n    def totalMoney(self, n: int) -> int:\\n        weeks, days = divmod(n, self.N)\\n        return weeks * self.N * (self.N + weeks) // 2 + weeks * days + days * (days + 1) // 2\\n\\n```"
    },
    {
        "slug": "baseball-game",
        "tags": "python3",
        "release_time": 1675598458,
        "code": "class Solution:\n    def calPoints(self, o: List[str]) -> int:\n        i = 0\n        l = []\n        p = []\n        while i<len(o):\n            if o[i]!= \"C\" and o[i]!= \"D\" and o[i]!= \"+\":\n                l.append(int(o[i]))\n                # print(l)\n            elif o[i]==\"C\":\n                l.remove(l[-1])\n                # print(l)\n            elif o[i] == \"D\":\n                l.append(l[-1]*2)\n                # print(l)\n            elif o[i] == \"+\":\n                l.append(l[-1] + l[-2])\n                # print(l)\n            i+=1\n        return (sum(l))",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def calPoints(self, o: List[str]) -> int:\\n        i = 0\\n        l = []\\n        p = []\\n        while i<len(o):\\n            if o[i]!= \"C\" and o[i]!= \"D\" and o[i]!= \"+\":\\n                l.append(int(o[i]))\\n                # print(l)\\n            elif o[i]==\"C\":\\n                l.remove(l[-1])\\n                # print(l)\\n            elif o[i] == \"D\":\\n                l.append(l[-1]*2)\\n                # print(l)\\n            elif o[i] == \"+\":\\n                l.append(l[-1] + l[-2])\\n                # print(l)\\n            i+=1\\n        return (sum(l))\\n```"
    },
    {
        "slug": "construct-the-longest-new-string",
        "tags": "python3",
        "release_time": 1687711912,
        "code": "class Solution:\n    def longestString(self, x: int, y: int, z: int) -> int:\n\n        if x > y: x,y = y,x\n\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;",
        "content": "```\\nclass Solution:\\n    def longestString(self, x: int, y: int, z: int) -> int:\\n\\n        if x > y: x,y = y,x\\n\\n        return min(x + y, 2*x + 1 ) * 2 + 2*z;\\n```\\n[https://leetcode.com/problems/construct-the-longest-new-string/submissions/985072631/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n"
    },
    {
        "slug": "concatenation-of-consecutive-binary-numbers",
        "tags": "python3",
        "release_time": 1679421217,
        "code": "class Solution:\n    def concatenatedBinary(self, n: int) -> int:\n        res = \"\"\n        for x in range(1, n+1):\n            res += bin(x)[2:]\n        return int(res, 2) % (10**9+7)",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def concatenatedBinary(self, n: int) -> int:\\n        res = \"\"\\n        for x in range(1, n+1):\\n            res += bin(x)[2:]\\n        return int(res, 2) % (10**9+7)\\n```"
    },
    {
        "slug": "convert-binary-number-in-a-linked-list-to-integer",
        "tags": "python3",
        "release_time": 1674836842,
        "code": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def getDecimalValue(self, head: ListNode) -> int:\n        binary=[]\n        while head!=None:\n            binary.append(head.val)\n            head=head.next\n        return int(\"\".join(str(i)for i in binary),2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def getDecimalValue(self, head: ListNode) -> int:\\n        binary=[]\\n        while head!=None:\\n            binary.append(head.val)\\n            head=head.next\\n        return int(\"\".join(str(i)for i in binary),2)\\n```"
    },
    {
        "slug": "unique-number-of-occurrences",
        "tags": "python3",
        "release_time": 1669786839,
        "code": "from collections import Counter\nclass Solution:\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\n        d=Counter(arr)\n        l=list(d.values())\n        print(l)\n        if len(l)==len(set(l)):\n            return True\n        else:\n            return False",
        "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def uniqueOccurrences(self, arr: List[int]) -> bool:\\n        d=Counter(arr)\\n        l=list(d.values())\\n        print(l)\\n        if len(l)==len(set(l)):\\n            return True\\n        else:\\n            return False\\n```"
    },
    {
        "slug": "binary-string-with-substrings-representing-1-to-n",
        "tags": "python3",
        "release_time": 1686094636,
        "code": "class Solution:\n    def queryString(self, s: str, n: int) -> bool:\n        test=True\n        i=1\n        while i<=n:\n            if s.find(format(i,\"b\"))==-1:\n                test=False\n                break\n            i+=1\n        return test",
        "content": "# Intuition\\nTo determine if the binary representation of all integers in the range [1, n] are substrings of a given binary string s, we can iterate through the range and check if each binary representation exists as a substring in s. If we find any missing substring, we return False; otherwise, we return True.\\n\\n# Approach:\\nWe initialize a boolean variable test as True, which will be used to keep track of whether all substrings are present or not. We start iterating from 1 to n using a while loop. For each iteration, we convert the current integer i into its binary representation using the format(i, \"b\") function. We then use the find() method on the binary string s to check if the binary representation exists as a substring. If it does not, we update test to False and break out of the loop. Finally, we increment i by 1.\\n\\nAfter the loop completes, we return the value of test, which will be True if all substrings are present, or False if any substring is missing.\\n\\n# Time complexity:\\nThe time complexity of this approach is O(n * m), where n is the given integer n and m is the average length of the binary representations of the integers from 1 to n. This is because we iterate through the range [1, n] and, for each iteration, perform a string search operation using the find() method, which takes O(m) time.\\n\\n# Space complexity:\\nThe space complexity of this approach is O(1) because we only use a constant amount of extra space to store the boolean variable test, the integer variable i, and the temporary binary representation of each integer. The input string s is not counted in the space complexity as it is given and does not require any additional space.\\n\\n# Code\\n```\\nclass Solution:\\n    def queryString(self, s: str, n: int) -> bool:\\n        test=True\\n        i=1\\n        while i<=n:\\n            if s.find(format(i,\"b\"))==-1:\\n                test=False\\n                break\\n            i+=1\\n        return test\\n```"
    },
    {
        "slug": "maximum-number-of-occurrences-of-a-substring",
        "tags": "python3",
        "release_time": 1681240929,
        "code": "class Solution:\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n\n        c = Counter([s[i:i+minSize] for i in range(len(s)-minSize+1)])\n      \n        return max((c[substr] for substr in c\n                      if len(set(substr)) <= maxLetters), default = 0)",
        "content": "Another`Counter`version for consideration. Two observations:\\n- The`maxSize`parameter is a \"red herring.\" I suspect it was added to make this problem a *Medium* rather than an *Easy*. For example, if the string`\"abcdef\"`has five occurrences, then so does`\"abc\"` Thus, if `minSize = 3`, then we only need check strings of length three.\\n- There are some test cases in which no substring qualifies under the`maxLetters`constraint, so using the`default`parameter in`max`takes care of that.\\n```\\nclass Solution:\\n    def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\\n\\n        c = Counter([s[i:i+minSize] for i in range(len(s)-minSize+1)])\\n      \\n        return max((c[substr] for substr in c\\n                      if len(set(substr)) <= maxLetters), default = 0)\\n```\\n[https://leetcode.com/problems/maximum-number-of-occurrences-of-a-substring/submissions/932085530/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n"
    },
    {
        "slug": "subarray-with-elements-greater-than-varying-threshold",
        "tags": "python3",
        "release_time": 1657406330,
        "code": "class Solution:\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\n                            # Stack elements are the array's indices idx, and montonic with respect to nums[idx].\n                            # When the index of the nearest smaller value to nums[idx] comes to the top of the \n                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.\n                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.\n\t\t\t\t\t\t\t\n        nums.append(0)\n        stack = deque()\n\n        for idx in range(len(nums)):\n\n            while stack and nums[idx] <= nums[stack[-1]]:           \n                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]\n                k = idx if not stack else idx - stack[-1] -1        \n                if n > threshold //k: return k                      # threshold criterion. if n passes, all\n                                                                    # elements of the interval pass\n            stack.append(idx)\n\n        return -1",
        "content": "```\\nclass Solution:\\n    def validSubarraySize(self, nums: List[int], threshold: int) -> int:\\n                            # Stack elements are the array\\'s indices idx, and montonic with respect to nums[idx].\\n                            # When the index of the nearest smaller value to nums[idx] comes to the top of the \\n                            # stack, we check whether the threshold criterion is satisfied. If so, we are done.\\n                            #  If not, we continue. Return -1 if we reach the end of nums without a winner.\\n\\t\\t\\t\\t\\t\\t\\t\\n        nums.append(0)\\n        stack = deque()\\n\\n        for idx in range(len(nums)):\\n\\n            while stack and nums[idx] <= nums[stack[-1]]:           \\n                n = nums[stack.pop()]                               # n is the next smaller value for nums[idx]\\n                k = idx if not stack else idx - stack[-1] -1        \\n                if n > threshold //k: return k                      # threshold criterion. if n passes, all\\n                                                                    # elements of the interval pass\\n            stack.append(idx)\\n\\n        return -1"
    },
    {
        "slug": "partition-to-k-equal-sum-subsets",
        "tags": "python3",
        "release_time": 1691463460,
        "code": "class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        memo = {}\n\n        def backtrack(k, bucket, nums, start, used, target):\n            # \\u57FA\\u672C case\n            if k == 0:\n                # \\u6240\\u6709\\u6876\\u90FD\\u88AB\\u88C5\\u6EE1\\u4E86\\uFF0C\\u4E14 nums \\u5168\\u90E8\\u7528\\u5B8C\n                return True\n            if bucket == target:\n                res = backtrack(k - 1, 0, nums, 0, used, target)\n                # \\u7F13\\u5B58\\u7ED3\\u679C\n                memo[used] = res\n                return res\n            if used in memo:\n                # \\u907F\\u514D\\u5197\\u4F59\\u8BA1\\u7B97\n                return memo[used]\n            \n            for i in range(start, len(nums)):\n                if ((used >> i) & 1) == 1:\n                    # nums[i] \\u5DF2\\u7ECF\\u88AB\\u88C5\\u5165\\u522B\\u7684\\u6876\\u4E2D\n                    continue\n                if nums[i] + bucket > target:\n                    continue\n                used |= 1 << i\n                bucket += nums[i]\n                if backtrack(k, bucket, nums, i + 1, used, target):\n                    return True\n                used ^= 1 << i\n                bucket -= nums[i]\n            \n            return False\n        \n        # \\u786E\\u4FDD k \\u4E0D\\u5927\\u4E8E nums \\u7684\\u957F\\u5EA6\n        if k > len(nums):\n            return False\n        sum_nums = sum(nums)\n        if sum_nums % k != 0:\n            return False       \n        used = 0 # \\u4F7F\\u7528\\u4F4D\\u56FE\\u6280\\u5DE7\n        target = sum_nums // k # \\u6BCF\\u4E2A\\u6876\\u7684\\u76EE\\u6807\\u548C\n        # k \\u53F7\\u6876\\u521D\\u59CB\\u4EC0\\u4E48\\u90FD\\u6CA1\\u88C5\\uFF0C\\u4ECE nums[0] \\u5F00\\u59CB\\u505A\\u9009\\u62E9\n        return backtrack(k, 0, nums, 0, used, target)\n    #     nums.sort(reverse=True)\n    #     # \\u6392\\u9664\\u4E00\\u4E9B\\u57FA\\u672C\\u60C5\\u51B5\n    #     if k > len(nums):\n    #         return False\n    #     # \\u5C06\\u6240\\u6709\\u6570\\u7684\\u548C\\u6C42\\u51FA\\u6765\n    #     _sum = sum(nums)\n    #     # \\u5982\\u679C\\u6240\\u6709\\u6570\\u7684\\u548C\\u4E0D\\u80FD\\u88AB k \\u6574\\u9664\\uFF0C\\u5C31\\u4E0D\\u7528\\u7EE7\\u7EED\\u4E86\n    #     if _sum % k != 0:\n    #         return False\n    #     # \\u6240\\u6709\\u5206\\u51FA\\u6765\\u7684\\u6876\\u9700\\u8981\\u88C5 target \\u4E2A\\u6570\\u5B57\n    #     target = _sum // k\n    #     # k \\u4E2A\\u6876\n    #     bucket = [0] * k\n    #     # \\u9012\\u5F52\\u7A77\\u4E3E\n\n    #     return self.backtrack(nums, 0, bucket, target)\n\n    # def backtrack(self, nums, index, bucket, target):\n    #     # \\u6240\\u6709\\u6570\\u90FD\\u586B\\u5B8C\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u6876\\u91CC\\u7684\\u6570\\u5B57\\u548C\\u90FD\\u662F target\n    #     if index == len(nums):\n    #         for i in range(len(bucket)):\n    #             if bucket[i] != target:\n    #                 return False\n    #         return True\n        \n    #     # \\u6BCF\\u4E2A\\u6876\\u90FD\\u5C1D\\u8BD5\\u4E00\\u4E0B\n    #     for i in range(len(bucket)):\n    #         # \\u5982\\u679C\\u52A0\\u8FDB\\u53BB\\u8FD9\\u4E2A\\u6570\\uFF0C\\u8FD9\\u4E2A\\u6876\\u7684\\u6570\\u5B57\\u548C\\u5C31\\u8D85\\u8FC7\\u4E86 target\\uFF0C\\u90A3\\u5C31\\u4E0D\\u80FD\\u52A0\\u4E86\n    #         if bucket[i] + nums[index] > target:\n    #             continue\n    #         # \\u52A0\\u8FDB\\u53BB\n    #         bucket[i] += nums[index]\n    #         # \\u5982\\u679C\\u8FD9\\u4E2A\\u52A0\\u6CD5\\u662F\\u53EF\\u884C\\u65B9\\u6848\\uFF0C\\u5C31\\u7EE7\\u7EED\\u9012\\u5F52\\u4E0B\\u53BB\n    #         if self.backtrack(nums, index + 1, bucket, target):\n    #             return True\n    #         # \\u52A0\\u5B8C\\u53C8\\u8981\\u64A4\\u6D88\\u52A0\\u6CD5\\uFF0C\\u6062\\u590D\\u73B0\\u573A\\uFF0C\\u7EE7\\u7EED\\u5C1D\\u8BD5\\u522B\\u7684\\u52A0\\u6CD5\n    #         bucket[i] -= nums[index]\n    #     # \\u65E0\\u89E3\\uFF0C\\u8FD4\\u56DE false\n    #     return False",
        "content": "\\u5176\\u5B9E\\u6211\\u66F4\\u80FD\\u7406\\u89E3\\u4ECE\\u6570\\u5B57\\u6765\\u770B\\uFF0C\\u4F46\\u662F\\u6570\\u5B57\\u7684\\u65F6\\u95F4\\u8D85\\u65F6\\u4E86\\u3002\\u6876\\u6709\\u70B9\\u4E00\\u77E5\\u534A\\u89E3\\u7684\\u611F\\u89C9\\n\\n# Code\\n```\\nclass Solution:\\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\\n        memo = {}\\n\\n        def backtrack(k, bucket, nums, start, used, target):\\n            # \\u57FA\\u672C case\\n            if k == 0:\\n                # \\u6240\\u6709\\u6876\\u90FD\\u88AB\\u88C5\\u6EE1\\u4E86\\uFF0C\\u4E14 nums \\u5168\\u90E8\\u7528\\u5B8C\\n                return True\\n            if bucket == target:\\n                res = backtrack(k - 1, 0, nums, 0, used, target)\\n                # \\u7F13\\u5B58\\u7ED3\\u679C\\n                memo[used] = res\\n                return res\\n            if used in memo:\\n                # \\u907F\\u514D\\u5197\\u4F59\\u8BA1\\u7B97\\n                return memo[used]\\n            \\n            for i in range(start, len(nums)):\\n                if ((used >> i) & 1) == 1:\\n                    # nums[i] \\u5DF2\\u7ECF\\u88AB\\u88C5\\u5165\\u522B\\u7684\\u6876\\u4E2D\\n                    continue\\n                if nums[i] + bucket > target:\\n                    continue\\n                used |= 1 << i\\n                bucket += nums[i]\\n                if backtrack(k, bucket, nums, i + 1, used, target):\\n                    return True\\n                used ^= 1 << i\\n                bucket -= nums[i]\\n            \\n            return False\\n        \\n        # \\u786E\\u4FDD k \\u4E0D\\u5927\\u4E8E nums \\u7684\\u957F\\u5EA6\\n        if k > len(nums):\\n            return False\\n        sum_nums = sum(nums)\\n        if sum_nums % k != 0:\\n            return False       \\n        used = 0 # \\u4F7F\\u7528\\u4F4D\\u56FE\\u6280\\u5DE7\\n        target = sum_nums // k # \\u6BCF\\u4E2A\\u6876\\u7684\\u76EE\\u6807\\u548C\\n        # k \\u53F7\\u6876\\u521D\\u59CB\\u4EC0\\u4E48\\u90FD\\u6CA1\\u88C5\\uFF0C\\u4ECE nums[0] \\u5F00\\u59CB\\u505A\\u9009\\u62E9\\n        return backtrack(k, 0, nums, 0, used, target)\\n    #     nums.sort(reverse=True)\\n    #     # \\u6392\\u9664\\u4E00\\u4E9B\\u57FA\\u672C\\u60C5\\u51B5\\n    #     if k > len(nums):\\n    #         return False\\n    #     # \\u5C06\\u6240\\u6709\\u6570\\u7684\\u548C\\u6C42\\u51FA\\u6765\\n    #     _sum = sum(nums)\\n    #     # \\u5982\\u679C\\u6240\\u6709\\u6570\\u7684\\u548C\\u4E0D\\u80FD\\u88AB k \\u6574\\u9664\\uFF0C\\u5C31\\u4E0D\\u7528\\u7EE7\\u7EED\\u4E86\\n    #     if _sum % k != 0:\\n    #         return False\\n    #     # \\u6240\\u6709\\u5206\\u51FA\\u6765\\u7684\\u6876\\u9700\\u8981\\u88C5 target \\u4E2A\\u6570\\u5B57\\n    #     target = _sum // k\\n    #     # k \\u4E2A\\u6876\\n    #     bucket = [0] * k\\n    #     # \\u9012\\u5F52\\u7A77\\u4E3E\\n\\n    #     return self.backtrack(nums, 0, bucket, target)\\n\\n    # def backtrack(self, nums, index, bucket, target):\\n    #     # \\u6240\\u6709\\u6570\\u90FD\\u586B\\u5B8C\\u4E86\\uFF0C\\u6BCF\\u4E2A\\u6876\\u91CC\\u7684\\u6570\\u5B57\\u548C\\u90FD\\u662F target\\n    #     if index == len(nums):\\n    #         for i in range(len(bucket)):\\n    #             if bucket[i] != target:\\n    #                 return False\\n    #         return True\\n        \\n    #     # \\u6BCF\\u4E2A\\u6876\\u90FD\\u5C1D\\u8BD5\\u4E00\\u4E0B\\n    #     for i in range(len(bucket)):\\n    #         # \\u5982\\u679C\\u52A0\\u8FDB\\u53BB\\u8FD9\\u4E2A\\u6570\\uFF0C\\u8FD9\\u4E2A\\u6876\\u7684\\u6570\\u5B57\\u548C\\u5C31\\u8D85\\u8FC7\\u4E86 target\\uFF0C\\u90A3\\u5C31\\u4E0D\\u80FD\\u52A0\\u4E86\\n    #         if bucket[i] + nums[index] > target:\\n    #             continue\\n    #         # \\u52A0\\u8FDB\\u53BB\\n    #         bucket[i] += nums[index]\\n    #         # \\u5982\\u679C\\u8FD9\\u4E2A\\u52A0\\u6CD5\\u662F\\u53EF\\u884C\\u65B9\\u6848\\uFF0C\\u5C31\\u7EE7\\u7EED\\u9012\\u5F52\\u4E0B\\u53BB\\n    #         if self.backtrack(nums, index + 1, bucket, target):\\n    #             return True\\n    #         # \\u52A0\\u5B8C\\u53C8\\u8981\\u64A4\\u6D88\\u52A0\\u6CD5\\uFF0C\\u6062\\u590D\\u73B0\\u573A\\uFF0C\\u7EE7\\u7EED\\u5C1D\\u8BD5\\u522B\\u7684\\u52A0\\u6CD5\\n    #         bucket[i] -= nums[index]\\n    #     # \\u65E0\\u89E3\\uFF0C\\u8FD4\\u56DE false\\n    #     return False\\n```"
    },
    {
        "slug": "find-lucky-integer-in-an-array",
        "tags": "python3",
        "release_time": 1687164804,
        "code": "class Solution:\n    def findLucky(self, arr: List[int]) -> int:\n        dic={}\n        l=[]\n        for i in arr:\n            if i not in dic:\n                dic[i]=1\n            else:\n                dic[i]+=1\n        for i in dic:\n            if i==dic[i]:\n                l.append(i)\n        if(len(l)<1):\n            return -1\n        return max(l)",
        "content": "\\n```\\nclass Solution:\\n    def findLucky(self, arr: List[int]) -> int:\\n        dic={}\\n        l=[]\\n        for i in arr:\\n            if i not in dic:\\n                dic[i]=1\\n            else:\\n                dic[i]+=1\\n        for i in dic:\\n            if i==dic[i]:\\n                l.append(i)\\n        if(len(l)<1):\\n            return -1\\n        return max(l)\\n```"
    },
    {
        "slug": "maximum-profit-of-operating-a-centennial-wheel",
        "tags": "python3",
        "release_time": 1687863850,
        "code": "class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        maxProfit=-1\n        ans=i=curRounds=curCustomers=rem=0\n        while i<len(customers) or rem:\n            if i<len(customers):\n                rem+=customers[i]\n                i+=1\n            curRounds+=1\n            if rem-4>=0:\n                rem-=4\n                curCustomers+=4\n            else:\n                curCustomers+=rem\n                rem=0\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\n            if curProfit>maxProfit:\n                maxProfit=curProfit\n                ans=curRounds\n        return -1 if maxProfit<=0 else ans",
        "content": "```\\nclass Solution:\\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\\n        maxProfit=-1\\n        ans=i=curRounds=curCustomers=rem=0\\n        while i<len(customers) or rem:\\n            if i<len(customers):\\n                rem+=customers[i]\\n                i+=1\\n            curRounds+=1\\n            if rem-4>=0:\\n                rem-=4\\n                curCustomers+=4\\n            else:\\n                curCustomers+=rem\\n                rem=0\\n            curProfit=(curCustomers*boardingCost)-(curRounds*runningCost)\\n            if curProfit>maxProfit:\\n                maxProfit=curProfit\\n                ans=curRounds\\n        return -1 if maxProfit<=0 else ans\\n```"
    },
    {
        "slug": "number-of-operations-to-make-network-connected",
        "tags": "python3",
        "release_time": 1679538335,
        "code": "class Solution:\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\n        count = 0           # number of redundant connections\n        network = [i for i in range(n)]\n\n        def find(x):\n            if network[x] != x:\n                network[x] = find(network[x])\n            return network[x]\n        \n        def union(a, b):\n            # return True if 2 nodes are already connected.\n            root_a = find(a)\n            root_b = find(b)\n            network[root_a] = root_b\n            return True if root_a == root_b else False\n        \n        for link in connections:\n            if union(link[0], link[1]):\n                count += 1\n\n        # count the number of connected clusters\n        a = len(set([find(i) for i in range(n)]))\n        return -1 if a - 1 > count else a - 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Union find to count the redundant connections and connected clusters.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def makeConnected(self, n: int, connections: List[List[int]]) -> int:\\n        count = 0           # number of redundant connections\\n        network = [i for i in range(n)]\\n\\n        def find(x):\\n            if network[x] != x:\\n                network[x] = find(network[x])\\n            return network[x]\\n        \\n        def union(a, b):\\n            # return True if 2 nodes are already connected.\\n            root_a = find(a)\\n            root_b = find(b)\\n            network[root_a] = root_b\\n            return True if root_a == root_b else False\\n        \\n        for link in connections:\\n            if union(link[0], link[1]):\\n                count += 1\\n\\n        # count the number of connected clusters\\n        a = len(set([find(i) for i in range(n)]))\\n        return -1 if a - 1 > count else a - 1\\n```"
    },
    {
        "slug": "binary-tree-inorder-traversal",
        "tags": "python3",
        "release_time": 1688586459,
        "code": "class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        ans=[]\n        def inorder(root,ans):\n            if not root:\n                return None\n            inorder(root.left,ans)\n            ans.append(root.val)\n            inorder(root.right,ans)\n        inorder(root,ans)\n        return ans",
        "content": "# 1. Recursive Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        def inorder(root,ans):\\n            if not root:\\n                return None\\n            inorder(root.left,ans)\\n            ans.append(root.val)\\n            inorder(root.right,ans)\\n        inorder(root,ans)\\n        return ans\\n```\\n# 2. Iterative Approach\\n```\\nclass Solution:\\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        ans=[]\\n        stack=[]\\n        cur=root\\n        while stack or cur:\\n            if cur:\\n                stack.append(cur)\\n                cur=cur.left\\n            else:\\n                cur=stack.pop()\\n                ans.append(cur.val)\\n                cur=cur.right\\n        return ans\\n```\\n# please upvote me it would encourage me alot\\n"
    },
    {
        "slug": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
        "tags": "python3",
        "release_time": 1680223652,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n                                                            #DFS\n        stack = [(cloned)]\n        while stack:\n            n = stack.pop()\n            if n.val == target.val: return n\n            if n.left: stack.append(n.left)\n            if n.right: stack.append(n.right)\n                                                            #Recursive DFS\n        if not original: return None\n        if original is target: return cloned\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)",
        "content": "\\n\\n# Complexity\\n- Time complexity: O(n), whenre n is the number of nodes in cloned tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h), where h is the height of the cloned tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n                                                            #DFS\\n        stack = [(cloned)]\\n        while stack:\\n            n = stack.pop()\\n            if n.val == target.val: return n\\n            if n.left: stack.append(n.left)\\n            if n.right: stack.append(n.right)\\n                                                            #Recursive DFS\\n        if not original: return None\\n        if original is target: return cloned\\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n\\n```"
    },
    {
        "slug": "maximum-bags-with-full-capacity-of-rocks",
        "tags": "python3",
        "release_time": 1672116486,
        "code": "class Solution:\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\n        dif=[capacity[i]-rocks[i] for i in range(len(rocks))]\n        dif.sort()\n        ct=0\n        for i in range(len(dif)):\n            if additionalRocks==0:\n                break\n            if additionalRocks>=dif[i]:\n                ct+=1\n                additionalRocks-=dif[i]\n            else:\n                break\n        return ct",
        "content": "# Intuition\\nMy thought behind this logic is that I want to fill up the bags first that needs less additional rocks to full the bags\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIt\\'s the greedy approach, sort the bags with their difference between full capacity and current filled amount \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumBags(self, capacity: List[int], rocks: List[int], additionalRocks: int) -> int:\\n        dif=[capacity[i]-rocks[i] for i in range(len(rocks))]\\n        dif.sort()\\n        ct=0\\n        for i in range(len(dif)):\\n            if additionalRocks==0:\\n                break\\n            if additionalRocks>=dif[i]:\\n                ct+=1\\n                additionalRocks-=dif[i]\\n            else:\\n                break\\n        return ct\\n```"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "tags": "python3",
        "release_time": 1675783420,
        "code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        lst,val,tmp=[],[],[]\n        for i in nums:\n            if i==pivot:val.append(i)\n            elif i<pivot:lst.append(i)\n            else:tmp.append(i)\n        return lst+val+tmp",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        lst,val,tmp=[],[],[]\\n        for i in nums:\\n            if i==pivot:val.append(i)\\n            elif i<pivot:lst.append(i)\\n            else:tmp.append(i)\\n        return lst+val+tmp\\n```"
    },
    {
        "slug": "make-array-zero-by-subtracting-equal-amounts",
        "tags": "python3",
        "release_time": 1679755806,
        "code": "class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        uniq_non_zero = set()\n        for num in nums:\n            if num == 0:\n                continue\n            uniq_non_zero.add(num)\n        return len(uniq_non_zero)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA brute-force approach will be:\\n1. sort in increasing order\\n2. get first non-zero element\\n3. deduct all non-zero elements with the above\\n4. continue until all non-zero elements are zeroed out\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe above intuition, leads to the following realization:\\n\\nIf we count unique non-zero elements in the array, that many\\nnumber of operations are required to zero out the entire array\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where is n is the length of the array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m) where m is the total number of unique non-zero elements in the array\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumOperations(self, nums: List[int]) -> int:\\n        uniq_non_zero = set()\\n        for num in nums:\\n            if num == 0:\\n                continue\\n            uniq_non_zero.add(num)\\n        return len(uniq_non_zero)\\n```"
    },
    {
        "slug": "moving-stones-until-consecutive-ii",
        "tags": "python3",
        "release_time": 1690635827,
        "code": "class Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n                # increment \n                starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the base of this problem is a linear scan. This is because we are trying to achieve the pairing of minimum number of moves and maximum number of moves. As such, we are trying to sort the move value space and scan over it linearly. This can be achieved with a few key insights from the problem that keep it at a medium level. \\n\\nFirst, we have a list size lower bound of 3. This is actually dreadfully important for one of our key edge cases that make this easily solvable so don\\'t discard such things when they come up! \\n\\nSecond, we have that all the stone values are unique. \\n\\nThird, we have that all the stone values are positive integers from 1 to 10^9. This is important both as an insight into the fact that we are working with only positive values, and that we are working with a very large value space compared to a much relatively smaller value ordination (there are 10^9 values for the stones, but only 10^4 positions at most for them) \\n\\nWe are also provided with a helpful hint \\n>For the minimum, how many cows are already in place? For the maximum, we have to lose either the gap A[1] - A[0] or A[N-1] - A[N-2] (where N = A.length), but every other space can be occupied ?  \\n\\nWe turn first to the idea of the maximum, where we have a gap we will need to lose of either between the first and second position or ultimate and penultimate position. \\n\\nIf we consider a list of 3 items, our minimum, what is our minimum values to get our minimal return? Not to spoil anything, but it is 1, 2, 3 \\n\\nThis is key to the problem, since there are no spaces provided between the values, so our return should be [0, 0] \\n\\nBy realizing the impact of this the approach follows below. Try to work out for a few values and sizes to get the feel for it and you\\'ll likely find an understanding either intuitively or by action. I recommend working with small list sizes and trying to generate [0, 1], [0, 2], [1, 2], and [2, 2] with only 3 or so items. It\\'ll be difficult, but worth it for the understanding pay off. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe original ordering of the stones is not valid compared to their ordinal positioning, and since we know we have a size limit much less than a value limit, we start by sorting. \\n\\nThen, we want to know how much space we have to work witin, so get the size of your listing (how many stones do you have regardless of how much they are worth?) \\n\\nThen, we need to calculate the two largest costs, move penultimate and move ultimate (final in the code) \\n\\nMove penultimate is the cost of swapping the stones at the second to last spot and the first spot, minus the cost of the number of stones you have (Since you moved over the whole thing!) plus 2 to deal with the fact that they are unique\\n\\nMove ultimate is the cost of swapping the stones at the last spot and second spot, minus the cost of the number of stones you have plus 2 to deal with the fact that they are unique\\n\\nIf either of these is 0, the other must be locked in as most moves, as most moves will be the max of these two options (try to convince yourself of why that is the case! This relates to the idea of the list sizings, and is really clearly seen with a list of size 3)\\n\\nIf either is 0, \\n- min legal moves is min of 2 and most moves \\n- return min legal moves and most moves \\n\\nOtherwise we now must consider how many max legal moves are there really? \\n\\nSet max legal moves to 0 \\nSet starting index to 0 \\nenumerate index and stone in stones \\n- while stones at starting index lte stone - stone length \\n    - increment starting index \\n- our max legal moves here is the max of itself (so it preserves good discoveries) and index - starting index + 1 (+1 for the fact we use 0 indexing) \\n- but, it cannot get too big! Remember, we already found the actual max, so don\\'t let anything in here fool you! Set max legal moves as such to min(max(max_legal_moves, index - starting_index + 1), max_moves) \\n- this keeps our newly found max legal less than our actual max moves \\n\\nWhen done enumerating return length - max legal moves, max moves \\n\\n# Complexity\\n- Time complexity : O(S log S + S)\\n    - O(S log S) to sort the stones \\n    - O(S) to loop over (while loop is incindental, as it can only run as many times as the length of stones as well in total, so it does not add to this)  \\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo additional space utilized \\n\\n# Code\\n```\\nclass Solution:\\n    \\'\\'\\'\\n        Test cases walk through \\n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \\n\\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \\n        Stone length -> 3                                                                   5\\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \\n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \\n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \\n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\\n\\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \\n        starting index is 0                                                                 starting index is 0 \\n\\n        Enumeration                                                                         Enumeration\\n            index is 0, stone is 4                                                             index is 0, stone is 3 \\n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \\n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \\n                 -> max legal moves is 1                                                            \\n\\n            index is 1, stone is 7                                                             index is 1, stone is 4 \\n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \\n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\\n            stones[1] <= 7 - 3 ? No, skip while                                                 \\n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \\n                -> max legal moves is 1                                                        index is 2, stone is 5 \\n                                                                                               stones[0] lte 5 - 5 ? No skip while \\n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \\n            stones[1] <= 9 - 3 ? No, skip while                                                 \\n            max legal moves is min(max of self and 2-1 + 1), max_moves\\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \\n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \\n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \\n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \\n                                                                                               index is 4, stones is 10 \\n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 1 \\n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 2 \\n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \\n                                                                                                    starting index is 3 \\n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \\n                                                                                            End enumeration\\n\\n                                                                                            Return [5 - 3, 3] -> [2, 3]\\n    \\'\\'\\'\\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\\n        # order does not need to be maintained, so sorting is optimal \\n        stones.sort()\\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\\n        stone_length = len(stones)\\n        # what is the cost of moving the second to last stone and the 0th stone? \\n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \\n        # what is the cost of moving the last stone and the 1st stone? \\n        move_final = stones[-1] - stones[1] - stone_length + 2 \\n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \\n        # our most moves possible are the max of these two \\n        most_moves = max(move_penultimate, move_final)\\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \\n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \\n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \\n        # our minimal length is 3 \\n        # let a, b, c be stones in order \\n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \\n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \\n        # c - 1 = a + 1 -> c = a + 2 \\n        # all stones must be at least 1 to 10^9 and are unique \\n        # so at minimum a is 1, b is 2 and c is 3  \\n        # in this case, move final is also 0 so we get 0, 0 \\n        # if a = 4, b = 5, c = 7 \\n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \\n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \\n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \\n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \\n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \\n        if move_penultimate == 0 or move_final == 0 : \\n            min_legal_moves = min(2, most_moves)\\n            return [min_legal_moves, most_moves]\\n        # how many legal moves are there in sorted order? \\n        max_legal_moves = 0 \\n        # starting from 0th index \\n        starting_index = 0\\n        # enumerate each stone and index \\n        for index, stone in enumerate(stones) :\\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \\n            while stones[starting_index] <= stone - stone_length : \\n                # increment \\n                starting_index += 1\\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \\n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \\n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \\n        return [stone_length - max_legal_moves, most_moves]\\n```"
    },
    {
        "slug": "can-place-flowers",
        "tags": "python3",
        "release_time": 1691328348,
        "code": "class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        flowerbed=[0]+flowerbed+[0]\n        for i in range(1,len(flowerbed)-1):\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\n        if n<=0:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/c82b49a3-d51e-40a4-b4b5-197596cb28f2_1691328287.5834074.png)\\n\\n\\n\\n\\n\\nPLease UPVOTE \\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\\n        flowerbed=[0]+flowerbed+[0]\\n        for i in range(1,len(flowerbed)-1):\\n            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;n-=1\\n        if n<=0:return True\\n        return False\\n```"
    },
    {
        "slug": "count-operations-to-obtain-zero",
        "tags": "python3",
        "release_time": 1675354627,
        "code": "class Solution:\n    def countOperations(self, num1: int, num2: int) -> int:\n        count=0\n        while num1!=0 and num2!=0:\n            if num1>=num2:\n                num1=num1-num2\n                count+=1\n            else:\n                num2=num2-num1\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countOperations(self, num1: int, num2: int) -> int:\\n        count=0\\n        while num1!=0 and num2!=0:\\n            if num1>=num2:\\n                num1=num1-num2\\n                count+=1\\n            else:\\n                num2=num2-num1\\n                count+=1\\n        return count\\n\\n```"
    },
    {
        "slug": "maximum-difference-between-node-and-ancestor",
        "tags": "python3",
        "release_time": 1670564299,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        mini, maxi = root.val, root.val\n        ans = 0\n        st = [(root, mini, maxi)]\n        while st:\n            node, a, b = st.pop()\n            if node.right:\n                mini = min(node.right.val, node.val, a)\n                maxi = max(node.right.val, node.val, b)\n                ans = max(ans, maxi-mini)\n                st.append((node.right,mini , maxi))\n            if node.left:\n                mini = min(node.left.val, node.val, a)\n                maxi = max(node.left.val, node.val, b)\n                ans = max(ans, maxi-mini)\n                st.append((node.left,mini , maxi))\n        return ans",
        "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\\n        mini, maxi = root.val, root.val\\n        ans = 0\\n        st = [(root, mini, maxi)]\\n        while st:\\n            node, a, b = st.pop()\\n            if node.right:\\n                mini = min(node.right.val, node.val, a)\\n                maxi = max(node.right.val, node.val, b)\\n                ans = max(ans, maxi-mini)\\n                st.append((node.right,mini , maxi))\\n            if node.left:\\n                mini = min(node.left.val, node.val, a)\\n                maxi = max(node.left.val, node.val, b)\\n                ans = max(ans, maxi-mini)\\n                st.append((node.left,mini , maxi))\\n        return ans\\n\\n\\n```"
    },
    {
        "slug": "excel-sheet-column-title",
        "tags": "python3",
        "release_time": 1692665922,
        "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n        res = \"\"\n        while n > 0:\n            r = (n-1) % 26\n            n = (n-1)// 26\n            res += chr(ord(\"A\")+r)\n        return res[::-1]",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n        res = \"\"\\n        while n > 0:\\n            r = (n-1) % 26\\n            n = (n-1)// 26\\n            res += chr(ord(\"A\")+r)\\n        return res[::-1]\\n```"
    },
    {
        "slug": "corporate-flight-bookings",
        "tags": "python3",
        "release_time": 1671743412,
        "code": "class Solution:\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\n\n        arr = [0]*(n+1)\n        for lv, ar, seats in bookings:\n            arr[lv-1]+= seats\n            arr[ar]-= seats\n\n        return list(accumulate(arr[:-1]))",
        "content": "```\\nclass Solution:\\n    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:\\n\\n        arr = [0]*(n+1)\\n        for lv, ar, seats in bookings:\\n            arr[lv-1]+= seats\\n            arr[ar]-= seats\\n\\n        return list(accumulate(arr[:-1]))\\n```\\n[https://leetcode.com/problems/corporate-flight-bookings/submissions/863934491/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(*N*)."
    },
    {
        "slug": "excel-sheet-column-title",
        "tags": "python3",
        "release_time": 1692685570,
        "code": "class Solution:\n    def convertToTitle(self, n: int) -> str:\n\n        alpha, ans = 'Z'+ ascii_uppercase, \"\"\n\n        while n:\n            n, r = divmod(n,26)\n            ans = alpha[r] + ans\n            if not r: n-= 1\n        return ans",
        "content": "```\\nclass Solution:\\n    def convertToTitle(self, n: int) -> str:\\n\\n        alpha, ans = \\'Z\\'+ ascii_uppercase, \"\"\\n\\n        while n:\\n            n, r = divmod(n,26)\\n            ans = alpha[r] + ans\\n            if not r: n-= 1\\n        return ans\\n```\\n[https://leetcode.com/problems/excel-sheet-column-title/submissions/611614578/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(log*N*) and space complexity is *O*(1), in which *N* ~ `n`."
    },
    {
        "slug": "design-linked-list",
        "tags": "python3",
        "release_time": 1676191082,
        "code": "class Node:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n\n\nclass MyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n        self.lenn = 0\n        \n\n    def get(self, index: int) -> int:\n        if index >= self.lenn:\n            return -1\n        \n        cur = self.head\n        while index:\n            cur = cur.next\n            index -= 1\n        return cur.val\n        \n\n    def addAtHead(self, val: int) -> None:\n        new = Node(val)\n        self.head, new.next = new, self.head\n        if not self.tail:\n            self.tail = self.head\n\n        self.lenn += 1\n        \n\n    def addAtTail(self, val: int) -> None:\n        new = Node(val)\n        if self.head:\n            self.tail.next, self.tail = new, new\n        else:\n            self.head = self.tail = new\n\n        self.lenn += 1\n        \n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index > self.lenn:\n            return\n        elif index == self.lenn:\n            self.addAtTail(val)\n        elif index == 0:\n            self.addAtHead(val)\n        else:\n            cur = self.head\n            index -= 1\n            while index:\n                cur = cur.next\n                index -= 1\n\n            new = Node(val)\n            cur.next, new.next = new, cur.next\n\n            self.lenn += 1\n        \n\n    def deleteAtIndex(self, index: int) -> None:\n        if index >= self.lenn:\n            return\n        elif index == 0:\n            self.head = self.head.next\n        else:\n            cur = self.head\n            i = index - 1\n            while i:\n                cur = cur.next\n                i -= 1\n        \n            cur.next = cur.next.next\n            if index == self.lenn - 1:\n                self.tail = cur\n\n        self.lenn -= 1\n        if self.lenn == 0:\n            self.head = self.tail = None\n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.val = val\\n        self.next = None\\n\\n\\nclass MyLinkedList:\\n    def __init__(self):\\n        self.head = None\\n        self.tail = None\\n        self.lenn = 0\\n        \\n\\n    def get(self, index: int) -> int:\\n        if index >= self.lenn:\\n            return -1\\n        \\n        cur = self.head\\n        while index:\\n            cur = cur.next\\n            index -= 1\\n        return cur.val\\n        \\n\\n    def addAtHead(self, val: int) -> None:\\n        new = Node(val)\\n        self.head, new.next = new, self.head\\n        if not self.tail:\\n            self.tail = self.head\\n\\n        self.lenn += 1\\n        \\n\\n    def addAtTail(self, val: int) -> None:\\n        new = Node(val)\\n        if self.head:\\n            self.tail.next, self.tail = new, new\\n        else:\\n            self.head = self.tail = new\\n\\n        self.lenn += 1\\n        \\n\\n    def addAtIndex(self, index: int, val: int) -> None:\\n        if index > self.lenn:\\n            return\\n        elif index == self.lenn:\\n            self.addAtTail(val)\\n        elif index == 0:\\n            self.addAtHead(val)\\n        else:\\n            cur = self.head\\n            index -= 1\\n            while index:\\n                cur = cur.next\\n                index -= 1\\n\\n            new = Node(val)\\n            cur.next, new.next = new, cur.next\\n\\n            self.lenn += 1\\n        \\n\\n    def deleteAtIndex(self, index: int) -> None:\\n        if index >= self.lenn:\\n            return\\n        elif index == 0:\\n            self.head = self.head.next\\n        else:\\n            cur = self.head\\n            i = index - 1\\n            while i:\\n                cur = cur.next\\n                i -= 1\\n        \\n            cur.next = cur.next.next\\n            if index == self.lenn - 1:\\n                self.tail = cur\\n\\n        self.lenn -= 1\\n        if self.lenn == 0:\\n            self.head = self.tail = None\\n\\n\\n# Your MyLinkedList object will be instantiated and called as such:\\n# obj = MyLinkedList()\\n# param_1 = obj.get(index)\\n# obj.addAtHead(val)\\n# obj.addAtTail(val)\\n# obj.addAtIndex(index,val)\\n# obj.deleteAtIndex(index)\\n```"
    },
    {
        "slug": "count-the-number-of-vowel-strings-in-range",
        "tags": "python3",
        "release_time": 1679626972,
        "code": "class Solution:\n    def isVowel(self, char):\n        return True if char in ('A', 'E', 'I', 'O', 'U', 'a', 'e', 'i', 'o', 'u') else False\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\n        count = 0\n        for i in range(left, right+1):\n            wordLen = len(words[i])\n            if self.isVowel(words[i][0]) and self.isVowel(words[i][-1]):\n                count += 1 \n        return count",
        "content": "# Intuition\\nThis a simple string problem. We can solve it simple iterative approach.\\n\\n# Approach\\nIterative approach.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - Linear Time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - Constant Time\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isVowel(self, char):\\n        return True if char in (\\'A\\', \\'E\\', \\'I\\', \\'O\\', \\'U\\', \\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\') else False\\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\\n        count = 0\\n        for i in range(left, right+1):\\n            wordLen = len(words[i])\\n            if self.isVowel(words[i][0]) and self.isVowel(words[i][-1]):\\n                count += 1 \\n        return count\\n\\n```"
    },
    {
        "slug": "convert-integer-to-the-sum-of-two-no-zero-integers",
        "tags": "python3",
        "release_time": 1679182204,
        "code": "class Solution:\n    def getNoZeroIntegers(self, n: int) -> List[int]:\n        for i in range(n-1, -1, -1):\n            if '0' not in str(i) and '0' not in str(n - i):\n                return [i, n-i ]\n\n        #Oneliner\n\n        return next([i, n-i] for i in range(n-1, -1, -1) if '0' not in str(i) and '0' not in str(n-i))",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getNoZeroIntegers(self, n: int) -> List[int]:\\n        for i in range(n-1, -1, -1):\\n            if \\'0\\' not in str(i) and \\'0\\' not in str(n - i):\\n                return [i, n-i ]\\n\\n        #Oneliner\\n\\n        return next([i, n-i] for i in range(n-1, -1, -1) if \\'0\\' not in str(i) and \\'0\\' not in str(n-i))\\n```"
    },
    {
        "slug": "length-of-the-longest-valid-substring",
        "tags": "python3",
        "release_time": 1689480141,
        "code": "class Solution:\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\n        trie = {}\n        for f in forbidden:\n            t = trie\n            for c in f:\n                if c not in t:\n                    t[c] = {}\n                t = t[c]\n            t[\"end\"] = True\n        \n        def isForbidden(s):\n            t = trie\n            counter = 0\n            for c in s:\n                if c not in t:\n                    return False\n                t = t[c]\n                counter += 1\n                if \"end\" in t:\n                    return counter\n            return False\n        \n        res = 0\n        j = len(word)\n        for i in range(len(word) - 1, -1, -1):\n            truc = isForbidden(word[i:j])\n            if truc:\n                j = i + truc - 1\n            res = max(res, j - i)\n        return res",
        "content": "Put all the forbidden strings into a trie, so that for each string `s`, we can check every substring starts from the beginning (i.e. `s[:1]`,  `s[:2]` ...  `s[:len(s)]`) in one travesal.\\n\\nUse a sliding window to iterate from back to front, each time, we only need to check whether the substrings starting from the new character is forbidden. If the substring is forbidden, then we truncate the string and continue to search.\\n\\nUsing a trie can make the foibidden check fails faster and can deal with longer foibidden strings.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:\\n        trie = {}\\n        for f in forbidden:\\n            t = trie\\n            for c in f:\\n                if c not in t:\\n                    t[c] = {}\\n                t = t[c]\\n            t[\"end\"] = True\\n        \\n        def isForbidden(s):\\n            t = trie\\n            counter = 0\\n            for c in s:\\n                if c not in t:\\n                    return False\\n                t = t[c]\\n                counter += 1\\n                if \"end\" in t:\\n                    return counter\\n            return False\\n        \\n        res = 0\\n        j = len(word)\\n        for i in range(len(word) - 1, -1, -1):\\n            truc = isForbidden(word[i:j])\\n            if truc:\\n                j = i + truc - 1\\n            res = max(res, j - i)\\n        return res\\n```"
    },
    {
        "slug": "card-flipping-game",
        "tags": "python3",
        "release_time": 1685678247,
        "code": "class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\n        for i in sorted(set(fronts + backs)):\n            if i in bad:\n                continue\n            return i\n        return 0",
        "content": "# Intuition\\nThe only way you can\\'t have a good integer is if you have a card with it on both sides.  You want the minimum, so just sort, giving you the lowest, and check if any card has it on both sides.\\n\\n# Code\\n```\\nclass Solution:\\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\\n        bad = set(i for i,j in zip(fronts, backs) if i==j)\\n        for i in sorted(set(fronts + backs)):\\n            if i in bad:\\n                continue\\n            return i\\n        return 0\\n\\n```"
    },
    {
        "slug": "xor-queries-of-a-subarray",
        "tags": "python3",
        "release_time": 1665357595,
        "code": "class Solution:\n    #Let n = len(arr) and m = len(queries)!\n    #Time-Complexity: O(n + m)\n    #Space-Complexity: O(n)\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\n        #Approach: To get prefix exclusive or from L to R indices, you can first get prefix exclusive\n        #ors from index 0 to last index position in-bouds! Then, to get exclusive or using elements\n        #from arr from L to R, then take prefix[L-1] ^ prefix[R] -> (arr[0] ^ arr[1] ^...^arr[L-1]) ^\n        #(arr[0] ^ arr[1] ^...^arr[R]) -> the pairs of arr[0] to arr[L-1] will exclusive or to 0 ->\n        #chain of 0 exclusive ors -> the result is arr[L] ^ arr[L+1] ^...^arr[R]!\n        \n        #initialize prefix exclusive or with first element of input array!\n        prefix_or = [arr[0]]\n        for i in range(1, len(arr)):\n            prefix_or.append(prefix_or[i-1] ^ arr[i])\n        #intialize answer!\n        ans = []\n        for L, R in queries:\n            L_one_less = None\n            if(L == 0):\n                ans.append(prefix_or[R])\n                continue\n            L_one_less = prefix_or[L-1]\n            sub_res = prefix_or[R]\n            res = L_one_less ^ sub_res\n            ans.append(res)\n        return ans",
        "content": "```\\nclass Solution:\\n    #Let n = len(arr) and m = len(queries)!\\n    #Time-Complexity: O(n + m)\\n    #Space-Complexity: O(n)\\n    def xorQueries(self, arr: List[int], queries: List[List[int]]) -> List[int]:\\n        #Approach: To get prefix exclusive or from L to R indices, you can first get prefix exclusive\\n        #ors from index 0 to last index position in-bouds! Then, to get exclusive or using elements\\n        #from arr from L to R, then take prefix[L-1] ^ prefix[R] -> (arr[0] ^ arr[1] ^...^arr[L-1]) ^\\n        #(arr[0] ^ arr[1] ^...^arr[R]) -> the pairs of arr[0] to arr[L-1] will exclusive or to 0 ->\\n        #chain of 0 exclusive ors -> the result is arr[L] ^ arr[L+1] ^...^arr[R]!\\n        \\n        #initialize prefix exclusive or with first element of input array!\\n        prefix_or = [arr[0]]\\n        for i in range(1, len(arr)):\\n            prefix_or.append(prefix_or[i-1] ^ arr[i])\\n        #intialize answer!\\n        ans = []\\n        for L, R in queries:\\n            L_one_less = None\\n            if(L == 0):\\n                ans.append(prefix_or[R])\\n                continue\\n            L_one_less = prefix_or[L-1]\\n            sub_res = prefix_or[R]\\n            res = L_one_less ^ sub_res\\n            ans.append(res)\\n        return ans"
    },
    {
        "slug": "minimum-operations-to-make-a-subsequence",
        "tags": "python3",
        "release_time": 1609646709,
        "code": "class Solution:\n    def minOperations(self, target: List[int], arr: List[int]) -> int:\n        loc = {x: i for i, x in enumerate(target)}\n        stack = []\n        for x in arr: \n            if x in loc: \n                i = bisect_left(stack, loc[x])\n                if i < len(stack): stack[i] = loc[x]\n                else: stack.append(loc[x])\n        return len(target) - len(stack)",
        "content": "**Algo**\\nMaintain an increasing array of indices of values in `target`. \\n\\n**Implementation** \\n```\\nclass Solution:\\n    def minOperations(self, target: List[int], arr: List[int]) -> int:\\n        loc = {x: i for i, x in enumerate(target)}\\n        stack = []\\n        for x in arr: \\n            if x in loc: \\n                i = bisect_left(stack, loc[x])\\n                if i < len(stack): stack[i] = loc[x]\\n                else: stack.append(loc[x])\\n        return len(target) - len(stack)\\n```\\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`"
    },
    {
        "slug": "maximum-number-of-moves-in-a-grid",
        "tags": "python3",
        "release_time": 1684134022,
        "code": "class Solution:\n    def maxMoves(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dq = deque(range(m))\n        moves = 0\n        while dq and moves < n-1:\n            nxt = set()\n            for _ in range(len(dq)):\n                idx = dq.popleft()\n                val = grid[idx][moves]\n                for i in range(max(0, idx-1), min(m, idx+2)):\n                    if grid[i][moves+1] > val:\n                        nxt.add(i)\n            if len(nxt) > 0:\n                moves += 1\n            dq.extend(nxt)\n        return moves",
        "content": "1. From left to right, for each column, save the row_indices of reachable cells in `dq`.\\n2. Row_indices of reachable cells in the next column are saved in `nxt`. If `nxt` is nonempty, we can move to the next column, hence add 1 to `moves`.\\n```\\nclass Solution:\\n    def maxMoves(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        dq = deque(range(m))\\n        moves = 0\\n        while dq and moves < n-1:\\n            nxt = set()\\n            for _ in range(len(dq)):\\n                idx = dq.popleft()\\n                val = grid[idx][moves]\\n                for i in range(max(0, idx-1), min(m, idx+2)):\\n                    if grid[i][moves+1] > val:\\n                        nxt.add(i)\\n            if len(nxt) > 0:\\n                moves += 1\\n            dq.extend(nxt)\\n        return moves\\n"
    },
    {
        "slug": "longest-non-decreasing-subarray-from-two-arrays",
        "tags": "python3",
        "release_time": 1689023068,
        "code": "class Solution:\n    def maxNonDecreasingLength(self, nums1: List[int],\n                                     nums2: List[int]) -> int:        \n\n        ans, s0, s1 = 1,1,1\n\n        for a1,b1,a2,b2 in zip(nums1, nums1[1:], \n                               nums2, nums2[1:]):\n     \n            s0, s1 = (max(s0*(a1 <= b1),  s1*(a2 <= b1))+1, \n                      max(s0*(a1 <= b2),  s1*(a2 <= b2))+1)\n\n            ans = max(ans, s0, s1)\n\n        return ans",
        "content": "See\\n\\n[https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/solutions/3739198/java-c-python-dp/] (yup, @leecode215) \\n\\nfor a detailed explanation of the algorithm. (If you feel like upvoting, upvote him instead. I\\'m just playing in the cover band...)\\n```\\nclass Solution:\\n    def maxNonDecreasingLength(self, nums1: List[int],\\n                                     nums2: List[int]) -> int:        \\n\\n        ans, s0, s1 = 1,1,1\\n\\n        for a1,b1,a2,b2 in zip(nums1, nums1[1:], \\n                               nums2, nums2[1:]):\\n     \\n            s0, s1 = (max(s0*(a1 <= b1),  s1*(a2 <= b1))+1, \\n                      max(s0*(a1 <= b2),  s1*(a2 <= b2))+1)\\n\\n            ans = max(ans, s0, s1)\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/longest-non-decreasing-subarray-from-two-arrays/submissions/991305892/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1), in which *N* ~ `len(nums1)`."
    },
    {
        "slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
        "tags": "python3",
        "release_time": 1668377140,
        "code": "class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        def makeNode(p, i, j):\n            if j-i < 1:\n                return None\n            p[0] += 1\n            return TreeNode(inorder[i]) if j-i == 1 else makeTree(p,i,j)\n        def makeTree(p,i,j):\n            v = preorder[p[0]]\n            k = inorder.index(v, i, j)\n            return TreeNode(v, makeNode(p, i, k), makeNode(p, k + 1, j))\n        return makeTree([0],0,len(inorder))",
        "content": "**First draft:**\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        def makeNode(p, i, j):\\n            if j-i < 1:\\n                return None\\n            p[0] += 1\\n            return TreeNode(inorder[i]) if j-i == 1 else makeTree(p,i,j)\\n        def makeTree(p,i,j):\\n            v = preorder[p[0]]\\n            k = inorder.index(v, i, j)\\n            return TreeNode(v, makeNode(p, i, k), makeNode(p, k + 1, j))\\n        return makeTree([0],0,len(inorder))\\n```\\nKey insights and algorithm:\\n- the first item in preorder is root\\n- we can partition inorder on root resulting in two subarrays such that the left and right subarrays are the in-order traversals for root\\'s left and right subtrees\\n- if the left subarray is empty, root.left is null; otherwise we advance the pointer into preorder and set root.left to be (1) a leaf node if the left subarray has only one item or (2) a recursively built subTree using the suffix of preorder beginning at our pointer and the left subarray of inorder\\n- we treat the right subarray similarly.\\n\\nTime complexity is O(n log n) because we use one or more calls to index() totaling O(n) operations at each level of the tree, with O(log n) levels. Space complexity is O(n) for the new tree data structure.\\n\\n**Second draft:**\\n```\\nclass Solution:\\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\\n        idx = {v:i for i, v in enumerate(inorder)}\\n        def makeNode(p, i, j):\\n            if j-i < 1:\\n                return None\\n            p[0] += 1\\n            return TreeNode(inorder[i]) if j-i == 1 else makeTree(p,i,j)\\n        def makeTree(p,i,j):\\n            v = preorder[p[0]]\\n            return TreeNode(v, makeNode(p, i, idx[v]), makeNode(p, idx[v] + 1, j))\\n        return makeTree([0],0,len(inorder))\\n```\\nChanges:\\n- now we initialize a dictionary that maps value to index within inorder, adding O(n) to our space complexity which leaves it unchanged at O(n)\\n- time complexity is reduced to O(n) since we have replaced the O(n) index() calls per O(log n) tree levels with a single O(1) dictionary lookup at each of the n iterations over preorder."
    },
    {
        "slug": "minimum-size-subarray-sum",
        "tags": "python3",
        "release_time": 1688621746,
        "code": "class Solution:\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\n        minlen = float('inf')\n        l,sum =0,0\n        for r in range(len(nums)):\n            sum += nums[r]\n            while sum >= target:\n                minlen = min(minlen, r-l+1)\n                sum -= nums[l]\n                l += 1\n        return minlen if minlen<=len(nums) else 0",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe use the sliding window approach where the sum of elements in the window is considered at every iteration. If the sum >= target we update our answer, yet since we need the minimum possible size, we keep decreasing the size of the window as much as possible from the left to get the minimum length subarray. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe set the `minlen`(minimum window size) to `float(\\'inf\\')` which is the maximum possible value. Next we initialize left boundary of our window `l` to `0`. `sum` is the variable that calculates the sum of numbers in each window and we compare it with the `target`. We iterate over `r`, the right boundary of the window. Hence our window size is `r-l+1`. For each `r` we add `nums[r]` to the  `sum`. If `sum >= target` we update `minlen`. But, we might get a smaller window size as well where the condition `sum >= target` suffices. Hence, we reduce the window size, by increasing `l` by `1` and subtracting `nums[l]` from `sum` and updating `minlen` as long as the condition holds. Now, if there is no such subarray,`minlen` still has the value  `float(\\'inf\\')`. So, we return `0` in this case, otherwise we return `minlen`.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSubArrayLen(self, target: int, nums: List[int]) -> int:\\n        minlen = float(\\'inf\\')\\n        l,sum =0,0\\n        for r in range(len(nums)):\\n            sum += nums[r]\\n            while sum >= target:\\n                minlen = min(minlen, r-l+1)\\n                sum -= nums[l]\\n                l += 1\\n        return minlen if minlen<=len(nums) else 0\\n\\n\\n```"
    },
    {
        "slug": "smallest-string-with-swaps",
        "tags": "python3",
        "release_time": 1651023323,
        "code": "class Solution:\n    def union(self, a, b):\n        self.parent[self.find(a)] = self.find(b)\n\t\t\n    def find(self, a):\n        if self.parent[a] != a:\n            self.parent[a] = self.find(self.parent[a])\n\n        return self.parent[a]\n        \n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\n\t\t# 1. Union-Find\n        self.parent = list(range(len(s)))\n        for a, b in pairs:\n            self.union(a, b)\n\n\t\t# 2. Grouping\n        group = defaultdict(lambda: ([], []))  \n        for i, ch in enumerate(s):\n            parent = self.find(i)\n            group[parent][0].append(i)\n            group[parent][1].append(ch)\n\n\t\t# 3. Sorting\n        res = [''] * len(s)\n        for ids, chars in group.values():\n            ids.sort()\n            chars.sort()\n            for ch, i in zip(chars, ids):\n                res[i] = ch\n                \n        return ''.join(res)",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**"
    },
    {
        "slug": "next-greater-element-i",
        "tags": "python3",
        "release_time": 1691487651,
        "code": "class Solution:\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        out=[]\n        for i in range(0,len(nums1)):\n            if(nums2.index(nums1[i])==len(nums2)-1):\n                out.append(-1)\n            else:\n                j=nums2.index(nums1[i])+1\n                while(1):\n                    if(nums1[i]<nums2[j]):\n                        out.append(nums2[j])\n                        break\n                    if(j==len(nums2)-1):\n                        out.append(-1)\n                        break\n                    j+=1\n        return out",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:\\n        out=[]\\n        for i in range(0,len(nums1)):\\n            if(nums2.index(nums1[i])==len(nums2)-1):\\n                out.append(-1)\\n            else:\\n                j=nums2.index(nums1[i])+1\\n                while(1):\\n                    if(nums1[i]<nums2[j]):\\n                        out.append(nums2[j])\\n                        break\\n                    if(j==len(nums2)-1):\\n                        out.append(-1)\\n                        break\\n                    j+=1\\n        return out\\n```"
    },
    {
        "slug": "validate-binary-search-tree",
        "tags": "python3",
        "release_time": 1692592763,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        stack=[]\n        stack.append([root,-1*float('inf'),float('inf')])\n        while(stack):\n            s=stack.pop()\n            t=s[0]\n            le=s[1]\n            ri=s[2]\n            if t.val<=le or t.val>=ri:\n                return False\n            if t.right!=None:\n                stack.append([t.right,t.val,ri])\n            if t.left!=None:\n                stack.append([t.left,le,t.val])\n        return True",
        "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        stack=[]\\n        stack.append([root,-1*float(\\'inf\\'),float(\\'inf\\')])\\n        while(stack):\\n            s=stack.pop()\\n            t=s[0]\\n            le=s[1]\\n            ri=s[2]\\n            if t.val<=le or t.val>=ri:\\n                return False\\n            if t.right!=None:\\n                stack.append([t.right,t.val,ri])\\n            if t.left!=None:\\n                stack.append([t.left,le,t.val])\\n        return True\\n```"
    },
    {
        "slug": "jump-game-vii",
        "tags": "python3",
        "release_time": 1690351903,
        "code": "class Solution:\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n        \n        window = deque()\n        # to keep the list of past maxJump reachable indices\n        \n        window.append(0)\n        for i in range(1, len(s)):\n            \n            # clear the window beyond maxJump\n            if window and window[0] + maxJump < i:\n                window.popleft()\n\n            # check reachability of i\n            if s[i] == '0' and window and window[0] + minJump <= i:\n                window.append(i)\n\n        return window and window[-1] == len(s) - 1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor computing if any index i is reachable from index 0 or not, we only need the reachability information of indices in the range (i-maxJump, i-1). This is because if index i is reachable and has a path from index 0, then it has to have a predecessor node / index in the range (i-maxJump, i-1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We linearly scan each index / element of s.\\n\\n2. For each index i (if s[i] = 0) we check if it\\'s reachable from index 0 or not.\\n\\n3. For this check, we manitain a sliding window that contains all the reachable-from-index-0 indices in the range (i-maxJump, i-1). This window contains all indices in increasing order.\\n\\n4. So for each i we check if the first element f (smallest and farthest from i) in the window doesn\\'t skip i with the smallest possible jump. That is, i >= f + minJump. This is because if i < f + minJump, then no other index j in the window can jump to i (all of them will jump ahead of i).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) for linear scanning of s\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(maxJump) for the sliding window\\n\\n# Code\\n```\\nclass Solution:\\n    def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\\n        \\n        window = deque()\\n        # to keep the list of past maxJump reachable indices\\n        \\n        window.append(0)\\n        for i in range(1, len(s)):\\n            \\n            # clear the window beyond maxJump\\n            if window and window[0] + maxJump < i:\\n                window.popleft()\\n\\n            # check reachability of i\\n            if s[i] == \\'0\\' and window and window[0] + minJump <= i:\\n                window.append(i)\\n\\n        return window and window[-1] == len(s) - 1\\n```"
    },
    {
        "slug": "node-with-highest-edge-score",
        "tags": "python3",
        "release_time": 1673006370,
        "code": "class Solution:\n    def edgeScore(self, edges: List[int]) -> int:\n        n=len(edges)\n        sc=[0]*n\n        mx=0\n        ans=0\n        for i in range(n):\n            sc[edges[i]]+=i\n            if sc[edges[i]]>mx:\n                mx=sc[edges[i]]\n                ans=edges[i]\n            elif sc[edges[i]]==mx:\n                if ans>edges[i]:\n                    ans=edges[i]\n        return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nArray Traversal\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def edgeScore(self, edges: List[int]) -> int:\\n        n=len(edges)\\n        sc=[0]*n\\n        mx=0\\n        ans=0\\n        for i in range(n):\\n            sc[edges[i]]+=i\\n            if sc[edges[i]]>mx:\\n                mx=sc[edges[i]]\\n                ans=edges[i]\\n            elif sc[edges[i]]==mx:\\n                if ans>edges[i]:\\n                    ans=edges[i]\\n        return ans\\n\\n        \\n```"
    },
    {
        "slug": "check-if-move-is-legal",
        "tags": "python3",
        "release_time": 1683004690,
        "code": "class Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n\n        board = [['.']*10] + [                      #  <--  border the board with ['.'] cells\n                 ['.']+row+['.'] for row in board]+ [ \n                 ['.']*10]\n\n        other = 'B' if color == 'W' else 'W'\n\n        dir = ((-1,-1), (-1,0), (-1, 1),            #   <--  The eight directions\n               ( 0,-1),         ( 0, 1),\n               ( 1,-1), ( 1,0), ( 1, 1))\n\n        for dr, dc in dir:\n\n            r, c = rMove + 1 + dr, cMove + 1 + dc   #   <--  First, check whether cell adj to \n            if board[r][c] != other: continue       #        move cell is the other color\n\n            while board[r][c] == other:             #   <--  Second, iterate through any \n                r+= dr                              #        other-color cells\n                c+= dc\n\n            if board[r][c] == color: return True    #   <--  Third, if the cell after the string \n                                                    #        of other-color cells is a color cell\n        return False",
        "content": "Pretty much the same eight-direction approach as other posted solutions, but with one additional twist. We construct a border of`[\".\"]`cells around the`board`. Having this border reduces the number of states to be tested to determine whether a specific direction yields a legal move.\\n```\\nclass Solution:\\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\\n\\n        board = [[\\'.\\']*10] + [                      #  <--  border the board with [\\'.\\'] cells\\n                 [\\'.\\']+row+[\\'.\\'] for row in board]+ [ \\n                 [\\'.\\']*10]\\n\\n        other = \\'B\\' if color == \\'W\\' else \\'W\\'\\n\\n        dir = ((-1,-1), (-1,0), (-1, 1),            #   <--  The eight directions\\n               ( 0,-1),         ( 0, 1),\\n               ( 1,-1), ( 1,0), ( 1, 1))\\n\\n        for dr, dc in dir:\\n\\n            r, c = rMove + 1 + dr, cMove + 1 + dc   #   <--  First, check whether cell adj to \\n            if board[r][c] != other: continue       #        move cell is the other color\\n\\n            while board[r][c] == other:             #   <--  Second, iterate through any \\n                r+= dr                              #        other-color cells\\n                c+= dc\\n\\n            if board[r][c] == color: return True    #   <--  Third, if the cell after the string \\n                                                    #        of other-color cells is a color cell\\n        return False\\n```\\n[https://leetcode.com/problems/check-if-move-is-legal/submissions/1007185467/]()\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(1) and space complexity is *O*(1).\\n"
    },
    {
        "slug": "shortest-cycle-in-a-graph",
        "tags": "python3",
        "release_time": 1681100130,
        "code": "class Solution:\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\n        graph = defaultdict(list)\n        for i, j in edges:\n            graph[i].append(j)\n            graph[j].append(i)\n        \n        def dfs(start):\n            # return shortest cycle staring at start\n            # store (cur, parent)\n            dq = deque([(start, -1)])\n            dist = [float('inf')] * n\n            dist[start] = 0\n            cur_min = float('inf')\n            while dq:\n                cur, par = dq.popleft()\n                for nei in graph[cur]:\n                    if dist[nei] == float('inf'):\n                        dist[nei] = dist[cur] + 1\n                        dq.append((nei, cur))\n                    elif nei != par:\n                        cur_min = min(cur_min, dist[nei] + dist[cur] + 1)\n                # if not comment out below 2 lines and return early, it will fail the list test case, why?? \n                # I thought as long as it finds a cycle, it must be the shortest from this node due to bfs property?\n                # if cur_min < float('inf'):\n                #     return cur_min\n            return cur_min\n        \n        ans = min([dfs(i) for i in range(n)])\n        return ans if ans < float('inf') else -1",
        "content": "The overall idea is to apply bfs, and viewed a cycle as two different paths starting from start, and merge at a common node. \\n\\nFor this test case\\n[[0,3],[0,5],[3,4],[4,5],[1,9],[1,11],[9,10],[11,10],[2,6],[2,8],[6,7],[8,7],[0,1],[0,2],[1,2]]\\n\\nCan some one help explain why.. it forms a very special graph if you draw it. I think immediately after we found a cycle, we can return its length already, but it would fail. See code comment below. Thanks!\\n```\\nclass Solution:\\n    def findShortestCycle(self, n: int, edges: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for i, j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n        \\n        def dfs(start):\\n            # return shortest cycle staring at start\\n            # store (cur, parent)\\n            dq = deque([(start, -1)])\\n            dist = [float(\\'inf\\')] * n\\n            dist[start] = 0\\n            cur_min = float(\\'inf\\')\\n            while dq:\\n                cur, par = dq.popleft()\\n                for nei in graph[cur]:\\n                    if dist[nei] == float(\\'inf\\'):\\n                        dist[nei] = dist[cur] + 1\\n                        dq.append((nei, cur))\\n                    elif nei != par:\\n                        cur_min = min(cur_min, dist[nei] + dist[cur] + 1)\\n                # if not comment out below 2 lines and return early, it will fail the list test case, why?? \\n                # I thought as long as it finds a cycle, it must be the shortest from this node due to bfs property?\\n                # if cur_min < float(\\'inf\\'):\\n                #     return cur_min\\n            return cur_min\\n        \\n        ans = min([dfs(i) for i in range(n)])\\n        return ans if ans < float(\\'inf\\') else -1\\n```"
    },
    {
        "slug": "array-partition",
        "tags": "python3",
        "release_time": 1679312457,
        "code": "class Solution:\n    def arrayPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        res = 0\n        for i in range(0, len(nums), 2):\n            res += nums[i]\n        return res",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        res = 0\\n        for i in range(0, len(nums), 2):\\n            res += nums[i]\\n        return res\\n        \\n```\\none-liner:\\n```\\nclass Solution:\\n    def arrayPairSum(self, nums: List[int]) -> int:\\n        return sum(sorted(nums)[::2])\\n```"
    },
    {
        "slug": "check-if-point-is-reachable",
        "tags": "python3",
        "release_time": 1674321554,
        "code": "class Solution:\n    def isReachable(self, targetX: int, targetY: int) -> bool:\n        def gcd(a, b):\n            while b:\n                a, b=b, a%b\n            return a\n        d=gcd(targetX, targetY)\n        while d!=1:\n            if d&1:\n                return False\n            d>>=1\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition is quite straightforward: a pair (a, b) is accessible if and only if the greatest common divisor of a and b, gcd(a, b), is a power of 2.\\nThe difficulty is proving this, which fortunately was not required during the contest. Anyway, here is the proof.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn one direction, note that all four operations preserve this property. The starting pair (1, 1) has it since $gcd(1, 1)=1=2^0$, the first two operations preserve the gcd, and the last two operations can multiply the gcd by 2 (or not). Thus, gcd(a, b) can only be a power of 2.\\n\\nConversely, starting from (1, 1) and multiplying the first term repeatedly by 2 we can obtain any pair of the form $(2^n, 1)$, then subtracting $1$ from $2^n$ repeatedly we can obtain any pair of the form $(n, 1)$.\\n\\nMultiplying the second term by 2 repeatedly we can obtain any pair of the form $(n, 2^m)$, then by subtracting $n$ from $2^m$ repeatedly we can obtain any pair of the form $(n,\\\\ 2^m \\\\mod n)$.\\n\\nSuppose we want to obtain the pair (n, k), where k<n and gcd(n, k)=1. Consider the infinite arithmetic progression (n, n+k, n+2k, ...). By Dirichlet\\'s theorem, this progression contains infinitely many primes. Consider one of them: p=n+jk for some $j \\\\geq 0$.\\n\\nBy a slight generalization of [Artin\\'s conjecture](https://mathworld.wolfram.com/ArtinsConjecture.html) (the generalization may need proof, but Artin\\'s conjecture was proved by Christopher Hooley, [\"On Artin\\'s Conjecture\"](https://eudml.org/doc/150785), in 1967, assuming the [Generalized Riemann Hypothesis](https://en.wikipedia.org/wiki/Generalized_Riemann_hypothesis)), there are infinitely many such p for which 2 is a primitive root of unity modulo p, meaning that $2^{p-1} \\\\equiv 1 \\\\mod p$ and $2^{k} \\\\not \\\\equiv 1 \\\\mod p$ for $0<k<p-1$.\\n\\nWe know we can obtain any pair of the form $(p,\\\\ 2^m \\\\mod p)$. Since p is prime, the multiplicative group $\\\\mathbb Z_p^*$ is cyclic. Since 2 is a generator (its order is equal to the order of the group), we can obtain any pair (p, k) where $1 \\\\leq k <p$ using powers of 2 modulo p, including the k we want.\\n\\nBut this is the same as (n+jk, k) and then by repeatedly subtracting k from n+jk we can obtain (n, k), as desired.\\n\\nBy symmetry (doing the same thing in reverse if necessary), we can obtain any pair (n, m) where gcd(m, n)=1. Finally, multiplying m and n by (possibly different) arbitrary powers of 2 we can obtain any pair whose gcd is a power of two.\\n\\nEdited: The initial proof was wrong and I corrected it.\\n\\n# Complexity\\n- Time complexity: Logarithmic: $O(\\\\max(\\\\log a, \\\\log b))$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isReachable(self, targetX: int, targetY: int) -> bool:\\n        def gcd(a, b):\\n            while b:\\n                a, b=b, a%b\\n            return a\\n        d=gcd(targetX, targetY)\\n        while d!=1:\\n            if d&1:\\n                return False\\n            d>>=1\\n        return True\\n        \\n```"
    },
    {
        "slug": "asteroid-collision",
        "tags": "python3",
        "release_time": 1690019312,
        "code": "class Solution:\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\n        stack=[]\n        for i in range(len(asteroids)):\n            while stack and asteroids[i]<0<stack[-1]:    \n                if -asteroids[i]>stack[-1]:\n                    stack.pop()\n                    continue\n                elif -asteroids[i]==stack[-1]:\n                    stack.pop()\n                break\n            else:\n                stack.append(asteroids[i])\n            \n        return stack",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/1c54c38a-0a0d-4d04-a41b-365b811d3391_1690019308.8670018.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def asteroidCollision(self, asteroids: List[int]) -> List[int]:\\n        stack=[]\\n        for i in range(len(asteroids)):\\n            while stack and asteroids[i]<0<stack[-1]:    \\n                if -asteroids[i]>stack[-1]:\\n                    stack.pop()\\n                    continue\\n                elif -asteroids[i]==stack[-1]:\\n                    stack.pop()\\n                break\\n            else:\\n                stack.append(asteroids[i])\\n            \\n        return stack\\n```"
    },
    {
        "slug": "number-of-ways-to-split-a-string",
        "tags": "python3",
        "release_time": 1687719570,
        "code": "class Solution:\n    def numWays(self, s: str) -> int:\n        MOD = 10 ** 9 + 7\n        N = len(s)\n        c1 = s.count('1')\n        if not c1:\n            return (((N-1)*(N-2))//2) % MOD\n        if c1 % 3:\n            return 0\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\n        cnt = 0\n        cnt1 = 0\n        for i in range(N):\n            if s[i] == '1':\n                cnt += 1\n            if cnt == c1//3:\n                idx1 = i\n                break\n        for i in range(idx1+1,N):\n            if s[i] == '1':\n                idx2 = i\n                break\n        for i in range(N-1,-1,-1):\n            if s[i] == '1':\n                cnt1 += 1\n            if cnt1 == c1//3:\n                idx4 = i\n                break\n        for i in range(idx4-1,-1,-1):\n            if s[i] == '1':\n                idx3 = i\n                break\n        return ((idx2-idx1) * (idx4-idx3)) % MOD",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numWays(self, s: str) -> int:\\n        MOD = 10 ** 9 + 7\\n        N = len(s)\\n        c1 = s.count(\\'1\\')\\n        if not c1:\\n            return (((N-1)*(N-2))//2) % MOD\\n        if c1 % 3:\\n            return 0\\n        idx1, idx2, idx3, idx4 = 0, 0, 0, 0\\n        cnt = 0\\n        cnt1 = 0\\n        for i in range(N):\\n            if s[i] == \\'1\\':\\n                cnt += 1\\n            if cnt == c1//3:\\n                idx1 = i\\n                break\\n        for i in range(idx1+1,N):\\n            if s[i] == \\'1\\':\\n                idx2 = i\\n                break\\n        for i in range(N-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                cnt1 += 1\\n            if cnt1 == c1//3:\\n                idx4 = i\\n                break\\n        for i in range(idx4-1,-1,-1):\\n            if s[i] == \\'1\\':\\n                idx3 = i\\n                break\\n        return ((idx2-idx1) * (idx4-idx3)) % MOD\\n```"
    },
    {
        "slug": "construct-quad-tree",
        "tags": "python3",
        "release_time": 1677526765,
        "code": "\"\"\"\n# Definition for a QuadTree node.\nclass Node:\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\n        self.val = val\n        self.isLeaf = isLeaf\n        self.topLeft = topLeft\n        self.topRight = topRight\n        self.bottomLeft = bottomLeft\n        self.bottomRight = bottomRight\n\"\"\"\n\ndef is_leaf(grid: List[List[int]]) -> bool:\n    N = len(grid)\n    k = grid[0][0]\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == k:\n                continue\n            return False\n    return True\n\n\n\nclass Solution:\n    def construct(self, grid: List[List[int]]) -> 'Node':\n        N = len(grid)\n        if is_leaf(grid):\n            return Node(\n                val=bool(grid[0][0]),\n                isLeaf=True,\n                topLeft=None,\n                topRight=None,\n                bottomLeft=None,\n                bottomRight=None,\n            )\n        else:\n            return Node(\n                val=False,\n                isLeaf=False,\n                topLeft=self.construct([i[:N//2] for i in grid[:N//2]]),\n                topRight=self.construct([i[N//2:] for i in grid[:N//2]]),\n                bottomLeft=self.construct([i[:N//2] for i in grid[N//2:]]),\n                bottomRight=self.construct([i[N//2:] for i in grid[N//2:]]),\n            )",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a QuadTree node.\\nclass Node:\\n    def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):\\n        self.val = val\\n        self.isLeaf = isLeaf\\n        self.topLeft = topLeft\\n        self.topRight = topRight\\n        self.bottomLeft = bottomLeft\\n        self.bottomRight = bottomRight\\n\"\"\"\\n\\ndef is_leaf(grid: List[List[int]]) -> bool:\\n    N = len(grid)\\n    k = grid[0][0]\\n    for i in range(N):\\n        for j in range(N):\\n            if grid[i][j] == k:\\n                continue\\n            return False\\n    return True\\n\\n\\n\\nclass Solution:\\n    def construct(self, grid: List[List[int]]) -> \\'Node\\':\\n        N = len(grid)\\n        if is_leaf(grid):\\n            return Node(\\n                val=bool(grid[0][0]),\\n                isLeaf=True,\\n                topLeft=None,\\n                topRight=None,\\n                bottomLeft=None,\\n                bottomRight=None,\\n            )\\n        else:\\n            return Node(\\n                val=False,\\n                isLeaf=False,\\n                topLeft=self.construct([i[:N//2] for i in grid[:N//2]]),\\n                topRight=self.construct([i[N//2:] for i in grid[:N//2]]),\\n                bottomLeft=self.construct([i[:N//2] for i in grid[N//2:]]),\\n                bottomRight=self.construct([i[N//2:] for i in grid[N//2:]]),\\n            )\\n```"
    },
    {
        "slug": "sum-of-beauty-of-all-substrings",
        "tags": "python3",
        "release_time": 1615047825,
        "code": "class Solution:\n    def beautySum(self, s: str) -> int:\n        ans = 0 \n        for i in range(len(s)):\n            freq = [0]*26\n            for j in range(i, len(s)):\n                freq[ord(s[j])-97] += 1\n                ans += max(freq) - min(x for x in freq if x)\n        return ans",
        "content": "\\n```\\nclass Solution:\\n    def beautySum(self, s: str) -> int:\\n        ans = 0 \\n        for i in range(len(s)):\\n            freq = [0]*26\\n            for j in range(i, len(s)):\\n                freq[ord(s[j])-97] += 1\\n                ans += max(freq) - min(x for x in freq if x)\\n        return ans \\n```"
    },
    {
        "slug": "minimum-impossible-or",
        "tags": "python3",
        "release_time": 1676858879,
        "code": "class Solution:\n    def minImpossibleOR(self, nums: List[int]) -> int:\n        bit_set = set()\n        for num in nums:\n            if num == num & (-num):\n                bit_set.add(num)\n        \n        i = 1\n        while i in bit_set:\n            i = i << 1\n        return i",
        "content": "A number can be expressed by some power of two numbers. Thus, we only need to check the power of two numbers in the list, and find the minimum missing one.\\n\\nTo check the power of two, we can simply do:\\n\\n`num == num & (-num)`\\n\\n\\n\\n```\\nclass Solution:\\n    def minImpossibleOR(self, nums: List[int]) -> int:\\n        bit_set = set()\\n        for num in nums:\\n            if num == num & (-num):\\n                bit_set.add(num)\\n        \\n        i = 1\\n        while i in bit_set:\\n            i = i << 1\\n        return i\\n```"
    },
    {
        "slug": "minimum-string-length-after-removing-substrings",
        "tags": "python3",
        "release_time": 1684643998,
        "code": "class Solution:\n    def minLength(self, s: str) -> int:\n        while \"AB\" in s or \"CD\" in s:\n            if \"AB\" in s:\n                s = s.replace(\"AB\",\"\")\n            elif \"CD\" in s:\n                s = s.replace(\"CD\",\"\")\n        return len(s)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minLength(self, s: str) -> int:\\n        while \"AB\" in s or \"CD\" in s:\\n            if \"AB\" in s:\\n                s = s.replace(\"AB\",\"\")\\n            elif \"CD\" in s:\\n                s = s.replace(\"CD\",\"\")\\n        return len(s)\\n```"
    },
    {
        "slug": "minimum-seconds-to-equalize-a-circular-array",
        "tags": "python3",
        "release_time": 1691251985,
        "code": "class Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        p = collections.defaultdict(list)\n        d = collections.defaultdict(int)\n        for i, num in enumerate(nums):\n            p[num].append(i)\n            if len(p[num]) > 1:\n                p_num = p[num]\n                d[num] = max(d[num], p_num[-1] - p_num[-2] - 1)\n        res = n - 1\n        for num in d:\n            p_num = p[num]\n            d[num] = max(d[num], n - 1 - p_num[-1] + p_num[0])\n            res = min(res, d[num])\n        \n        return math.ceil(res / 2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumSeconds(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        p = collections.defaultdict(list)\\n        d = collections.defaultdict(int)\\n        for i, num in enumerate(nums):\\n            p[num].append(i)\\n            if len(p[num]) > 1:\\n                p_num = p[num]\\n                d[num] = max(d[num], p_num[-1] - p_num[-2] - 1)\\n        res = n - 1\\n        for num in d:\\n            p_num = p[num]\\n            d[num] = max(d[num], n - 1 - p_num[-1] + p_num[0])\\n            res = min(res, d[num])\\n        \\n        return math.ceil(res / 2)\\n\\n```"
    },
    {
        "slug": "find-peak-element",
        "tags": "python3",
        "release_time": 1689939984,
        "code": "class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n=len(nums)\n        low=0\n        high=n-1\n        if n==1:\n            return 0\n        \n        while low<=high:\n            mid=(low+high)//2\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\n                return mid\n            elif nums[mid]<=nums[mid+1]:\n                low=mid+1\n            else:\n                high=mid-1\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/505c2b70-2b55-4398-bf2d-50123576dc6c_1689939982.9395442.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findPeakElement(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        low=0\\n        high=n-1\\n        if n==1:\\n            return 0\\n        \\n        while low<=high:\\n            mid=(low+high)//2\\n            if (mid==0 or nums[mid]>=nums[mid-1] ) and (mid==n-1 or nums[mid]>=nums[mid+1]) :\\n                return mid\\n            elif nums[mid]<=nums[mid+1]:\\n                low=mid+1\\n            else:\\n                high=mid-1\\n        return -1\\n```"
    },
    {
        "slug": "minimum-time-to-complete-all-tasks",
        "tags": "python3",
        "release_time": 1678595753,
        "code": "class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda x:x[1])\n        on=[0]*2001\n        for s,e,d in tasks:\n            cr=sum(on[s:e+1])\n            while cr<d:\n                # Greedy: finish the task as late as you can which benefits later tasks\n                if on[e]!=1:on[e]=1; cr+=1\n                e-=1\n        return sum(on)",
        "content": "# Intuition\\nRun earlier task as late as you can which benefits later tasks.\\n\\n# Approach\\nGREEDY\\n\\n# Complexity\\n- Time complexity: $O(NT)$\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\\n        tasks.sort(key=lambda x:x[1])\\n        on=[0]*2001\\n        for s,e,d in tasks:\\n            cr=sum(on[s:e+1])\\n            while cr<d:\\n                # Greedy: finish the task as late as you can which benefits later tasks\\n                if on[e]!=1:on[e]=1; cr+=1\\n                e-=1\\n        return sum(on)\\n```"
    },
    {
        "slug": "merge-two-sorted-lists",
        "tags": "python3",
        "release_time": 1646614850,
        "code": "class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        cur = dummy = ListNode()\n        while list1 and list2:               \n            if list1.val < list2.val:\n                cur.next = list1\n                list1, cur = list1.next, list1\n            else:\n                cur.next = list2\n                list2, cur = list2.next, list2\n                \n        if list1 or list2:\n            cur.next = list1 if list1 else list2\n            \n        return dummy.next",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFor simplicity, we create a dummy node to which we attach nodes from lists. We iterate over lists using two-pointers and build up a resulting list so that values are monotonically increased.\\n\\nTime: **O(n)**\\nSpace: **O(1)**\\n\\n```\\nclass Solution:\\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\\n        cur = dummy = ListNode()\\n        while list1 and list2:               \\n            if list1.val < list2.val:\\n                cur.next = list1\\n                list1, cur = list1.next, list1\\n            else:\\n                cur.next = list2\\n                list2, cur = list2.next, list2\\n                \\n        if list1 or list2:\\n            cur.next = list1 if list1 else list2\\n            \\n        return dummy.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**"
    },
    {
        "slug": "find-closest-node-to-given-two-nodes",
        "tags": "python3",
        "release_time": 1674617837,
        "code": "class Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n        rdist = 0 \n        nodes = []\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\n            distArray[it][distArrayIndex] = rdist\n            nodes.append(it)\n            it = edges[it]\n            rdist += 1\n        return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1",
        "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n"
    },
    {
        "slug": "faulty-keyboard",
        "tags": "python3",
        "release_time": 1691296860,
        "code": "class Solution:\n    def finalString(self, s: str) -> str:\n        while \"i\" in s:\n            index=s.index(\"i\")\n\n            #first half and second half\n            first=s[:index][::-1]\n            second=s[index+1:]\n\n            s=\"\".join([first,second])\n        return s",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def finalString(self, s: str) -> str:\\n        while \"i\" in s:\\n            index=s.index(\"i\")\\n\\n            #first half and second half\\n            first=s[:index][::-1]\\n            second=s[index+1:]\\n\\n            s=\"\".join([first,second])\\n        return s\\n```"
    },
    {
        "slug": "adding-two-negabinary-numbers",
        "tags": "python3",
        "release_time": 1674727355,
        "code": "class Solution:\n    def addBinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = carry >> 1\n        return res[::-1]\n\n    def addNegabinary(self, A, B):\n        res = []\n        carry = 0\n        while A or B or carry:\n            carry += (A or [0]).pop() + (B or [0]).pop()\n            res.append(carry & 1)\n            carry = -(carry >> 1)\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        return res[::-1]",
        "content": "# Code\\n```\\nclass Solution:\\n    def addBinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = carry >> 1\\n        return res[::-1]\\n\\n    def addNegabinary(self, A, B):\\n        res = []\\n        carry = 0\\n        while A or B or carry:\\n            carry += (A or [0]).pop() + (B or [0]).pop()\\n            res.append(carry & 1)\\n            carry = -(carry >> 1)\\n        while len(res) > 1 and res[-1] == 0:\\n            res.pop()\\n        return res[::-1]\\n```"
    },
    {
        "slug": "maximum-number-of-balloons",
        "tags": "python3",
        "release_time": 1687699664,
        "code": "from collections import Counter\n\nclass Solution:\n    def maxNumberOfBalloons(self, text: str) -> int:\n        cnt = Counter(text)\n        return min([cnt['b'], cnt['a'], cnt['n'], cnt['l'] // 2, cnt['o'] // 2])",
        "content": "# Approach\\nUse Counter and don\\'t worry about it\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maxNumberOfBalloons(self, text: str) -> int:\\n        cnt = Counter(text)\\n        return min([cnt[\\'b\\'], cnt[\\'a\\'], cnt[\\'n\\'], cnt[\\'l\\'] // 2, cnt[\\'o\\'] // 2])\\n\\n```"
    },
    {
        "slug": "sum-of-beauty-in-the-array",
        "tags": "python3",
        "release_time": 1677284773,
        "code": "class Solution:\n    def sumOfBeauties(self, nums: List[int]) -> int:\n        nums1 = list(accumulate(nums, lambda x, y: max(x, y)))\n        nums2 = list(accumulate(nums[::-1], lambda x, y: min(x, y)))[::-1]\n        cnt = 0\n        for i in range(1, len(nums) - 1):\n            if nums1[i - 1] < nums[i] < nums2[i + 1]:\n                cnt += 2\n            elif nums[i - 1] < nums[i] < nums[i + 1]:\n                cnt += 1\n        return cnt",
        "content": "```\\nclass Solution:\\n    def sumOfBeauties(self, nums: List[int]) -> int:\\n        nums1 = list(accumulate(nums, lambda x, y: max(x, y)))\\n        nums2 = list(accumulate(nums[::-1], lambda x, y: min(x, y)))[::-1]\\n        cnt = 0\\n        for i in range(1, len(nums) - 1):\\n            if nums1[i - 1] < nums[i] < nums2[i + 1]:\\n                cnt += 2\\n            elif nums[i - 1] < nums[i] < nums[i + 1]:\\n                cnt += 1\\n        return cnt\\n```\\n"
    },
    {
        "slug": "minimum-fuel-cost-to-report-to-the-capital",
        "tags": "python3",
        "release_time": 1676207658,
        "code": "class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adjacencyList = [[] for i in range(len(roads) + 1)]\n        res = [0]\n        for road in roads : \n            adjacencyList[road[0]].append(road[1])\n            adjacencyList[road[1]].append(road[0])\n        visited = [0 for i in range(len(roads) + 1)]\n        visited[0]=1\n        def dfs(i,visited):\n            if visited[i] == 1:\n                return 0\n            visited[i] = 1\n            tot = 1\n            for k in adjacencyList[i]:\n                tot += dfs(k,visited)\n            if tot%seats == 0:\n                res[0] += tot//seats\n            else :\n                res[0] += tot//seats + 1\n            return tot\n        for i in adjacencyList[0]:\n            total = dfs(i,visited)\n        return res[0]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```"
    },
    {
        "slug": "minimize-the-maximum-of-two-arrays",
        "tags": "python3",
        "release_time": 1671901071,
        "code": "import math\nclass Solution:\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\n        \n        def gcd(a, b):\n            if (a == 0):\n                return b\n\n            if (b == 0):\n                return a\n\n            if (a == b):\n                return a\n\n            if (a > b):\n                return gcd(a-b, b)\n            return gcd(a, b-a)\n        \n        def lcm(a,b):\n            return a*b//gcd(a,b)\n            \n        d1=divisor1\n        d2=divisor2\n        u1=uniqueCnt1\n        u2=uniqueCnt2\n        \n        l=1\n        r=10**(10)\n        #r=7\n        res=float('inf')\n        while l<=r:\n            m=(l+r)//2\n            x=m-m//d1\n            y=m-m//d2\n            z=m-m//(lcm(d1,d2))\n            \n            if x<u1 or y<u2 or z<u1+u2:\n                l=m+1\n                continue\n            else:\n                res=min(res,m)\n                r=m-1\n                \n            \n            \n       \n        return res",
        "content": "# Intuition\\n1st Insight: Seeing that uniqueCnt1 and uniqueCnt2 are order of $$10^9$$ and our answer is also potentially of that magnitude, we might think to consider a logarithmic solution such as binary search.\\n\\n2nd Insight: It isn\\'t obvious how to find the minimum maximum value across all arrays satisfying the condition or even construct the arrays. One question we might ask is can we determine if a maximum value $$V$$ is possible? Yes we can! \\n\\n*Also another reason to consider this approach is if some value $$V$$ is possible, then it is possible to construct such arrays for any value greater than $$V$$ e.g. using the same array constructed for $$V$$.\\n\\nLet $$k$$ be the number of elements that don\\'t divide $$divisor1$$. If $$k < uniqueCnt1$$ then $$V$$ isn\\'t possible as there aren\\'t enough numbers from $$1$$ to $$V$$ that don\\'t divide $$divisor1$$. We can make the same argument for $$divisor2$$ and $$uniqueCnt2$$.\\n\\nNow there is one more condition that is neccessary for $$V$$ to possible. Let $$k$$ be the number of elements that are not divisible by at least 1 of $$divisor1$$ and $$divisor2$$. We must have that $$k >= uniqueCnt1 + uniqueCnt2$$.\\n\\n$$V$$ is valid if and only if these three properties are satisfied.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThus we solve this problem using binary search. We can let our right pointer be $$10^{10}$$ which is sufficiently high and our left be 1. Inside the while loop we perform the checks as described above. To do the third check notice that the number of elements from $$1$$ to $$V$$ that dont divide at least one of $$divisor1$$ and $$divisor2$$ is equal to $$V$$ minus the number of elements that divide both $$divisor1$$ and $$divisor2$$. This is just \\n$$V - V/lcm(divisor1,divisor2)$$. We use this binary search to find the lowest possible value of V.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(uniqueCnt1+uniqueCnt2))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n```\\nimport math\\nclass Solution:\\n    def minimizeSet(self, divisor1: int, divisor2: int, uniqueCnt1: int, uniqueCnt2: int) -> int:\\n        \\n        def gcd(a, b):\\n            if (a == 0):\\n                return b\\n\\n            if (b == 0):\\n                return a\\n\\n            if (a == b):\\n                return a\\n\\n            if (a > b):\\n                return gcd(a-b, b)\\n            return gcd(a, b-a)\\n        \\n        def lcm(a,b):\\n            return a*b//gcd(a,b)\\n            \\n        d1=divisor1\\n        d2=divisor2\\n        u1=uniqueCnt1\\n        u2=uniqueCnt2\\n        \\n        l=1\\n        r=10**(10)\\n        #r=7\\n        res=float(\\'inf\\')\\n        while l<=r:\\n            m=(l+r)//2\\n            x=m-m//d1\\n            y=m-m//d2\\n            z=m-m//(lcm(d1,d2))\\n            \\n            if x<u1 or y<u2 or z<u1+u2:\\n                l=m+1\\n                continue\\n            else:\\n                res=min(res,m)\\n                r=m-1\\n                \\n            \\n            \\n       \\n        return res\\n```"
    },
    {
        "slug": "minimize-maximum-pair-sum-in-array",
        "tags": "python3",
        "release_time": 1677615909,
        "code": "class Solution:\n    def minPairSum(self, nums: List[int]) -> int:\n        nums.sort()\n        list2=[]\n        left,right=0,len(nums)-1\n        while left<right:\n            list2.append(nums[left]+nums[right])\n            left+=1\n            right-=1\n        return max(list2)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```"
    },
    {
        "slug": "minimum-addition-to-make-integer-beautiful",
        "tags": "python3",
        "release_time": 1667102439,
        "code": "class Solution:\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\n        total = added = 0\n        mask = 10\n        while sum([int(c) for c in str(n)]) > target:\n            added = mask - n % mask\n            if added != mask:\n                n += added\n                total += added\n                # print('n',n,'added',added,'mask',mask)\n            mask *= 10\n        return total",
        "content": "```\\n\\nclass Solution:\\n    def makeIntegerBeautiful(self, n: int, target: int) -> int:\\n        total = added = 0\\n        mask = 10\\n        while sum([int(c) for c in str(n)]) > target:\\n            added = mask - n % mask\\n            if added != mask:\\n                n += added\\n                total += added\\n                # print(\\'n\\',n,\\'added\\',added,\\'mask\\',mask)\\n            mask *= 10\\n        return total\\n```\\n\\nExample:\\n```\\nn: 94598\\ntarget: 6\\n\\nPrinted:\\nn 94600 added 2 mask 10\\nn 95000 added 400 mask 1000\\nn 100000 added 5000 mask 10000\\n\\ntotal is 2 + 400 + 5000\\n```"
    },
    {
        "slug": "allocate-mailboxes",
        "tags": "python3",
        "release_time": 1669475231,
        "code": "class Solution:\n    def minDistance(self, A, K):\n        A.sort()\n        N = len(A)\n        P = [0] + list(accumulate(A))\n        dp = [0] + [float('inf')] * N\n        for i in range(K):\n            for j in range(N - 1, i - 1, -1):\n                for k in range(j, i - 1, -1):\n                    m = (k + j) >> 1\n                    cost = P[j + 1] + P[k] - 2 * P[m] - A[m] * (j - 2 * m + k + 1)\n                    dp[j + 1] = min(dp[j + 1], dp[k] + cost)\n        return dp[-1]",
        "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minDistance(self, A, K):\\n        A.sort()\\n        N = len(A)\\n        P = [0] + list(accumulate(A))\\n        dp = [0] + [float(\\'inf\\')] * N\\n        for i in range(K):\\n            for j in range(N - 1, i - 1, -1):\\n                for k in range(j, i - 1, -1):\\n                    m = (k + j) >> 1\\n                    cost = P[j + 1] + P[k] - 2 * P[m] - A[m] * (j - 2 * m + k + 1)\\n                    dp[j + 1] = min(dp[j + 1], dp[k] + cost)\\n        return dp[-1]\\n```"
    },
    {
        "slug": "double-a-number-represented-as-a-linked-list",
        "tags": "python3",
        "release_time": 1691899930,
        "code": "class Solution:\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \n        def dfs(node):\n            \n            sm = 2*node.val + (dfs(node.next) if node.next else 0)\n\n            node.val = sm%10\n            return sm//10\n\n        return ListNode(1, head) if dfs(head) else head",
        "content": "We use recursion to return the carry digit to the parent node, and at the end, we check whether an additional node is needed should `head` have a carry.\\n```\\nclass Solution:\\n    def doubleIt(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        def dfs(node):\\n            \\n            sm = 2*node.val + (dfs(node.next) if node.next else 0)\\n\\n            node.val = sm%10\\n            return sm//10\\n\\n        return ListNode(1, head) if dfs(head) else head\\n```\\n[https://leetcode.com/problems/double-a-number-represented-as-a-linked-list/submissions/1019843248/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*N*), in which *+ ~ number of nodes in the linked list."
    },
    {
        "slug": "lowest-common-ancestor-of-a-binary-search-tree",
        "tags": "python3",
        "release_time": 1691072257,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        minval, maxval = min(p.val, q.val), max(p.val, q.val)\n        while root:\n            if minval <= root.val <= maxval:\n                break\n\n            if root.val > maxval:\n                root = root.left\n            else:\n                root = root.right\n        \n        return root",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this tree is a BST, it simplifies the problem a lot. Think about what property should hold true for a node to be the lowest common ancestor.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn thinking a bit, you realize that the lowest common ancestor will be the node for which : \\n\\n    a) min(p,q) is in the left subtree (or equal to the node value)\\n    b) max(p,q) is in the right subtree (or equal to the node value)\\n\\nIf this is not true for the current node, then I go right if the value is lesser than the min, or I go left if the value is greater than the max.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(logN)$$ - as we are going down the depth of the tree\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$ - we do not use recursion, or any data structure while iterating.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def lowestCommonAncestor(self, root: \\'TreeNode\\', p: \\'TreeNode\\', q: \\'TreeNode\\') -> \\'TreeNode\\':\\n        minval, maxval = min(p.val, q.val), max(p.val, q.val)\\n        while root:\\n            if minval <= root.val <= maxval:\\n                break\\n\\n            if root.val > maxval:\\n                root = root.left\\n            else:\\n                root = root.right\\n        \\n        return root\\n        \\n\\n            \\n```"
    },
    {
        "slug": "longest-well-performing-interval",
        "tags": "python3",
        "release_time": 1664031594,
        "code": "class Solution:\n    def longestWPI(self, A):\n        curr, ans, D = 0, 0, {}\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\n            curr += i\n            D[curr] = D.get(curr, e)\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\n        return ans",
        "content": "`Time Complexity` : `O(n)`\\n`Space Complexity` : `O(n)`\\n```\\nclass Solution:\\n    def longestWPI(self, A):\\n        curr, ans, D = 0, 0, {}\\n        for e, i in enumerate(map(lambda x: (-1, 1)[x > 8], A)):\\n            curr += i\\n            D[curr] = D.get(curr, e)\\n            ans = e + 1 if curr > 0 else max(ans, e - D.get(curr - 1, e))\\n        return ans\\n```"
    },
    {
        "slug": "subarray-sums-divisible-by-k",
        "tags": "python3",
        "release_time": 1674109748,
        "code": "class Solution:\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\n        lst=[0]*k\n        n=len(nums)\n        sm=0\n        for i in range(n):\n            sm+=nums[i]\n            lst[sm%k]+=1\n        st=lst[0]\n        ct=(st*(2+(st-1)))//2\n        for i in range(1,k):\n            x=lst[i]\n            ct+=(x*(x-1))//2\n        return ct",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def subarraysDivByK(self, nums: List[int], k: int) -> int:\\n        lst=[0]*k\\n        n=len(nums)\\n        sm=0\\n        for i in range(n):\\n            sm+=nums[i]\\n            lst[sm%k]+=1\\n        st=lst[0]\\n        ct=(st*(2+(st-1)))//2\\n        for i in range(1,k):\\n            x=lst[i]\\n            ct+=(x*(x-1))//2\\n        return ct\\n\\n\\n        \\n\\n\\n        \\n        \\n```"
    },
    {
        "slug": "find-the-longest-semi-repetitive-substring",
        "tags": "python3",
        "release_time": 1686413120,
        "code": "class Solution:\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\n        res=0\n        tab=[1]\n        for i in range(1,len(s)):\n            if ( s[i]==s[i-1]):\n                tab.append(1)\n            else:\n                tab[-1]=tab[-1]+1\n        for j in range(1,len(tab)):\n            res=max(res,tab[j]+tab[j-1])\n        \n        return max(res,tab[0])",
        "content": "# Intuition\\nThe problem asks us to find the length of the longest semi-repetitive substring in a given string. A semi-repetitive substring is defined as a substring that contains at most one consecutive pair of the same digits.\\n\\n\\n# Approach\\nTo solve this problem, we can iterate through the string and keep track of the lengths of consecutive substrings with the same digits. We use a dynamic programming approach to store the lengths in the \\'tab\\' array.\\n\\nWe initialize the \\'tab\\' array with the length of the first digit in the string. Then, for each subsequent digit, we check if it is the same as the previous one. If it is, we increment the length of the current substring. Otherwise, we start a new substring by appending a length of 1 to the \\'tab\\' array.\\n\\nAfter populating the \\'tab\\' array, we iterate through it to find the maximum length of a semi-repetitive substring. To do this, we compare the sum of the current element and the previous element in the \\'tab\\' array. We keep track of the maximum length encountered so far in the \\'res\\' variable. Finally, we return the maximum length of a semi-repetitive substring, which is the maximum between \\'res\\' and the first element in the \\'tab\\' array.\\n# Complexity\\n- Time complexity:\\nTime complexity: The algorithm iterates through the input string once, resulting in a linear time complexity of O(n), where n is the length of the input string.\\n\\n\\n- Space complexity:\\nSpace complexity: The algorithm uses additional space to store the \\'tab\\' array, which has a length equal to the number of substrings with different digits in the input string. In the worst case, where all digits are unique, the \\'tab\\' array would have a length of n, resulting in a space complexity of O(n).\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSemiRepetitiveSubstring(self, s: str) -> int:\\n        res=0\\n        tab=[1]\\n        for i in range(1,len(s)):\\n            if ( s[i]==s[i-1]):\\n                tab.append(1)\\n            else:\\n                tab[-1]=tab[-1]+1\\n        for j in range(1,len(tab)):\\n            res=max(res,tab[j]+tab[j-1])\\n        \\n        return max(res,tab[0])\\n                \\n                \\n        \\n```"
    },
    {
        "slug": "count-zero-request-servers",
        "tags": "python3",
        "release_time": 1687623885,
        "code": "class Solution:\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\n        # sort logs by time\n        m = len(logs)\n        logs.sort(key = lambda x: x[1])\n        mi, ma = logs[0][1], logs[-1][1]\n        \n        # sort queries by start (ends are sorted too\n        # since they are equal window length queries)\n        qs = []\n        for i, e in enumerate(queries):\n            start = max(mi, e - x)\n            end = min(ma, e)\n            qs.append((start, end, i))\n        qs.sort()\n        \n        ct = Counter()\n        ans = [n] * len(qs)\n        l = r = 0\n        for s, e, x in qs:\n            # move right pointer to the [query end], track servers\n            while r < m and logs[r][1] <= e:\n                idx = logs[r][0]\n                ct[idx] += 1\n                r += 1\n            # move left pointer to [query start - 1], remove servers\n            while l < m and logs[l][1] < s:\n                idx = logs[l][0]\n                if idx in ct:\n                    ct[idx] -= 1\n                    if not ct[idx]:\n                        del ct[idx]\n                l += 1\n            # update answer\n            ans[x] = n - len(ct)\n            # terminate if all logs out of the window\n            if l == m:\n                break\n        return ans",
        "content": "# Intuition\\nSince the queries are offline and of equal length, we sort them by start. Sorted queries have non-decreasing starts and ends. Sort the logs by time too.\\n\\nThen traverse the queries with the aid of a sliding window. For a certain query, move right pointer to window end, track servers into the window. Next, move left pointer to window start - 1, remove servers out of the window. Finally answer the query.\\n\\n# Code\\n```\\nclass Solution:\\n    def countServers(self, n: int, logs: List[List[int]], x: int, queries: List[int]) -> List[int]:\\n        # sort logs by time\\n        m = len(logs)\\n        logs.sort(key = lambda x: x[1])\\n        mi, ma = logs[0][1], logs[-1][1]\\n        \\n        # sort queries by start (ends are sorted too\\n        # since they are equal window length queries)\\n        qs = []\\n        for i, e in enumerate(queries):\\n            start = max(mi, e - x)\\n            end = min(ma, e)\\n            qs.append((start, end, i))\\n        qs.sort()\\n        \\n        ct = Counter()\\n        ans = [n] * len(qs)\\n        l = r = 0\\n        for s, e, x in qs:\\n            # move right pointer to the [query end], track servers\\n            while r < m and logs[r][1] <= e:\\n                idx = logs[r][0]\\n                ct[idx] += 1\\n                r += 1\\n            # move left pointer to [query start - 1], remove servers\\n            while l < m and logs[l][1] < s:\\n                idx = logs[l][0]\\n                if idx in ct:\\n                    ct[idx] -= 1\\n                    if not ct[idx]:\\n                        del ct[idx]\\n                l += 1\\n            # update answer\\n            ans[x] = n - len(ct)\\n            # terminate if all logs out of the window\\n            if l == m:\\n                break\\n        return ans\\n```"
    },
    {
        "slug": "find-mode-in-binary-search-tree",
        "tags": "python3",
        "release_time": 1675923228,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\n        def bfs(freq):\n            queue = [root]\n            while queue:\n                curr= queue.pop()\n                if curr.left:\n                    queue.append(curr.left)\n                if curr.right:\n                    queue.append(curr.right)\n                freq.setdefault(curr.val, 0)\n                freq[curr.val] += 1\n        \n        freq = {}\n        bfs(freq)\n        freq = freq.items()\n        ans = []\n        max_cnt = 0\n\n        for num, cnt in freq:\n            if cnt > max_cnt:\n                max_cnt = cnt\n\n        for num, cnt in freq:\n            if cnt == max_cnt:\n                ans.append(num)\n        return ans",
        "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```"
    },
    {
        "slug": "dinner-plate-stacks",
        "tags": "python3",
        "release_time": 1678104819,
        "code": "class DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.arr = []\n        self.capacity = capacity\n        self.nonFullSt = [] # min heap of non-full stacks\n\n    def push(self, val: int) -> None:\n        while self.nonFullSt:\n            stID = heappop(self.nonFullSt)\n            if stID < len(self.arr) and len(self.arr[stID]) < self.capacity:\n                # This check is needed because the nonFullSt Id can be greater than self.arr size in case we poped many empy stacks from self.arr in a pop(self) function\n                self.arr[stID].append(val)\n                if len(self.arr[stID]) == self.capacity:\n                    heappush(self.nonFullSt, stID)\n                return\n        if self.arr:\n            if len(self.arr[-1]) == self.capacity:\n                self.arr.append([val])\n            else:\n                self.arr[-1].append(val)\n        else:\n            self.arr.append([val])\n\n\n    def pop(self) -> int:\n        while self.arr:\n            if len(self.arr[-1]) > 0:\n                return self.arr[-1].pop()\n            else:\n                self.arr.pop()\n        return -1\n\n    def popAtStack(self, index: int) -> int:\n        if len(self.arr) > index and len(self.arr[index]) > 0:\n            # this stack was full, add it to the nonFullSt heap\n            if len(self.arr[index]) == self.capacity:\n                heappush(self.nonFullSt, index)\n            return self.arr[index].pop()\n        return -1\n\n\n# Your DinnerPlates object will be instantiated and called as such:\n# obj = DinnerPlates(capacity)\n# obj.push(val)\n# param_2 = obj.pop()\n# param_3 = obj.popAtStack(index)",
        "content": "# Approach\\nCreate a heap of non full stacks, \\npush a new value at first to the non full stack and only if there no such stacks, create a new stack.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DinnerPlates:\\n\\n    def __init__(self, capacity: int):\\n        self.arr = []\\n        self.capacity = capacity\\n        self.nonFullSt = [] # min heap of non-full stacks\\n\\n    def push(self, val: int) -> None:\\n        while self.nonFullSt:\\n            stID = heappop(self.nonFullSt)\\n            if stID < len(self.arr) and len(self.arr[stID]) < self.capacity:\\n                # This check is needed because the nonFullSt Id can be greater than self.arr size in case we poped many empy stacks from self.arr in a pop(self) function\\n                self.arr[stID].append(val)\\n                if len(self.arr[stID]) == self.capacity:\\n                    heappush(self.nonFullSt, stID)\\n                return\\n        if self.arr:\\n            if len(self.arr[-1]) == self.capacity:\\n                self.arr.append([val])\\n            else:\\n                self.arr[-1].append(val)\\n        else:\\n            self.arr.append([val])\\n\\n\\n    def pop(self) -> int:\\n        while self.arr:\\n            if len(self.arr[-1]) > 0:\\n                return self.arr[-1].pop()\\n            else:\\n                self.arr.pop()\\n        return -1\\n\\n    def popAtStack(self, index: int) -> int:\\n        if len(self.arr) > index and len(self.arr[index]) > 0:\\n            # this stack was full, add it to the nonFullSt heap\\n            if len(self.arr[index]) == self.capacity:\\n                heappush(self.nonFullSt, index)\\n            return self.arr[index].pop()\\n        return -1\\n\\n\\n# Your DinnerPlates object will be instantiated and called as such:\\n# obj = DinnerPlates(capacity)\\n# obj.push(val)\\n# param_2 = obj.pop()\\n# param_3 = obj.popAtStack(index)\\n```"
    },
    {
        "slug": "capitalize-the-title",
        "tags": "python3",
        "release_time": 1672637914,
        "code": "class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        li = title.split()\n        for i,l in enumerate(li):\n            if len(l) <= 2:\n                li[i] = l.lower()\n            else:\n                li[i] = l[0].upper() + l[1:].lower()\n        return ' '.join(li)",
        "content": "# Code\\n```\\nclass Solution:\\n    def capitalizeTitle(self, title: str) -> str:\\n        li = title.split()\\n        for i,l in enumerate(li):\\n            if len(l) <= 2:\\n                li[i] = l.lower()\\n            else:\\n                li[i] = l[0].upper() + l[1:].lower()\\n        return \\' \\'.join(li)\\n```"
    },
    {
        "slug": "sliding-window-median",
        "tags": "python3",
        "release_time": 1687587517,
        "code": "class Solution:\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\n        tree = None\n        ans = []\n        for i, x in enumerate(nums):\n            tree = insert(tree, x)\n            if size(tree) > k:\n                tree = remove(tree, nums[i - k])\n            if size(tree) == k:\n                if k % 2 == 1:\n                    ans.append(get(tree, k // 2 + 1))\n                else:\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\n        return ans\n\n\n\nclass Node:\n    __slots__ = ['val', 'count', 'weight', 'size', 'left', 'right']\n    def __init__(self, val):\n        self.val = val\n        self.count = 1\n        self.weight = random.random()\n        self.size = 1\n        self.left = self.right = None\n\n\ndef touch(root):\n    if not root:\n        return\n    root.size = root.count + size(root.left) + size(root.right)\n\n\ndef size(root):\n    if not root:\n        return 0\n    return root.size\n\n\ndef insert(root, val):\n    t1, r, t2 = split(root, val)\n    if not r:\n        r = Node(val)\n    else:\n        r.count += 1\n        touch(r)\n    t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef remove(root, val):\n    t1, r, t2 = split(root, val)\n    if r and r.count > 1:\n        r.count -= 1\n        touch(r)\n        t2 = join(r, t2)\n    return join(t1, t2)\n\n\ndef split(root, val):\n    if not root:\n        return None, None, None\n    elif root.val < val:\n        a, b, c = split(root.right, val)\n        root.right = a\n        touch(root)\n        return root, b, c\n    elif root.val > val:\n        a, b, c = split(root.left, val)\n        root.left = c\n        touch(root)\n        return a, b, root\n    else:\n        a, c = root.left, root.right\n        root.left = root.right = None\n        touch(root)\n        return a, root, c\n\n\ndef join(t1, t2):\n    if not t1:\n        return t2\n    elif not t2:\n        return t1\n    elif t1.weight < t2.weight:\n        t1.right = join(t1.right, t2)\n        touch(t1)\n        return t1\n    else:\n        t2.left = join(t1, t2.left)\n        touch(t2)\n        return t2\n\n\ndef get(root, index):\n    if size(root.left) < index <= size(root.left) + root.count:\n        return root.val\n    elif size(root.left) + root.count < index:\n        return get(root.right, index - root.count - size(root.left))\n    else:\n        return get(root.left, index)",
        "content": "\\n\\n```\\nclass Solution:\\n    def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:\\n        tree = None\\n        ans = []\\n        for i, x in enumerate(nums):\\n            tree = insert(tree, x)\\n            if size(tree) > k:\\n                tree = remove(tree, nums[i - k])\\n            if size(tree) == k:\\n                if k % 2 == 1:\\n                    ans.append(get(tree, k // 2 + 1))\\n                else:\\n                    ans.append((get(tree, k // 2) + get(tree, k // 2 + 1)) / 2)\\n        return ans\\n\\n\\n\\nclass Node:\\n    __slots__ = [\\'val\\', \\'count\\', \\'weight\\', \\'size\\', \\'left\\', \\'right\\']\\n    def __init__(self, val):\\n        self.val = val\\n        self.count = 1\\n        self.weight = random.random()\\n        self.size = 1\\n        self.left = self.right = None\\n\\n\\ndef touch(root):\\n    if not root:\\n        return\\n    root.size = root.count + size(root.left) + size(root.right)\\n\\n\\ndef size(root):\\n    if not root:\\n        return 0\\n    return root.size\\n\\n\\ndef insert(root, val):\\n    t1, r, t2 = split(root, val)\\n    if not r:\\n        r = Node(val)\\n    else:\\n        r.count += 1\\n        touch(r)\\n    t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef remove(root, val):\\n    t1, r, t2 = split(root, val)\\n    if r and r.count > 1:\\n        r.count -= 1\\n        touch(r)\\n        t2 = join(r, t2)\\n    return join(t1, t2)\\n\\n\\ndef split(root, val):\\n    if not root:\\n        return None, None, None\\n    elif root.val < val:\\n        a, b, c = split(root.right, val)\\n        root.right = a\\n        touch(root)\\n        return root, b, c\\n    elif root.val > val:\\n        a, b, c = split(root.left, val)\\n        root.left = c\\n        touch(root)\\n        return a, b, root\\n    else:\\n        a, c = root.left, root.right\\n        root.left = root.right = None\\n        touch(root)\\n        return a, root, c\\n\\n\\ndef join(t1, t2):\\n    if not t1:\\n        return t2\\n    elif not t2:\\n        return t1\\n    elif t1.weight < t2.weight:\\n        t1.right = join(t1.right, t2)\\n        touch(t1)\\n        return t1\\n    else:\\n        t2.left = join(t1, t2.left)\\n        touch(t2)\\n        return t2\\n\\n\\ndef get(root, index):\\n    if size(root.left) < index <= size(root.left) + root.count:\\n        return root.val\\n    elif size(root.left) + root.count < index:\\n        return get(root.right, index - root.count - size(root.left))\\n    else:\\n        return get(root.left, index)\\n\\n```"
    },
    {
        "slug": "construct-binary-search-tree-from-preorder-traversal",
        "tags": "python3",
        "release_time": 1673886911,
        "code": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\nclass Solution:\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\n        if len(preorder) == 0:\n            return None\n        root = TreeNode(preorder[0])\n\n        def insertNode(root, newVal):\n            if root.val > newVal:\n                if root.left is None:\n                    root.left = TreeNode(newVal)\n                    return\n                insertNode(root.left, newVal)\n            if root.val < newVal:\n                if root.right is None:\n                    root.right = TreeNode(newVal)\n                    return\n                insertNode(root.right, newVal)\n        \n        for val in preorder[1:]:\n            insertNode(root, val)\n        return root",
        "content": "# Python3 Solution\\n```\\nclass TreeNode:\\n    def __init__(self, val=0, left=None, right=None):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\nclass Solution:\\n    def bstFromPreorder(self, preorder: List[int]) -> Optional[TreeNode]:\\n        if len(preorder) == 0:\\n            return None\\n        root = TreeNode(preorder[0])\\n\\n        def insertNode(root, newVal):\\n            if root.val > newVal:\\n                if root.left is None:\\n                    root.left = TreeNode(newVal)\\n                    return\\n                insertNode(root.left, newVal)\\n            if root.val < newVal:\\n                if root.right is None:\\n                    root.right = TreeNode(newVal)\\n                    return\\n                insertNode(root.right, newVal)\\n        \\n        for val in preorder[1:]:\\n            insertNode(root, val)\\n        return root\\n```"
    },
    {
        "slug": "find-the-middle-index-in-array",
        "tags": "python3",
        "release_time": 1677769847,
        "code": "class Solution:\n    def findMiddleIndex(self, nums: List[int]) -> int:\n        for i in range(len(nums)):\n            if sum(nums[:i]) == sum(nums[i+1:]):\n                return i\n        return -1",
        "content": "![image.png](https://assets.leetcode.com/users/images/a383ce68-68f6-434c-b9b1-3c1ba1e7581b_1677769611.1766207.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMiddleIndex(self, nums: List[int]) -> int:\\n        for i in range(len(nums)):\\n            if sum(nums[:i]) == sum(nums[i+1:]):\\n                return i\\n        return -1     \\n```\\n![image.png](https://assets.leetcode.com/users/images/6e988a26-45e1-4a54-af31-b7e36633683b_1677769719.5696645.png)\\n"
    },
    {
        "slug": "check-if-all-1s-are-at-least-length-k-places-away",
        "tags": "python3",
        "release_time": 1679899973,
        "code": "class Solution:\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\n        count=k\n        for i in nums:\n            if i==1:\n                if count<k:\n                    return False\n                count=0\n            else:\n                count+=1\n        return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def kLengthApart(self, nums: List[int], k: int) -> bool:\\n        count=k\\n        for i in nums:\\n            if i==1:\\n                if count<k:\\n                    return False\\n                count=0\\n            else:\\n                count+=1\\n        return True                 \\n```"
    },
    {
        "slug": "decode-xored-array",
        "tags": "python3",
        "release_time": 1678374508,
        "code": "class Solution:\n    def decode(self, encoded: List[int], first: int) -> List[int]:\n        arr=[first]\n        temp=0\n        for i in encoded:\n            temp=i^first\n            arr.append(temp)\n            first=temp\n        return arr",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def decode(self, encoded: List[int], first: int) -> List[int]:\\n        arr=[first]\\n        temp=0\\n        for i in encoded:\\n            temp=i^first\\n            arr.append(temp)\\n            first=temp\\n        return arr\\n```"
    },
    {
        "slug": "reverse-bits",
        "tags": "python3",
        "release_time": 1691409685,
        "code": "class Solution:\n    def f(self,n,r,count):\n        if n<1:\n            return r<<(32-count)\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\n    def reverseBits(self, n: int) -> int:\n        return self.f(n,0,0)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def f(self,n,r,count):\\n        if n<1:\\n            return r<<(32-count)\\n        return self.f(n>>1,(r<<1)|(n&1),count+1)\\n    def reverseBits(self, n: int) -> int:\\n        return self.f(n,0,0)\\n```"
    },
    {
        "slug": "sort-the-matrix-diagonally",
        "tags": "python3",
        "release_time": 1692273735,
        "code": "class Solution:\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        d=defaultdict(list)\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                d[i-j].append(mat[i][j])\n        for i in d.values():\n            i.sort()\n        for i in range(len(mat)):\n            for j in range(len(mat[0])):\n                v=d[i-j].pop(0)\n                mat[i][j]=v\n        return mat",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Hashmap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:94.27%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:86.07%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n        for i in d.values():\\n            i.sort()\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                v=d[i-j].pop(0)\\n                mat[i][j]=v\\n        return mat\\n```"
    },
    {
        "slug": "top-k-frequent-words",
        "tags": "python3",
        "release_time": 1666200900,
        "code": "class Solution:\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\n        dico = defaultdict(int)\n        for word in words: dico[word]+=1\n        \n        res = sorted(dico, key = lambda x: (-dico[x], x))\n        return res[:k]",
        "content": "```\\nclass Solution:\\n    def topKFrequent(self, words: List[str], k: int) -> List[str]:\\n        dico = defaultdict(int)\\n        for word in words: dico[word]+=1\\n        \\n        res = sorted(dico, key = lambda x: (-dico[x], x))\\n        return res[:k]\\n```\\n\\n#plzzzz upvote the code"
    },
    {
        "slug": "substrings-of-size-three-with-distinct-characters",
        "tags": "python3",
        "release_time": 1675615400,
        "code": "class Solution:\n    def countGoodSubstrings(self, s: str) -> int:\n\n        l = 0\n        r = 2\n        count=0\n\n        while(r<len(s)):\n            new = {}\n            for i in range(l,r+1):\n                new[s[i]] = 1 + new.get(s[i],0)\n\n            flag = True    \n\n            for i in new.values():\n                if i>1:\n                    flag=False\n            if flag == True:\n                count+=1   \n            l+=1\n            r+=1\n\n        return count",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```"
    },
    {
        "slug": "minimum-flips-to-make-a-or-b-equal-to-c",
        "tags": "python3",
        "release_time": 1682793274,
        "code": "class Solution:\n    def minFlips(self, a: int, b: int, c: int) -> int:\n        if a | b == c: return 0\n        c = ('0' * 32 + bin(c)[2:])[-32:]\n        a = ('0' * 32 + bin(a)[2:])[-32:]\n        b = ('0' * 32 + bin(b)[2:])[-32:]\n        \n        \n        cnt = 0\n        for i in range(len(c)):\n            if c[i] == '1':\n                if not (a[i] == c[i] or b[i] == c[i]):\n                    cnt += 1\n            else:\n                if a[i] != c[i]:\n                    cnt += 1\n                if b[i] != c[i]:\n                    cnt += 1\n        return cnt",
        "content": "# Code\\n\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        if a | b == c: return 0\\n        c = (\\'0\\' * 32 + bin(c)[2:])[-32:]\\n        a = (\\'0\\' * 32 + bin(a)[2:])[-32:]\\n        b = (\\'0\\' * 32 + bin(b)[2:])[-32:]\\n        \\n        \\n        cnt = 0\\n        for i in range(len(c)):\\n            if c[i] == \\'1\\':\\n                if not (a[i] == c[i] or b[i] == c[i]):\\n                    cnt += 1\\n            else:\\n                if a[i] != c[i]:\\n                    cnt += 1\\n                if b[i] != c[i]:\\n                    cnt += 1\\n        return cnt\\n```\\n\\n## Bit Manipulation\\n```\\nclass Solution:\\n    def minFlips(self, a: int, b: int, c: int) -> int:\\n        return bin((a | b) ^ c).count(\\'1\\') + bin(a & b & ((a | b) ^ c)).count(\\'1\\')\\n```"
    },
    {
        "slug": "minimum-number-of-swaps-to-make-the-string-balanced",
        "tags": "python3",
        "release_time": 1690271220,
        "code": "class Solution:\n    def minSwaps(self, s: str) -> int:\n        cnt = 0\n        stack = []\n        for p in s:\n            if p == \"[\": stack.append(\"[\")\n            else:\n                if not stack: \n                    stack.append(\"]\")\n                    cnt += 1\n                else: \n                    stack.pop()\n        return cnt",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSwaps(self, s: str) -> int:\\n        cnt = 0\\n        stack = []\\n        for p in s:\\n            if p == \"[\": stack.append(\"[\")\\n            else:\\n                if not stack: \\n                    stack.append(\"]\")\\n                    cnt += 1\\n                else: \\n                    stack.pop()\\n        return cnt\\n```"
    },
    {
        "slug": "binary-tree-postorder-traversal",
        "tags": "python3",
        "release_time": 1681625602,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        L=[]\n        def pot(node):\n            if node is None:\n                return\n            pot(node.left)\n            pot(node.right)\n            L.append(node.val)\n            return L\n        return pot(root)",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\\n        L=[]\\n        def pot(node):\\n            if node is None:\\n                return\\n            pot(node.left)\\n            pot(node.right)\\n            L.append(node.val)\\n            return L\\n        return pot(root)\\n            \\n```"
    },
    {
        "slug": "tuple-with-same-product",
        "tags": "python3",
        "release_time": 1659614874,
        "code": "class Solution:\n    tupleSameProduct = lambda _, nums: sum(count*(count-1) for _, count in Counter([nums[i] * nums[j] for j in range(1, len(nums)) for i in range(len(nums) - 1) if j > i]).items()) * 4",
        "content": "```\\nclass Solution:\\n    tupleSameProduct = lambda _, nums: sum(count*(count-1) for _, count in Counter([nums[i] * nums[j] for j in range(1, len(nums)) for i in range(len(nums) - 1) if j > i]).items()) * 4\\n```"
    },
    {
        "slug": "last-moment-before-all-ants-fall-out-of-a-plank",
        "tags": "python3",
        "release_time": 1674935019,
        "code": "class Solution:\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\n        return max(max(left, default=0), n - min(right, default=n))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this problem is to find the last moment when any of the ants are still on the line. This can be done by looking at the leftmost ant\\'s position and the rightmost ant\\'s position. The answer will be whichever of these two is greater.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we will use a two-pass approach. In the first pass, we will find the maximum position of any of the ants in the left array. In the second pass, we will find the minimum position of any of the ants in the right array. Finally, we will compare these two values and return the greater of the two. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:\\n        return max(max(left, default=0), n - min(right, default=n))\\n```"
    },
    {
        "slug": "verifying-an-alien-dictionary",
        "tags": "python3",
        "release_time": 1675353365,
        "code": "class Solution:\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\n        mapper = {chr(i):-1 for i in range(97,97+26)}\n        def map_value():\n            nonlocal order\n            nonlocal mapper\n            for i in range(len(order)):\n                mapper[order[i]] = i\n        map_value()\n        def helper():\n            for i in range(len(words)-1):\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\n                    return False\n                else:\n                    for j in range(min(len(words[i]), len(words[i+1]))):\n                        if words[i][j] != words[i+1][j]:\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\n                                return False\n                            break\n            return True\n        return helper()",
        "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- In lexicographically ordered dictionary we don\\'t have any words less in value after greater.\\n- So we don\\'t need to traverse $$words$$ array $$n^2$$ times just check it for $$n$$ times.\\n- if $$current word[i]$$ is greater in size of $$currentword[i+1]$$ and  next word is having less value according to orders then return false\\n- else check for every word pair in one iteration from i=0 to i=n-1\\n- because for $$nth$$ word we will check at $$n-1\\'th$$ tearm\\n- proceed further till we match in pair of $$words[i]$$ and $$words[i+1]$$\\n- when not matched check $$current$$ $$alphabet$$ $$order$$ in $$words[i]$$ and $$words[i+1]$$\\n- if it\\'s not according to given order then return false\\n- else at last return true\\n\\n# Code\\n```\\nclass Solution:\\n    def isAlienSorted(self, words: List[str], order: str) -> bool:\\n        mapper = {chr(i):-1 for i in range(97,97+26)}\\n        def map_value():\\n            nonlocal order\\n            nonlocal mapper\\n            for i in range(len(order)):\\n                mapper[order[i]] = i\\n        map_value()\\n        def helper():\\n            for i in range(len(words)-1):\\n                if len(words[i+1])<len(words[i]) and mapper[words[i+1][0]] <= mapper[words[i][0]] and words[i+1] in words[i]:\\n                    return False\\n                else:\\n                    for j in range(min(len(words[i]), len(words[i+1]))):\\n                        if words[i][j] != words[i+1][j]:\\n                            if mapper[words[i+1][j]] < mapper[words[i][j]]:\\n                                return False\\n                            break\\n            return True\\n        return helper()\\n```"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "tags": "python3",
        "release_time": 1583640064,
        "code": "class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nei = collections.defaultdict(set)\n        for a, b in edges:\n            nei[a].add(b)\n            nei[b].add(a)\n            \n        visited, res = set(), 0.\n        def dfs(leaf_id, p, time):\n            nonlocal res\n            if time >= t:\n                if leaf_id == target: res = p\n                return\n            visited.add(leaf_id)\n            neighbors = nei[leaf_id] - visited\n            for n in neighbors or [leaf_id]:\n                dfs(n, p / (len(neighbors) or 1), time + 1)\n        dfs(1, 1, 0)\n        return res",
        "content": "**Idea**\\nFirst we build an adjacency list using `edges`.\\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\\n2. Use set to record all the visited nodes along the way **(method 2)**\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3, DFS with recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        visited, res = set(), 0.\\n        def dfs(leaf_id, p, time):\\n            nonlocal res\\n            if time >= t:\\n                if leaf_id == target: res = p\\n                return\\n            visited.add(leaf_id)\\n            neighbors = nei[leaf_id] - visited\\n            for n in neighbors or [leaf_id]:\\n                dfs(n, p / (len(neighbors) or 1), time + 1)\\n        dfs(1, 1, 0)\\n        return res\\n```\\n\\n**Python 3, BFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.popleft()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS on tree without recursion, method 1**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n                    \\n        dp = collections.deque([1])\\n        while dp:\\n            leaf = dp.popleft()\\n            for n_ in nei[leaf]:\\n                nei[n_].remove(leaf)\\n                dp += n_,\\n                \\n        dp = [(1, 1, 0)]\\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            for n in nei[leaf] or [leaf]:\\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\\n        return 0.0\\n```\\n"
    },
    {
        "slug": "reorganize-string",
        "tags": "python3",
        "release_time": 1672349911,
        "code": "from collections import Counter\nclass Solution:\n    def reorganizeString(self, s: str) -> str:\n        counter=Counter(s)\n        max_heap=[]\n        for char, count in counter.items():\n            heapq.heappush(max_heap, (-count, char))\n        res = \"\"\n        heapq.heapify(max_heap)\n        while max_heap:\n            if len(max_heap)>1:\n                first1,first2=heapq.heappop(max_heap)\n              \n                res += first2\n                sec1,sec2=heapq.heappop(max_heap)\n                \n                res += sec2\n                first1,sec1 = -first1,-sec1\n                first1-=1\n                sec1-=1\n                if first1>0:\n                    heapq.heappush(max_heap,(-first1,first2))\n                \n                if sec1>0:\n                    heapq.heappush(max_heap,(-sec1,sec2))\n            else:\n                f1,f2=heapq.heappop(max_heap)\n                if -f1==1:\n                  \n                    res += f2\n                    \n                else:\n                    return \"\"\n        return ''.join(res)",
        "content": "\\n\\n# Code\\n```\\n\\nfrom collections import Counter\\nclass Solution:\\n    def reorganizeString(self, s: str) -> str:\\n        counter=Counter(s)\\n        max_heap=[]\\n        for char, count in counter.items():\\n            heapq.heappush(max_heap, (-count, char))\\n        res = \"\"\\n        heapq.heapify(max_heap)\\n        while max_heap:\\n            if len(max_heap)>1:\\n                first1,first2=heapq.heappop(max_heap)\\n              \\n                res += first2\\n                sec1,sec2=heapq.heappop(max_heap)\\n                \\n                res += sec2\\n                first1,sec1 = -first1,-sec1\\n                first1-=1\\n                sec1-=1\\n                if first1>0:\\n                    heapq.heappush(max_heap,(-first1,first2))\\n                \\n                if sec1>0:\\n                    heapq.heappush(max_heap,(-sec1,sec2))\\n            else:\\n                f1,f2=heapq.heappop(max_heap)\\n                if -f1==1:\\n                  \\n                    res += f2\\n                    \\n                else:\\n                    return \"\"\\n        return \\'\\'.join(res)\\n\\n\\n            \\n\\n\\n```"
    },
    {
        "slug": "minimum-bit-flips-to-convert-number",
        "tags": "python3",
        "release_time": 1677410468,
        "code": "class Solution:\n    def minBitFlips(self, start: int, goal: int) -> int:\n        s=bin(start)[2:].zfill(50)\n        g=bin(goal)[2:].zfill(50)\n        count=0\n        for i in range(50):\n            if s[i]!=g[i]:\n                count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minBitFlips(self, start: int, goal: int) -> int:\\n        s=bin(start)[2:].zfill(50)\\n        g=bin(goal)[2:].zfill(50)\\n        count=0\\n        for i in range(50):\\n            if s[i]!=g[i]:\\n                count+=1\\n        return count\\n```"
    },
    {
        "slug": "restore-the-array",
        "tags": "python3",
        "release_time": 1682229291,
        "code": "class Solution:\n    def numberOfArrays(self, s: str, k: int) -> int:\n\n        n = len(s)\n        mod = 10**9+7\n\n        @lru_cache(None)\n        def rec(i=0):\n\n            if i==n :\n                return 1\n            \n            if s[i]==\"0\":\n                return 0\n            \n            res = 0\n            curr = \"\"\n            for x in range(i, n):\n                curr += s[x]\n                if int(curr)<=k:\n                    res += (rec(x+1)%mod)\n                    res %= mod\n                else:\n                    break\n\n            return res\n        \n        return rec()",
        "content": "# Code\\n```\\nclass Solution:\\n    def numberOfArrays(self, s: str, k: int) -> int:\\n\\n        n = len(s)\\n        mod = 10**9+7\\n\\n        @lru_cache(None)\\n        def rec(i=0):\\n\\n            if i==n :\\n                return 1\\n            \\n            if s[i]==\"0\":\\n                return 0\\n            \\n            res = 0\\n            curr = \"\"\\n            for x in range(i, n):\\n                curr += s[x]\\n                if int(curr)<=k:\\n                    res += (rec(x+1)%mod)\\n                    res %= mod\\n                else:\\n                    break\\n\\n            return res\\n        \\n        return rec()\\n```"
    },
    {
        "slug": "make-array-empty",
        "tags": "python3",
        "release_time": 1682784092,
        "code": "from sortedcontainers import SortedList\nclass Solution:\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\n        n = len(nums)\n        sl = SortedList((num, i) for i, num in enumerate(nums))\n        sl_idx = SortedList(range(n))\n        start, ans = 0, 0\n        while sl:\n            num, i = sl.pop(0)\n            ans += self.count(sl_idx, n, start, i)\n            sl_idx.remove(i)\n            start = (i + 1) % n\n        return ans\n    \n    def count(self, sl, n, start, end):\n        if start <= end:\n            return sl.bisect(end) - sl.bisect_left(start)\n        else:\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)",
        "content": "# Intuition\\nThink of the array `nums` as a circular array. Then each operation is essentially finding the number of (remaining) elements from the previously deleted element to the next deleted element, in a circular fashion.\\n\\n# Approach\\nWe use a SortedList `sl` or a min-heap to keep track of the current smallest element in the remaining array. We use another SortedList `sl_idx` to keep track of the remaining indices in sorted order. Each time, we count the number of indices between `[start, end]` (inclusive) in the remaining `sl_idx`, and add it to `ans`. Given we are putting elements in a circular fashion, there could be two possibilities where `start <= end` or `start > end`. For the case of `start > end`, we can count the number of indices between `[0, start]` (inclusive) and `[end, n - 1]` (inclusive).\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def countOperationsToEmptyArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sl = SortedList((num, i) for i, num in enumerate(nums))\\n        sl_idx = SortedList(range(n))\\n        start, ans = 0, 0\\n        while sl:\\n            num, i = sl.pop(0)\\n            ans += self.count(sl_idx, n, start, i)\\n            sl_idx.remove(i)\\n            start = (i + 1) % n\\n        return ans\\n    \\n    def count(self, sl, n, start, end):\\n        if start <= end:\\n            return sl.bisect(end) - sl.bisect_left(start)\\n        else:\\n            return self.count(sl, n, start, n - 1) + self.count(sl, n, 0, end)\\n```"
    },
    {
        "slug": "jump-game",
        "tags": "python3",
        "release_time": 1691402123,
        "code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        if len(nums) == 1:return True\n        i = 0;j = i\n        for i in range(100000):\n            if j > i+nums[i]:pass\n            else:j = i+nums[i]\n            i+=1\n            if i > j:break\n            if j >= len(nums)-1:return True\n        return False",
        "content": "![image.png](https://assets.leetcode.com/users/images/9b0eb852-09a0-4829-a78a-b24cb7c1674a_1691402108.0266314.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def canJump(self, nums: List[int]) -> bool:\\n        if len(nums) == 1:return True\\n        i = 0;j = i\\n        for i in range(100000):\\n            if j > i+nums[i]:pass\\n            else:j = i+nums[i]\\n            i+=1\\n            if i > j:break\\n            if j >= len(nums)-1:return True\\n        return False\\n        \\n```"
    },
    {
        "slug": "letter-tile-possibilities",
        "tags": "python3",
        "release_time": 1674568270,
        "code": "from itertools import permutations \nclass Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        a=[]\n        for i in range(len(tiles)):\n            a.append(list(permutations(tiles,i+1)))\n        s=[]\n        for i in a:\n            if i not in s:\n                s.append(set(i))\n        c=0\n        for i in s:\n            c+=len(i)\n        return c",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nNot sure about the space complexity ,I think it should be O(N^2)\\n# Code\\n```\\nfrom itertools import permutations \\nclass Solution:\\n    def numTilePossibilities(self, tiles: str) -> int:\\n        a=[]\\n        for i in range(len(tiles)):\\n            a.append(list(permutations(tiles,i+1)))\\n        s=[]\\n        for i in a:\\n            if i not in s:\\n                s.append(set(i))\\n        c=0\\n        for i in s:\\n            c+=len(i)\\n        return c\\n```"
    },
    {
        "slug": "the-kth-factor-of-n",
        "tags": "python3",
        "release_time": 1683316029,
        "code": "from sortedcontainers import SortedList\nclass Solution:\n    def kthFactor(self, n: int, k: int) -> int:\n        if k>n:\n            return -1\n        lst=SortedList()\n\n        for i in range(1,n+1):\n            if n%i==0:\n                lst.add(i)      #  bst=lst[:]      \n        if len(lst)<k:\n            return -1\n        return lst[k-1]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing sorted container and sortest list\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def kthFactor(self, n: int, k: int) -> int:\\n        if k>n:\\n            return -1\\n        lst=SortedList()\\n\\n        for i in range(1,n+1):\\n            if n%i==0:\\n                lst.add(i)      #  bst=lst[:]      \\n        if len(lst)<k:\\n            return -1\\n        return lst[k-1]\\n```"
    },
    {
        "slug": "making-file-names-unique",
        "tags": "python3",
        "release_time": 1678465781,
        "code": "from typing import List\n\n\"\"\"\n1487. Making File Names Unique\n\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\n\nSince 2 files cannot have the same name,\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\n\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\n\n\nEX:\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\n\nEX:\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\n\nEx:\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\n\"\"\"\n\n\nclass Solution:\n    \"\"\"\n    if it's already in the seen dictionary,\n    append a suffix k to the name until a unique name is found.\n\n    Time: O(n^2) in the worst case where all file names are the same\n    space: O(n)\n    \"\"\"\n    def getFolderNames(self, names: List[str]) -> List[str]:\n\n        ans = []  # stores unique file names\n        seen = {}\n\n        for name in names:\n            if name not in seen:\n                ans.append(name)\n                seen[name] = 1\n            else:\n                k = seen[name]\n                # creating variants\n                while True:\n                    new_name = name + '(' + str(k) + ')'\n                    if new_name not in seen:\n                        ans.append(new_name)\n                        seen[new_name] = 1\n                        break\n                    else:\n                        k += 1\n\n                # save the latest version of variant so to avaoid above while\n                # loop calculation\n                seen[name] = k\n            \n\n        return ans",
        "content": "\\n```\\nfrom typing import List\\n\\n\"\"\"\\n1487. Making File Names Unique\\n\\ncreate n folders in your file system such that, at the ith minute, U will create a folder with the name names[i].\\n\\nSince 2 files cannot have the same name,\\nif you enter a folder name that was previously used, the system will have a suffix addition to its name in the form of (k), where, k is the smallest positive integer such that the obtained name remains unique.\\n\\nReturn an arr of str of length n where ans[i] is the actual name the system will assign to the ith folder when you create it.\\n\\n\\nEX:\\n[\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\nO/P -> [\"pes\",\"fifa\",\"gta\",\"pes(2019)\"]\\n\\nEX:\\n[\"gta\",\"gta(1)\",\"gta\",\"avalon\"]\\no/p: [\"gta\",\"gta(1)\",\"gta(2)\",\"avalon\"]\\n\\nEx:\\n[\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece\"]\\no/p: [\"onepiece\",\"onepiece(1)\",\"onepiece(2)\",\"onepiece(3)\",\"onepiece(4)\"]\\n\"\"\"\\n\\n\\nclass Solution:\\n    \"\"\"\\n    if it\\'s already in the seen dictionary,\\n    append a suffix k to the name until a unique name is found.\\n\\n    Time: O(n^2) in the worst case where all file names are the same\\n    space: O(n)\\n    \"\"\"\\n    def getFolderNames(self, names: List[str]) -> List[str]:\\n\\n        ans = []  # stores unique file names\\n        seen = {}\\n\\n        for name in names:\\n            if name not in seen:\\n                ans.append(name)\\n                seen[name] = 1\\n            else:\\n                k = seen[name]\\n                # creating variants\\n                while True:\\n                    new_name = name + \\'(\\' + str(k) + \\')\\'\\n                    if new_name not in seen:\\n                        ans.append(new_name)\\n                        seen[new_name] = 1\\n                        break\\n                    else:\\n                        k += 1\\n\\n                # save the latest version of variant so to avaoid above while\\n                # loop calculation\\n                seen[name] = k\\n            \\n\\n        return ans\\n\\n```"
    },
    {
        "slug": "remove-max-number-of-edges-to-keep-graph-fully-traversable",
        "tags": "python3",
        "release_time": 1685531884,
        "code": "class DSU():\n    def __init__(self, n):\n        self.par = list(range(n))\n        self.rank = [1] * n\n        self.size = 1\n    \n    def find(self, u):\n        if u != self.par[u]:\n            self.par[u] = self.find(self.par[u])\n        return self.par[u]\n    \n    def union(self, u, v):\n        uu, vv = self.find(u), self.find(v)\n        if uu == vv:\n            return False\n        if self.rank[uu] > self.rank[vv]:\n            self.par[vv] = self.par[self.par[vv]]\n            self.par[vv] = uu\n        elif self.rank[vv] > self.par[uu]:\n            self.par[uu] = self.par[self.par[uu]]\n            self.par[uu] = vv\n        else:\n            self.par[uu] = vv\n            self.rank[vv] += 1\n        self.size += 1\n        return True\n\nclass Solution:\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\n        uf1, uf2, ans = DSU(n), DSU(n), 0\n\n        for t, u, v in edges:\n            if t == 3 and (not uf1.union(u-1, v-1) or not uf2.union(u-1, v-1)):\n                ans += 1\n        for t, u, v in edges:\n            if t == 1 and not uf1.union(u-1, v-1):\n                ans += 1\n            elif t == 2 and not uf2.union(u-1, v-1):\n                ans += 1\n        return ans if uf1.size == n and uf2.size == n else -1",
        "content": "\\n# Code\\n```\\nclass DSU():\\n    def __init__(self, n):\\n        self.par = list(range(n))\\n        self.rank = [1] * n\\n        self.size = 1\\n    \\n    def find(self, u):\\n        if u != self.par[u]:\\n            self.par[u] = self.find(self.par[u])\\n        return self.par[u]\\n    \\n    def union(self, u, v):\\n        uu, vv = self.find(u), self.find(v)\\n        if uu == vv:\\n            return False\\n        if self.rank[uu] > self.rank[vv]:\\n            self.par[vv] = self.par[self.par[vv]]\\n            self.par[vv] = uu\\n        elif self.rank[vv] > self.par[uu]:\\n            self.par[uu] = self.par[self.par[uu]]\\n            self.par[uu] = vv\\n        else:\\n            self.par[uu] = vv\\n            self.rank[vv] += 1\\n        self.size += 1\\n        return True\\n\\nclass Solution:\\n    def maxNumEdgesToRemove(self, n: int, edges: List[List[int]]) -> int:\\n        uf1, uf2, ans = DSU(n), DSU(n), 0\\n\\n        for t, u, v in edges:\\n            if t == 3 and (not uf1.union(u-1, v-1) or not uf2.union(u-1, v-1)):\\n                ans += 1\\n        for t, u, v in edges:\\n            if t == 1 and not uf1.union(u-1, v-1):\\n                ans += 1\\n            elif t == 2 and not uf2.union(u-1, v-1):\\n                ans += 1\\n        return ans if uf1.size == n and uf2.size == n else -1\\n```"
    },
    {
        "slug": "find-kth-bit-in-nth-binary-string",
        "tags": "python3",
        "release_time": 1669030599,
        "code": "class Solution:\n    def findKthBit(self, N, K, R = True):\n        if K == 1: return '0' if R else '1'\n        mid = (1 << (N - 1))\n        if K < mid: return self.findKthBit(N - 1, K, R)\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\n        return '1' if R else '0'",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n\\n### Recursive Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K, R = True):\\n        if K == 1: return \\'0\\' if R else \\'1\\'\\n        mid = (1 << (N - 1))\\n        if K < mid: return self.findKthBit(N - 1, K, R)\\n        if K > mid: return self.findKthBit(N - 1, 2 * mid - K, not R)\\n        return \\'1\\' if R else \\'0\\'\\n```\\n\\n### Iterative Approach\\n```\\nclass Solution:\\n    def findKthBit(self, N, K):\\n        ans = 1\\n        mid = (1 << (N - 1))\\n        while K > 1:\\n            if K == mid: return str(ans)\\n            if K > mid: \\n                K = 2 * mid - K\\n                ans ^= 1\\n            mid >>= 1\\n        return str(ans^1)\\n```"
    },
    {
        "slug": "frog-position-after-t-seconds",
        "tags": "python3",
        "release_time": 1687584099,
        "code": "from queue import Queue\n\nclass Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        if edges == []:\n            if target == 1:return 1\n            return 0\n\n        d = {}\n        for i in edges:\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\n        \n        visit = [0]*(n+1)\n\n        q = Queue()     \n        q.put([1 , 1])\n\n        for dur in range(t):\n            \n            l = q.qsize()\n            for i in range(l):\n                temp = q.get()\n\n                # Count no.of non-visited nodes\n                count = 0\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: count += 1\n            \n                if temp[0] == target and count == 0:     \n                    # If the target is reached and if its the end node\n                    return temp[1]\n                \n                if visit[temp[0]] != 0:    # if already visited\n                    continue\n                \n                visit[temp[0]] = 1\n\n                for ele in d[temp[0]]:\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\n                \n        \n        l = q.qsize()\n        for i in range(l):\n            temp = q.get()\n            if temp[0] == target:\n                return temp[1]\n\n        return 0",
        "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```"
    },
    {
        "slug": "design-circular-deque",
        "tags": "python3",
        "release_time": 1679466440,
        "code": "class MyCircularDeque:\n\n    def __init__(self, k: int):\n        self.deque=[]\n        self.len=k\n\n    def insertFront(self, value: int) -> bool:\n        if len(self.deque)<self.len:\n            self.deque.insert(0,value) \n            return True\n        else:\n            return False\n\n    def insertLast(self, value: int) -> bool:\n        if len(self.deque)<self.len:\n            self.deque.append(value) \n            return True\n        else:\n            return False\n\n    def deleteFront(self) -> bool:\n        if self.deque:\n            self.deque=self.deque[1:]\n            return True\n\n    def deleteLast(self) -> bool:\n        if self.deque:\n            self.deque=self.deque[:-1]\n            return True\n\n    def getFront(self) -> int:\n        if self.deque:\n            return self.deque[0]\n        else:return -1\n\n\n    def getRear(self) -> int:\n        if self.deque:\n            return self.deque[-1]\n        else:return -1\n\n    def isEmpty(self) -> bool:\n        if self.deque:\n            return False\n        return True\n\n    def isFull(self) -> bool:\n        if self.len==len(self.deque):return True\n\n\n# Your MyCircularDeque object will be instantiated and called as such:\n# obj = MyCircularDeque(k)\n# param_1 = obj.insertFront(value)\n# param_2 = obj.insertLast(value)\n# param_3 = obj.deleteFront()\n# param_4 = obj.deleteLast()\n# param_5 = obj.getFront()\n# param_6 = obj.getRear()\n# param_7 = obj.isEmpty()\n# param_8 = obj.isFull()",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MyCircularDeque:\\n\\n    def __init__(self, k: int):\\n        self.deque=[]\\n        self.len=k\\n\\n    def insertFront(self, value: int) -> bool:\\n        if len(self.deque)<self.len:\\n            self.deque.insert(0,value) \\n            return True\\n        else:\\n            return False\\n\\n    def insertLast(self, value: int) -> bool:\\n        if len(self.deque)<self.len:\\n            self.deque.append(value) \\n            return True\\n        else:\\n            return False\\n\\n    def deleteFront(self) -> bool:\\n        if self.deque:\\n            self.deque=self.deque[1:]\\n            return True\\n\\n    def deleteLast(self) -> bool:\\n        if self.deque:\\n            self.deque=self.deque[:-1]\\n            return True\\n\\n    def getFront(self) -> int:\\n        if self.deque:\\n            return self.deque[0]\\n        else:return -1\\n\\n\\n    def getRear(self) -> int:\\n        if self.deque:\\n            return self.deque[-1]\\n        else:return -1\\n\\n    def isEmpty(self) -> bool:\\n        if self.deque:\\n            return False\\n        return True\\n\\n    def isFull(self) -> bool:\\n        if self.len==len(self.deque):return True\\n\\n\\n# Your MyCircularDeque object will be instantiated and called as such:\\n# obj = MyCircularDeque(k)\\n# param_1 = obj.insertFront(value)\\n# param_2 = obj.insertLast(value)\\n# param_3 = obj.deleteFront()\\n# param_4 = obj.deleteLast()\\n# param_5 = obj.getFront()\\n# param_6 = obj.getRear()\\n# param_7 = obj.isEmpty()\\n# param_8 = obj.isFull()\\n```"
    },
    {
        "slug": "valid-permutations-for-di-sequence",
        "tags": "python3",
        "release_time": 1664693730,
        "code": "class Solution:\n    def numPermsDISequence(self, s: str) -> int:\n        mem=defaultdict(int)\n        def dfs(i,val=0):\n            if i==len(s):\n                return 1\n            if (i,val) in mem:\n                return mem[i,val]\n            p=0\n            if s[i]==\"D\":\n                for ind in range(0,val+1):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            else:\n                for ind in range(val+1,i+2):\n                    p+=dfs(i+1,ind)%(10**9+7)\n            mem[i,val]=p\n            return p\n        return dfs(0)",
        "content": "To add a new character to a sequence we only have to consider the last element-\\n\\nLets say currently DID sequence is 1032- this can form\\n\\nDIDI - in cases where we end with 3,4\\nDIDD - in cases where we end with 0,1,2\\n\\nSo just use the last element value to create a new sequence.\\n\\n```\\nclass Solution:\\n    def numPermsDISequence(self, s: str) -> int:\\n        mem=defaultdict(int)\\n        def dfs(i,val=0):\\n            if i==len(s):\\n                return 1\\n            if (i,val) in mem:\\n                return mem[i,val]\\n            p=0\\n            if s[i]==\"D\":\\n                for ind in range(0,val+1):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            else:\\n                for ind in range(val+1,i+2):\\n                    p+=dfs(i+1,ind)%(10**9+7)\\n            mem[i,val]=p\\n            return p\\n        return dfs(0)\\n ```\\n\\t\\t\\t\\t"
    },
    {
        "slug": "nearest-exit-from-entrance-in-maze",
        "tags": "python3",
        "release_time": 1690728200,
        "code": "class Solution:\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\n        len_y = len(maze)-1\n        len_x = len(maze[0])-1\n\n        if len_x==0 and len_y==0:\n                return -1\n\n        queue = collections.deque()\n\n\n        queue.append((entrance[0],entrance[1]))\n\n        maze[entrance[0]][entrance[1]] = 2\n        moves=0\n        while queue:\n\n                for i in range(len(queue)):\n                        current_y, current_x = queue.popleft()\n\n\n                        if not (current_x== entrance[1] and current_y== entrance[0]) and (current_y==0 or current_y == len_y or current_x== 0 or current_x ==len_x):\n                                return moves\n\n\n                        #up\n                        if current_y-1>=0 and maze[current_y - 1][current_x] == '.':\n                                queue.append((current_y-1,current_x))\n                                maze[current_y-1][current_x]=2\n                        # down\n                        if current_y+1 <= len_y and maze[current_y + 1][current_x] == '.':\n                                queue.append((current_y + 1, current_x))\n                                maze[current_y+1][current_x] = 2\n                        #left\n                        if current_x-1 >=0 and maze[current_y][current_x-1] == '.':\n                                queue.append((current_y, current_x-1))\n                                maze[current_y][current_x-1] = 2\n                        #right\n                        if current_x+1 <=len_x and maze[current_y][current_x+1] == '.':\n                                queue.append((current_y, current_x+1))\n                                maze[current_y][current_x+1] = 2\n\n\n                moves+=1\n\n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- I modify maze to mark visited cells\\n- I use \"loop unrolling\" technique to look up, down, left, right\\n\\n\\n# Complexity\\n- Time complexity:\\nBeats 100%\\n\\n\\n- Space complexity:\\nBeats 66.3%\\n\\n# Code\\n```\\nclass Solution:\\n    def nearestExit(self, maze: List[List[str]], entrance: List[int]) -> int:\\n        len_y = len(maze)-1\\n        len_x = len(maze[0])-1\\n\\n        if len_x==0 and len_y==0:\\n                return -1\\n\\n        queue = collections.deque()\\n\\n\\n        queue.append((entrance[0],entrance[1]))\\n\\n        maze[entrance[0]][entrance[1]] = 2\\n        moves=0\\n        while queue:\\n\\n                for i in range(len(queue)):\\n                        current_y, current_x = queue.popleft()\\n\\n\\n                        if not (current_x== entrance[1] and current_y== entrance[0]) and (current_y==0 or current_y == len_y or current_x== 0 or current_x ==len_x):\\n                                return moves\\n\\n\\n                        #up\\n                        if current_y-1>=0 and maze[current_y - 1][current_x] == \\'.\\':\\n                                queue.append((current_y-1,current_x))\\n                                maze[current_y-1][current_x]=2\\n                        # down\\n                        if current_y+1 <= len_y and maze[current_y + 1][current_x] == \\'.\\':\\n                                queue.append((current_y + 1, current_x))\\n                                maze[current_y+1][current_x] = 2\\n                        #left\\n                        if current_x-1 >=0 and maze[current_y][current_x-1] == \\'.\\':\\n                                queue.append((current_y, current_x-1))\\n                                maze[current_y][current_x-1] = 2\\n                        #right\\n                        if current_x+1 <=len_x and maze[current_y][current_x+1] == \\'.\\':\\n                                queue.append((current_y, current_x+1))\\n                                maze[current_y][current_x+1] = 2\\n\\n\\n                moves+=1\\n\\n        return -1\\n```"
    },
    {
        "slug": "minimum-time-to-repair-cars",
        "tags": "python3",
        "release_time": 1679155502,
        "code": "class Solution:\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        lo,hi = 0,100*cars*cars\n        def repair(time):\n            n = cars\n            for r in ranks:\n                n -= floor(sqrt(time/r))\n                if n<=0:\n                    break\n            return n<=0\n        while lo<=hi:\n            m = (lo+hi)//2\n            if repair(m):\n                ans = m\n                hi = m-1\n            else:\n                lo = m+1\n        return ans",
        "content": "The helper function *repair(time)* determines if *cars* can be repaired within *time*.\\n\\n# Code\\n```\\nclass Solution:\\n    def repairCars(self, ranks: List[int], cars: int) -> int:\\n        lo,hi = 0,100*cars*cars\\n        def repair(time):\\n            n = cars\\n            for r in ranks:\\n                n -= floor(sqrt(time/r))\\n                if n<=0:\\n                    break\\n            return n<=0\\n        while lo<=hi:\\n            m = (lo+hi)//2\\n            if repair(m):\\n                ans = m\\n                hi = m-1\\n            else:\\n                lo = m+1\\n        return ans\\n```"
    },
    {
        "slug": "two-sum",
        "tags": "python3",
        "release_time": 1679057864,
        "code": "class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        dict={}\n        for i,n in enumerate(nums):\n            if n in dict:\n                return dict[n],i\n            else:\n                dict[target-n]=i\n    #please upvote me it would encourage me alot",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\\n        dict={}\\n        for i,n in enumerate(nums):\\n            if n in dict:\\n                return dict[n],i\\n            else:\\n                dict[target-n]=i\\n    #please upvote me it would encourage me alot\\n\\n```"
    },
    {
        "slug": "expression-add-operators",
        "tags": "python3",
        "release_time": 1679535604,
        "code": "class Solution:\n    def addOperators(self, s: str, target: int) -> List[str]:\n        # need to traverse through s\n        # backtrack each case of  start index and then +,*,-\n        # need empty array ofcourse\n        # need curidx = i\n        # need the str path to append to the arr if my --> cur_num == target\n        # need the prevNum access for multiplication\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\n        # return ans\n        \n        res = []\n\n        def dfs(i, path, cur_num, prevNum):\n            if i == len(s):\n                if cur_num == target:\n                    res.append(path)\n                return\n            \n            for j in range(i, len(s)):\n                # starting with zero?\n                if j > i and s[i] == '0':\n                    break\n                num = int(s[i:j+1])\n\n                # if cur index is 0 then simple add that number\n                if i == 0:\n                    dfs(j + 1, path + str(num), cur_num + num, num)\n                else:\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\n        \n        dfs(0, \"\", 0, 0)\n        return res",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def addOperators(self, s: str, target: int) -> List[str]:\\n        # need to traverse through s\\n        # backtrack each case of  start index and then +,*,-\\n        # need empty array ofcourse\\n        # need curidx = i\\n        # need the str path to append to the arr if my --> cur_num == target\\n        # need the prevNum access for multiplication\\n        # 1 2 3 4 5 --> 1 + 2 + 3 + 4 * 5\\n        #               ^ ^ ^ ^ ^ ^ ^ == 10 but we wanna do 4*5 so ---\\n        # just do 1 + 2 + 3 + 4 + (- 4) + (4 * 5)\\n        # return ans\\n        \\n        res = []\\n\\n        def dfs(i, path, cur_num, prevNum):\\n            if i == len(s):\\n                if cur_num == target:\\n                    res.append(path)\\n                return\\n            \\n            for j in range(i, len(s)):\\n                # starting with zero?\\n                if j > i and s[i] == \\'0\\':\\n                    break\\n                num = int(s[i:j+1])\\n\\n                # if cur index is 0 then simple add that number\\n                if i == 0:\\n                    dfs(j + 1, path + str(num), cur_num + num, num)\\n                else:\\n                    dfs(j + 1, path + \"+\" + str(num), cur_num + num, num)\\n                    dfs(j + 1, path + \"-\" + str(num), cur_num - num, -num)\\n                    dfs(j + 1, path + \"*\" + str(num), cur_num - prevNum + prevNum * num, prevNum * num)\\n        \\n        dfs(0, \"\", 0, 0)\\n        return res\\n        \\n```"
    },
    {
        "slug": "find-the-k-sum-of-an-array",
        "tags": "python3",
        "release_time": 1661054589,
        "code": "class Solution:\n    def kSum(self, nums: List[int], k: int) -> int:\n        m = sum(x for x in nums if x > 0)\n        pq = [(-m, 0)] \n        vals = sorted(abs(x) for x in nums)\n        for _ in range(k): \n            x, i = heappop(pq)\n            if i < len(vals): \n                heappush(pq, (x+vals[i], i+1))\n                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))\n        return -x",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nHere, I will discuss a strategy to find the kth largest subsequence sum. \\n* We start from the sum of all positive numbers in `nums` which is the largest one (say `m`); \\n* To proceed, we subtract absolute values from `m`; \\n\\t* If the number is positive, this is equivalent to removing the number from the subsequence sum; \\n\\t* If the number is negative, this is equivalent to adding the number to the subsequence sum;  \\n* To enumerate all possitibilites, we generate a tree-ish path to cover different combinations;\\n\\t* This can be done by repeatedly generating two branches at each point with one always include a value at a given index `i` and the other always exclude the value. \\n\\nHere, I use a priority queue to control for the size so that the runtime won\\'t explode. \\n\\n**Analysis**\\nTime complexity O(NlogN + KlogK)\\nSpace complexity O(N + K)\\n\\n```\\nclass Solution:\\n    def kSum(self, nums: List[int], k: int) -> int:\\n        m = sum(x for x in nums if x > 0)\\n        pq = [(-m, 0)] \\n        vals = sorted(abs(x) for x in nums)\\n        for _ in range(k): \\n            x, i = heappop(pq)\\n            if i < len(vals): \\n                heappush(pq, (x+vals[i], i+1))\\n                if i: heappush(pq, (x-vals[i-1]+vals[i], i+1))\\n        return -x\\n```"
    },
    {
        "slug": "check-if-string-is-transformable-with-substring-sort-operations",
        "tags": "python3",
        "release_time": 1688219312,
        "code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    idx = defaultdict(deque)\n    for i, c in enumerate(s):\n      idx[int(c)].append(i)\n    for c in t:\n      d = int(c)\n      if not idx[d]: return False\n      for i in range(d):\n        if idx[i] and idx[i][0] < idx[d][0]: return False\n      idx[d].popleft()\n    return True",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isTransformable(self, s: str, t: str) -> bool:\\n    idx = defaultdict(deque)\\n    for i, c in enumerate(s):\\n      idx[int(c)].append(i)\\n    for c in t:\\n      d = int(c)\\n      if not idx[d]: return False\\n      for i in range(d):\\n        if idx[i] and idx[i][0] < idx[d][0]: return False\\n      idx[d].popleft()\\n    return True\\n```"
    },
    {
        "slug": "kth-smallest-element-in-a-sorted-matrix",
        "tags": "python3",
        "release_time": 1683639306,
        "code": "class Solution:\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\n        list1 = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix)):\n                list1.append(matrix[i][j])\n        list1.sort()\n        return list1[k-1]",
        "content": "\\n\\n# Solution in Python3\\n```\\nclass Solution:\\n    def kthSmallest(self, matrix: List[List[int]], k: int) -> int:\\n        list1 = []\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix)):\\n                list1.append(matrix[i][j])\\n        list1.sort()\\n        return list1[k-1]\\n```"
    },
    {
        "slug": "random-pick-with-blacklist",
        "tags": "python3",
        "release_time": 1575262585,
        "code": "from random import randint\n\nclass Solution:\n\n    def __init__(self, N: int, blacklist: List[int]):\n        blacklist = set(blacklist)  #to avoid TLE\n        self.N = N - len(blacklist) #to be used in pick()\n        key = [x for x in blacklist if x < N-len(blacklist)]\n        val = [x for x in range(N-len(blacklist), N) if x not in blacklist]\n        self.mapping = dict(zip(key, val))\n\n    def pick(self) -> int:\n        i = randint(0, self.N-1)\n        return self.mapping.get(i, i)",
        "content": "Hash map blacklisted value in `[0, N-len(blacklist))` to whitelisted value in `[N-len(blacklist), N)`, and then randomly pick number in `[0, N-len(blacklist))`. \\n```\\nfrom random import randint\\n\\nclass Solution:\\n\\n    def __init__(self, N: int, blacklist: List[int]):\\n        blacklist = set(blacklist)  #to avoid TLE\\n        self.N = N - len(blacklist) #to be used in pick()\\n        key = [x for x in blacklist if x < N-len(blacklist)]\\n        val = [x for x in range(N-len(blacklist), N) if x not in blacklist]\\n        self.mapping = dict(zip(key, val))\\n\\n    def pick(self) -> int:\\n        i = randint(0, self.N-1)\\n        return self.mapping.get(i, i)\\n```\\n"
    },
    {
        "slug": "range-sum-query-2d-immutable",
        "tags": "python3",
        "release_time": 1666466370,
        "code": "class NumMatrix:\n    def __init__(self, matrix: List[List[int]]):\n        self.W = len(matrix[0])+1   \n        self.H = len(matrix)+1\n        self.ps = [[0 for _ in range(self.W)] for _ in range(self.H)]\n        for i in range(1, self.H):\n            for j in range(1, self.W):\n                self.ps[i][j] = self.ps[i-1][j] + self.ps[i][j-1] - self.ps[i-1][j-1] + matrix[i-1][j-1]\n\n    # ps[x][y] = matrix[0][0]+...+matrix[x-1][y-1]\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\n        return self.ps[row2+1][col2+1] - self.ps[row1][col2+1] - self.ps[row2+1][col1] + self.ps[row1][col1]\n\n\n# Your NumMatrix object will be instantiated and called as such:\n# obj = NumMatrix(matrix)\n# param_1 = obj.sumRegion(row1,col1,row2,col2)",
        "content": "# Intuition\\nIt\\'s derived from the same method of prefix sum in arrays: adding up [0]~[i-1], save the result in preSum[i]\\n\\n# Approach\\nIn a matrix, the additional dimension makes it more complex to define or calculate the prefix sum than working on an array.\\nLet\\'s start with this intuitive definition:\\nSay, $$preSum[i][j]$$ represents the sum of all elements in the rectangular area surrounded by $$x=0,i-1$$ and $$y=0,j-1$$, which means:\\n\\n$$preSum[i][j] = \\u03A3matrix[x][y], where x=0...i-1, y=0...j-1$$\\n\\nFollowing this definition, we have:\\n\\n$$preSum[i][j] = preSum[i-1][j] + preSum[i][j-1] - preSum[i-1][j-1] + matrix[i-1][j-1]$$\\n\\n# Complexity\\n- Time complexity:\\nO(n*m), when computing preSum matrix\\nO(1), when getting regional sum\\n\\n- Space complexity:\\nO(n*m)\\n\\n# Code\\n```\\nclass NumMatrix:\\n    def __init__(self, matrix: List[List[int]]):\\n        self.W = len(matrix[0])+1   \\n        self.H = len(matrix)+1\\n        self.ps = [[0 for _ in range(self.W)] for _ in range(self.H)]\\n        for i in range(1, self.H):\\n            for j in range(1, self.W):\\n                self.ps[i][j] = self.ps[i-1][j] + self.ps[i][j-1] - self.ps[i-1][j-1] + matrix[i-1][j-1]\\n\\n    # ps[x][y] = matrix[0][0]+...+matrix[x-1][y-1]\\n    def sumRegion(self, row1: int, col1: int, row2: int, col2: int) -> int:\\n        return self.ps[row2+1][col2+1] - self.ps[row1][col2+1] - self.ps[row2+1][col1] + self.ps[row1][col1]\\n\\n\\n# Your NumMatrix object will be instantiated and called as such:\\n# obj = NumMatrix(matrix)\\n# param_1 = obj.sumRegion(row1,col1,row2,col2)\\n```"
    },
    {
        "slug": "amount-of-time-for-binary-tree-to-be-infected",
        "tags": "python3",
        "release_time": 1661054544,
        "code": "class Solution: \t\t\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        graph = defaultdict(list)\n        \n        stack = [(root, None)]\n        while stack: \n            n, p = stack.pop()\n            if p: \n                graph[p.val].append(n.val)\n                graph[n.val].append(p.val)\n            if n.left: stack.append((n.left, n))\n            if n.right: stack.append((n.right, n))\n        \n        ans = -1\n        seen = {start}\n        queue = deque([start])\n        while queue: \n            for _ in range(len(queue)): \n                u = queue.popleft()\n                for v in graph[u]: \n                    if v not in seen: \n                        seen.add(v)\n                        queue.append(v)\n            ans += 1\n        return ans",
        "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nI find it easier to treat the tree as a graph. First, I convert the tree to graph. Then I run a BFS to find the furthest away point which represents the answer. \\n\\n**Analysis**\\nTime complexity O(N)\\nSpace complexity O(N)\\t\\t\\n\\n```\\nclass Solution: \\t\\t\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        stack = [(root, None)]\\n        while stack: \\n            n, p = stack.pop()\\n            if p: \\n                graph[p.val].append(n.val)\\n                graph[n.val].append(p.val)\\n            if n.left: stack.append((n.left, n))\\n            if n.right: stack.append((n.right, n))\\n        \\n        ans = -1\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                u = queue.popleft()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        seen.add(v)\\n                        queue.append(v)\\n            ans += 1\\n        return ans \\n```"
    },
    {
        "slug": "maximum-value-of-k-coins-from-piles",
        "tags": "python3",
        "release_time": 1681577614,
        "code": "class Solution:\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\n        \n        @lru_cache(None)\n        def dfs(coins, moves):\n            if len(piles) == coins: return 0\n\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\n\n            for j in range(min(len(pile), moves)):\n                curr += pile[j]\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\n\n            return ans\n        \n        return dfs(0,k)",
        "content": "```\\nclass Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @lru_cache(None)\\n        def dfs(coins, moves):\\n            if len(piles) == coins: return 0\\n\\n            ans, curr, pile = dfs(coins+1, moves), 0, piles[coins]\\n\\n            for j in range(min(len(pile), moves)):\\n                curr += pile[j]\\n                ans = max(ans, curr + dfs(coins+1, moves-j-1))\\n\\n            return ans\\n        \\n        return dfs(0,k)\\n```\\n[https://leetcode.com/problems/maximum-value-of-k-coins-from-piles/submissions/934256020/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*^2) and space complexity is *O*(*N*^2)."
    },
    {
        "slug": "next-permutation",
        "tags": "python3",
        "release_time": 1688693505,
        "code": "class Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        # Base case\n        if nums == sorted(nums, key=lambda x: -x):\n            nums.sort()\n            return\n\n        for i in range(len(nums) - 1, 0, -1):\n            if nums[i - 1] < nums[i]:\n                # Find the first value that is less than the current value\n                min_idx, min_val = len(nums), float('inf')\n                for j in range(len(nums) - 1, i - 1, -1):\n                    if nums[j] > nums[i - 1] and nums[j] < min_val:\n                        min_val = nums[j]\n                        min_idx = j\n                nums[i - 1], nums[min_idx] = nums[min_idx], nums[i - 1]\n\n                # Bubble Sort\n                while True:\n                    swapped = False\n                    for k in range(i, len(nums) - 1):\n                        if nums[k] > nums[k + 1]:\n                            swapped = True\n                            nums[k], nums[k + 1] = nums[k + 1], nums[k]\n                    if swapped == False: break\n                    \n                return",
        "content": "alright, tbh it beat 85%, I was cappin a bit\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nThe intuition for this approach is that we want to find the first pair (a, b), starting on the right side (moving left) where a is less than b. \\n\\nThis must be one of the number (a) that needs to change, since we know that everything to the right of that index must be sorted in descending order, and there is no possible modification that will make the right section (from the index of b forward) a greater permutation. \\n\\nThen we must find the other number to swap with. We only want to jump to the next permutation, so we want to find the smallest number in the right section that is greater than a. \\n\\nAfter identifying that number, we\\'ll call c in the right section, we can make the swap, so that we know that everything from the beninning of nums to c must be a part of the next permutation. [n1, n2, c ...]\\n\\nLastly, we just need to sort the right of c to ensure that the right side is sorted. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. If the number is sorted in decreasing order, then we know that it must wrap around to nums sorted in increasing order \\n2. Then, we make a single pass starting from the end of the array. Our goal is to find that pair (a, b). \\n3. Once we identify a, we search from b forward to identify the smallest value above a, which we\\'ll call \"c\". \\n4. We make the swap between \"a\" and \"c\". \\n5. Finally, we just sort from b onward. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$ (the in-place bubble sort)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # Base case\\n        if nums == sorted(nums, key=lambda x: -x):\\n            nums.sort()\\n            return\\n\\n        for i in range(len(nums) - 1, 0, -1):\\n            if nums[i - 1] < nums[i]:\\n                # Find the first value that is less than the current value\\n                min_idx, min_val = len(nums), float(\\'inf\\')\\n                for j in range(len(nums) - 1, i - 1, -1):\\n                    if nums[j] > nums[i - 1] and nums[j] < min_val:\\n                        min_val = nums[j]\\n                        min_idx = j\\n                nums[i - 1], nums[min_idx] = nums[min_idx], nums[i - 1]\\n\\n                # Bubble Sort\\n                while True:\\n                    swapped = False\\n                    for k in range(i, len(nums) - 1):\\n                        if nums[k] > nums[k + 1]:\\n                            swapped = True\\n                            nums[k], nums[k + 1] = nums[k + 1], nums[k]\\n                    if swapped == False: break\\n                    \\n                return\\n\\n\\n```"
    },
    {
        "slug": "maximum-number-of-consecutive-values-you-can-make",
        "tags": "python3",
        "release_time": 1686412278,
        "code": "class Solution:\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\n    ans = 1  # next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def getMaximumConsecutive(self, coins: List[int]) -> int:\\n    ans = 1  # next value we want to make\\n\\n    for coin in sorted(coins):\\n      if coin > ans:\\n        return ans\\n      ans += coin\\n\\n    return ans\\n\\n```"
    },
    {
        "slug": "shortest-subarray-with-sum-at-least-k",
        "tags": "python3",
        "release_time": 1676049846,
        "code": "class Solution:\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\n        N = len(nums)\n        # edge case of one entry \n        if N == 1 : \n            if nums[0] == k : \n                return 1 \n            return -1 \n        # queue of indices of prefix sums \n        queue = collections.deque()\n        # zeroth sum of no values \n        prefix_sums = [0]\n        # loop over nums \n        for num in nums :\n            # get the sum value by using value up to here process  \n            prefix_sums.append(prefix_sums[-1] + num)\n        # if it is this size, we never found it \n        min_size = N + 1 \n        # enumerate prefix sums to keep indices as you go \n        for index, value in enumerate(prefix_sums) : \n            # while you have a queue and the value current is less than the value of the prefix sums most recently queued \n            while queue and value <= prefix_sums[queue[-1]] : \n                # remove the item most recently queued\n                queue.pop()\n            # while you have a queue and the value minus the front value is greater than or equal to k\n            while queue and value - prefix_sums[queue[0]] >= k : \n                # set min size to the min of itself and the distance between index and leftmost index of queue \n                min_size = min(min_size, index - queue.popleft())\n            # append the index at the end of the loop to the queue \n            queue.append(index)\n        # if it changed, you found it \n        if min_size != N + 1 : \n            return min_size\n        # if it did not, you never found it \n        return -1",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeeds a monotonic queue as we are going to find the minimal length and need to care about the value reaching k. As such, we are bounded on two sides so that sliding window / two pointer is not going to cut it. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBased on intuition, we start by finding the length of the nums, and determine if we are edge case of a length of 1 before proceeding. \\n\\nAfter edge case, we set up our queue and our prefix sums, filling with the values in the array as needed. Our minimum size needs to start outside of range, so we begin with a range of N+1. \\n\\nNow, we enumerate our prefix sums, and track indices and values by doing so. As we do\\n- While we have a queue and our current value is less than our prefix_sums mosts recent value added we pop from the front. \\n- Afterwards, while we have a queue and our current value minus our starting value is greater than or equal to k, we want to recast our minimum size as the minimum of itself and the popleft of the queue, removing from the front. \\n    - We do the first while loop to ensure that our prefix sums approach K without going too far past it. We are trying to limit this to only the size needed. \\n    - Similarly, we are concerned that our value with the front most item may end up past K, so we consider the same while loop process using the difference and recasting min size as we do so. \\n    - Together then, we limit on both ends of the queue as we move thorugh the prefix sums, thus finding the correct length through this process. \\n\\n\\nAt the end we will check to see if min size was ever changed. If it was not, not possible, return -1. Otherwise, return minimum size.\\n\\n# Complexity\\n- Time complexity: O(2N), one loop through the nums for prefix sums and one loop again for minimum size \\n\\n- Space complexity: O(N) as we needed to store the prefix sum. The queue size may add another O(N) in worst case, and as such O(2N) as well. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def shortestSubarray(self, nums: List[int], k: int) -> int:\\n        N = len(nums)\\n        # edge case of one entry \\n        if N == 1 : \\n            if nums[0] == k : \\n                return 1 \\n            return -1 \\n        # queue of indices of prefix sums \\n        queue = collections.deque()\\n        # zeroth sum of no values \\n        prefix_sums = [0]\\n        # loop over nums \\n        for num in nums :\\n            # get the sum value by using value up to here process  \\n            prefix_sums.append(prefix_sums[-1] + num)\\n        # if it is this size, we never found it \\n        min_size = N + 1 \\n        # enumerate prefix sums to keep indices as you go \\n        for index, value in enumerate(prefix_sums) : \\n            # while you have a queue and the value current is less than the value of the prefix sums most recently queued \\n            while queue and value <= prefix_sums[queue[-1]] : \\n                # remove the item most recently queued\\n                queue.pop()\\n            # while you have a queue and the value minus the front value is greater than or equal to k\\n            while queue and value - prefix_sums[queue[0]] >= k : \\n                # set min size to the min of itself and the distance between index and leftmost index of queue \\n                min_size = min(min_size, index - queue.popleft())\\n            # append the index at the end of the loop to the queue \\n            queue.append(index)\\n        # if it changed, you found it \\n        if min_size != N + 1 : \\n            return min_size\\n        # if it did not, you never found it \\n        return -1 \\n```"
    },
    {
        "slug": "longest-happy-prefix",
        "tags": "python3",
        "release_time": 1668441861,
        "code": "class Solution:\n    def longestPrefix(self, s: str) -> str:\n        n = [0] + [None] * (len(s) - 1)\n\n        for i in range(1, len(s)):\n            k = n[i - 1] # trying length k + 1\n            while (k > 0) and (s[i] != s[k]):\n                k = n[k - 1]\n            if s[i] == s[k]:\n                k += 1\n            n[i] = k\n        happy_border = n[-1]\n        return s[:happy_border]",
        "content": "# Intuition\\nThe idea is to compute prefix function for each substring in a given \\nstring, storing the result in a dp array of size = s.length()\\n\\n# Approach\\n1. The base case is a substring of length 1, s[0], and its prefix function\\n= 0, i. e. an empty string. dp[0] = 0;\\n2. Starting from i = 1 to (s.length() - 1), iterate over all possible substrings to get their prefix functions;\\n3. To compute the value for dp[i] we need to compare s[i] and s[k], putting\\ninto k previously calculated value, dp[i - 1];\\n4. k stands for the length of prefix/suffix of a substring, s[0,k) == s[i\\u2212k,i). So, on each step we need to compare the only 2 symbols, which extend out overlapping from both ends;\\n5. If s[i] == s[k], then dp[i] = k + 1, otherwise k = dp[k - 1];\\n6. Then while k > 0 and the current k doesn\\u2019t work, keep setting k to dp[k\\u22121];\\n\\nThe result will be in the last element of the dp array, as for the prefix function value of the whole string s.\\n \\n# Complexity\\n- Time complexity:\\nEven if we still have at most O(n) string comparisons, each one only compares two characters, so it\\u2019s now O(1) per comparison. That means we can compute the whole prefix function in O(n).\\n\\n- Space complexity:\\nWe need a dp array of size O(n) to store the results of the prefix function computation.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestPrefix(self, s: str) -> str:\\n        n = [0] + [None] * (len(s) - 1)\\n\\n        for i in range(1, len(s)):\\n            k = n[i - 1] # trying length k + 1\\n            while (k > 0) and (s[i] != s[k]):\\n                k = n[k - 1]\\n            if s[i] == s[k]:\\n                k += 1\\n            n[i] = k\\n        happy_border = n[-1]\\n        return s[:happy_border]\\n```"
    },
    {
        "slug": "partition-array-into-three-parts-with-equal-sum",
        "tags": "python3",
        "release_time": 1679245385,
        "code": "class Solution:\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\n        total = sum(arr)\n        each_sum = total//3\n        if total % 3 != 0: return False\n        sumi = count = 0\n        for x in arr:\n            if count == 2:\n                return True\n            sumi += x\n            if sumi == each_sum:\n                sumi = 0\n                count += 1\n        return False",
        "content": "# Code\\n```\\nclass Solution:\\n    def canThreePartsEqualSum(self, arr: List[int]) -> bool:\\n        total = sum(arr)\\n        each_sum = total//3\\n        if total % 3 != 0: return False\\n        sumi = count = 0\\n        for x in arr:\\n            if count == 2:\\n                return True\\n            sumi += x\\n            if sumi == each_sum:\\n                sumi = 0\\n                count += 1\\n        return False\\n        \\n\\n```"
    },
    {
        "slug": "compare-version-numbers",
        "tags": "python3",
        "release_time": 1645762398,
        "code": "class Solution:\n    def compareVersion(self, v1: str, v2: str) -> int:\n        v1, v2 = list(map(int, v1.split('.'))), list(map(int, v2.split('.')))  \n        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):\n            if rev1 == rev2:\n                continue\n\n            return -1 if rev1 < rev2 else 1 \n\n        return 0",
        "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nFirstly, we split versions by `.` and convert revisions to integers. Next, we iterate over revisions and compare one by one.\\n\\n`zip_longest` - same as a `zip` but it also pads lists with zeros if lengths are not equal *(see https://docs.python.org/3/library/itertools.html#itertools.ziplongest)*\\n\\nRuntime: 32 ms, faster than **83.77%** of Python3 online submissions for Compare Version Numbers.\\nMemory Usage: 13.8 MB, less than **99.63%** of Python3 online submissions for Compare Version Numbers.\\n\\n```\\nclass Solution:\\n    def compareVersion(self, v1: str, v2: str) -> int:\\n        v1, v2 = list(map(int, v1.split(\\'.\\'))), list(map(int, v2.split(\\'.\\')))  \\n        for rev1, rev2 in zip_longest(v1, v2, fillvalue=0):\\n            if rev1 == rev2:\\n                continue\\n\\n            return -1 if rev1 < rev2 else 1 \\n\\n        return 0\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**"
    },
    {
        "slug": "sequential-digits",
        "tags": "python3",
        "release_time": 1692100858,
        "code": "class Solution:\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\n        l = len(str(low))\n        h = len(str(high))\n        ans = []\n        for i in range(l,h+1):\n            for j in range(1,11-i):\n                t = str(j)\n                for k in range(i-1):\n                    t+=str(int(t[-1])+1)\n                if int(t)<=high and int(t)>=low:\n                    ans.append(int(t))\n        ans.sort()\n        return ans",
        "content": "# Intuition\\nThe constraints make us think that thi sproblem should be solved with the help of converting the low and high to stirngs.\\n\\n# Approach\\nCalculate the length of low and high and then run a loop from lowest length to greatest length.\\nfor each length there can be only certain possibilites \\nFor ex.- For length 5 there can be\\n[12345,23456,34567,45678,56789]\\nhere we can see the last number starts from 5 that is 11-len(of that iteration.)\\nfor each start we then make the number by by incrementing the last digit by one till the length is reached and then check if it lies between the range of low and high. \\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:easy\\n\\n# Code\\n```\\nclass Solution:\\n    def sequentialDigits(self, low: int, high: int) -> List[int]:\\n        l = len(str(low))\\n        h = len(str(high))\\n        ans = []\\n        for i in range(l,h+1):\\n            for j in range(1,11-i):\\n                t = str(j)\\n                for k in range(i-1):\\n                    t+=str(int(t[-1])+1)\\n                if int(t)<=high and int(t)>=low:\\n                    ans.append(int(t))\\n        ans.sort()\\n        return ans\\n\\n```"
    },
    {
        "slug": "increasing-order-search-tree",
        "tags": "python3",
        "release_time": 1676961244,
        "code": "class Solution:\n    def increasingBST(self, root: TreeNode) -> TreeNode:\n        newRoot = TreeNode(0)\n        self.temp = newRoot\n        def inorder(root):\n            if root is None: return None\n            inorder(root.left)\n            new = TreeNode(root.val)\n            self.temp.right = new\n            self.temp = self.temp.right\n            inorder(root.right)\n        inorder(root)\n        return newRoot.right",
        "content": "# Code\\n```\\nclass Solution:\\n    def increasingBST(self, root: TreeNode) -> TreeNode:\\n        newRoot = TreeNode(0)\\n        self.temp = newRoot\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            new = TreeNode(root.val)\\n            self.temp.right = new\\n            self.temp = self.temp.right\\n            inorder(root.right)\\n        inorder(root)\\n        return newRoot.right\\n```"
    },
    {
        "slug": "duplicate-zeros",
        "tags": "python3",
        "release_time": 1692347310,
        "code": "class Solution:\n    def duplicateZeros(self, arr: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify arr in-place instead.\n        \"\"\"\n        try: i = arr.index(0)\n        except: return\n        s = deque([0])\n        for k in range(i+1,len(arr)):\n            if arr[k] == 0:\n                s.append(0)\n                s.append(0)\n            else:\n                s.append(arr[k])\n            arr[k] = s.popleft()",
        "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        try: i = arr.index(0)\\n        except: return\\n        s = deque([0])\\n        for k in range(i+1,len(arr)):\\n            if arr[k] == 0:\\n                s.append(0)\\n                s.append(0)\\n            else:\\n                s.append(arr[k])\\n            arr[k] = s.popleft()\\n\\n        \\n```"
    },
    {
        "slug": "course-schedule-ii",
        "tags": "python3",
        "release_time": 1682857369,
        "code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        dic={i:[] for i in range(numCourses)}\n        for crs,pre in prerequisites:\n            dic[crs].append(pre)\n        output=[]\n        visit,cycle=set(),set()\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n            cycle.add(crs)\n            for pre in dic[crs]:\n                if dfs(pre)==False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n        for c in range(numCourses):\n            if dfs(c)==False:\n                return []\n        return output",
        "content": "```\\nclass Solution:\\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\\n        dic={i:[] for i in range(numCourses)}\\n        for crs,pre in prerequisites:\\n            dic[crs].append(pre)\\n        output=[]\\n        visit,cycle=set(),set()\\n        def dfs(crs):\\n            if crs in cycle:\\n                return False\\n            if crs in visit:\\n                return True\\n            cycle.add(crs)\\n            for pre in dic[crs]:\\n                if dfs(pre)==False:\\n                    return False\\n            cycle.remove(crs)\\n            visit.add(crs)\\n            output.append(crs)\\n            return True\\n        for c in range(numCourses):\\n            if dfs(c)==False:\\n                return []\\n        return output\\n   ```"
    },
    {
        "slug": "count-number-of-pairs-with-absolute-difference-k",
        "tags": "python3",
        "release_time": 1674930335,
        "code": "class Solution:\n    def countKDifference(self, nums: List[int], k: int) -> int:\n        count=0\n        for i in range(len(nums)):\n            for j in range(len(nums)):\n                if i < j and abs(nums[i]-nums[j])==k:\n                    count+=1\n        return count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countKDifference(self, nums: List[int], k: int) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(len(nums)):\\n                if i < j and abs(nums[i]-nums[j])==k:\\n                    count+=1\\n        return count\\n```"
    },
    {
        "slug": "minimum-path-sum",
        "tags": "python3",
        "release_time": 1679905011,
        "code": "class Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        @cache\n        def dp(i: int, j: int) -> int:\n            if i < 0 or j < 0:\n                return maxsize\n            if i == j == 0:\n                return grid[0][0]\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\n\n        return dp(len(grid) - 1, len(grid[0]) - 1)",
        "content": "# Top-Down DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(n*m)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        @cache\\n        def dp(i: int, j: int) -> int:\\n            if i < 0 or j < 0:\\n                return maxsize\\n            if i == j == 0:\\n                return grid[0][0]\\n            return grid[i][j] + min(dp(i - 1, j), dp(i, j - 1))\\n\\n        return dp(len(grid) - 1, len(grid[0]) - 1)\\n```\\n\\n\\n# Dottom-Up DP\\n\\n## Complexity\\n- Time complexity: $$O(n*m)$$\\n- Space complexity: $$O(1)$$\\n\\n```\\nclass Solution:\\n    def minPathSum(self, grid: List[List[int]]) -> int:\\n        n, m = len(grid), len(grid[0])\\n\\n        for i in range(1, n):\\n            grid[i][0] += grid[i - 1][0]\\n\\n        for j in range(1, m):\\n            grid[0][j] += grid[0][j - 1]\\n\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\\n\\n        return grid[n - 1][m - 1]\\n```"
    },
    {
        "slug": "partitioning-into-minimum-number-of-deci-binary-numbers",
        "tags": "python3",
        "release_time": 1673679882,
        "code": "class Solution:\n    def minPartitions(self, n: str) -> int:\n        return int(max(n))",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPartitions(self, n: str) -> int:\\n        return int(max(n))\\n```"
    },
    {
        "slug": "masking-personal-information",
        "tags": "python3",
        "release_time": 1679428862,
        "code": "class Solution:\n    def maskPII(self, s: str) -> str:\n        # Email\n        if '@' in s:\n            s = s.lower()\n            a = s.split('@')[0]\n            b = s.split('@')[1]\n            a = a[0]+'*'*5+a[-1]\n            return a+'@'+b\n        # Phone Number\n        else:\n            for x in '+-() ':\n                s = s.replace(x, '')\n    \n            ln = len(s)\n            res = ''\n            if ln>10:\n                res = '+'+'*'*(ln-10)+'-'\n            res+='***-***-'+s[-4:]\n            return res\n\n        return ''",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maskPII(self, s: str) -> str:\\n        # Email\\n        if \\'@\\' in s:\\n            s = s.lower()\\n            a = s.split(\\'@\\')[0]\\n            b = s.split(\\'@\\')[1]\\n            a = a[0]+\\'*\\'*5+a[-1]\\n            return a+\\'@\\'+b\\n        # Phone Number\\n        else:\\n            for x in \\'+-() \\':\\n                s = s.replace(x, \\'\\')\\n    \\n            ln = len(s)\\n            res = \\'\\'\\n            if ln>10:\\n                res = \\'+\\'+\\'*\\'*(ln-10)+\\'-\\'\\n            res+=\\'***-***-\\'+s[-4:]\\n            return res\\n\\n        return \\'\\'\\n```"
    },
    {
        "slug": "nim-game",
        "tags": "python3",
        "release_time": 1676816152,
        "code": "class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return n % 4 != 0",
        "content": "This is a classic example of a game theory problem where both players play optimally. The game\\'s outcome depends on the number of stones in the heap. To determine whether you can win the game or not, we need to look at the number of stones in the heap and find a pattern.\\n\\nLet\\'s consider the base cases first:\\n\\n- If there is only one stone, you can remove it and win the game.\\n- If there are two stones, you can remove one stone and win the game.\\n- If there are three stones, you can remove two stones and win the game.\\n\\nFor n=4, you cannot win the game, as you can remove at most three stones on your turn, and your friend can remove the remaining stones on their turn. Therefore, your friend will win the game.\\n\\nFor n=5,6,7, you can win the game. If there are 5 stones, you can remove one stone and reduce it to four stones, and your friend will be forced to remove one to three stones. In any case, you will be able to remove the last stone and win the game.\\n\\nSimilarly, if there are six stones, you can remove two stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nIf there are seven stones, you can remove three stones, leaving four stones in the heap. Your friend will be forced to remove one to three stones, and you will be able to remove the last stone and win the game.\\n\\nWe can observe that for any n that is a multiple of four, you cannot win the game. For any other value of n, you can win the game.\\n\\nTherefore, to solve this problem, we need to check if n is a multiple of four or not. If it is, return false; otherwise, return true.\\n\\n# Code\\n```\\nclass Solution:\\n    def canWinNim(self, n: int) -> bool:\\n        return n % 4 != 0\\n```"
    },
    {
        "slug": "k-th-smallest-prime-fraction",
        "tags": "python3",
        "release_time": 1678280050,
        "code": "from fractions import Fraction\nclass Solution:\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\n        sol_arr = []\n        for i in range(len(arr)-1):\n            for j in range(i+1,len(arr)):\n                sol_arr.append(arr[i]/arr[j])\n        sol_arr = sorted(sol_arr)\n        smallest = sol_arr[k-1]\n        sol = str(Fraction(str(smallest)).limit_denominator())\n        numerator, denominator = sol.split(\"/\")\n        return [int(numerator), int(denominator)]",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom fractions import Fraction\\nclass Solution:\\n    def kthSmallestPrimeFraction(self, arr: List[int], k: int) -> List[int]:\\n        sol_arr = []\\n        for i in range(len(arr)-1):\\n            for j in range(i+1,len(arr)):\\n                sol_arr.append(arr[i]/arr[j])\\n        sol_arr = sorted(sol_arr)\\n        smallest = sol_arr[k-1]\\n        sol = str(Fraction(str(smallest)).limit_denominator())\\n        numerator, denominator = sol.split(\"/\")\\n        return [int(numerator), int(denominator)]\\n```"
    },
    {
        "slug": "subarrays-with-k-different-integers",
        "tags": "python3",
        "release_time": 1672032022,
        "code": "from collections import defaultdict\nclass Solution:\n    def atmostk(self,n,k,nums):\n        l=0\n        r=0\n        map=defaultdict(int)\n        ans=0\n        while r<n:\n            map[nums[r]]+=1\n            while len(map)>k:\n                map[nums[l]]-=1\n                if map[nums[l]]==0:\n                    del map[nums[l]]\n                l+=1\n            \n            ans+=r-l+1\n            r+=1\n        return ans\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)",
        "content": "\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def atmostk(self,n,k,nums):\\n        l=0\\n        r=0\\n        map=defaultdict(int)\\n        ans=0\\n        while r<n:\\n            map[nums[r]]+=1\\n            while len(map)>k:\\n                map[nums[l]]-=1\\n                if map[nums[l]]==0:\\n                    del map[nums[l]]\\n                l+=1\\n            \\n            ans+=r-l+1\\n            r+=1\\n        return ans\\n    def subarraysWithKDistinct(self, nums: List[int], k: int) -> int:\\n        return self.atmostk(len(nums),k,nums)-self.atmostk(len(nums),k-1,nums)\\n```"
    },
    {
        "slug": "partition-array-according-to-given-pivot",
        "tags": "python3",
        "release_time": 1676781647,
        "code": "class Solution:\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\n        l_lst = []\n        for i in range(len(nums)):\n            if nums[i] < pivot:\n                l_lst.append(nums[i])\n        for i in range(len(nums)):\n            if nums[i]==pivot:\n                l_lst.append(nums[i])\n        for i in range(len(nums)):\n            if nums[i]>pivot:\n                l_lst.append(nums[i])\n        return l_lst",
        "content": "# Please upvote if you find the solution helpful.\\n# Code\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]==pivot:\\n                l_lst.append(nums[i])\\n        for i in range(len(nums)):\\n            if nums[i]>pivot:\\n                l_lst.append(nums[i])\\n        return l_lst\\n\\n```\\n                                    or\\n```\\nclass Solution:\\n    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:\\n        l_lst = []\\n        m_lst=[]\\n        h_lst=[]\\n        for i in range(len(nums)):\\n            if nums[i] < pivot:\\n                l_lst.append(nums[i])\\n            elif nums[i]==pivot:\\n                m_lst.append(nums[i])\\n            else:\\n                h_lst.append(nums[i])\\n        return l_lst+m_lst+h_lst\\n```\\n"
    },
    {
        "slug": "path-sum-iii",
        "tags": "python3",
        "release_time": 1685594365,
        "code": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\n        self.count = 0\n        def sum(node, targetSum):\n            if node is None:\n                return \n            elif node.val==targetSum:\n                self.count+=1\n            sum(node.left, targetSum-node.val)\n            sum(node.right, targetSum-node.val)\n        def dfs(node, target):\n            if node is None:\n                return \n            sum(node, target)\n            dfs(node.left, target)\n            dfs(node.right,target)\n        dfs(root, targetSum)\n        return self.count",
        "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:\\n        self.count = 0\\n        def sum(node, targetSum):\\n            if node is None:\\n                return \\n            elif node.val==targetSum:\\n                self.count+=1\\n            sum(node.left, targetSum-node.val)\\n            sum(node.right, targetSum-node.val)\\n        def dfs(node, target):\\n            if node is None:\\n                return \\n            sum(node, target)\\n            dfs(node.left, target)\\n            dfs(node.right,target)\\n        dfs(root, targetSum)\\n        return self.count\\n```"
    },
    {
        "slug": "distribute-repeating-integers",
        "tags": "python3",
        "release_time": 1626405953,
        "code": "from collections import Counter, defaultdict\n\nclass Solution:\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\n        quantity.sort(reverse=True)\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\n        def backtrack(i: int = 0) -> bool:\n            if i == len(quantity):\n                return True\n            \n            for freq, count in list(freqCounts.items()):\n                if freq >= quantity[i] and count > 0:\n                    freqCounts[freq] -= 1\n                    freqCounts[freq - quantity[i]] += 1\n                    if backtrack(i + 1):\n                        return True\n                    freqCounts[freq] += 1\n                    freqCounts[freq - quantity[i]] -= 1\n            \n            return False\n        \n        return backtrack()",
        "content": "1. Sort the `quantity` array in reverse order, since allocating larger quantities first will more quickly reduce the search space.\\n2. Get the frequency of each number in `nums`, ignoring the actual numbers.\\n3. Then further get the count of each frequency, storing this in `freqCounts`. We do this so that in our backtracking step, we don\\'t try allocating a quantity to two different but equal frequencies, as they would have an equivalent result.\\n4. In the backtracking, we try allocating each quantity to each unique frequency, simply decrementing and incrementing the frequency counts in each step.\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def canDistribute(self, nums: List[int], quantity: List[int]) -> bool:\\n        quantity.sort(reverse=True)\\n        freqCounts = defaultdict(int, Counter(Counter(nums).values()))\\n        def backtrack(i: int = 0) -> bool:\\n            if i == len(quantity):\\n                return True\\n            \\n            for freq, count in list(freqCounts.items()):\\n                if freq >= quantity[i] and count > 0:\\n                    freqCounts[freq] -= 1\\n                    freqCounts[freq - quantity[i]] += 1\\n                    if backtrack(i + 1):\\n                        return True\\n                    freqCounts[freq] += 1\\n                    freqCounts[freq - quantity[i]] -= 1\\n            \\n            return False\\n        \\n        return backtrack()\\n```"
    },
    {
        "slug": "valid-arrangement-of-pairs",
        "tags": "python3",
        "release_time": 1638676934,
        "code": "class Solution:\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\n        graph = defaultdict(list)\n        degree = defaultdict(int) # net out degree \n        for x, y in pairs: \n            graph[x].append(y)\n            degree[x] += 1\n            degree[y] -= 1\n                \n        for k in degree: \n            if degree[k] == 1: \n                x = k\n                break \n                \n        ans = []\n\n        def fn(x): \n            \"\"\"Return Eulerian path via dfs.\"\"\"\n            while graph[x]: fn(graph[x].pop()) \n            ans.append(x)\n        \n        fn(x)\n        ans.reverse()\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]",
        "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/b1948f8814bebeca475cbb354cd44d19092dff59) for solutions of weekly 270.\\n\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```\\n\\nAdding an iterative implementation of Hieholzer\\'s algo from @delphih\\n```\\nclass Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n        stack = [x]\\n        while stack: \\n            while graph[stack[-1]]: \\n                stack.append(graph[stack[-1]].pop())\\n            ans.append(stack.pop())\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n```"
    },
    {
        "slug": "plus-one",
        "tags": "python3",
        "release_time": 1692505877,
        "code": "class Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n        s= ''.join(map(str,digits))\n        i=int(s)+1\n        li=list(map(int,str(i)))  \n        return li",
        "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def plusOne(self, digits: List[int]) -> List[int]:\\n        s= \\'\\'.join(map(str,digits))\\n        i=int(s)+1\\n        li=list(map(int,str(i)))  \\n        return li\\n```"
    },
    {
        "slug": "maximum-element-after-decreasing-and-rearranging",
        "tags": "python3",
        "release_time": 1679258970,
        "code": "class Solution:\n    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\n        return reduce(lambda res, x: min(res + 1, x), sorted(arr), 0)",
        "content": "# Complexity\\n- Time complexity: $$O(sort)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumElementAfterDecrementingAndRearranging(self, arr: List[int]) -> int:\\n        return reduce(lambda res, x: min(res + 1, x), sorted(arr), 0)\\n\\n```"
    },
    {
        "slug": "maximum-product-of-word-lengths",
        "tags": "python3",
        "release_time": 1675091373,
        "code": "class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        total=0\n        words=list(set(words))\n        for i in range(len(words)):\n            for j in range(i+1,len(words)):\n                ans=0\n                for k in words[i]:\n                    if k not in words[j]:ans=len(words[i])*len(words[j])\n                    else:\n                        ans=0\n                        break\n                total=max(total,ans)\n        return total",
        "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxProduct(self, words: List[str]) -> int:\\n        total=0\\n        words=list(set(words))\\n        for i in range(len(words)):\\n            for j in range(i+1,len(words)):\\n                ans=0\\n                for k in words[i]:\\n                    if k not in words[j]:ans=len(words[i])*len(words[j])\\n                    else:\\n                        ans=0\\n                        break\\n                total=max(total,ans)\\n        return total \\n```"
    },
    {
        "slug": "stone-game-vi",
        "tags": "python3",
        "release_time": 1690568814,
        "code": "class Solution:\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\n        # hurt other enemy rather than self collecting to max\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\n        bobPoints = sum(b)\n        alicePoints = 0\n        for i in range(0, len(a), 2):\n            alicePoints += combines[i][1]\n            bobPoints -= combines[i][2]\n        if alicePoints > bobPoints:\n            return 1\n        elif alicePoints < bobPoints:\n            return -1\n        return 0",
        "content": "# Intuition\\nIn this problem instead of picking/not Picking largest making sum we need to pick those stones by alice which can hurt bob more.\\nSo we combine them and sort them in reverse order\\n`why we can do sorting? Because in question its stated we can pick any stone (and not only from left most or right most)`\\nNow alice will pick first highest combined effecting the bobPoints most (which is the total Sum of bob values) and then skip next point (which is to be picked by bob).\\nAccording to our alicePoints and bobPoints return the ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def stoneGameVI(self, a: List[int], b: List[int]) -> int:\\n        # hurt other enemy rather than self collecting to max\\n        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))]\\n        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want\\n        bobPoints = sum(b)\\n        alicePoints = 0\\n        for i in range(0, len(a), 2):\\n            alicePoints += combines[i][1]\\n            bobPoints -= combines[i][2]\\n        if alicePoints > bobPoints:\\n            return 1\\n        elif alicePoints < bobPoints:\\n            return -1\\n        return 0\\n        \\n\\n```"
    },
    {
        "slug": "make-costs-of-paths-equal-in-a-binary-tree",
        "tags": "python3",
        "release_time": 1683566460,
        "code": "class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n\n        ans = 0\n        n//=2                                               # <-- 1)\n\n        for i in reversed(range(n)):\n        \n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\n\n            ans+= mx - mn\n            cost[i]+= mx\n\n        return ans",
        "content": "A couple of notes:\\n1. The iteration covers only the parents, so we can prune the leaves from the iteration.\\n2. We add `1` each to `2i` and `2i+1` because `cost` is zero-indexed and the tree is one-indexed.\\n\\n\\n```\\nclass Solution:\\n    def minIncrements(self, n: int, cost: List[int]) -> int:\\n\\n        ans = 0\\n        n//=2                                               # <-- 1)\\n\\n        for i in reversed(range(n)):\\n        \\n            mn, mx = sorted((cost[2*i+1], cost[2*i+2]))     # <-- 2)\\n\\n            ans+= mx - mn\\n            cost[i]+= mx\\n\\n        return ans\\n```\\n[https://leetcode.com/problems/make-costs-of-paths-equal-in-a-binary-tree/submissions/946746736/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n"
    },
    {
        "slug": "add-edges-to-make-degrees-of-all-nodes-even",
        "tags": "python3",
        "release_time": 1671397421,
        "code": "class Solution:\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\n        neighbors = [set() for _ in range(n)]\n        for edge in edges:\n            a, b = edge\n            a -=1\n            b -=1\n            neighbors[a].add(b)\n            neighbors[b].add(a)\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\n        numOdd = len(oddDegreesNodes)\n        if numOdd == 0:\n            return True\n        elif numOdd == 4:\n            # Only possible if there are two pairs of vertices which are not connected\n            o1, o2, o3, o4 = oddDegreesNodes\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\n        elif numOdd == 2:\n            # Only possible if both not connected or both connected but there is another node to connect to\n            o1, o2 = oddDegreesNodes\n            if o1 not in neighbors[o2]:\n                 # Case 1: Not connected\n                return True\n            # Case 2\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\n            # Oops, no other node to connect to!\n            return len(bothConnectedTo) != n\n        return False",
        "content": "# Intuition\\nProblem is only solvable if odd nodes are 2 or 4. Note that it is impossible for there to be 1 or 3 odd nodes, since sum(degrees) %2 == 0\\n\\n# Approach\\nWith 2 odds, they can either connect to each other or to some other vertex that neither is connected to\\n\\nWith 4 odds, there must be two separate pairs of vertices that are unconnected.\\n\\n# Complexity\\n- Time complexity:\\nO(n) since the longest loop is making the graph\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n(note: was updated from previous incorrect solution)\\n```\\nclass Solution:\\n    def isPossible(self, n: int, edges: List[List[int]]) -> bool:\\n        neighbors = [set() for _ in range(n)]\\n        for edge in edges:\\n            a, b = edge\\n            a -=1\\n            b -=1\\n            neighbors[a].add(b)\\n            neighbors[b].add(a)\\n        oddDegreesNodes = [i for i in range(n) if (len(neighbors[i]) % 2 == 1)]\\n        numOdd = len(oddDegreesNodes)\\n        if numOdd == 0:\\n            return True\\n        elif numOdd == 4:\\n            # Only possible if there are two pairs of vertices which are not connected\\n            o1, o2, o3, o4 = oddDegreesNodes\\n            return (o1 not in neighbors[o2] and o3 not in neighbors[o4]) or (o1 not in neighbors[o3] and o2 not in neighbors[o4]) or (o1 not in neighbors[o4] and o2 not in neighbors[o3])\\n        elif numOdd == 2:\\n            # Only possible if both not connected or both connected but there is another node to connect to\\n            o1, o2 = oddDegreesNodes\\n            if o1 not in neighbors[o2]:\\n                 # Case 1: Not connected\\n                return True\\n            # Case 2\\n            bothConnectedTo = neighbors[o1] | neighbors[o2]\\n            # Oops, no other node to connect to!\\n            return len(bothConnectedTo) != n\\n        return False\\n```"
    },
    {
        "slug": "minimum-speed-to-arrive-on-time",
        "tags": "python3",
        "release_time": 1690342800,
        "code": "class Solution:\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\n        if len(dist) >= hour + 1  : return -1\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\n        while left<right:\n            mid=(left+right)//2\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\n                right=mid\n            else:\n                left=mid+1\n        return left",
        "content": "![image.png](https://assets.leetcode.com/users/images/b88e2aad-dabb-4eac-afd0-759a7cc70942_1690342594.5715153.png)\\n\\n\\n# Complexity\\n- Time complexity: O(m*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSpeedOnTime(self, dist: List[int], hour: float) -> int:\\n        if len(dist) >= hour + 1  : return -1\\n        left,right = 1, ceil(max(max(dist),dist[-1]/(1 if hour.is_integer() else hour-int(hour))))\\n        while left<right:\\n            mid=(left+right)//2\\n            if sum([ceil(i/mid) for i in dist[:-1]])+(dist[-1]/mid) <= hour :\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```"
    }
]